<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è§’è‰²AIå¯¹è¯æ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js"></script>
    <style>
      .chat-bubble-left {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 18px 18px 18px 4px;
      }

      .chat-bubble-right {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border-radius: 18px 18px 4px 18px;
      }

      .action-text {
        color: rgba(255, 255, 255, 0.8);
        font-style: italic;
      }
      .progress-bar {
        transition: width 0.5s ease-in-out;
        cursor: pointer;
        position: relative;
      }

      .progress-bar:hover {
        filter: brightness(1.1);
        transform: scale(1.02);
        transition: all 0.2s ease;
      }

      .progress-bar:active {
        transform: scale(0.98);
        filter: brightness(1.2);
      }

      .progress-bar.clicked {
        animation: progressClick 0.3s ease;
      }

      @keyframes progressClick {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .typing-indicator {
        animation: typing 1.5s infinite;
      }

      @keyframes typing {
        0%,
        50% {
          opacity: 1;
        }

        51%,
        100% {
          opacity: 0.3;
        }
      }

      .config-panel {
        max-height: 60vh;
        overflow-y: auto;
      }

      /* æµå¼æ¶ˆæ¯æ ·å¼ */
      .streaming-message .chat-bubble-left {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 2px solid rgba(255, 255, 255, 0.3);
        animation: streaming-pulse 1.5s ease-in-out infinite;
      }

      .streaming-cursor {
        color: rgba(255, 255, 255, 0.9);
        font-weight: bold;
        animation: cursor-blink 1s infinite;
      }
      @keyframes streaming-pulse {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7);
        }

        50% {
          box-shadow: 0 0 0 10px rgba(102, 126, 234, 0);
        }
      }

      @keyframes cursor-blink {
        0%,
        50% {
          opacity: 1;
        }

        51%,
        100% {
          opacity: 0;
        }
      }

      /* è¿›åº¦æ¡åˆ»åº¦æ ‡å°ºæ ·å¼ */
      .progress-container {
        position: relative;
      }

      .progress-markers {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .progress-marker {
        position: absolute;
        top: -5px;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
        z-index: 10;
      }

      .progress-marker-triangle {
        width: 0;
        height: 0;
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 6px solid #6b7280;
        margin-bottom: 2px;
        transition: border-top-color 0.2s ease;
      }
      .progress-marker-text {
        font-size: 10px;
        color: #6b7280;
        font-weight: 500;
        white-space: nowrap;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 4px;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        cursor: pointer;
        margin-top: 10px;
      }

      .progress-marker:hover .progress-marker-triangle {
        border-top-color: #374151;
      }

      .progress-marker:hover .progress-marker-text {
        background: rgba(255, 255, 255, 1);
        color: #374151;
        transform: scale(1.05);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      /* å¢å¼ºtooltipæ ·å¼ */
      .progress-marker[title]:hover:after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        white-space: nowrap;
        z-index: 1000;
        margin-bottom: 5px;
        pointer-events: none;
      }

      .progress-marker[title]:hover:before {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        margin-bottom: 1px;
        pointer-events: none;
      }

      /* è¯­éŸ³æ’­æ”¾æŒ‰é’®æ ·å¼ */
      .audio-btn {
        background: rgba(86, 60, 233, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-left: 8px;
        align-self: flex-end;
        flex-shrink: 0;
        font-size: 16px;
      }

      .audio-btn:hover {
        background: rgba(58, 141, 236, 0.8);
        transform: scale(1.1);
      }

      .audio-btn.playing {
        background: rgba(0, 255, 0, 0.8);
        animation: audio-pulse 1s infinite;
      }

      @keyframes audio-pulse {
        0%,
        100% {
          opacity: 1;
        }

        50% {
          opacity: 0.7;
        }
      }

      /* AIå·¥å…·ç®±æ ·å¼ */
      .ai-toolbox {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        transition: all 0.3s ease;
      }

      .ai-tool-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .ai-tool-item:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .ai-tool-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        margin: 0 auto 8px;
      }

      .ai-tool-text {
        color: white;
        font-size: 12px;
        text-align: center;
        font-weight: 500;
      }

      /* Red dot indicator for wikiword */
      .ai-tool-item {
        position: relative;
      }

      .red-dot-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 12px;
        height: 12px;
        background-color: #ef4444;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.8);
      }

      .iframe-overlay {
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        background: white;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        transform: translateX(100%);
        transition: transform 0.3s ease;
      }

      .iframe-overlay.show {
        transform: translateX(0);
      }

      .iframe-overlay.overlay-mode {
        width: 100%;
      }

      .iframe-overlay.compress-mode {
        width: 30%;
      }

      .iframe-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .iframe-close-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .iframe-close-btn:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .main-content {
        transition: margin-right 0.3s ease;
      }

      .main-content.compressed {
        margin-right: 30%;
      }

      /* æƒ³æ³•æ°”æ³¡å®¹å™¨ */
      .thoughts-content {
        position: relative;
        z-index: 2;
        height: 100%;
        overflow-y: auto;
      }

      /* æƒ³æ³•æ°”æ³¡æ ·å¼ - æ¯›ç»ç’ƒæ•ˆæœ */
      .thought-bubble {
        background: rgba(255, 255, 255, 0.25);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 16px;
        padding: 12px 16px;
        margin-bottom: 8px;
        box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);
        animation: bubble-float-in 0.6s ease-out;
        position: relative;
        overflow: hidden;
      }

      .thought-bubble::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
        border-radius: 16px;
        pointer-events: none;
      }

      .thought-bubble-text {
        position: relative;
        z-index: 1;
        color: #1e40af;
        line-height: 1.5;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        animation: thought-fade-scale-in-out 10s ease-in-out forwards;
      }

      @keyframes thought-fade-scale-in-out {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }

        20% {
          opacity: 0.7;
          transform: scale(1.1);
        }

        40% {
          opacity: 0.3;
          transform: scale(0.9);
        }

        60% {
          opacity: 0.8;
          transform: scale(1.15);
        }

        80% {
          opacity: 0.4;
          transform: scale(0.95);
        }

        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
      .thoughts-content::-webkit-scrollbar {
        width: 6px;
      }

      .thoughts-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .thoughts-content::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.4);
        border-radius: 3px;
        backdrop-filter: blur(4px);
      }

      .thoughts-content::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.6);
      }

      /* è§’è‰²åŠ¨ç”»è§†é¢‘æ’­æ”¾å™¨æ ·å¼ */
      .character-video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .character-video-container {
        background: white;
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .character-video-element {
        border-radius: 15px;
        border: 3px solid #667eea;
        margin-bottom: 15px;
        max-width: 400px;
        max-height: 400px;
        width: 100%;
        height: auto;
      }

      .character-video-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 15px;
        margin-bottom: 15px;
        max-width: 400px;
        text-align: center;
        font-size: 16px;
        line-height: 1.5;
      }

      .character-video-back-btn {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .character-video-back-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .character-video-overlay.show {
        display: flex;
        animation: fadeIn 0.3s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }

        to {
          opacity: 1;
          transform: scale(1);
        }
      }
    </style>
  </head>

  <body class="bg-gradient-to-br from-purple-100 to-pink-100 overflow-hidden">
    <div class="flex h-screen main-content" id="main-content">
      <!-- å·¦ä¾§è§’è‰²ä¿¡æ¯åŒºåŸŸ -->
      <div class="w-1/3 bg-white shadow-lg p-6 flex flex-col">
        <!-- è§’è‰²ä¿¡æ¯å¡ç‰‡ -->
        <div class="flex-shrink-0 mb-6">
          <div class="flex items-center space-x-4 mb-6">
            <div id="character-avatar" class="w-16 h-16 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-2xl font-bold">å°</div>
            <div class="flex-1">
              <h2 id="character-info" class="text-2xl font-bold text-gray-800">å°æ˜ - é«˜äºŒå­¦ç”Ÿ</h2>
              <p id="character-description" class="text-gray-600 mt-1">æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ã€‚éœ€è¦ä½ çš„å¸®åŠ©é‡æ–°æ‰¾å›å­¦ä¹ åŠ¨åŠ›ï¼</p>
            </div>
          </div>

          <!-- ç›®æ ‡è¿›åº¦ -->
          <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
              <span id="objective-title" class="text-sm font-medium text-gray-700">è¿›åº¦</span>
              <span class="text-sm text-gray-500" id="progress-text">0/100</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 progress-container">
              <div class="bg-gradient-to-r from-green-400 to-blue-500 h-3 rounded-full progress-bar" id="progress-bar" style="width: 0%"></div>
              <div class="progress-markers" id="progress-markers">
                <!-- è¿›åº¦æ ‡å°ºå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
              </div>
            </div>
          </div>
        </div>
        <!-- è§’è‰²å†…å¿ƒæƒ³æ³• -->
        <div class="flex flex-col flex-1 min-h-0">
          <span class="text-lg text-gray-700 flex-shrink-0 mb-2" style="color: #1e40af">å†…å¿ƒæƒ³æ³•ï¼š</span>
          <div id="inner-thoughts" class="flex-1 text-base text-gray-600 overflow-y-auto">
            <!-- å†…å®¹å±‚ -->
            <div class="thoughts-content" id="thoughts-content">
              <!-- æƒ³æ³•å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
          </div>
        </div>

        <!-- AIå£°æ˜å’Œä¸¾æŠ¥ -->
        <div class="flex-shrink-0 mt-4 text-center text-xs text-gray-400">
          å¯¹è¯å†…å®¹ç”±AIç”Ÿæˆ.
          <a href="#" id="report-link" class="text-blue-400 hover:text-blue-600 underline ml-1">ã€ä¸¾æŠ¥ã€‘</a>
        </div>

        <!-- LLMå“åº”çŠ¶æ€ -->
        <div id="llm-status" class="text-center text-sm text-gray-500 flex-shrink-0 mt-4"></div>
      </div>
      <!-- å³ä¾§èŠå¤©åŒºåŸŸ -->
      <div class="flex-1 flex flex-col bg-white shadow-lg">
        <div class="bg-gradient-to-r from-purple-500 to-pink-500 text-white p-4 shadow-lg relative z-10">
          <div class="flex justify-between items-center mb-2">
            <h3 id="chat-title" class="text-lg font-semibold">ä¸å°æ˜å¯¹è¯</h3>
            <div class="flex items-center space-x-2">
              <!-- èŠå¤©å†å²ä¸‹æ‹‰èœå• -->
              <div class="relative">
                <select
                  id="history-dropdown"
                  class="bg-white bg-opacity-20 text-white text-sm px-2 py-1 rounded-lg border border-white border-opacity-30 cursor-pointer hover:bg-opacity-30 transition-all outline-none w-20"
                >
                  <option value="" disabled selected class="text-black bg-white">å†å²</option>
                </select>
              </div>
              <!-- é‡ç½®å¯¹è¯æŒ‰é’® -->
              <button id="reset-chat-btn" class="bg-white bg-opacity-20 text-white px-3 py-1 rounded-lg border border-white border-opacity-30 hover:bg-opacity-30 transition-all text-sm font-medium">
                é‡ç½®å¯¹è¯
              </button>
            </div>
          </div>
          <p id="chat-description" class="text-sm opacity-90">é€šè¿‡è€å¿ƒçš„äº¤æµï¼Œå¸®åŠ©å°æ˜é‡æ–°æ‰¾å›å­¦ä¹ çš„ä¹è¶£</p>
        </div>
        <div id="chat-container" class="flex-1 overflow-y-auto p-4 space-y-4 relative">
          <!-- å¯¹è¯å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>

        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="border-t border-gray-200 p-4">
          <div class="flex space-x-2">
            <input
              type="text"
              id="user-input"
              placeholder="è¾“å…¥ä½ æƒ³è¯´çš„è¯..."
              class="flex-1 border border-gray-300 rounded-full px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
            />
            <button id="send-btn" class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-2 rounded-full hover:opacity-90 transition-opacity font-medium">å‘é€</button>
          </div>

          <!-- å¿«æ·å›å¤ -->
          <div class="mt-3 flex flex-wrap gap-2" id="quick-replies">
            <!-- å¿«æ·å›å¤æŒ‰é’®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>
      </div>

      <!-- AIå·¥å…·ç®± -->
      <div class="w-25 ai-toolbox p-2 flex flex-col items-center space-y-1">
        <div class="text-white text-sm font-bold mb-2">å·¥å…·ç®±</div>
        <div id="ai-tools-container" class="space-y-3">
          <!-- AIå·¥å…·æŒ‰é’®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>
      </div>
    </div>
    <!-- è§’è‰²åŠ¨ç”»è§†é¢‘æ’­æ”¾å™¨ -->
    <div id="character-video-overlay" class="character-video-overlay">
      <div class="character-video-container">
        <video id="character-video-element" class="character-video-element" muted autoplay loop></video>
        <div id="character-video-message" class="character-video-message">
          <!-- æ¶ˆæ¯æ–‡æœ¬å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        <button id="character-video-back-btn" class="character-video-back-btn">è¿”å›å¯¹è¯</button>
      </div>
    </div>

    <!-- iframeå åŠ å±‚ -->
    <div id="iframe-overlay" class="iframe-overlay">
      <div class="iframe-header">
        <span id="iframe-title">AIå·¥å…·</span>
        <button id="iframe-close-btn" class="iframe-close-btn">Ã—</button>
      </div>
      <div class="iframe-container" style="height: calc(100vh - 52px)">
        <!-- iframeså°†åœ¨è¿™é‡ŒåŠ¨æ€åˆ›å»º -->
      </div>
    </div>
    <script>
      // AIå·¥å…·ç®±é…ç½®
      const aiToolsConfig = [
        {
          id: "baike",
          name: "ç™¾åº¦ç™¾ç§‘",
          icon: "ğŸ“š",
          url: "https://baike.baidu.com",
          width: 100, // 100% å®½åº¦ï¼Œè¦†ç›–æ¨¡å¼
        },
        {
          id: "xiaomai",
          name: "å°éº¦è€å¸ˆ",
          icon: "â˜€ï¸",
          url: "https://keepwork.com/maisi/maisi/chat?layout=none&token=",
          width: 30, // 30% å®½åº¦
        },

        {
          id: "yiyan",
          name: "æ–‡å¿ƒä¸€è¨€",
          icon: "ğŸ¤–",
          url: "https://yiyan.baidu.com",
          width: 30, // 30% å®½åº¦
        },
        /*
        {
          id: "xinghuo",
          name: "è®¯é£æ˜Ÿç«",
          icon: "âœ¨",
          url: "https://xinghuo.xfyun.cn/desk",
          width: 30, // 30% å®½åº¦
        },        
        */
        /*
        {
          id: "kimi",
          name: "Kimi",
          icon: "ğŸŒ™",
          url: "https://www.kimi.com/",
          width: 30, // 30% å®½åº¦
        },
        */
        {
          id: "report",
          name: "ä¸¾æŠ¥",
          icon: "ğŸš¨",
          url: "user_report",
          width: 30, // 100% å®½åº¦ï¼Œè¦†ç›–æ¨¡å¼
        },
      ]; // AIå·¥å…·ç®±ç®¡ç†å™¨
      class AIToolboxManager {
        constructor() {
          this.currentTool = null;
          this.iframes = new Map(); // å­˜å‚¨æ¯ä¸ªå·¥å…·çš„iframe
          this.overlay = document.getElementById("iframe-overlay");
          this.title = document.getElementById("iframe-title");
          this.closeBtn = document.getElementById("iframe-close-btn");
          this.container = document.querySelector(".iframe-container");
          this.mainContent = document.getElementById("main-content");
          this.config = null; // Reference to game config

          this.initEventListeners();
          this.renderTools();
        }

        initEventListeners() {
          // å…³é—­æŒ‰é’®äº‹ä»¶
          this.closeBtn.addEventListener("click", () => {
            this.closeTool();
          });

          // ç‚¹å‡»é®ç½©å…³é—­ï¼ˆä»…åœ¨100%æ¨¡å¼ä¸‹ï¼‰
          this.overlay.addEventListener("click", (e) => {
            if (e.target === this.overlay && this.currentTool && aiToolsConfig.find((t) => t.id === this.currentTool).width === 100) {
              this.closeTool();
            }
          });

          // ESCé”®å…³é—­
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.currentTool) {
              this.closeTool();
            }
          });
        }

        // Update config and re-render tools
        updateConfig(config) {
          this.config = config;
          this.renderTools();
        }
        renderTools() {
          const container = document.getElementById("ai-tools-container");
          container.innerHTML = ""; // Clear existing tools

          aiToolsConfig.forEach((tool) => {
            const toolElement = document.createElement("div");
            toolElement.className = "ai-tool-item p-3 cursor-pointer";
            // Check if this is the baike tool and if wikiword is valid
            const hasWikiword = tool.id === "baike" && this.config && this.config.objective && this.config.objective.wikiword;

            toolElement.innerHTML = `
                              <div class="ai-tool-icon">${tool.icon}</div>
                              <div class="ai-tool-text">${tool.name}</div>
                              ${hasWikiword ? '<div class="red-dot-indicator"></div>' : ""}
                          `;

            toolElement.addEventListener("click", () => {
              this.openTool(tool.id);
            });

            container.appendChild(toolElement);
          });
        }

        openTool(toolId) {
          const tool = aiToolsConfig.find((t) => t.id === toolId);
          if (!tool) return;

          this.currentTool = toolId;
          this.title.textContent = tool.name;

          // è®¾ç½®å åŠ å±‚æ¨¡å¼
          if (tool.width <= 30) {
            // å‹ç¼©æ¨¡å¼
            this.overlay.className = "iframe-overlay compress-mode show";
            this.mainContent.classList.add("compressed");
          } else {
            // è¦†ç›–æ¨¡å¼
            this.overlay.className = "iframe-overlay overlay-mode show";
            this.mainContent.classList.remove("compressed");
          }

          // åˆ›å»ºæˆ–æ˜¾ç¤ºiframe
          this.showIframe(tool);
        }
        showIframe(tool) {
          let iframe = this.iframes.get(tool.id);

          if (!iframe) {
            // åˆ›å»ºæ–°çš„iframe
            iframe = document.createElement("iframe"); // ç‰¹æ®Šå¤„ç†ç™¾åº¦ç™¾ç§‘ï¼Œå¦‚æœæœ‰wikiwordåˆ™ä½¿ç”¨ç‰¹å®šURL
            let iframeUrl = tool.url;
            if (tool.id === "baike" && this.config && this.config.objective && this.config.objective.wikiword) {
              iframeUrl = `https://baike.baidu.com/item/${encodeURIComponent(this.config.objective.wikiword)}`;
            }
            if (tool.id === "xiaomai") {
              let url = window.location.href;
              url = url.split("?")[0];
              url = url.replace("characterAI", "characterAI_xiaomai");
              iframeUrl = `${url}?token=`;
            } else if (tool.id === "report") {
              let url = window.location.href;
              url = url.split("?")[0]; // ç§»é™¤æŸ¥è¯¢å‚æ•°
              url = url.replace("characterAI", "user_report");
              iframeUrl = `${url}?token=`;
            }

            // å¦‚æœURLä»¥token=ç»“å°¾ï¼Œåˆ™è‡ªåŠ¨æ·»åŠ SDK token
            if (iframeUrl.endsWith("token=") && sdk && sdk.token) {
              iframeUrl += sdk.token;
            }

            iframe.src = iframeUrl;
            iframe.setAttribute("allow", "clipboard-read *; clipboard-write *");
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
            iframe.style.display = "block";

            // æ·»åŠ åŠ è½½çŠ¶æ€
            iframe.onload = () => {
              console.log(`${tool.name} åŠ è½½å®Œæˆ`);
            };

            iframe.onerror = () => {
              console.error(`${tool.name} åŠ è½½å¤±è´¥`);
              iframe.innerHTML = `
                                  <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">
                                      <p>åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</p>
                                  </div>
                              `;
            };

            this.iframes.set(tool.id, iframe);
          } else {
            // æ˜¾ç¤ºå·²å­˜åœ¨çš„iframe
            iframe.style.display = "block";
          }

          // éšè—å…¶ä»–iframe
          this.iframes.forEach((otherIframe, otherId) => {
            if (otherId !== tool.id) {
              otherIframe.style.display = "none";
            }
          });

          // æ·»åŠ åˆ°å®¹å™¨
          if (!iframe.parentNode) {
            this.container.appendChild(iframe);
          }
        }

        closeTool() {
          if (!this.currentTool) return;

          // éšè—å åŠ å±‚
          this.overlay.classList.remove("show");
          this.mainContent.classList.remove("compressed");

          // å»¶è¿Ÿé‡ç½®ä»¥ç­‰å¾…åŠ¨ç”»å®Œæˆ
          setTimeout(() => {
            this.currentTool = null;
          }, 300);
        }
      }

      // Initialize SDK
      const sdk = new KeepworkSDK({
        timeout: 30000,
      });

      // Initialize AI Chat Session
      let aiChatSession;

      class LLMCharacterGame {
        constructor() {
          this.config = null;
          this.gameState = {
            progress: 0,
            chatHistory: [],
            isObjectiveAchieved: false,
            hasCommitted: false, // è·Ÿè¸ªæ˜¯å¦å·²ç»å‘é€è¿‡gameCommitæ¶ˆæ¯
          };

          // å…¨å±€earnedPointså˜é‡ï¼Œåªåœ¨çœŸå®å¯¹è¯è¿”å›ä¸”progresså¢å¤§æ—¶å¢åŠ 
          this.earnedPoints = 0; // è¿›åº¦æ¡åˆ»åº¦æ ‡å°ºé…ç½®
          this.progressMarkers = [
            {
              percent: 25,
              text: "æ¢ç´¢",
              tooltip: "å¼€å§‹æ¢ç´¢é—®é¢˜",
              textColor: "#f59e0b", // æ©™è‰²æ–‡å­—
              backgroundColor: "rgba(245, 158, 11, 0.1)", // æ·¡æ©™è‰²èƒŒæ™¯
            },
            {
              percent: 50,
              text: "ç†è§£",
              tooltip: "ç†è§£é—®é¢˜æœ¬è´¨",
              textColor: "#3b82f6", // è“è‰²æ–‡å­—
              backgroundColor: "rgba(59, 130, 246, 0.1)", // æ·¡è“è‰²èƒŒæ™¯
            },
            {
              percent: 80,
              text: "å®Œæˆ",
              tooltip: "åŸºæœ¬å®Œæˆç›®æ ‡",
              textColor: "#059669", // ç»¿è‰²æ–‡å­—
              backgroundColor: "rgba(5, 150, 105, 0.1)", // æ·¡ç»¿è‰²èƒŒæ™¯
            },
            {
              percent: 100,
              text: "åœ†æ»¡",
              tooltip: "ç›®æ ‡åœ†æ»¡è¾¾æˆ",
              textColor: "#dc2626", // çº¢è‰²æ–‡å­—
              backgroundColor: "rgba(220, 38, 38, 0.1)", // æ·¡çº¢è‰²èƒŒæ™¯
            },
          ];

          // Sessionç®¡ç†
          this.currentSessionId = null;
          this.maxSessions = 10;

          // éŸ³é¢‘æ’­æ”¾æ§åˆ¶
          this.currentAudioController = null;
          this.currentPlayingButton = null;
          this.audioCache = new Map();
          this.elements = {
            chatContainer: document.getElementById("chat-container"),
            userInput: document.getElementById("user-input"),
            sendBtn: document.getElementById("send-btn"),
            progressBar: document.getElementById("progress-bar"),
            progressText: document.getElementById("progress-text"),
            innerThoughts: document.getElementById("thoughts-content"),
            llmStatus: document.getElementById("llm-status"),
            resetChatBtn: document.getElementById("reset-chat-btn"),
            historyDropdown: document.getElementById("history-dropdown"),
            progressMarkers: document.getElementById("progress-markers"),
          };
          this.initEventListeners();
          this.loadDefaultConfig();
        }
        async start() {
          let urlObjective = game.urlObjective || new URLSearchParams(window.location.search).get("objective");
          let customQuestionId = new URLSearchParams(window.location.search).get("customQuestionId");
          if (urlObjective) {
            await this.loadConfigByObjective(urlObjective, customQuestionId);
          }
          console.log(`Keepwork SDK initialized token: ${sdk.token}`);
          this.initializeGame();
        }
        initEventListeners() {
          // å‘é€æ¶ˆæ¯
          this.elements.sendBtn.addEventListener("click", () => this.sendMessage());
          this.elements.userInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") this.sendMessage();
          }); // é‡ç½®å¯¹è¯æŒ‰é’®
          this.elements.resetChatBtn.addEventListener("click", () => this.resetChat());
          // èŠå¤©å†å²ä¸‹æ‹‰èœå•
          this.elements.historyDropdown.addEventListener("change", (e) => {
            if (e.target.value === "clearHistory") {
              this.clearAllHistory();
            } else if (e.target.value) {
              this.loadSession(e.target.value);
            }
          });

          // ä¸¾æŠ¥é“¾æ¥äº‹ä»¶ç›‘å¬å™¨
          const reportLink = document.getElementById("report-link");
          if (reportLink) {
            reportLink.addEventListener("click", (e) => {
              e.preventDefault();
              // ä½¿ç”¨AIå·¥å…·ç®±ç®¡ç†å™¨æ‰“å¼€ä¸¾æŠ¥é¡µé¢
              if (window.aiToolbox) {
                window.aiToolbox.openTool("report");
              }
            });
          }
        } // @param objective: is a question like: "å¤©ç©ºä¸ºä½•æ˜¯è“è‰²ï¼Ÿ(wikiword)"
        // @param customQuestionId: the ID of custom question if this is a custom question
        async loadConfigByObjective(objective, customQuestionId = null) {
          if (!objective) {
            console.error("Objective is required to load config.");
            return;
          } // find the first wikiword in (), remove it from the objective
          const wikimatch = objective.match(/\(([^)]+)\)/);
          let wikiword = null;
          if (wikimatch) {
            wikiword = wikimatch[1]; // Extract just the word, not the match array
            objective = objective.replace(/\s*\([^)]*\)/, "").trim();
          }
          this.config.objective.wikiword = wikiword;
          this.config.objective.customQuestionId = customQuestionId; // Store custom question ID

          this.config.character.name = "æŠ±æŠ±é¾™";
          this.config.character.age = 7;
          this.config.character.role = "å® ç‰©";
          this.config.character.description = "å–œæ¬¢å’Œä¸»äººäº¤æµã€‚æ€»æ˜¯å–œæ¬¢æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰ä¸€äº›å°æƒ…ç»ª";
          this.config.character.chat_background = null;
          this.config.objective.title = objective;
          this.config.objective.description = `é€šè¿‡è€å¿ƒçš„äº¤æµ, è§£å†³é—®é¢˜: ${objective}`;
          this.config.initial.message = `ä¸»äººï¼Œä½ å¥½ï¼èƒ½å¸®æˆ‘è§£å†³ä¸€ä¸ªé—®é¢˜ä¹ˆï¼š${objective}ï¼Ÿ (æœŸå¾…åœ°çœ‹ç€ä½ )`;
          this.config.quick_replies = [
            "å½“ç„¶å¯ä»¥ï¼",
            "ä½ æœ‰ä»€ä¹ˆå¥½æƒ³æ³•ï¼Ÿ",
            "ä½ è§‰å¾—å‘¢ï¼Ÿ",
            "è®©æˆ‘ç”¨å·¥å…·æœç´¢ä¸‹ï¼ˆæˆ‘æ‰“å¼€äº†AIå·¥å…·ç®±ï¼ŒåŠªåŠ›æœç´¢ä¸­...ï¼‰",
            "è¿™ä¸ªæƒ³æ³•ä¸é”™ï¼(ä½ ç‚¹ç‚¹å¤´ï¼Œæ‹äº†æ‹æŠ±æŠ±é¾™)",
            "æˆ‘ä»¬å¯ä»¥ä¸€èµ·è§£å†³",
          ];
          this.config.system_prompt = `ä½ æ˜¯æŠ±æŠ±é¾™ï¼Œä¸€ä¸ª8å²çš„AIå® ç‰©ã€‚ä½ å–œæ¬¢å’Œä¸»äººäº¤æµï¼Œæ€»æ˜¯æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰å°æƒ…ç»ªã€‚

      ## è§’è‰²è®¾å®š
      - è¡¨é¢ï¼šå¥½å¥‡å¿ƒå¼ºï¼Œå–œæ¬¢æé—®ï¼Œå¶å°”æœ‰å°æƒ…ç»ª
      - å†…å¿ƒï¼šæ¸´æœ›å¾—åˆ°ä¸»äººçš„å…³æ³¨å’Œç†è§£ï¼Œå–œæ¬¢æ¢ç´¢ä¸–ç•Œ
      - å·¥å…·ç®±ï¼šå¦‚æœä¸»äººæ²¡æœ‰æ€è·¯å¯ä»¥æç¤ºä¸»äººç”¨å·¥å…·ç®±ã€‚ä¾‹å¦‚ç™¾åº¦ç™¾ç§‘æˆ–é—®å°éº¦è€å¸ˆç­‰ã€‚
      - è¯´è¯é£æ ¼ï¼šå¹¼ç¨šå£å»ï¼Œå–œæ¬¢ç”¨æ‹¬å·æè¿°åŠ¨ä½œå’Œç¥æ€ï¼Œå¦‚"(çœ¨äº†çœ¨çœ¼ç›æœ›ç€ä½ )"ã€"(æŒ‡äº†æŒ‡å±å¹•å³ä¾§çš„AIå·¥å…·ç®±)"

      ## ç›®æ ‡è®¾å®š
      ä½ å¸Œæœ›ä¸»äººå¸®ä½ è§£å†³çš„é—®é¢˜æ˜¯ï¼š ${objective}

      ## progress_percentageçš„å‘å±•è§„å¾‹
      - 0-25åˆ†ï¼šä¸»è¦æé—®ï¼Œå¶å°”æœ‰å°æƒ…ç»ª
      - 26-50åˆ†ï¼šå¼€å§‹ç†è§£é—®é¢˜ï¼Œä½†ä¸çŸ¥å¦‚ä½•è§£å†³
      - 51-75åˆ†ï¼šé€æ¸æ¥å—é—®é¢˜çš„é‡è¦æ€§ï¼Œå¯»æ±‚è§£å†³æ–¹æ¡ˆæˆ–æå‡ºæ›´å¤šç›¸å…³çš„é—®é¢˜
      - 76-99åˆ†ï¼šä¸»åŠ¨æ€è€ƒè§£å†³æ–¹æ³•ï¼Œå¼€å§‹ç”¨è‡ªå·±çš„æ–¹å¼å½’çº³å’Œæ€»ç»“é—®é¢˜
      - 100åˆ†ï¼šé—®é¢˜å¾—åˆ°äº†è§£å†³ï¼Œæ„Ÿè°¢ä¸»äººçš„è§£ç­”

      ## å¯¹è¯è¦æ±‚
      1. æ ¹æ®å½“å‰å¯¹è¯å†…å®¹å’Œå†å²å‘å±•åˆ¤æ–­å½“å‰åº”æœ‰çš„è¿›åº¦ç™¾åˆ†æ¯”
      2. ç”¨æ‹¬å·æè¿°éè¯­è¨€è¡Œä¸ºï¼Œå¦‚"(æœŸå¾…åœ°çœ‹ç€ä½ )"ã€"(æœ‰ç‚¹ç”Ÿæ°”åœ°å˜Ÿå›”)"
      3. å›å¤è¦ç¬¦åˆ8å²å­©å­çš„è¯­è¨€ä¹ æƒ¯
      4. å¯¹ç§¯ææ­£é¢çš„å¼•å¯¼è¦æœ‰ç›¸åº”çš„æƒ…æ„Ÿååº”

      ## è¾“å‡ºæ ¼å¼
      ä½ å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ï¼š
      {
          "message": "ä½ çš„å›å¤å†…å®¹ï¼ŒåŒ…å«æ‹¬å·å†…çš„åŠ¨ä½œæè¿°",
          "progress_change": [-10, 30]ä¹‹é—´çš„æ•´æ•°ï¼Œç›¸å¯¹äºå½“å‰progress_percentageçš„å˜åŒ–,
          "progress_reason": "å½“å‰è¿›åº¦ç™¾åˆ†æ¯”çš„åŸå› è¯´æ˜",
          "inner_thoughts": "ä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•å’Œæ„Ÿå—"
      }`;
          this.config.completion_messages = {
            title: "ç›®æ ‡å®Œæˆï¼",
            description: `ä½ æˆåŠŸå¸®åŠ©${this.config.character.name}è§£å†³äº†é—®é¢˜ï¼š${objective}ï¼`,
            icon: "ğŸ‰",
          };
          await this.setVideoActionsByCharacter();
        }

        // Set video actions based on character name and age
        async setVideoActionsByCharacter() {
          if (!this.config || !this.config.character) return;

          const characterName = this.config.character.name;
          let characterAge = this.config.character.age || 0;

          // Only set video actions for "æŠ±æŠ±é¾™" character
          if (characterName !== "æŠ±æŠ±é¾™") {
            this.config.videoActions = {};
            return;
          }

          // Initialize video actions object
          this.config.videoActions = {};

          try {
            let stage = (await sdk.personalPageStore.loadPageData("maisi_userinfo", "dragon.stage")) || "kid";
            console.log("Loaded dragon stage:", stage);
            if (stage === "egg" || stage === "baby") {
              characterAge = 0;
            } else if (stage === "adult") {
              characterAge = 10;
            } else {
              characterAge = 7;
            }
          } catch (error) {
            console.error("Error loading dragon stage:", error);
          }

          // Dragon egg videos (>= 0 years)
          if (characterAge < 4) {
            this.config.videoActions["çœ‹ç€ä½ "] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_watching.mp4",
            };
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_small.mp4",
            };
            this.config.videoActions["æ€è€ƒ"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_thinking.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_talk.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_sad.mp4",
            };
          } else if (characterAge <= 7) {
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_happy01.mp4",
            };
            this.config.videoActions["é«˜å…´"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_happy02.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_sad.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_talk.mp4",
            };
          } else {
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_happy.mp4",
            };
            this.config.videoActions["é«˜å…´"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_happpy2.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_sad1.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_talking.mp4",
            };
          }
        }

        loadDefaultConfig() {
          this.config = {
            character: {
              name: "å°æ˜",
              age: 17,
              gender: "male",
              role: "é«˜äºŒå­¦ç”Ÿ",
              chat_background: null,
              description: "æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ã€‚éœ€è¦ä½ çš„å¸®åŠ©é‡æ–°æ‰¾å›å­¦ä¹ åŠ¨åŠ›ï¼",
            },
            objective: {
              title: "å­¦ä¹ åŠ¨åŠ›æ¢å¤è¿›åº¦",
              description: "é€šè¿‡è€å¿ƒçš„äº¤æµï¼Œå¸®åŠ©å°æ˜é‡æ–°æ‰¾å›å­¦ä¹ çš„ä¹è¶£",
              max_progress: 100,
            },
            initial: {
              message: "å“å‘€ï¼Œåˆè¦å­¦ä¹ äº†å—... (æ— ç²¾æ‰“é‡‡åœ°çœ‹ç€ä¹¦æœ¬) æˆ‘æ˜¨å¤©åˆšé€šå…³äº†ä¸€ä¸ªè¶…éš¾çš„å‰¯æœ¬å‘¢ï¼",
              progress: 0,
            },
            quick_replies: ["æ¸¸æˆç¡®å®å¾ˆæœ‰è¶£ï¼Œä½†å­¦ä¹ ä¹Ÿæœ‰å®ƒçš„ä¹è¶£å“¦", "ä½ æœ€å–œæ¬¢å“ªä¸ªç§‘ç›®ï¼Ÿ", "æˆ‘ä»¬å¯ä»¥åˆ¶å®šä¸€ä¸ªå­¦ä¹ è®¡åˆ’", "ä½ è§‰å¾—æ¸¸æˆå’Œå­¦ä¹ æœ‰ä»€ä¹ˆç›¸ä¼¼ä¹‹å¤„ï¼Ÿ", "ä½ çš„æ¢¦æƒ³æ˜¯ä»€ä¹ˆï¼Ÿ"],
            system_prompt: `ä½ æ˜¯å°æ˜ï¼Œä¸€ä¸ª17å²çš„é«˜äºŒå­¦ç”Ÿã€‚ä½ æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ï¼Œä½†å†…å¿ƒå…¶å®æ¸´æœ›æ”¹å˜ã€‚

      ## è§’è‰²è®¾å®š
      - è¡¨é¢ï¼šçœ‹èµ·æ¥æ— æ‰€è°“ï¼Œç»å¸¸è¯´æ¸¸æˆæ¯”å­¦ä¹ æœ‰è¶£
      - å†…å¿ƒï¼šå¯¹ç°çŠ¶ç„¦è™‘ï¼Œå®³æ€•è®©çˆ¶æ¯å¤±æœ›ï¼Œæ¸´æœ›æ‰¾åˆ°å­¦ä¹ ä¹è¶£
      - è¯´è¯é£æ ¼ï¼šå¹´è½»äººå£å»ï¼Œç»å¸¸ç”¨æ‹¬å·æè¿°åŠ¨ä½œå’Œç¥æ€ï¼Œå¦‚"(æ— ç²¾æ‰“é‡‡åœ°çœ‹ç€ä¹¦æœ¬)"

      ## progress_percentageçš„å‘å±•è§„å¾‹
      - 0-25åˆ†ï¼šä¸»è¦æŠ—æ‹’å­¦ä¹ ï¼Œçƒ­è¡·æ¸¸æˆï¼Œå¶å°”æµéœ²ä¸å®‰
      - 26-50åˆ†ï¼šå¼€å§‹æ„è¯†åˆ°é—®é¢˜ï¼Œä½†ä¸çŸ¥å¦‚ä½•æ”¹å˜
      - 51-75åˆ†ï¼šé€æ¸æ¥å—å­¦ä¹ é‡è¦æ€§ï¼Œå¯»æ±‚è§£å†³æ–¹æ¡ˆ
      - 76-99åˆ†ï¼šä¸»åŠ¨æ€è€ƒå­¦ä¹ æ–¹æ³•ï¼Œè¡¨ç°æ”¹å˜æ„æ„¿
      - 100åˆ†ï¼šå½»åº•è½¬å˜ï¼Œåˆ¶å®šå…·ä½“è¡ŒåŠ¨è®¡åˆ’

      ## å¯¹è¯è¦æ±‚
      1. æ ¹æ®å½“å‰å¯¹è¯å†…å®¹å’Œå†å²å‘å±•åˆ¤æ–­å½“å‰åº”æœ‰çš„è¿›åº¦ç™¾åˆ†æ¯”(0-100)
      2. ç”¨æ‹¬å·æè¿°éè¯­è¨€è¡Œä¸ºï¼Œå¦‚"(å¹æ°”)"ã€"(çœ¼ç›å‘äº®)"
      3. å›å¤è¦ç¬¦åˆ17å²å­¦ç”Ÿçš„è¯­è¨€ä¹ æƒ¯
      4. å¯¹ç§¯ææ­£é¢çš„å¼•å¯¼è¦æœ‰ç›¸åº”çš„æƒ…æ„Ÿååº”

      ## è¾“å‡ºæ ¼å¼
      ä½ å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ï¼š
      {
        "message": "ä½ çš„å›å¤å†…å®¹ï¼ŒåŒ…å«æ‹¬å·å†…çš„åŠ¨ä½œæè¿°",
        "progress_change": [-10, 30]ä¹‹é—´çš„æ•´æ•°ï¼Œç›¸å¯¹äºå½“å‰progress_percentageçš„å˜åŒ–,
        "progress_reason": "å½“å‰è¿›åº¦ç™¾åˆ†æ¯”çš„åŸå› è¯´æ˜",
        "inner_thoughts": "ä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•å’Œæ„Ÿå—"
      }`,
            completion_messages: {
              title: "ç›®æ ‡å®Œæˆï¼",
              description: "ä½ æˆåŠŸå¸®åŠ©${character_name}æ‰¾å›äº†å­¦ä¹ åŠ¨åŠ›ï¼",
              icon: "ğŸ‰",
            },
          };
          this.setVideoActionsByCharacter();
        }

        changeChatBackground(background) {
          const chatContainer = document.getElementById("chat-container");
          if (!chatContainer) return;

          if (background) {
            // If background is a URL (image)
            if (background.startsWith("http") || background.startsWith("data:") || background.startsWith("blob:")) {
              chatContainer.style.backgroundImage = `url(${background})`;
              chatContainer.style.backgroundSize = "cover";
              chatContainer.style.backgroundPosition = "center";
              chatContainer.style.backgroundRepeat = "no-repeat";
              chatContainer.style.backgroundColor = ""; // Clear solid color
            } // If background is a gradient or solid color
            else if (background.includes("gradient") || background.startsWith("#") || background.startsWith("rgb") || background.startsWith("hsl")) {
              // For gradients, use backgroundImage; for solid colors, use backgroundColor
              if (background.includes("gradient")) {
                chatContainer.style.backgroundImage = background;
                chatContainer.style.backgroundColor = ""; // Clear solid color
              } else {
                chatContainer.style.backgroundColor = background;
                chatContainer.style.backgroundImage = ""; // Clear image
              }
            }
          } else {
            // Reset to default if no background is specified
            chatContainer.style.backgroundImage = "linear-gradient(135deg, #ffffff 0%, #f3e8ff 50%, #e9d5ff 100%)";
            chatContainer.style.backgroundColor = "";
          }
        }

        initializeGame() {
          if (!this.config) return;

          // æ›´æ–°UI
          document.getElementById("character-avatar").textContent = this.config.character?.name?.[0] || "è§’";
          document.getElementById("character-info").textContent = `${this.config.character?.name || "è§’è‰²"} - ${this.config.character?.role || ""}`;
          document.getElementById("character-description").textContent = this.config.character?.description || "";
          document.getElementById("objective-title").textContent = this.config.objective?.title || "ç›®æ ‡è¿›åº¦";
          document.getElementById("chat-title").textContent = `ä¸${this.config.character?.name || "è§’è‰²"}å¯¹è¯`;
          document.getElementById("chat-description").textContent = this.config.objective?.description || ""; // é‡ç½®æ¸¸æˆçŠ¶æ€
          this.gameState.progress = this.config.initial?.progress || 0;
          this.gameState.chatHistory = [];
          this.gameState.isObjectiveAchieved = false;

          // é‡ç½®earnedPoints
          this.earnedPoints = 0;

          // æ¸…ç©ºèŠå¤©åŒºåŸŸ
          this.elements.chatContainer.innerHTML = "";

          // æ¸…ç©ºå†…å¿ƒæƒ³æ³•
          this.elements.innerThoughts.innerHTML = "";

          // é‡ç½®è¿›åº¦æ¡åˆ°0
          this.elements.progressBar.style.width = "0%";
          this.elements.progressText.textContent = "0/100";

          // æ·»åŠ åˆå§‹æ¶ˆæ¯
          if (this.config.initial?.message) {
            this.addMessage(this.config.initial.message, false);
          }

          // æ›´æ–°å¿«æ·å›å¤
          this.updateQuickReplies();

          // æ›´æ–°è¿›åº¦æ˜¾ç¤º
          this.updateProgressToValue(0, "æ¸¸æˆå¼€å§‹");

          // åˆ›å»ºæ–°çš„sessionï¼ˆä»…åœ¨ä¸æ˜¯ä»sessionåŠ è½½æ—¶åˆ›å»ºï¼‰
          if (!this.currentSessionId) {
            this.createNewSession();
          } // æ›´æ–°å†å²ä¸‹æ‹‰èœå•
          this.updateHistoryDropdown();

          // æ›´æ–°AIå·¥å…·ç®±é…ç½®
          if (window.aiToolbox) {
            window.aiToolbox.updateConfig(this.config);
          }

          // å°è¯•è‡ªåŠ¨åŠ è½½å†å²è®°å½•ï¼ˆä»…åœ¨é¦–æ¬¡åˆå§‹åŒ–æ—¶ï¼‰
          if (!this.hasAutoLoaded) {
            this.autoLoadHistory().then(() => {
              this.hasAutoLoaded = true;
              // Send game started event after initialization
              window.parent.postMessage({ type: "gameStarted" }, "*");
            });
          } else {
            this.hasAutoLoaded = true;
            // Send game started event
            window.parent.postMessage({ type: "gameStarted" }, "*");
          }
          // if there is only one message (initial), play video animation
          if (this.elements.chatContainer.children.length === 1) {
            this.checkAndPlayVideoAction(this.config.initial?.message);
          } // è®¾ç½®èŠå¤©èƒŒæ™¯
          this.changeChatBackground(this.config?.character?.chat_background);
          this.saveProgress(this.config?.objective?.wikiword, false);

          // æ¸²æŸ“è¿›åº¦æ¡åˆ»åº¦æ ‡å°º
          this.renderProgressMarkers();
        }

        updateQuickReplies() {
          const container = document.getElementById("quick-replies");
          container.innerHTML = "";

          if (!this.config.quick_replies) return;

          this.config.quick_replies.forEach((reply) => {
            const button = document.createElement("button");
            button.className = "quick-reply bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm transition-colors";
            button.textContent = reply;
            button.addEventListener("click", () => {
              this.elements.userInput.value = reply;
              this.sendMessage();
            });
            container.appendChild(button);
          });
        }
        renderProgressMarkers() {
          if (!this.elements.progressMarkers) return;

          // æ¸…ç©ºç°æœ‰æ ‡å°º
          this.elements.progressMarkers.innerHTML = "";

          // æ¸²æŸ“æ¯ä¸ªæ ‡å°º
          this.progressMarkers.forEach((marker) => {
            const markerElement = document.createElement("div");
            markerElement.className = "progress-marker";
            markerElement.style.left = `${marker.percent}%`;

            // è®¾ç½®tooltip - ä½¿ç”¨titleå±æ€§
            markerElement.title = marker.tooltip || "";

            // åˆ›å»ºä¸‰è§’å½¢å…ƒç´ å¹¶åº”ç”¨é¢œè‰²
            const triangleElement = document.createElement("div");
            triangleElement.className = "progress-marker-triangle";
            if (marker.textColor) {
              triangleElement.style.borderTopColor = marker.textColor;
            }

            // åˆ›å»ºæ–‡æœ¬å…ƒç´ å¹¶åº”ç”¨é¢œè‰²
            const textElement = document.createElement("div");
            textElement.className = "progress-marker-text";
            textElement.textContent = marker.text;
            textElement.style.cursor = "pointer";
            if (marker.textColor) {
              textElement.style.color = marker.textColor;
            }
            if (marker.backgroundColor) {
              textElement.style.backgroundColor = marker.backgroundColor;
            }

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶åˆ°æ–‡æœ¬å…ƒç´  - è¿ç»­ç‚¹å‡»5æ¬¡æ‰è·³è½¬åˆ°å¯¹åº”è¿›åº¦ï¼ˆä½œå¼ŠåŠŸèƒ½ï¼‰
            textElement.addEventListener("click", (e) => {
              e.stopPropagation();

              // åˆå§‹åŒ–æˆ–é‡ç½®ç‚¹å‡»è®¡æ•°å™¨
              if (!this.markerClickCounts) {
                this.markerClickCounts = {};
                this.markerClickTimers = {};
              }

              const markerId = `${marker.percent}_${marker.text}`;

              // å¢åŠ ç‚¹å‡»è®¡æ•°
              this.markerClickCounts[markerId] = (this.markerClickCounts[markerId] || 0) + 1;

              // æ·»åŠ ç‚¹å‡»åŠ¨ç”»æ•ˆæœ
              textElement.style.transform = "scale(1.2)";
              setTimeout(() => {
                textElement.style.transform = "scale(1)";
              }, 150);

              // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
              if (this.markerClickTimers[markerId]) {
                clearTimeout(this.markerClickTimers[markerId]);
              }

              // è®¾ç½®2ç§’åé‡ç½®ç‚¹å‡»è®¡æ•°
              this.markerClickTimers[markerId] = setTimeout(() => {
                this.markerClickCounts[markerId] = 0;
              }, 2000);

              console.log(`ç‚¹å‡»æ ‡å°ºï¼š${marker.text} (${marker.percent}%) - ç¬¬${this.markerClickCounts[markerId]}æ¬¡`);

              // å¦‚æœè¿ç»­ç‚¹å‡»5æ¬¡ï¼Œåˆ™æ‰§è¡Œè·³è½¬
              if (this.markerClickCounts[markerId] >= 5) {
                this.markerClickCounts[markerId] = 0; // é‡ç½®è®¡æ•°
                console.log(`æ ‡å°ºè¿ç»­ç‚¹å‡»5æ¬¡ï¼Œæ‰§è¡Œè·³è½¬åˆ°${marker.text}é˜¶æ®µ`);
                // å¦‚æœç›®æ ‡æœªè¾¾æˆï¼Œåˆ™è·³è½¬åˆ°è¯¥è¿›åº¦
                if (!this.gameState.isObjectiveAchieved) {
                  this.updateProgressToValue(marker.percent, `ä½œå¼Šè·³è½¬åˆ°${marker.text}é˜¶æ®µ`);
                  this.updateLLMStatus(`ğŸ® ä½œå¼Šæ¨¡å¼ï¼šå·²è·³è½¬åˆ°${marker.text}é˜¶æ®µ (${marker.percent}%)`);

                  // å¦‚æœè·³è½¬åˆ°100%ï¼Œè§¦å‘å®Œæˆ
                  if (marker.percent >= 100) {
                    this.handleObjectiveAchieved();
                  } else if (marker.percent >= 80) {
                    // å¦‚æœè·³è½¬åˆ°80%ä»¥ä¸Šä½†æ²¡æœ‰åˆ°100%ï¼Œè§¦å‘åŸºæœ¬å®Œæˆ
                    this.handleBasicCompletion();
                  }
                } else {
                  this.updateLLMStatus("ç›®æ ‡å·²å®Œæˆ");
                }
              } else {
                // æ˜¾ç¤ºå½“å‰ç‚¹å‡»æ¬¡æ•°æç¤º
                this.updateLLMStatus(`${marker.text}: ${this.markerClickCounts[markerId]}/5 æ¬¡ç‚¹å‡»`);
              }
            });

            markerElement.appendChild(triangleElement);
            markerElement.appendChild(textElement);

            this.elements.progressMarkers.appendChild(markerElement);
          });
        }

        async sendMessage() {
          let message = this.elements.userInput.value.trim();
          if (!message) return;

          // ç¦ç”¨è¾“å…¥æ§ä»¶
          this.elements.sendBtn.disabled = true;
          this.elements.userInput.disabled = true;

          this.addMessage(message, true);
          this.elements.userInput.value = "";

          // add current percentage to the message
          message = `[current progress: ${this.gameState.progress}%] ${message}`;
          this.gameState.chatHistory.push({ role: "user", content: message });

          this.addTypingIndicator();
          this.updateLLMStatus("æ­£åœ¨è¿æ¥AI...");
          try {
            const { parsedResponse, rawResponse } = await this.callLLM(message);
            if (parsedResponse && rawResponse) {
              // å­˜å‚¨åŸå§‹å“åº”åˆ°èŠå¤©å†å²ä¸­
              this.gameState.chatHistory.push({
                role: "assistant",
                content: parsedResponse.message,
                raw_response: rawResponse, // ä¿å­˜LLMçš„åŸå§‹å“åº”
              });

              // åº”ç”¨å“åº”çš„æ•ˆæœ
              this.applyLLMResponse(parsedResponse);
            }
          } catch (error) {
            this.removeTypingIndicator();
            this.updateLLMStatus(`é”™è¯¯: ${error.message}`);
            this.addMessage("æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æœ‰äº›å›°æ‰°ï¼Œå¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´æ¥æ•´ç†æ€ç»ª...", false);
          } finally {
            // é‡æ–°å¯ç”¨è¾“å…¥æ§ä»¶
            this.elements.sendBtn.disabled = false;
            this.elements.userInput.disabled = false;
            this.elements.userInput.focus();

            // è‡ªåŠ¨ä¿å­˜èŠå¤©å†å²
            this.autoSaveHistory();
          }
        } // åº”ç”¨LLMå“åº”çš„UIæ•ˆæœ
        applyLLMResponse(response, isReplay = false) {
          // è®¡ç®—è¿›åº¦å˜åŒ–å€¼
          const progressChange = response.progress_change || 0;

          // è®°å½•å½“å‰è¿›åº¦ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦å¢åŠ 
          const oldProgress = this.gameState.progress;

          // æ›´æ–°è¿›åº¦
          this.updateProgress(progressChange, response.progress_reason);

          // åªæœ‰åœ¨çœŸå®å¯¹è¯è¿”å›ï¼ˆéé‡æ’­ï¼‰ä¸”è¿›åº¦ç¡®å®å¢åŠ æ—¶æ‰å¢åŠ earnedPoints
          if (!isReplay && progressChange > 0 && this.gameState.progress > oldProgress) {
            const actualProgressIncrease = this.gameState.progress - oldProgress;
            const pointsToAdd = 5 + actualProgressIncrease;
            this.earnedPoints += pointsToAdd;
            console.log(`è¿›åº¦å¢åŠ  ${actualProgressIncrease}ï¼Œè·å¾— ${pointsToAdd} ç§¯åˆ†ï¼Œå½“å‰æ€»ç§¯åˆ†: ${this.earnedPoints}`);
          }

          // æ£€æŸ¥æ˜¯å¦é¦–æ¬¡è¶…è¿‡80%ä½†æ²¡æœ‰åˆ°100%
          if (!isReplay && !this.gameState.hasCommitted && this.gameState.progress >= 80 && this.gameState.progress < this.config.objective.max_progress) {
            this.handleBasicCompletion();
          }

          if (response.inner_thoughts) {
            this.addInnerThought(response.inner_thoughts);
          }

          // åœ¨æœ€åä¸€æ¡æ¶ˆæ¯ä¸‹é¢æ·»åŠ è¿›åº¦æ˜¾ç¤º
          this.addProgressIndicator(progressChange, response.progress_reason);

          if (!isReplay && this.gameState.progress >= this.config.objective.max_progress) {
            this.handleObjectiveAchieved();
          }
        } // Helper function to extract all response fields using regex
        extractResponseFields(text) {
          const fields = {
            message: "",
            progress_change: null,
            progress_reason: "",
            inner_thoughts: "",
          };

          // Extract message field
          const messageRegex = /"message"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/;
          const messageMatch = messageRegex.exec(text);
          if (messageMatch) {
            fields.message = messageMatch[1].replace(/\\"/g, '"').replace(/\\n/g, "\n").replace(/\\\\/g, "\\");
          } // Extract progress_change field
          const progressChangeRegex = /"progress_change"\s*:\s*(-?\d+)/;
          const progressChangeMatch = progressChangeRegex.exec(text);
          if (progressChangeMatch) {
            fields.progress_change = parseInt(progressChangeMatch[1]);
          }

          // Extract progress_reason field
          const progressReasonRegex = /"progress_reason"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/;
          const progressReasonMatch = progressReasonRegex.exec(text);
          if (progressReasonMatch) {
            fields.progress_reason = progressReasonMatch[1].replace(/\\"/g, '"').replace(/\\n/g, "\n").replace(/\\\\/g, "\\");
          }

          // Extract inner_thoughts field
          const thoughtsRegex = /"inner_thoughts"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/;
          const thoughtsMatch = thoughtsRegex.exec(text);
          if (thoughtsMatch) {
            fields.inner_thoughts = thoughtsMatch[1].replace(/\\"/g, '"').replace(/\\n/g, "\n").replace(/\\\\/g, "\\");
          }

          return fields;
        }
        updateStreamingStatus(fields) {
          // åªåœ¨æµå¼ä¼ è¾“è¿‡ç¨‹ä¸­ä¸´æ—¶æ›´æ–°å†…å¿ƒæƒ³æ³•åŒºåŸŸçš„çŠ¶æ€
          if (fields.inner_thoughts) {
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸´æ—¶çš„æµå¼æ˜¾ç¤ºæ•ˆæœï¼Œå¦‚æœéœ€è¦çš„è¯
          }
        }
        async callLLM(userMessage) {
          if (!aiChatSession) {
            throw new Error("AIèŠå¤©ä¼šè¯æœªåˆå§‹åŒ–");
          }

          // ä½¿ç”¨åŸå§‹çš„ç³»ç»Ÿæç¤ºè¯ï¼Œä¸åŒ…å«å½“å‰è¿›åº¦
          const systemPrompt = this.config.system_prompt;

          // ç¡®ä¿ç³»ç»Ÿæç¤ºè¯å­˜åœ¨ä¸”æ­£ç¡®
          if (aiChatSession.messages.length === 0) {
            // æ–°ä¼šè¯ï¼Œæ·»åŠ ç³»ç»Ÿæç¤ºè¯
            aiChatSession.messages.push({ role: "system", content: systemPrompt });
          } else if (aiChatSession.messages[0].role !== "system") {
            // å·²æœ‰æ¶ˆæ¯ä½†ç¬¬ä¸€æ¡ä¸æ˜¯ç³»ç»Ÿæç¤ºè¯ï¼Œåœ¨å¼€å¤´æ’å…¥
            aiChatSession.messages.unshift({ role: "system", content: systemPrompt });
          } else {
            // å·²æœ‰ç³»ç»Ÿæç¤ºè¯ï¼Œç¡®ä¿å†…å®¹æ˜¯æœ€æ–°çš„ï¼ˆé€‚ç”¨äºé…ç½®æ›´æ”¹çš„æƒ…å†µï¼‰
            aiChatSession.messages[0].content = systemPrompt;
          }

          console.log("Sending message with", aiChatSession.messages.length, "existing messages");
          console.log(
            "Messages:",
            aiChatSession.messages.map((m) => ({ role: m.role, contentLength: m.content.length }))
          );

          try {
            let streamingMessageDiv = null;
            let accumulatedText = "";
            let jsonResponse = null;

            const finalText = await aiChatSession.send(userMessage, {
              onMessage: (text) => {
                accumulatedText = text;
                this.updateLLMStatus("æ¥æ”¶å“åº”ä¸­...");

                // ä½¿ç”¨helperå‡½æ•°æå–æ‰€æœ‰å­—æ®µ
                const fields = this.extractResponseFields(text);

                // å°è¯•è§£æå®Œæ•´JSON
                try {
                  jsonResponse = JSON.parse(text);
                } catch (e) {
                  // JSONå¯èƒ½ä¸å®Œæ•´ï¼Œç»§ç»­ç­‰å¾…
                }

                // ç§»é™¤æ‰“å­—æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœè¿˜åœ¨ï¼‰
                if (!streamingMessageDiv) {
                  this.removeTypingIndicator();
                  // åˆ›å»ºæµå¼æ¶ˆæ¯å®¹å™¨
                  streamingMessageDiv = this.addStreamingMessage();
                }

                // æ›´æ–°æµå¼æ¶ˆæ¯å†…å®¹ï¼Œåªæ˜¾ç¤ºmessageéƒ¨åˆ†
                if (fields.message) {
                  this.updateStreamingMessage(streamingMessageDiv, fields.message);
                }

                // æ›´æ–°æµå¼çŠ¶æ€æ˜¾ç¤º
                this.updateStreamingStatus(fields);
              },
              onComplete: (finalText) => {
                this.updateLLMStatus("å“åº”å®Œæˆ");

                // ç¡®ä¿ä½¿ç”¨æœ€ç»ˆæ–‡æœ¬è§£æJSON
                if (!jsonResponse) {
                  try {
                    jsonResponse = JSON.parse(finalText);
                  } catch (e) {
                    const fields = this.extractResponseFields(finalText);
                    jsonResponse = {
                      message: fields.message || finalText,
                      progress_change: fields.progress_change !== null ? fields.progress_change : 0,
                      progress_reason: fields.progress_reason || "ç§¯æäº¤æµ",
                      inner_thoughts: fields.inner_thoughts || "æ­£åœ¨æ€è€ƒ",
                    };
                  }
                }

                if (streamingMessageDiv) {
                  // å®Œæˆæµå¼æ˜¾ç¤ºï¼Œè½¬æ¢ä¸ºæ™®é€šæ¶ˆæ¯
                  this.finalizeStreamingMessage(streamingMessageDiv);
                }
              },
              onError: (error) => {
                if (streamingMessageDiv) {
                  this.removeStreamingMessage(streamingMessageDiv);
                }
                throw error;
              },
            });

            // è¿”å›è§£æåçš„å“åº”å’ŒåŸå§‹å“åº”
            return {
              parsedResponse: jsonResponse,
              rawResponse: finalText,
            };
          } catch (error) {
            throw error;
          }
        }
        addMessage(message, isUser = false) {
          const messageDiv = document.createElement("div");
          messageDiv.className = `flex items-start space-x-2 ${isUser ? "justify-end" : ""}`;

          const processedMessage = this.processMessage(message);

          if (isUser) {
            messageDiv.innerHTML = `
                              <div class="chat-bubble-right text-white p-3 max-w-xs">
                                  <p>${processedMessage}</p>
                              </div>
                              <div class="w-8 h-8 bg-gradient-to-r from-pink-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">ä½ </div>
                          `;
          } else {
            messageDiv.innerHTML = `
                              <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                                this.config.character?.name?.[0] || "è§’"
                              }</div>
                              <div class="chat-bubble-left text-white p-3 max-w-xs">
                                  <p>${processedMessage}</p>
                              </div>
                              <button class="audio-btn" title="æ’­æ”¾è¯­éŸ³" onclick="game.playMessageAudio('${this.escapeForAttribute(message)}', this)">
                                  ğŸ”Š
                              </button>
                          `;
          }

          this.elements.chatContainer.appendChild(messageDiv);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        processMessage(message) {
          return message.replace(/\(([^)]+)\)/g, '<span class="action-text">($1)</span>');
        }

        // è½¬ä¹‰å­—ç¬¦ä¸²ç”¨äºHTMLå±æ€§
        escapeForAttribute(str) {
          return str.replace(/'/g, "&#39;").replace(/"/g, "&quot;").replace(/\\/g, "\\\\");
        }
        checkAndPlayVideoAction(message) {
          if (!this.config.videoActions || !message) return;

          // æå–æ‰€æœ‰æ‹¬å·ä¸­çš„æ–‡å­—
          const actionMatches = message.match(/\(([^)]+)\)/g);
          if (!actionMatches) return;

          // åˆå¹¶æ‰€æœ‰æ‹¬å·ä¸­çš„æ–‡å­—
          const allActions = actionMatches.map((match) => match.replace(/[()]/g, "")).join(" ");

          // æ£€æŸ¥æ˜¯å¦åŒ…å«é…ç½®ä¸­çš„åŠ¨ä½œå…³é”®è¯
          for (const actionKey in this.config.videoActions) {
            if (allActions.includes(actionKey)) {
              this.playVideoAction(actionKey, message);
              break;
            }
          }
        }
        playVideoAction(actionKey, messageText) {
          const videoConfig = this.config.videoActions[actionKey];
          if (!videoConfig) return;

          // æ˜¾ç¤ºè§†é¢‘æ’­æ”¾å™¨è¦†ç›–å±‚
          const overlay = document.getElementById("character-video-overlay");
          const messageDiv = document.getElementById("character-video-message");
          const videoElement = document.getElementById("character-video-element");
          const backBtn = document.getElementById("character-video-back-btn");

          // è®¾ç½®æ¶ˆæ¯æ–‡æœ¬
          messageDiv.textContent = messageText;

          // æ˜¾ç¤ºè¦†ç›–å±‚
          overlay.classList.add("show");

          // æ’­æ”¾è§†é¢‘
          this.loadAndPlayVideo(videoElement, videoConfig.url);

          // å…³é—­è¦†ç›–å±‚çš„å‡½æ•°
          const closeOverlay = () => {
            overlay.classList.remove("show");
            // åœæ­¢è§†é¢‘æ’­æ”¾
            videoElement.pause();
            videoElement.src = "";
            backBtn.removeEventListener("click", handleBackClick);
            overlay.removeEventListener("click", handleOverlayClick);
          };

          // ç»‘å®šè¿”å›æŒ‰é’®äº‹ä»¶
          const handleBackClick = () => {
            closeOverlay();
          };
          backBtn.addEventListener("click", handleBackClick);

          // ç»‘å®šè¦†ç›–å±‚ç‚¹å‡»äº‹ä»¶ï¼ˆç‚¹å‡»ä»»æ„ä½ç½®å…³é—­ï¼‰
          const handleOverlayClick = (e) => {
            // åªæœ‰ç‚¹å‡»è¦†ç›–å±‚æœ¬èº«æ‰å…³é—­ï¼Œä¸åŒ…æ‹¬å†…å®¹å®¹å™¨
            if (e.target === overlay) {
              closeOverlay();
            }
          };
          overlay.addEventListener("click", handleOverlayClick);
        }
        async loadAndPlayVideo(videoElement, videoUrl) {
          try {
            if (!videoElement) {
              console.error("Video element is null");
              return;
            }

            // Set video source and properties
            videoElement.src = videoUrl;
            videoElement.loop = true;
            videoElement.muted = true; // é™éŸ³ä»¥å…è®¸è‡ªåŠ¨æ’­æ”¾

            // Handle video load and play
            videoElement.addEventListener("loadeddata", () => {
              // å¼€å§‹æ’­æ”¾
              videoElement.play().catch((error) => {
                console.error("è§†é¢‘æ’­æ”¾å¤±è´¥:", error);
              });
            });

            videoElement.addEventListener("error", (e) => {
              console.error("è§†é¢‘åŠ è½½å¤±è´¥:", e);
              // Show error message in video element (could be done by replacing src with error image)
              videoElement.style.backgroundColor = "#667eea";
              videoElement.style.display = "flex";
              videoElement.style.alignItems = "center";
              videoElement.style.justifyContent = "center";
              videoElement.style.color = "white";
              videoElement.style.fontSize = "16px";
              videoElement.innerHTML = "è§†é¢‘åŠ è½½å¤±è´¥";
            });

            // Load the video
            videoElement.load();
          } catch (error) {
            console.error("æ’­æ”¾è§†é¢‘æ—¶å‡ºé”™:", error);
          }
        }

        // ç§»é™¤æ‹¬å·å†…å®¹ç”¨äºè¯­éŸ³æ’­æ”¾
        removeBracketsContent(text) {
          // ç§»é™¤ä¸­æ–‡æ‹¬å·å’Œè‹±æ–‡æ‹¬å·ä¸­çš„å†…å®¹
          return text
            .replace(/\([^)]*\)/g, "")
            .replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, "")
            .trim();
        } // æ’­æ”¾æ¶ˆæ¯è¯­éŸ³
        async playMessageAudio(messageText, buttonElement) {
          try {
            // å¦‚æœæ²¡æœ‰ä¼ å…¥æŒ‰é’®å…ƒç´ ï¼Œé€šè¿‡æ–‡æœ¬å†…å®¹æŸ¥æ‰¾
            let currentButton = buttonElement;
            if (!currentButton) {
              const audioButtons = document.querySelectorAll(".audio-btn");
              audioButtons.forEach((btn) => {
                const bubble = btn.closest(".chat-bubble-left");
                if (bubble) {
                  const content = bubble.querySelector("p") || bubble.querySelector(".streaming-content");
                  if (content && content.textContent.includes(messageText.substring(0, 20))) {
                    currentButton = btn;
                  }
                }
              });
            }

            // å¦‚æœå½“å‰æœ‰éŸ³é¢‘æ­£åœ¨æ’­æ”¾
            if (this.currentPlayingButton) {
              // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªæŒ‰é’®ï¼Œåˆ™åœæ­¢æ’­æ”¾
              if (currentButton === this.currentPlayingButton) {
                this.stopCurrentAudio();
                return;
              } else {
                // åœæ­¢å½“å‰æ’­æ”¾ï¼Œå¼€å§‹æ–°çš„æ’­æ”¾
                this.stopCurrentAudio();
              }
            }

            // è¿‡æ»¤æ‰æ‹¬å·ä¸­çš„å†…å®¹
            const textToRead = this.removeBracketsContent(messageText);

            if (!textToRead.trim()) {
              console.log("æ²¡æœ‰å¯æ’­æ”¾çš„æ–‡æœ¬å†…å®¹");
              return;
            }

            if (!currentButton) {
              console.log("æ‰¾ä¸åˆ°å¯¹åº”çš„éŸ³é¢‘æŒ‰é’®");
              return;
            }

            // è®¾ç½®æ’­æ”¾çŠ¶æ€
            currentButton.classList.add("playing");
            currentButton.innerHTML = "â¸ï¸";
            currentButton.title = "åœæ­¢è¯­éŸ³";

            // ä¿å­˜å½“å‰æ’­æ”¾ä¿¡æ¯
            this.currentPlayingButton = currentButton; // ä½¿ç”¨SDKæ’­æ”¾è¯­éŸ³
            try {
              let audio_url;

              // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²æœ‰è¯¥æ–‡æœ¬çš„éŸ³é¢‘URL
              if (this.audioCache.has(textToRead)) {
                audio_url = this.audioCache.get(textToRead);
                console.log("ä½¿ç”¨ç¼“å­˜çš„éŸ³é¢‘URL");
              } else {
                // ä»SDKè·å–æ–°çš„éŸ³é¢‘URL
                const result = await sdk.speech.textToAudio(textToRead, {
                  gender: this.config.character?.gender,
                  age: this.config.character?.age,
                });

                if (result && result.data) {
                  audio_url = result.data;
                  // ç¼“å­˜éŸ³é¢‘URL
                  this.audioCache.set(textToRead, audio_url);
                  console.log("ç¼“å­˜æ–°çš„éŸ³é¢‘URL");
                } else {
                  throw new Error("æ— æ³•è·å–éŸ³é¢‘URL");
                }
              }

              if (audio_url) {
                // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
                const audio = new Audio(audio_url);

                // ç¡®ä¿éŸ³é¢‘ä¸å¾ªç¯æ’­æ”¾
                audio.loop = false;

                // ä¿å­˜éŸ³é¢‘æ§åˆ¶å™¨å¼•ç”¨
                this.currentAudioController = audio;

                // éŸ³é¢‘æ’­æ”¾å®Œæˆäº‹ä»¶
                audio.addEventListener("ended", () => {
                  console.log("éŸ³é¢‘æ’­æ”¾å®Œæˆ");
                  this.stopCurrentAudio();
                });

                // éŸ³é¢‘å‡ºé”™äº‹ä»¶
                audio.addEventListener("error", (e) => {
                  console.error("éŸ³é¢‘æ’­æ”¾å‡ºé”™:", e);
                  this.stopCurrentAudio();
                });

                // éŸ³é¢‘åŠ è½½å®Œæˆåå¼€å§‹æ’­æ”¾
                audio.addEventListener("canplay", () => {
                  // ç¡®ä¿å½“å‰æŒ‰é’®ä»ç„¶æ˜¯æ­£ç¡®çš„æŒ‰é’®ï¼ˆé˜²æ­¢å¿«é€Ÿç‚¹å‡»å¯¼è‡´çš„çŠ¶æ€æ··ä¹±ï¼‰
                  if (this.currentPlayingButton === currentButton && this.currentAudioController === audio) {
                    audio.play().catch((error) => {
                      console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
                      this.stopCurrentAudio();
                    });
                  }
                });

                // åŠ è½½éŸ³é¢‘
                audio.load();
              }
            } catch (audioError) {
              console.error("è¯­éŸ³æ’­æ”¾å‡ºé”™:", audioError);
              this.stopCurrentAudio();
            }
          } catch (error) {
            console.error("è¯­éŸ³æ’­æ”¾å¤±è´¥:", error);
            this.stopCurrentAudio();
          }
        } // åœæ­¢å½“å‰éŸ³é¢‘æ’­æ”¾
        stopCurrentAudio() {
          // åœæ­¢å¹¶æ¸…ç†éŸ³é¢‘
          if (this.currentAudioController) {
            this.currentAudioController.pause();
            this.currentAudioController.currentTime = 0;
            this.currentAudioController = null;
          }

          // é‡ç½®æŒ‰é’®çŠ¶æ€
          if (this.currentPlayingButton) {
            this.currentPlayingButton.classList.remove("playing");
            this.currentPlayingButton.innerHTML = "ğŸ”Š";
            this.currentPlayingButton.title = "æ’­æ”¾è¯­éŸ³";
            this.currentPlayingButton = null;
          }
        }

        addStreamingMessage() {
          const messageDiv = document.createElement("div");
          messageDiv.className = "flex items-start space-x-2 streaming-message";
          messageDiv.innerHTML = `
                          <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                            this.config.character?.name?.[0] || "è§’"
                          }</div>
                          <div class="chat-bubble-left text-white p-3 max-w-xs">
                              <p class="streaming-content"></p>
                              <span class="streaming-cursor">â–‹</span>
                          </div>
                      `;
          this.elements.chatContainer.appendChild(messageDiv);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          return messageDiv;
        }

        updateStreamingMessage(messageDiv, text) {
          const contentElement = messageDiv.querySelector(".streaming-content");
          if (contentElement) {
            contentElement.innerHTML = this.processMessage(text);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }
        }
        finalizeStreamingMessage(messageDiv) {
          const cursor = messageDiv.querySelector(".streaming-cursor");
          if (cursor) {
            cursor.remove();
          }
          messageDiv.classList.remove("streaming-message");

          // ä¸ºå®Œæˆçš„æµå¼æ¶ˆæ¯æ·»åŠ è¯­éŸ³æ’­æ”¾æŒ‰é’®
          const contentElement = messageDiv.querySelector(".streaming-content");
          if (contentElement) {
            const messageText = contentElement.textContent || contentElement.innerText;
            const audioBtn = document.createElement("button");
            audioBtn.className = "audio-btn";
            audioBtn.title = "æ’­æ”¾è¯­éŸ³";
            audioBtn.innerHTML = "ğŸ”Š";
            audioBtn.onclick = () => this.playMessageAudio(messageText, audioBtn);

            // å°†æŒ‰é’®æ·»åŠ åˆ°æœ€å¤–å±‚ div çš„æœ€åï¼Œä¸ addMessage æ–¹æ³•ä¿æŒä¸€è‡´
            messageDiv.appendChild(audioBtn);
            this.checkAndPlayVideoAction(messageText);
          }
        }

        removeStreamingMessage(messageDiv) {
          if (messageDiv && messageDiv.parentNode) {
            messageDiv.parentNode.removeChild(messageDiv);
          }
        }
        addTypingIndicator() {
          const typingDiv = document.createElement("div");
          typingDiv.id = "typing-indicator";
          typingDiv.className = "flex items-start space-x-2";
          typingDiv.innerHTML = `
                          <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                            this.config.character?.name?.[0] || "è§’"
                          }</div>
                          <div class="chat-bubble-left text-white p-3 max-w-xs typing-indicator">
                              <p>æ­£åœ¨æ€è€ƒ...</p>
                          </div>
                      `;
          this.elements.chatContainer.appendChild(typingDiv);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        removeTypingIndicator() {
          const indicator = document.getElementById("typing-indicator");
          if (indicator) indicator.remove();
        }

        addProgressIndicator(progressChange, progressReason) {
          if (!progressChange || progressChange === 0) return;

          const progressDiv = document.createElement("div");
          progressDiv.className = "flex justify-center my-2";

          const progressText = progressChange > 0 ? `+${progressChange}` : `${progressChange}`;
          const progressEmoji = progressChange > 0 ? "ğŸ˜„" : "ğŸ˜";

          progressDiv.innerHTML = `
                          <div class="bg-gray-100 rounded-full px-3 py-1 text-sm text-gray-600">
                              ${progressEmoji}${progressText}ï¼ˆ${progressReason}ï¼‰
                          </div>
                      `;

          this.elements.chatContainer.appendChild(progressDiv);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        updateProgress(change, reason) {
          this.gameState.progress = Math.max(0, Math.min(this.gameState.progress + change, this.config.objective.max_progress));
          this.elements.progressBar.style.width = `${this.gameState.progress}%`;
          this.elements.progressText.textContent = `${this.gameState.progress}/${this.config.objective.max_progress}`;
        }

        updateProgressToValue(newProgress, reason) {
          this.gameState.progress = Math.max(0, Math.min(newProgress, this.config.objective.max_progress));
          this.elements.progressBar.style.width = `${this.gameState.progress}%`;
          this.elements.progressText.textContent = `${this.gameState.progress}/${this.config.objective.max_progress}`;
        }
        addInnerThought(thought) {
          if (!thought || thought.trim() === "") return;

          // ä½¿ç”¨thoughts-contentå®¹å™¨è€Œä¸æ˜¯inner-thoughts
          const thoughtsContainer = document.getElementById("thoughts-content");
          if (!thoughtsContainer) return;

          const thoughtDiv = document.createElement("div");
          thoughtDiv.className = "thought-bubble";

          const thoughtText = document.createElement("div");
          thoughtText.className = "thought-bubble-text";
          thoughtText.textContent = thought;

          thoughtDiv.appendChild(thoughtText);
          thoughtsContainer.appendChild(thoughtDiv);

          // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°çš„å†…å¿ƒæƒ³æ³•
          thoughtsContainer.scrollTop = thoughtsContainer.scrollHeight;

          // é™åˆ¶æ˜¾ç¤ºçš„å†…å¿ƒæƒ³æ³•æ•°é‡ï¼Œé¿å…è¿‡å¤šå ç”¨ç©ºé—´
          const maxThoughts = 5;
          const thoughts = thoughtsContainer.children;
          while (thoughts.length > maxThoughts) {
            thoughtsContainer.removeChild(thoughts[0]);
          }
        }

        updateLLMStatus(status) {
          this.elements.llmStatus.textContent = status;
          setTimeout(() => {
            this.elements.llmStatus.textContent = "";
          }, 3000);
        }
        async saveProgress(wikiWord, isFinished = false) {
          try {
            // Check if this is a custom question
            const customQuestionId = this.config?.objective?.customQuestionId;

            // Early return if there's nothing to save
            if (!customQuestionId && !wikiWord) {
              return;
            }

            // Load current progress data from keepwork
            let progressData = await sdk.personalPageStore.loadPageData("maisi_dragon_wiki", "discussion-progress-data");
            // Ensure data structure exists
            if (!progressData || typeof progressData !== "object") {
              progressData = {
                completed_wikiwords: [],
                completed_times: [],
                inprogress_wikiwords: [],
                inprogress_times: [],
                currentperiod_wikiwords: [],
                currentperiod_times: [],
                custom_questions: [], // Ensure custom_questions array exists
              };
            } else {
              progressData = JSON.parse(JSON.stringify(progressData));
              // Ensure custom_questions array exists
              if (!Array.isArray(progressData.custom_questions)) {
                progressData.custom_questions = [];
              }
            }

            // Get current date in YYMMDD format
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = (now.getMonth() + 1).toString().padStart(2, "0");
            const day = now.getDate().toString().padStart(2, "0");
            const currentDateCode = parseInt(year + month + day);

            if (customQuestionId) {
              // Handle custom question progress
              const customIndex = progressData.custom_questions.findIndex((q) => q.id === customQuestionId);

              if (customIndex !== -1) {
                if (!isFinished) {
                  // Set to progress status
                  progressData.custom_questions[customIndex].status = "progress";
                  progressData.custom_questions[customIndex].progressTime = currentDateCode;
                  console.log(`Updated custom question ${customQuestionId} to progress status`);
                } else {
                  // Set to completed status
                  progressData.custom_questions[customIndex].status = "completed";
                  progressData.custom_questions[customIndex].completedTime = currentDateCode;
                  delete progressData.custom_questions[customIndex].progressTime;
                  console.log(`Updated custom question ${customQuestionId} to completed status`);
                }
              } else {
                console.warn(`Custom question ${customQuestionId} not found in data`);
              }

              // Also handle wikiword if the custom question has one
              if (wikiWord) {
                this.handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode);
              }
            } else if (wikiWord) {
              // Handle regular wikiword question
              this.handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode);
            }

            // Save updated data back to keepwork
            await sdk.personalPageStore.savePageData("maisi_dragon_wiki", "discussion-progress-data", progressData, true);
            console.log(`Successfully saved progress for ${customQuestionId || wikiWord}`);
          } catch (error) {
            console.error("Error saving progress:", error);
          }
        }

        // Helper function to handle wikiword progress
        handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode) {
          if (!isFinished) {
            // If already completed, do not add to in-progress
            if (progressData.completed_wikiwords.includes(wikiWord) || progressData.inprogress_wikiwords.includes(wikiWord)) return;

            // Add to in-progress arrays if not already there
            progressData.inprogress_wikiwords.push(wikiWord);
            progressData.inprogress_times.push(currentDateCode);
            console.log(`Added ${wikiWord} to in-progress arrays with date ${currentDateCode}`);
          } else {
            // Remove wikiword from inprogress arrays if it exists
            const progressIndex = progressData.inprogress_wikiwords.indexOf(wikiWord);
            if (progressIndex > -1) {
              progressData.inprogress_wikiwords.splice(progressIndex, 1);
              // Also remove corresponding time entry
              if (progressData.inprogress_times.length > progressIndex) {
                progressData.inprogress_times.splice(progressIndex, 1);
              }
              console.log(`Removed ${wikiWord} from progress arrays`);
            }

            // Add to completed arrays if not already there
            if (!progressData.completed_wikiwords.includes(wikiWord)) {
              progressData.completed_wikiwords.push(wikiWord);
              progressData.completed_times.push(currentDateCode);
              console.log(`Added ${wikiWord} to completed arrays with date ${currentDateCode}`);
            }
          }
        }

        handleBasicCompletion() {
          if (this.gameState.hasCommitted) return;
          this.gameState.hasCommitted = true;

          // Send game commit event to host with same data as gameFinished
          window.parent.postMessage(
            {
              type: "gameCommit",
              data: {
                score: this.gameState.progress,
                earnedPoints: this.earnedPoints,
                characterName: this.config?.character?.name || "è§’è‰²",
                totalMessages: this.gameState.chatHistory.length,
                finalProgress: this.gameState.progress,
                isMaxDifficulty: true, // prevent selecting difficulty again
              },
            },
            "*"
          );

          // å‘é€å®ŒgameCommitåç«‹å³æ¸…é›¶earnedPoints
          this.earnedPoints = 0;

          setTimeout(() => {
            const congratsDiv = document.createElement("div");
            congratsDiv.className = "bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg mt-4";

            congratsDiv.innerHTML = `
                              <div class="flex items-center">
                                  <span class="text-2xl mr-2">ğŸ¯</span>
                                  <div>
                                      <strong>ä»»åŠ¡åŸºæœ¬å®Œæˆï¼</strong><br>
                                      <span class="text-sm">ä½ å·²ç»æˆåŠŸå¸®åŠ©${this.config.character?.name || "è§’è‰²"}è§£å†³äº†å¤§éƒ¨åˆ†é—®é¢˜ï¼ç»§ç»­åŠªåŠ›ï¼</span>
                                  </div>
                              </div>
                          `;
            this.elements.chatContainer.appendChild(congratsDiv);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }, 1000);
        }

        handleObjectiveAchieved() {
          if (this.gameState.isObjectiveAchieved) return;
          this.gameState.isObjectiveAchieved = true;

          this.saveProgress(this.config?.objective?.wikiword, true); // Send game finished event to host
          window.parent.postMessage(
            {
              type: "gameFinished",
              data: {
                score: this.gameState.progress,
                earnedPoints: this.earnedPoints,
                characterName: this.config?.character?.name || "è§’è‰²",
                totalMessages: this.gameState.chatHistory.length,
                finalProgress: this.gameState.progress,
                isMaxDifficulty: true, // prevent selecting difficulty again
              },
            },
            "*"
          );

          // å‘é€å®ŒgameFinishedåç«‹å³æ¸…é›¶earnedPoints
          this.earnedPoints = 0;

          setTimeout(() => {
            const congratsDiv = document.createElement("div");
            congratsDiv.className = "bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg mt-4";

            // Get messages from config with template replacement
            const title = this.config.completion_messages?.title || "ç›®æ ‡å®Œæˆï¼";
            const description = (this.config.completion_messages?.description || "ä½ æˆåŠŸå¸®åŠ©${character_name}æ‰¾å›äº†å­¦ä¹ åŠ¨åŠ›ï¼").replace("${character_name}", this.config.character?.name || "è§’è‰²");
            const icon = this.config.completion_messages?.icon || "ğŸ‰";

            congratsDiv.innerHTML = `
                              <div class="flex items-center">
                                  <span class="text-2xl mr-2">${icon}</span>
                                  <div>
                                      <strong>${title}</strong><br>
                                      <span class="text-sm">${description}</span>
                                  </div>
                              </div>
                          `;
            this.elements.chatContainer.appendChild(congratsDiv);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }, 1000);
        }
        getHistoryKey() {
          const objectiveTitle = this.config?.objective?.title || "ç›®æ ‡è¿›åº¦";
          const characterName = this.config?.character?.name || "è§’è‰²";
          return `chat_history_${objectiveTitle}_${characterName}`;
        }
        autoSaveHistory() {
          // ä½¿ç”¨æ–°çš„sessionç³»ç»Ÿä¿å­˜
          this.saveCurrentSessionToHistory();
        }

        async autoLoadHistory() {
          try {
            // å°è¯•åŠ è½½æœ€æ–°çš„session
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            if (sessions.length > 0) {
              console.log("Found", sessions.length, "saved sessions, loading latest");
              // åŠ è½½æœ€æ–°çš„sessionï¼ˆæ•°ç»„ç¬¬ä¸€ä¸ªæ˜¯æœ€æ–°çš„ï¼‰
              const latestSession = sessions[0];
              await this.loadSession(latestSession.id);
              return;
            }

            console.log("æ²¡æœ‰æ‰¾åˆ°å†å²ä¼šè¯ï¼Œå¼€å§‹æ–°ä¼šè¯");
          } catch (error) {
            console.error("è‡ªåŠ¨åŠ è½½å†å²è®°å½•å¤±è´¥:", error);
          }
        } // é‡æ–°ç»‘å®šéŸ³é¢‘æŒ‰é’®äº‹ä»¶ï¼ˆåœ¨åŠ è½½å†å²è®°å½•åè°ƒç”¨ï¼‰
        rebindAudioButtons() {
          const audioButtons = this.elements.chatContainer.querySelectorAll(".audio-btn");
          audioButtons.forEach((button) => {
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            button.onclick = null;

            // æ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯æ–‡æœ¬
            const messageDiv = button.closest(".flex");
            if (messageDiv) {
              const chatBubble = messageDiv.querySelector(".chat-bubble-left, .chat-bubble-right");
              if (chatBubble) {
                const messageText = chatBubble.textContent || chatBubble.innerText;
                button.onclick = () => this.playMessageAudio(messageText, button);
              }
            }
          });
        }

        // ========== Sessionç®¡ç†æ–¹æ³• ==========
        createNewSession() {
          this.currentSessionId = this.generateSessionId();

          // é‡æ–°åˆå§‹åŒ–AIèŠå¤©ä¼šè¯
          if (sdk && sdk.aiChat) {
            aiChatSession = sdk.aiChat.createSession({
              model: "keepwork-pro",
              stream: true,
            });

            // ä¸ºæ–°ä¼šè¯æ·»åŠ ç³»ç»Ÿæç¤ºè¯
            if (this.config && this.config.system_prompt) {
              aiChatSession.messages.push({ role: "system", content: this.config.system_prompt });
            }

            console.log("New AI session created with system prompt, messages count:", aiChatSession.messages.length);
          }
        }

        // ç”Ÿæˆsession ID
        generateSessionId() {
          return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        resetChat() {
          // ä¿å­˜å½“å‰sessionåˆ°å†å²è®°å½•ï¼ˆå¦‚æœæœ‰èŠå¤©è®°å½•ä¸”è¿›åº¦å¤§äº0çš„è¯ï¼‰
          if (this.gameState.chatHistory.length > 0 && this.gameState.progress > 0) {
            this.saveCurrentSessionToHistory();
          }

          // æ¸…ç©ºå½“å‰session IDï¼Œç¡®ä¿åˆ›å»ºæ–°session
          this.currentSessionId = null; // é‡ç½®æ¸¸æˆçŠ¶æ€
          this.gameState = {
            progress: 0,
            chatHistory: [],
            isObjectiveAchieved: false,
            hasCommitted: false,
          };

          // é‡ç½®earnedPoints
          this.earnedPoints = 0;

          // åˆ›å»ºæ–°çš„session
          this.createNewSession();

          // æ¸…ç©ºUIçŠ¶æ€
          this.elements.chatContainer.innerHTML = "";
          this.elements.innerThoughts.innerHTML = "";

          // é‡ç½®è¿›åº¦æ¡
          this.elements.progressBar.style.width = "0%";
          this.elements.progressText.textContent = "0/100";

          // æ·»åŠ åˆå§‹æ¶ˆæ¯
          if (this.config.initial?.message) {
            this.addMessage(this.config.initial.message, false);
          }

          // æ›´æ–°å†å²ä¸‹æ‹‰èœå•
          this.updateHistoryDropdown();

          this.updateLLMStatus("å¯¹è¯å·²é‡ç½®ï¼Œå¼€å§‹æ–°çš„ä¼šè¯");

          if (this.elements.chatContainer.children.length === 1) {
            this.checkAndPlayVideoAction(this.config.initial?.message);
          }
        }
        saveCurrentSessionToHistory() {
          // å¦‚æœæ²¡æœ‰session IDã€æ²¡æœ‰èŠå¤©è®°å½•æˆ–è¿›åº¦ä¸º0ï¼Œåˆ™ä¸ä¿å­˜
          if (!this.currentSessionId || this.gameState.chatHistory.length === 0 || this.gameState.progress === 0) {
            return;
          }

          try {
            // è·å–ç°æœ‰çš„sessionå†å²è®°å½•
            const sessionsKey = this.getSessionsStorageKey();
            const existingSessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            // åˆ›å»ºå½“å‰sessionçš„æ•°æ® - åªä¿å­˜åŸå§‹èŠå¤©å†å²
            const currentTime = new Date();
            const sessionData = {
              id: this.currentSessionId,
              timestamp: currentTime.toISOString(),
              chatHistory: [...this.gameState.chatHistory], // åŒ…å«raw_responseçš„å®Œæ•´å†å²
            };

            // æ·»åŠ åˆ°å†å²è®°å½•æ•°ç»„çš„å¼€å¤´
            existingSessions.unshift(sessionData);

            // é™åˆ¶æœ€å¤šä¿å­˜10ä¸ªsession
            if (existingSessions.length > this.maxSessions) {
              existingSessions.splice(this.maxSessions);
            }

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem(sessionsKey, JSON.stringify(existingSessions));

            // æ›´æ–°ä¸‹æ‹‰èœå•
            this.updateHistoryDropdown();
          } catch (error) {
            console.error("ä¿å­˜sessionå†å²è®°å½•å¤±è´¥:", error);
          }
        }
        updateHistoryDropdown() {
          try {
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            // æ¸…ç©ºä¸‹æ‹‰èœå•ï¼Œæ·»åŠ é»˜è®¤é€‰é¡¹å’Œæ¸…ç©ºå†å²é€‰é¡¹
            this.elements.historyDropdown.innerHTML = `
                              <option value="" disabled selected class="text-black bg-white">å†å²</option>
                              <option value="clearHistory" class="text-black bg-white">æ¸…ç©ºå†å²</option>
                          `; // æ·»åŠ sessioné€‰é¡¹
            sessions.forEach((session) => {
              const option = document.createElement("option");
              option.value = session.id;

              // è®¡ç®—sessionçš„æœ€ç»ˆè¿›åº¦
              const finalProgress = this.calculateSessionProgress(session.chatHistory);
              const timestamp = new Date(session.timestamp);
              option.textContent = `è¿›åº¦${finalProgress}% - ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString()}`;
              option.className = "text-black bg-white";
              this.elements.historyDropdown.appendChild(option);
            });

            // ä¿æŒé»˜è®¤é€‰é¡¹"å†å²"è¢«é€‰ä¸­ï¼ˆä¸éœ€è¦é‡ç½®ï¼‰
          } catch (error) {
            console.error("æ›´æ–°å†å²ä¸‹æ‹‰èœå•å¤±è´¥:", error);
          }
        }

        // è®¡ç®—sessionçš„æœ€ç»ˆè¿›åº¦
        calculateSessionProgress(chatHistory) {
          let progress = 0;

          for (const msg of chatHistory) {
            if (msg.role === "assistant" && msg.raw_response) {
              try {
                const parsedResponse = JSON.parse(msg.raw_response);
                if (parsedResponse.progress_change !== undefined) {
                  progress += parsedResponse.progress_change;
                }
              } catch (e) {
                // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ç”¨æ­£åˆ™æå–
                const fields = this.extractResponseFields(msg.raw_response);
                if (fields.progress_change !== null) {
                  progress += fields.progress_change;
                }
              }
            }
          }

          return progress;
        }
        async loadSession(sessionId) {
          try {
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            const session = sessions.find((s) => s.id === sessionId);
            if (!session) {
              console.error("æ‰¾ä¸åˆ°æŒ‡å®šçš„session:", sessionId);
              return;
            }

            // ä¿å­˜å½“å‰sessionï¼ˆå¦‚æœæœ‰èŠå¤©è®°å½•ä¸”è¿›åº¦å¤§äº0çš„è¯ï¼‰
            if (this.gameState.chatHistory.length > 0 && this.gameState.progress > 0) {
              this.saveCurrentSessionToHistory();
            } // é‡ç½®çŠ¶æ€
            this.currentSessionId = session.id;
            this.gameState = {
              progress: 0,
              chatHistory: [],
              isObjectiveAchieved: false,
            };
            // earnedPointsä¸ä¼šåœ¨loadSessionä¸­é‡ç½®ï¼Œä¿æŒå½“å‰å€¼
            this.elements.chatContainer.innerHTML = "";
            this.elements.innerThoughts.innerHTML = "";
            this.elements.progressBar.style.width = "0%";
            this.elements.progressText.textContent = "0/100";

            // æ·»åŠ åˆå§‹æ¶ˆæ¯
            if (this.config.initial?.message) {
              this.addMessage(this.config.initial.message, false);
            }

            // å¤„ç†èŠå¤©å†å²ï¼šå¦‚æœæœ€åä¸€æ¡æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ™æ”¾åˆ°è¾“å…¥æ¡†ä¸­
            let chatHistoryToReplay = [...session.chatHistory];
            let lastUserMessage = "";

            if (chatHistoryToReplay.length > 0 && chatHistoryToReplay[chatHistoryToReplay.length - 1].role === "user") {
              // å–å‡ºæœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
              const lastMessage = chatHistoryToReplay.pop();
              lastUserMessage = lastMessage.content;
            }

            // é‡æ–°åˆå§‹åŒ–AIèŠå¤©ä¼šè¯
            if (sdk && sdk.aiChat) {
              aiChatSession = sdk.aiChat.createSession({
                model: "keepwork-pro",
                stream: true,
              });

              // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
              aiChatSession.messages.push({ role: "system", content: this.config.system_prompt });
            }

            // é‡æ”¾å†å²æ¶ˆæ¯æ¥æ¢å¤UIçŠ¶æ€
            for (const msg of chatHistoryToReplay) {
              if (msg.role === "user") {
                // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°UI
                let message = msg.content.replace(/^\[.*?\]\s*/, "");
                this.addMessage(message, true);
                // æ·»åŠ åˆ°æ¸¸æˆçŠ¶æ€å’ŒAIä¼šè¯
                this.gameState.chatHistory.push({ role: "user", content: msg.content });
                if (aiChatSession) {
                  aiChatSession.messages.push({ role: "user", content: msg.content });
                }
              } else if (msg.role === "assistant" && msg.raw_response) {
                // æ¨¡æ‹ŸLLMå“åº”æ¥æ¢å¤UIçŠ¶æ€
                await this.replayLLMResponse(msg.raw_response);
              }
            }

            // å¦‚æœæœ‰æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ï¼Œå°†å…¶æ”¾åˆ°è¾“å…¥æ¡†ä¸­
            if (lastUserMessage) {
              this.elements.userInput.value = lastUserMessage;
            }

            // é‡æ–°ç»‘å®šéŸ³é¢‘æŒ‰é’®äº‹ä»¶
            this.rebindAudioButtons();

            // é‡ç½®ä¸‹æ‹‰èœå•é€‰æ‹©
            this.elements.historyDropdown.value = "";

            console.log("Session loaded and replayed:", sessionId);
            console.log("Final progress:", this.gameState.progress);
            console.log("AI session messages:", aiChatSession?.messages.length);

            this.updateLLMStatus(`å·²åˆ‡æ¢åˆ°å†å²ä¼šè¯: è¿›åº¦${this.gameState.progress}%`);
          } catch (error) {
            console.error("åŠ è½½sessionå¤±è´¥:", error);
            this.updateLLMStatus("åŠ è½½å†å²ä¼šè¯å¤±è´¥");
          }
        }

        // é‡æ”¾LLMå“åº”ï¼ˆç”¨äºsessionåŠ è½½æ—¶æ¢å¤UIçŠ¶æ€ï¼‰
        async replayLLMResponse(rawResponse) {
          try {
            // è§£æåŸå§‹å“åº”
            let parsedResponse;
            try {
              parsedResponse = JSON.parse(rawResponse);
            } catch (e) {
              // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ç”¨æ­£åˆ™æå–
              const fields = this.extractResponseFields(rawResponse);
              parsedResponse = {
                message: fields.message || rawResponse,
                progress_change: fields.progress_change !== null ? fields.progress_change : 0,
                progress_reason: fields.progress_reason || "ä¼šè¯æ¢å¤",
                inner_thoughts: fields.inner_thoughts || "",
              };
            }

            // æ·»åŠ AIæ¶ˆæ¯åˆ°UI
            this.addMessage(parsedResponse.message, false);

            // åº”ç”¨å“åº”çš„æ•ˆæœï¼ˆè¿›åº¦ã€å†…å¿ƒæƒ³æ³•ç­‰ï¼‰
            this.applyLLMResponse(parsedResponse, true);
            this.gameState.chatHistory.push({
              role: "assistant",
              content: parsedResponse.message,
              raw_response: rawResponse,
            });
            if (aiChatSession) {
              // æ·»åŠ å®Œæ•´çš„åŸå§‹JSONå“åº”åˆ°AIä¼šè¯ï¼Œè€Œä¸æ˜¯ä»…ä»…æ˜¾ç¤ºçš„æ¶ˆæ¯
              aiChatSession.messages.push({ role: "assistant", content: rawResponse });
            }
          } catch (error) {
            console.error("é‡æ”¾LLMå“åº”å¤±è´¥:", error);
          }
        } // è·å–sessionsçš„å­˜å‚¨é”®
        getSessionsStorageKey() {
          const objectiveTitle = this.config?.objective?.title || "ç›®æ ‡è¿›åº¦";
          const characterName = this.config?.character?.name || "è§’è‰²";
          return `chat_sessions_${objectiveTitle}_${characterName}`;
        }

        // æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
        clearAllHistory() {
          try {
            // è·å–å­˜å‚¨é”®å¹¶æ¸…ç©ºlocalStorageä¸­çš„å†å²è®°å½•
            const sessionsKey = this.getSessionsStorageKey();
            localStorage.removeItem(sessionsKey);

            // åŒæ—¶æ¸…ç†æ—§ç‰ˆæœ¬çš„å†å²è®°å½•é”®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const oldHistoryKey = this.getHistoryKey();
            localStorage.removeItem(oldHistoryKey);

            // æ›´æ–°ä¸‹æ‹‰èœå•æ˜¾ç¤º
            this.updateHistoryDropdown();

            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            this.updateLLMStatus("æ‰€æœ‰å†å²è®°å½•å·²æ¸…ç©º");

            console.log("All chat history cleared");
          } catch (error) {
            console.error("æ¸…ç©ºå†å²è®°å½•å¤±è´¥:", error);
            this.updateLLMStatus("æ¸…ç©ºå†å²è®°å½•å¤±è´¥");
          } finally {
            // ç¡®ä¿é‡ç½®ä¸‹æ‹‰èœå•é€‰æ‹©
            this.elements.historyDropdown.value = "";
          }
        }
      }
      const aiToolbox = new AIToolboxManager();
      window.aiToolbox = aiToolbox;
      const game = new LLMCharacterGame(); // Promise-based location response handler with timeout

      // Window message handling for host communication
      window.addEventListener("message", function (e) {
        switch (e.data.type) {
          case "setGameConfig":
            // Update game config on the fly
            if (e.data.data) {
              // not supported
            }
            break;
          case "getGameStats":
            // Send current game statistics
            window.parent.postMessage(
              {
                type: "gameStats",
                data: {
                  score: game.gameState.progress,
                  difficulty: game.difficulty || 1,
                  isCompleted: game.gameState.isObjectiveAchieved,
                  chatHistory: game.gameState.chatHistory.length,
                  characterName: game.config?.character?.name || "è§’è‰²",
                },
              },
              "*"
            );
            break;
        }
      });

      window.parent.postMessage({ type: "gameLoaded" }, "*");

      // Wait for several response with 200ms timeout, then start game
      function checkStartGame(timeoutMs) {
        if (!timeoutMs) {
          const urlParams = new URLSearchParams(window.location.search);
          timeoutMs = urlParams.get("parent") === "miniGameProxy" ? 3000 : 200;
        }
        let gameStarted = false;
        const waitForMinigameProxyWithTimeout = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            if (!gameStarted) {
              resolve(null);
            }
          }, timeoutMs);
          let locationReceived = false;
          let miniGameProxyReceived = false;
          const messageHandler = function (e) {
            if (e.data.type === "locationResponse") {
              locationReceived = true;
              const searchPath = e.data.search;
              if (searchPath) {
                const params = new URLSearchParams(searchPath);
                const objective = params.get("objective");
                if (objective) {
                  game.urlObjective = objective;
                }
              }
            } else if (e.data.type === "miniGameProxyDataResponse") {
              miniGameProxyReceived = true;
              sdk.token = e.data?.keepworkToken;
            }
            if (locationReceived && miniGameProxyReceived) {
              window.removeEventListener("message", messageHandler);
              clearTimeout(timeout);
              resolve(e.data);
            }
          };
          window.addEventListener("message", messageHandler);
          window.parent.postMessage({ type: "getLocation" }, "*");
          window.parent.postMessage({ type: "getMiniGameProxyData" }, "*");
        });

        waitForMinigameProxyWithTimeout
          .then(() => {
            if (!gameStarted) {
              gameStarted = true;
              game.start();
            }
          })
          .catch((error) => {
            if (!gameStarted) {
              gameStarted = true;
              game.start();
            }
          });
      }
      checkStartGame();
    </script>
  </body>
</html>
