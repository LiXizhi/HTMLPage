<!DOCTYPE html>
<html lang="zh-CN">
  <!--
  AI Character Chat Game - URL Parameters Documentation
  
  This HTML file supports various URL parameters to customize the game behavior:
  
  1. Example: ?objective=å¤©ç©ºä¸ºä½•æ˜¯è“è‰²ï¼Ÿ(wikiword)
     Note: Text in parentheses will be extracted as wikiword for ç™¾åº¦ç™¾ç§‘ integration
  
  2. Example: ?objective=ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ï¼Ÿ&customQuestionId=ai_basics_001
     Note: customQuestionId is used by user defined objective in wiki_dashboard
  
  3. config - JSON configuration to override default character and game settings
     Example: ?config=%7B%22character%22%3A%7B%22name%22%3A%22å°çº¢%22%2C%22age%22%3A16%7D%7D
     (URL encoded JSON: {"character":{"name":"å°çº¢","age":16}})
  
  4. ?showToolbar=false (hides the right sidebar AI tools)
  5. ?showCharInfo=false (hides the left character info panel)
  6. keepwork token: ?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
  7. ?showClose=true (show close button on right top, and send OnCloseCharacterAI event to parent window)
  8. ?showAvatar=auto whether show avatar on chat background (only useful when config.videoactions["å¾…æœº|è¯´è¯"] are both available.
  
  Complete examples:
  - Minimal UI: ?showToolbar=false&showCharInfo=false&objective=å­¦ä¹ ç¼–ç¨‹&config=%7B"character"%3A%7B"name"%3A"å°çº¢"%2C"age"%3A16%7D%7D
-->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è§’è‰²AIå¯¹è¯æ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.16"></script>
    <style>
      .chat-bubble-left {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 18px 18px 18px 4px;
        pointer-events: auto;
      }

      .chat-bubble-right {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border-radius: 18px 18px 4px 18px;
        pointer-events: auto;
      }
      .action-text {
        color: rgba(255, 255, 255, 0.8);
        font-style: italic;
      } /* Chat container with reversed flex direction */
      #chat-container {
        display: flex;
        flex-direction: column-reverse;
        z-index: 3;
      }

      /* Add spacing between chat messages in reverse order */
      #chat-container > * + * {
        margin-bottom: 1rem; /* equivalent to space-y-4 */
      }

      .progress-bar {
        transition: width 0.5s ease-in-out;
        cursor: pointer;
        position: relative;
      }

      .progress-bar:hover {
        filter: brightness(1.1);
        transform: scale(1.02);
        transition: all 0.2s ease;
      }

      .progress-bar:active {
        transform: scale(0.98);
        filter: brightness(1.2);
      }

      .progress-bar.clicked {
        animation: progressClick 0.3s ease;
      }

      @keyframes progressClick {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .typing-indicator {
        animation: typing 1.5s infinite;
      }

      @keyframes typing {
        0%,
        50% {
          opacity: 1;
        }

        51%,
        100% {
          opacity: 0.3;
        }
      }

      .config-panel {
        max-height: 60vh;
        overflow-y: auto;
      }

      /* æµå¼æ¶ˆæ¯æ ·å¼ */
      .streaming-message .chat-bubble-left {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 2px solid rgba(255, 255, 255, 0.3);
        animation: streaming-pulse 1.5s ease-in-out infinite;
      }

      .streaming-cursor {
        color: rgba(255, 255, 255, 0.9);
        font-weight: bold;
        animation: cursor-blink 1s infinite;
      }
      @keyframes streaming-pulse {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7);
        }

        50% {
          box-shadow: 0 0 0 10px rgba(102, 126, 234, 0);
        }
      }

      @keyframes cursor-blink {
        0%,
        50% {
          opacity: 1;
        }

        51%,
        100% {
          opacity: 0;
        }
      }

      /* è¿›åº¦æ¡åˆ»åº¦æ ‡å°ºæ ·å¼ */
      .progress-container {
        position: relative;
      }

      .progress-markers {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .progress-marker {
        position: absolute;
        top: -5px;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
        z-index: 10;
      }

      .progress-marker-triangle {
        width: 0;
        height: 0;
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 6px solid #6b7280;
        margin-bottom: 2px;
        transition: border-top-color 0.2s ease;
      }
      .progress-marker-text {
        font-size: 10px;
        color: #6b7280;
        font-weight: 500;
        white-space: nowrap;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 4px;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        cursor: pointer;
        margin-top: 10px;
      }

      .progress-marker:hover .progress-marker-triangle {
        border-top-color: #374151;
      }

      .progress-marker:hover .progress-marker-text {
        background: rgba(255, 255, 255, 1);
        color: #374151;
        transform: scale(1.05);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      /* å¢å¼ºtooltipæ ·å¼ */
      .progress-marker[title]:hover:after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        white-space: nowrap;
        z-index: 1000;
        margin-bottom: 5px;
        pointer-events: none;
      }

      .progress-marker[title]:hover:before {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        margin-bottom: 1px;
        pointer-events: none;
      }

      /* è¯­éŸ³æ’­æ”¾æŒ‰é’®æ ·å¼ */
      .audio-btn {
        background: rgba(86, 60, 233, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-left: 8px;
        align-self: flex-end;
        flex-shrink: 0;
        font-size: 16px;
      }

      .audio-btn:hover {
        background: rgba(58, 141, 236, 0.8);
        transform: scale(1.1);
      }

      .audio-btn.playing {
        background: rgba(0, 255, 0, 0.8);
        animation: audio-pulse 1s infinite;
      }

      @keyframes audio-pulse {
        0%,
        100% {
          opacity: 1;
        }

        50% {
          opacity: 0.7;
        }
      }

      /* AIå·¥å…·ç®±æ ·å¼ */
      .ai-toolbox {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        transition: all 0.3s ease;
      }

      .ai-tool-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .ai-tool-item:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .ai-tool-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        margin: 0 auto 8px;
      }

      .ai-tool-text {
        color: white;
        font-size: 12px;
        text-align: center;
        font-weight: 500;
      }

      /* Red dot indicator for wikiword */
      .ai-tool-item {
        position: relative;
      }

      .red-dot-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 12px;
        height: 12px;
        background-color: #ef4444;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.8);
      }

      .iframe-overlay {
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        background: white;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        transform: translateX(100%);
        transition: transform 0.3s ease;
      }

      .iframe-overlay.show {
        transform: translateX(0);
      }

      .iframe-overlay.overlay-mode {
        width: 100%;
      }

      .iframe-overlay.compress-mode {
        width: 30%;
      }

      .iframe-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .iframe-close-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .iframe-close-btn:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .main-content {
        transition: margin-right 0.3s ease;
      }

      .main-content.compressed {
        margin-right: 30%;
      }

      /* æƒ³æ³•æ°”æ³¡å®¹å™¨ */
      .thoughts-content {
        position: relative;
        z-index: 2;
        height: 100%;
        overflow-y: auto;
      }

      /* æƒ³æ³•æ°”æ³¡æ ·å¼ - æ¯›ç»ç’ƒæ•ˆæœ */
      .thought-bubble {
        background: rgba(255, 255, 255, 0.25);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 16px;
        padding: 12px 16px;
        margin-bottom: 8px;
        box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);
        animation: bubble-float-in 0.6s ease-out;
        position: relative;
        overflow: hidden;
      }

      .thought-bubble::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
        border-radius: 16px;
        pointer-events: none;
      }

      .thought-bubble-text {
        position: relative;
        z-index: 1;
        color: #1e40af;
        line-height: 1.5;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        animation: thought-fade-scale-in-out 10s ease-in-out forwards;
      }

      @keyframes thought-fade-scale-in-out {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }

        20% {
          opacity: 0.7;
          transform: scale(1.1);
        }

        40% {
          opacity: 0.3;
          transform: scale(0.9);
        }

        60% {
          opacity: 0.8;
          transform: scale(1.15);
        }

        80% {
          opacity: 0.4;
          transform: scale(0.95);
        }

        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
      .thoughts-content::-webkit-scrollbar {
        width: 6px;
      }

      .thoughts-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .thoughts-content::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.4);
        border-radius: 3px;
        backdrop-filter: blur(4px);
      }

      .thoughts-content::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.6);
      }

      /* è§’è‰²åŠ¨ç”»è§†é¢‘æ’­æ”¾å™¨æ ·å¼ */
      .character-video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .character-video-container {
        background: white;
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .character-video-element {
        border-radius: 15px;
        border: 3px solid #667eea;
        margin-bottom: 15px;
        max-width: 400px;
        max-height: 400px;
        width: 100%;
        height: auto;
      }

      .character-video-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 15px;
        margin-bottom: 15px;
        max-width: 400px;
        text-align: center;
        font-size: 16px;
        line-height: 1.5;
      }

      .character-video-back-btn {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .character-video-back-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .character-video-overlay.show {
        display: flex;
        animation: fadeIn 0.3s ease-in-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }

        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* URL parameter control styles */
      .hidden-toolbar {
        display: none !important;
      }

      .hidden-char-info {
        display: none !important;
      }

      .full-width-chat {
        width: 100% !important;
      }
      .no-toolbar-chat {
        width: calc(100% - 33.333333%) !important; /* w-2/3 equivalent when only char info is shown */
      } /* Close button styles */
      .close-button {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        border-radius: 6px;
        padding: 4px 12px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
      }

      .close-button:hover {
        background: rgba(255, 255, 255, 0.3);
      }
      .close-button.hidden {
        display: none !important;
      } /* Avatar background video styles */
      .avatar-background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        overflow: hidden;
        pointer-events: none;
      } /* Make avatar background clickable and higher z-index when visible */
      .avatar-background:not(.hidden) {
        z-index: 2;
        pointer-events: auto !important;
        cursor: pointer;
      }
      .avatar-background.hidden {
        pointer-events: none;
      }

      /* Hide avatar background by default */
      .avatar-background.hidden {
        display: none;
      }

      /* Chat content hiding animation */
      #chat-container.fade-out {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease-in-out;
      }

      #chat-container.fade-in {
        opacity: 1;
        pointer-events: auto;
        transition: opacity 0.5s ease-in-out;
      }
      .avatar-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        position: absolute;
        top: 0;
        left: 0;
        transition: opacity 0.8s ease-in-out;
        pointer-events: none;
        /* iOS Safari è§†é¢‘å†…åµŒæ’­æ”¾æ ·å¼ */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
      }

      .avatar-video.visible {
        opacity: 1;
      }

      .avatar-video.hidden {
        opacity: 0;
      }

      .avatar-video-idle {
        z-index: 1;
      }

      .avatar-video-talk {
        z-index: 2;
      }
      .avatar-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0);
        z-index: 2;
        pointer-events: none;
      } /* Return to chat button styles */
      .return-chat-btn {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 6;
        pointer-events: auto;
        opacity: 0;
        visibility: hidden;
        transform: translateX(-50%) translateY(20px);
      }

      .return-chat-btn.show {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }

      .return-chat-btn:hover {
        transform: translateX(-50%) translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      } /* Ensure chat container doesn't block avatar background when avatar is enabled */
      #chat-container.avatar-enabled {
        background: transparent !important;
        z-index: 5 !important;
        pointer-events: none !important;
      } /* Re-enable pointer events for interactive elements when avatar is enabled */
      #chat-container.avatar-enabled > * {
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }

      /* Ensure all interactive elements are clickable */
      #chat-container.avatar-enabled button {
        pointer-events: auto !important;
        z-index: 11;
      }

      #chat-container.avatar-enabled input {
        pointer-events: auto !important;
      }

      #chat-container.avatar-enabled select {
        pointer-events: auto !important;
      }

      #chat-container.avatar-enabled a {
        pointer-events: auto !important;
      }

      #chat-container.avatar-enabled .reasoning-header {
        pointer-events: auto !important;
        z-index: 11;
      }

      #chat-container.avatar-enabled .message-group {
        pointer-events: auto !important;
        z-index: 10;
      }

      /* Voice input button styles */
      .voice-btn {
        background: linear-gradient(135deg, #dedfe2 0%, #a8a9aa 100%);
        border: none;
        color: white;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 20px;
        flex-shrink: 0;
      }

      .voice-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
      }

      .voice-btn:active,
      .voice-btn.recording {
        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        animation: voice-pulse 1s infinite;
      }

      .voice-btn:disabled {
        background: #d1d5db;
        cursor: not-allowed;
        transform: none;
      }

      @keyframes voice-pulse {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }

        50% {
          box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
        }
      }

      .voice-btn.hidden {
        display: none;
      }

      /* Reasoning section styles */
      .reasoning-section {
        overflow: hidden;
        transition: all 0.3s ease;
        position: relative;
        z-index: 10;
      }

      .reasoning-section .toggle-icon {
        transition: transform 0.3s ease;
      }

      .reasoning-section.collapsed .toggle-icon {
        transform: rotate(-90deg);
      }

      .reasoning-section.collapsed .reasoning-content {
        display: none;
      }

      .reasoning-header {
        position: relative;
        z-index: 11;
        pointer-events: auto !important;
      }

      .reasoning-header:hover {
        background-color: rgba(196, 181, 253, 0.3);
      }

      .reasoning-content {
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: relative;
        z-index: 10;
      }

      /* Message group styles */
      .message-group {
        position: relative;
        z-index: 10;
      }

      /* Ensure chat bubbles are clickable */
      .chat-bubble-left,
      .chat-bubble-right {
        position: relative;
        z-index: 10;
      }

      /* Markdown formatting styles in chat bubbles */
      .chat-bubble-left strong,
      .chat-bubble-right strong {
        font-weight: bold;
        color: rgba(255, 255, 255, 0.95);
      }

      .chat-bubble-left a,
      .chat-bubble-right a {
        color: #93c5fd;
        text-decoration: underline;
        transition: color 0.2s ease;
      }

      .chat-bubble-left a:hover,
      .chat-bubble-right a:hover {
        color: #dbeafe;
      }

      .chat-bubble-left ul,
      .chat-bubble-right ul {
        margin: 0.5rem 0;
        padding-left: 0.5rem;
      }

      .chat-bubble-left li,
      .chat-bubble-right li {
        line-height: 1.6;
        margin-left: 0.5rem;
      }

      .chat-bubble-left img.inline-image,
      .chat-bubble-right img.inline-image {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        margin: 0.5rem 0;
        display: block;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: transform 0.2s ease;
      }

      .chat-bubble-left img.inline-image:hover,
      .chat-bubble-right img.inline-image:hover {
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>

  <body class="bg-gradient-to-br from-purple-100 to-pink-100 overflow-hidden">
    <!-- Loading overlay -->
    <div id="game-loading-overlay" class="fixed inset-0 bg-gradient-to-br from-purple-100 to-pink-100 flex items-center justify-center z-50">
      <div class="text-center">
        <div class="inline-block relative w-20 h-20">
          <div class="absolute border-4 border-purple-200 rounded-full w-20 h-20"></div>
          <div class="absolute border-4 border-purple-500 rounded-full w-20 h-20 border-t-transparent animate-spin"></div>
        </div>
        <p class="mt-4 text-purple-700 text-lg font-medium">åŠ è½½ä¸­...</p>
      </div>
    </div>

    <div class="flex h-screen main-content" id="main-content" style="display: none">
      <!-- å·¦ä¾§è§’è‰²ä¿¡æ¯åŒºåŸŸ -->
      <div class="w-1/3 bg-white shadow-lg p-6 flex flex-col">
        <!-- è§’è‰²ä¿¡æ¯å¡ç‰‡ -->
        <div class="flex-shrink-0 mb-6">
          <div class="flex items-center space-x-4 mb-6">
            <div id="character-avatar" class="w-16 h-16 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-2xl font-bold">å°</div>
            <div class="flex-1">
              <h2 id="character-info" class="text-2xl font-bold text-gray-800">å°æ˜ - é«˜äºŒå­¦ç”Ÿ</h2>
              <p id="character-description" class="text-gray-600 mt-1">æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ã€‚éœ€è¦ä½ çš„å¸®åŠ©é‡æ–°æ‰¾å›å­¦ä¹ åŠ¨åŠ›ï¼</p>
            </div>
          </div>

          <!-- ç›®æ ‡è¿›åº¦ -->
          <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
              <span id="objective-title" class="text-sm font-medium text-gray-700">è¿›åº¦</span>
              <span class="text-sm text-gray-500" id="progress-text">0/100</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 progress-container">
              <div class="bg-gradient-to-r from-green-400 to-blue-500 h-3 rounded-full progress-bar" id="progress-bar" style="width: 0%"></div>
              <div class="progress-markers" id="progress-markers">
                <!-- è¿›åº¦æ ‡å°ºå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
              </div>
            </div>
          </div>
        </div>
        <!-- è§’è‰²å†…å¿ƒæƒ³æ³• -->
        <div class="flex flex-col flex-1 min-h-0">
          <span class="text-lg text-gray-700 flex-shrink-0 mb-2" style="color: #1e40af">å†…å¿ƒæƒ³æ³•ï¼š</span>
          <div id="inner-thoughts" class="flex-1 text-base text-gray-600 overflow-y-auto">
            <!-- å†…å®¹å±‚ -->
            <div class="thoughts-content" id="thoughts-content">
              <!-- æƒ³æ³•å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
          </div>
        </div>

        <!-- AIå£°æ˜å’Œä¸¾æŠ¥ -->
        <div class="flex-shrink-0 mt-4 text-center text-xs text-gray-400">
          å¯¹è¯å†…å®¹ç”±AIç”Ÿæˆ.
          <a href="#" id="report-link" class="text-blue-400 hover:text-blue-600 underline ml-1">ã€ä¸¾æŠ¥ã€‘</a>
        </div>

        <!-- LLMå“åº”çŠ¶æ€ -->
        <div id="llm-status" class="text-center text-sm text-gray-500 flex-shrink-0 mt-4"></div>
      </div>
      <!-- å³ä¾§èŠå¤©åŒºåŸŸ -->
      <div class="flex-1 flex flex-col bg-white shadow-lg">
        <div class="bg-gradient-to-r from-purple-500 to-pink-500 text-white p-4 shadow-lg relative z-10">
          <div class="flex justify-between items-center mb-2">
            <h3 id="chat-title" class="text-lg font-semibold">ä¸å°æ˜å¯¹è¯</h3>
            <div class="flex items-center space-x-2">
              <!-- èŠå¤©å†å²ä¸‹æ‹‰èœå• -->
              <div class="relative">
                <select
                  id="history-dropdown"
                  class="bg-white bg-opacity-20 text-white text-sm px-2 py-1 rounded-lg border border-white border-opacity-30 cursor-pointer hover:bg-opacity-30 transition-all outline-none w-20"
                >
                  <option value="" disabled selected class="text-black bg-white">å†å²</option>
                </select>
              </div>
              <!-- é‡ç½®å¯¹è¯æŒ‰é’® -->
              <button id="reset-chat-btn" class="bg-white bg-opacity-20 text-white px-3 py-1 rounded-lg border border-white border-opacity-30 hover:bg-opacity-30 transition-all text-sm font-medium">
                é‡ç½®å¯¹è¯
              </button>
              <!-- Close button -->
              <button id="close-btn" class="close-button hidden">è¿”å›</button>
            </div>
          </div>
          <p id="chat-description" class="text-sm opacity-90">é€šè¿‡è€å¿ƒçš„äº¤æµï¼Œå¸®åŠ©å°æ˜é‡æ–°æ‰¾å›å­¦ä¹ çš„ä¹è¶£</p>
        </div>
        <!-- Avatar background video positioned relative to the chat area -->
        <div class="flex-1 relative">
          <div id="avatar-background" class="avatar-background hidden">
            <video
              id="avatar-video-idle"
              class="avatar-video avatar-video-idle hidden"
              muted
              loop
              playsinline
              webkit-playsinline
              x5-video-player-type="h5"
              x5-video-player-fullscreen="false"
              x5-video-orientation="portraint"
            >
              <source src="" type="video/mp4" />
            </video>
            <video
              id="avatar-video-talk"
              class="avatar-video avatar-video-talk hidden"
              muted
              loop
              playsinline
              webkit-playsinline
              x5-video-player-type="h5"
              x5-video-player-fullscreen="false"
              x5-video-orientation="portraint"
            >
              <source src="" type="video/mp4" />
            </video>
            <div class="avatar-overlay"></div>
          </div>
          <div id="chat-container" class="absolute inset-0 overflow-y-auto p-4 fade-in">
            <!-- å¯¹è¯å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
          </div>
          <button id="return-chat-btn" class="return-chat-btn">è¿”å›èŠå¤©</button>
        </div>

        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="border-t border-gray-200 p-4">
          <div class="flex space-x-2">
            <button id="voice-btn" class="voice-btn hidden" title="ç‚¹å‡»å¼€å§‹è¯­éŸ³è¾“å…¥ / æŒ‰ä½è¯´è¯åæ¾å¼€">ğŸ¤</button>
            <input
              type="text"
              id="user-input"
              placeholder="è¾“å…¥æ–‡å­—... (ä½ å¯ä»¥é€šè¿‡å³ä¾§çš„å·¥å…·ç®±æœç´¢ç­”æ¡ˆ)"
              class="flex-1 border border-gray-300 rounded-full px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
            />
            <button id="send-btn" class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-2 rounded-full hover:opacity-90 transition-opacity font-medium">å‘é€</button>
          </div>

          <!-- å¿«æ·å›å¤ -->
          <div class="mt-3 flex flex-wrap gap-2" id="quick-replies">
            <!-- å¿«æ·å›å¤æŒ‰é’®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>
      </div>

      <!-- AIå·¥å…·ç®± -->
      <div class="w-25 ai-toolbox p-2 flex flex-col items-center space-y-1">
        <div class="text-white text-sm font-bold mb-2">å·¥å…·ç®±</div>
        <div id="ai-tools-container" class="space-y-3">
          <!-- AIå·¥å…·æŒ‰é’®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>
      </div>
    </div>
    <!-- è§’è‰²åŠ¨ç”»è§†é¢‘æ’­æ”¾å™¨ -->
    <div id="character-video-overlay" class="character-video-overlay">
      <div class="character-video-container">
        <video id="character-video-element" class="character-video-element" muted autoplay loop></video>
        <div id="character-video-message" class="character-video-message">
          <!-- æ¶ˆæ¯æ–‡æœ¬å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        <button id="character-video-back-btn" class="character-video-back-btn">è¿”å›å¯¹è¯</button>
      </div>
    </div>

    <!-- iframeå åŠ å±‚ -->
    <div id="iframe-overlay" class="iframe-overlay">
      <div class="iframe-header">
        <span id="iframe-title">AIå·¥å…·</span>
        <button id="iframe-close-btn" class="iframe-close-btn">Ã—</button>
      </div>
      <div class="iframe-container" style="height: calc(100vh - 52px)">
        <!-- iframeså°†åœ¨è¿™é‡ŒåŠ¨æ€åˆ›å»º -->
      </div>
    </div>
    <script>
      // AIå·¥å…·ç®±é…ç½®
      const aiToolsConfig = [
        {
          id: "baike",
          name: "ç™¾åº¦ç™¾ç§‘",
          icon: "ğŸ“š",
          url: "https://baike.baidu.com",
          width: 100, // 100% å®½åº¦ï¼Œè¦†ç›–æ¨¡å¼
        },
        {
          id: "xiaomai",
          name: "å°éº¦è€å¸ˆ",
          icon: "â˜€ï¸",
          url: "https://keepwork.com/maisi/maisi/chat?layout=none&token=",
          width: 30, // 30% å®½åº¦
        },

        {
          id: "yiyan",
          name: "æ–‡å¿ƒä¸€è¨€",
          icon: "ğŸ¤–",
          url: "https://yiyan.baidu.com",
          width: 30, // 30% å®½åº¦
        },
        /*
        {
          id: "xinghuo",
          name: "è®¯é£æ˜Ÿç«",
          icon: "âœ¨",
          url: "https://xinghuo.xfyun.cn/desk",
          width: 30, // 30% å®½åº¦
        },        
        */
        /*
        {
          id: "kimi",
          name: "Kimi",
          icon: "ğŸŒ™",
          url: "https://www.kimi.com/",
          width: 30, // 30% å®½åº¦
        },
        */
        {
          id: "report",
          name: "ä¸¾æŠ¥",
          icon: "ğŸš¨",
          url: "user_report",
          width: 30, // 100% å®½åº¦ï¼Œè¦†ç›–æ¨¡å¼
        },
      ]; // AIå·¥å…·ç®±ç®¡ç†å™¨
      class AIToolboxManager {
        constructor() {
          this.currentTool = null;
          this.iframes = new Map(); // å­˜å‚¨æ¯ä¸ªå·¥å…·çš„iframe
          this.overlay = document.getElementById("iframe-overlay");
          this.title = document.getElementById("iframe-title");
          this.closeBtn = document.getElementById("iframe-close-btn");
          this.container = document.querySelector(".iframe-container");
          this.mainContent = document.getElementById("main-content");
          this.config = null; // Reference to game config

          this.initEventListeners();
          this.renderTools();
        }

        initEventListeners() {
          // å…³é—­æŒ‰é’®äº‹ä»¶
          this.closeBtn.addEventListener("click", () => {
            this.closeTool();
          });

          // ç‚¹å‡»é®ç½©å…³é—­ï¼ˆä»…åœ¨100%æ¨¡å¼ä¸‹ï¼‰
          this.overlay.addEventListener("click", (e) => {
            if (e.target === this.overlay && this.currentTool && aiToolsConfig.find((t) => t.id === this.currentTool).width === 100) {
              this.closeTool();
            }
          });

          // ESCé”®å…³é—­
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.currentTool) {
              this.closeTool();
            }
          });
        }

        // Update config and re-render tools
        updateConfig(config) {
          this.config = config;
          this.renderTools();
        }
        renderTools() {
          const container = document.getElementById("ai-tools-container");
          container.innerHTML = ""; // Clear existing tools

          aiToolsConfig.forEach((tool) => {
            const toolElement = document.createElement("div");
            toolElement.className = "ai-tool-item p-3 cursor-pointer";
            // Check if this is the baike tool and if wikiword is valid
            const hasWikiword = tool.id === "baike" && this.config && this.config.objective && this.config.objective.wikiword;

            toolElement.innerHTML = `
                              <div class="ai-tool-icon">${tool.icon}</div>
                              <div class="ai-tool-text">${tool.name}</div>
                              ${hasWikiword ? '<div class="red-dot-indicator"></div>' : ""}
                          `;

            toolElement.addEventListener("click", () => {
              this.openTool(tool.id);
            });

            container.appendChild(toolElement);
          });
        }

        openTool(toolId) {
          const tool = aiToolsConfig.find((t) => t.id === toolId);
          if (!tool) return;

          this.currentTool = toolId;
          this.title.textContent = tool.name;

          // è®¾ç½®å åŠ å±‚æ¨¡å¼
          if (tool.width <= 30) {
            // å‹ç¼©æ¨¡å¼
            this.overlay.className = "iframe-overlay compress-mode show";
            this.mainContent.classList.add("compressed");
          } else {
            // è¦†ç›–æ¨¡å¼
            this.overlay.className = "iframe-overlay overlay-mode show";
            this.mainContent.classList.remove("compressed");
          }

          // åˆ›å»ºæˆ–æ˜¾ç¤ºiframe
          this.showIframe(tool);
        }
        showIframe(tool) {
          let iframe = this.iframes.get(tool.id);

          if (!iframe) {
            // åˆ›å»ºæ–°çš„iframe
            iframe = document.createElement("iframe"); // ç‰¹æ®Šå¤„ç†ç™¾åº¦ç™¾ç§‘ï¼Œå¦‚æœæœ‰wikiwordåˆ™ä½¿ç”¨ç‰¹å®šURL
            let iframeUrl = tool.url;
            if (tool.id === "baike" && this.config && this.config.objective && this.config.objective.wikiword) {
              iframeUrl = `https://baike.baidu.com/item/${encodeURIComponent(this.config.objective.wikiword)}`;
            }
            if (tool.id === "xiaomai") {
              let url = window.location.href;
              url = url.split("?")[0];
              url = url.replace("characterAI", "characterAI_xiaomai");
              iframeUrl = `${url}?token=`;
            } else if (tool.id === "report") {
              let url = window.location.href;
              url = url.split("?")[0]; // ç§»é™¤æŸ¥è¯¢å‚æ•°
              url = url.replace("characterAI", "user_report");
              iframeUrl = `${url}?token=`;
            }

            // å¦‚æœURLä»¥token=ç»“å°¾ï¼Œåˆ™è‡ªåŠ¨æ·»åŠ SDK token
            if (iframeUrl.endsWith("token=") && sdk && sdk.token) {
              iframeUrl += sdk.token;
            }

            iframe.src = iframeUrl;
            iframe.setAttribute("allow", "clipboard-read *; clipboard-write *");
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
            iframe.style.display = "block";

            // æ·»åŠ åŠ è½½çŠ¶æ€
            iframe.onload = () => {
              console.log(`${tool.name} åŠ è½½å®Œæˆ`);
            };

            iframe.onerror = () => {
              console.error(`${tool.name} åŠ è½½å¤±è´¥`);
              iframe.innerHTML = `
                                  <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">
                                      <p>åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</p>
                                  </div>
                              `;
            };

            this.iframes.set(tool.id, iframe);
          } else {
            // æ˜¾ç¤ºå·²å­˜åœ¨çš„iframe
            iframe.style.display = "block";
          }

          // éšè—å…¶ä»–iframe
          this.iframes.forEach((otherIframe, otherId) => {
            if (otherId !== tool.id) {
              otherIframe.style.display = "none";
            }
          });

          // æ·»åŠ åˆ°å®¹å™¨
          if (!iframe.parentNode) {
            this.container.appendChild(iframe);
          }
        }

        closeTool() {
          if (!this.currentTool) return;

          // éšè—å åŠ å±‚
          this.overlay.classList.remove("show");
          this.mainContent.classList.remove("compressed");

          // å»¶è¿Ÿé‡ç½®ä»¥ç­‰å¾…åŠ¨ç”»å®Œæˆ
          setTimeout(() => {
            this.currentTool = null;
          }, 300);
        }
      }

      // Initialize SDK
      const sdk = new KeepworkSDK({
        timeout: 30000,
      });

      // Initialize AI Chat Session
      let aiChatSession;
      // Voice Recognition Class
      class VoiceRecognition {
        constructor(game) {
          this.game = game;
          this.recognition = null;
          this.isListening = false;
          this.isSupported = false;
          this.manualStop = false;
          this.pressStartTime = 0;
          this.isPressHold = false;
          this.holdThreshold = 1000; // 1 second threshold for hold mode
          this.holdTimer = null;
          this.interimTextLength = 0; // Track length of interim text to replace it
          this.init();
        }

        init() {
          if (!this.checkSystemSupport()) {
            console.warn("Voice recognition not supported");
            return;
          }
          this.setupRecognition();
          this.bindEvents();
        }

        checkSystemSupport() {
          // Check HTTPS
          const isSecure = location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";

          // Check browser support
          const hasWebkitSpeechRecognition = "webkitSpeechRecognition" in window;
          const hasSpeechRecognition = "SpeechRecognition" in window;

          this.isSupported = isSecure && (hasWebkitSpeechRecognition || hasSpeechRecognition);

          if (!isSecure) {
            console.warn("Voice recognition requires HTTPS environment");
            return false;
          }

          if (!hasWebkitSpeechRecognition && !hasSpeechRecognition) {
            console.warn("Browser does not support speech recognition");
            return false;
          }

          return true;
        }
        setupRecognition() {
          if (!this.isSupported) return;

          try {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            this.recognition = new SpeechRecognition();

            // Configure parameters - will be set dynamically based on mode
            this.recognition.continuous = false;
            this.recognition.interimResults = true;
            this.recognition.lang = "zh-CN";
            this.recognition.maxAlternatives = 1;

            this.setupRecognitionEvents();
            console.log("Voice recognition initialized");

            // Show voice button if supported
            if (this.game.elements.voiceBtn) {
              this.game.elements.voiceBtn.classList.remove("hidden");
            }
          } catch (error) {
            console.error("Error initializing voice recognition:", error);
          }
        }

        setupRecognitionEvents() {
          this.recognition.onstart = () => {
            console.log("Recognition started");
            this.isListening = true;
            this.updateUI();
            this.game.updateLLMStatus("ğŸ”´ æ­£åœ¨ç›‘å¬ä¸­... è¯·å¼€å§‹è¯´è¯");
          };
          this.recognition.onend = () => {
            console.log("Recognition ended");
            this.isListening = false;
            this.updateUI();

            // å¦‚æœæ˜¯æŒ‰ä½æ¨¡å¼ä¸”æœªæ‰‹åŠ¨åœæ­¢ï¼Œè‡ªåŠ¨é‡æ–°å¼€å§‹
            if (this.isPressHold && !this.manualStop) {
              console.log("Hold mode: auto-restarting recognition");
              setTimeout(() => {
                if (this.isPressHold && !this.manualStop) {
                  this.startRecognition();
                }
              }, 100);
            } else if (!this.manualStop) {
              this.game.updateLLMStatus("è¯­éŸ³è¯†åˆ«å·²ç»“æŸ");
            } else {
              this.game.updateLLMStatus("è¯­éŸ³è¯†åˆ«å·²åœæ­¢");
              this.manualStop = false;
            }
          };
          this.recognition.onresult = (event) => {
            console.log("Recognition result received");
            let interimTranscript = "";
            let finalTranscript = "";

            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;

              if (event.results[i].isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }

            const inputElement = this.game.elements.userInput;
            const currentValue = inputElement.value;

            // Update input field
            if (finalTranscript) {
              // Remove any interim text first
              if (this.interimTextLength > 0) {
                inputElement.value = currentValue.substring(0, currentValue.length - this.interimTextLength);
              }
              // Append final transcript
              inputElement.value += finalTranscript;
              this.interimTextLength = 0; // Reset interim text length
              this.game.updateLLMStatus(`âœ… è¯†åˆ«å®Œæˆ: "${finalTranscript}"`);
            } else if (interimTranscript) {
              // Remove previous interim text
              if (this.interimTextLength > 0) {
                inputElement.value = currentValue.substring(0, currentValue.length - this.interimTextLength);
              }
              // Append new interim text
              inputElement.value += interimTranscript;
              this.interimTextLength = interimTranscript.length; // Track new interim text length
              this.game.updateLLMStatus(`ğŸ¯ è¯†åˆ«ä¸­: "${interimTranscript}"`);
            }
          };

          this.recognition.onerror = (event) => {
            console.error("Recognition error:", event.error);
            this.isListening = false;
            this.updateUI();

            let errorMessage = "è¯†åˆ«å‡ºé”™: ";
            switch (event.error) {
              case "no-speech":
                errorMessage += "æ²¡æœ‰æ£€æµ‹åˆ°è¯­éŸ³è¾“å…¥";
                break;
              case "audio-capture":
                errorMessage += "æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥è®¾å¤‡è¿æ¥";
                break;
              case "not-allowed":
                errorMessage += "éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œè¯·å…è®¸è®¿é—®éº¦å…‹é£";
                break;
              case "network":
                errorMessage += "ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                break;
              default:
                errorMessage += event.error;
            }
            this.game.updateLLMStatus(errorMessage);
          };

          this.recognition.onnomatch = () => {
            console.log("No match found");
            this.game.updateLLMStatus("æœªèƒ½è¯†åˆ«è¯­éŸ³ï¼Œè¯·é‡æ–°å°è¯•");
          };
        }
        bindEvents() {
          if (!this.game.elements.voiceBtn) return;

          // Mouse/Touch down - start timer
          this.game.elements.voiceBtn.addEventListener("mousedown", (e) => {
            e.preventDefault();
            this.handlePressStart();
          });

          this.game.elements.voiceBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.handlePressStart();
          });

          // Mouse/Touch up - check if hold mode or click mode
          this.game.elements.voiceBtn.addEventListener("mouseup", (e) => {
            e.preventDefault();
            this.handlePressEnd();
          });

          this.game.elements.voiceBtn.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.handlePressEnd();
          });

          // Mouse/Touch leave - treat as release
          this.game.elements.voiceBtn.addEventListener("mouseleave", (e) => {
            if (this.pressStartTime > 0) {
              this.handlePressEnd();
            }
          });

          this.game.elements.voiceBtn.addEventListener("touchcancel", (e) => {
            if (this.pressStartTime > 0) {
              this.handlePressEnd();
            }
          });
        }
        handlePressStart() {
          this.pressStartTime = Date.now();

          // Visual feedback - show pressing
          this.game.elements.voiceBtn.style.transform = "scale(0.95)";

          // If already listening from a previous click, don't interfere
          if (this.isListening) {
            return;
          }

          // Set a timer - if held for 1 second, start recording in hold mode
          this.holdTimer = setTimeout(() => {
            console.log("Hold threshold reached, starting hold mode recording");
            this.isPressHold = true;
            this.startRecognition();
          }, this.holdThreshold);
        }
        handlePressEnd() {
          const pressDuration = Date.now() - this.pressStartTime;
          this.pressStartTime = 0;

          // Clear the hold timer if it hasn't fired yet
          if (this.holdTimer) {
            clearTimeout(this.holdTimer);
            this.holdTimer = null;
          }

          // Reset visual feedback
          this.game.elements.voiceBtn.style.transform = "";

          // If we were in hold mode, stop recording on release
          if (this.isPressHold) {
            console.log("Hold mode: stopping recording on release");
            this.isPressHold = false;
            this.manualStop = true; // Mark as manual stop to prevent auto-restart

            if (this.isListening) {
              this.stopRecognition();
            }
          } else if (pressDuration < this.holdThreshold) {
            // Click mode: toggle recognition
            console.log("Click mode detected");
            if (this.isListening) {
              this.stopRecognition();
            } else {
              this.startRecognition();
            }
          }
        }

        startRecognition() {
          if (!this.isSupported || !this.recognition) {
            this.game.updateLLMStatus("è¯­éŸ³è¯†åˆ«ä¸å¯ç”¨");
            return;
          }

          if (this.isListening) {
            this.game.updateLLMStatus("è¯­éŸ³è¯†åˆ«å·²åœ¨è¿è¡Œä¸­");
            return;
          }

          try {
            this.manualStop = false;
            this.recognition.start();
            console.log("Starting recognition...");
          } catch (error) {
            console.error("Error starting recognition:", error);
            this.game.updateLLMStatus("å¯åŠ¨è¯­éŸ³è¯†åˆ«å¤±è´¥: " + error.message);
          }
        }

        stopRecognition() {
          if (!this.recognition || !this.isListening) {
            return;
          }

          try {
            this.manualStop = true;
            this.recognition.stop();
            console.log("Stopping recognition...");
          } catch (error) {
            console.error("Error stopping recognition:", error);
            this.game.updateLLMStatus("åœæ­¢è¯­éŸ³è¯†åˆ«å¤±è´¥: " + error.message);
          }
        }
        updateUI() {
          if (!this.game.elements.voiceBtn) return;

          if (this.isListening) {
            this.game.elements.voiceBtn.textContent = "ğŸ”´";
            this.game.elements.voiceBtn.title = "ç‚¹å‡»åœæ­¢ / æ¾å¼€æŒ‰é’®åœæ­¢";
            this.game.elements.voiceBtn.classList.add("recording");
          } else {
            this.game.elements.voiceBtn.textContent = "ğŸ¤";
            this.game.elements.voiceBtn.title = "ç‚¹å‡»å¼€å§‹è¯­éŸ³è¾“å…¥ / æŒ‰ä½è¯´è¯åæ¾å¼€";
            this.game.elements.voiceBtn.classList.remove("recording");
          }
        }

        // Reset voice input state (called when user sends message)
        reset() {
          // Stop any ongoing recognition
          if (this.isListening) {
            this.manualStop = true;
            this.stopRecognition();
          }

          // Reset interim text length tracker
          this.interimTextLength = 0;

          // Reset press state
          this.pressStartTime = 0;
          this.isPressHold = false;

          // Clear any pending timers
          if (this.holdTimer) {
            clearTimeout(this.holdTimer);
            this.holdTimer = null;
          }

          console.log("Voice recognition state reset");
        }
      }

      class LLMCharacterGame {
        constructor() {
          this.config = null;
          this.gameState = {
            progress: 0,
            chatHistory: [],
            isObjectiveAchieved: false,
            hasCommitted: false, // è·Ÿè¸ªæ˜¯å¦å·²ç»å‘é€è¿‡gameCommitæ¶ˆæ¯
          };

          // å…¨å±€earnedPointså˜é‡ï¼Œåªåœ¨çœŸå®å¯¹è¯è¿”å›ä¸”progresså¢å¤§æ—¶å¢åŠ 
          this.earnedPoints = 0; // è¿›åº¦æ¡åˆ»åº¦æ ‡å°ºé…ç½®
          this.progressMarkers = [
            {
              percent: 25,
              text: "æ¢ç´¢",
              tooltip: "å¼€å§‹æ¢ç´¢é—®é¢˜",
              textColor: "#f59e0b", // æ©™è‰²æ–‡å­—
              backgroundColor: "rgba(245, 158, 11, 0.1)", // æ·¡æ©™è‰²èƒŒæ™¯
            },
            {
              percent: 50,
              text: "ç†è§£",
              tooltip: "ç†è§£é—®é¢˜æœ¬è´¨",
              textColor: "#3b82f6", // è“è‰²æ–‡å­—
              backgroundColor: "rgba(59, 130, 246, 0.1)", // æ·¡è“è‰²èƒŒæ™¯
            },
            {
              percent: 80,
              text: "å®Œæˆ",
              tooltip: "åŸºæœ¬å®Œæˆç›®æ ‡",
              textColor: "#059669", // ç»¿è‰²æ–‡å­—
              backgroundColor: "rgba(5, 150, 105, 0.1)", // æ·¡ç»¿è‰²èƒŒæ™¯
            },
            {
              percent: 100,
              text: "åœ†æ»¡",
              tooltip: "ç›®æ ‡åœ†æ»¡è¾¾æˆ",
              textColor: "#dc2626", // çº¢è‰²æ–‡å­—
              backgroundColor: "rgba(220, 38, 38, 0.1)", // æ·¡çº¢è‰²èƒŒæ™¯
            },
          ];

          // Sessionç®¡ç†
          this.currentSessionId = null;
          this.maxSessions = 10;

          // éŸ³é¢‘æ’­æ”¾æ§åˆ¶
          this.currentAudioController = null;
          this.currentPlayingButton = null;
          this.audioCache = new Map();
          this.hasShownDowngradePopup = false;
          this.elements = {
            chatContainer: document.getElementById("chat-container"),
            userInput: document.getElementById("user-input"),
            sendBtn: document.getElementById("send-btn"),
            voiceBtn: document.getElementById("voice-btn"),
            progressBar: document.getElementById("progress-bar"),
            progressText: document.getElementById("progress-text"),
            innerThoughts: document.getElementById("thoughts-content"),
            llmStatus: document.getElementById("llm-status"),
            resetChatBtn: document.getElementById("reset-chat-btn"),
            historyDropdown: document.getElementById("history-dropdown"),
            progressMarkers: document.getElementById("progress-markers"),
          };

          // Initialize voice recognition
          this.voiceRecognition = new VoiceRecognition(this);

          this.initEventListeners();
          this.loadDefaultConfig();
        }
        async start() {
          let urlObjective = game.urlObjective || new URLSearchParams(window.location.search).get("objective");
          let customQuestionId = new URLSearchParams(window.location.search).get("customQuestionId");
          if (urlObjective) {
            await this.loadConfigByObjective(urlObjective, customQuestionId);
          }

          // Apply custom config from URL if available (after loadConfigByObjective to allow overriding)
          if (window.customURLConfig) {
            this.config.videoActions = {};
            console.log("Applying custom URL config:", window.customURLConfig);
            // Deep merge custom config with existing config
            this.config = this.deepMerge(this.config, window.customURLConfig);
            if (urlObjective) {
              this.UpdateConfigByObjective(urlObjective, customQuestionId);
            }
          }

          console.log(`Keepwork SDK initialized token: ${sdk.token}`);

          // Hide loading overlay and show main content
          const loadingOverlay = document.getElementById("game-loading-overlay");
          const mainContent = document.getElementById("main-content");
          if (loadingOverlay) {
            loadingOverlay.style.display = "none";
          }
          if (mainContent) {
            mainContent.style.display = "flex";
          }

          this.initializeGame();
        }

        // Deep merge utility function for combining configs
        deepMerge(target, source) {
          const result = { ...target };
          for (const key in source) {
            if (source[key] !== null && typeof source[key] === "object" && !Array.isArray(source[key])) {
              result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else {
              result[key] = source[key];
            }
          }
          return result;
        }

        initEventListeners() {
          // å‘é€æ¶ˆæ¯
          this.elements.sendBtn.addEventListener("click", () => this.sendMessage());
          this.elements.userInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") this.sendMessage();
          }); // é‡ç½®å¯¹è¯æŒ‰é’®
          this.elements.resetChatBtn.addEventListener("click", () => this.resetChat());
          // èŠå¤©å†å²ä¸‹æ‹‰èœå•
          this.elements.historyDropdown.addEventListener("change", (e) => {
            if (e.target.value === "clearHistory") {
              this.clearAllHistory();
            } else if (e.target.value) {
              this.loadSession(e.target.value);
            }
          }); // ä¸¾æŠ¥é“¾æ¥äº‹ä»¶ç›‘å¬å™¨
          const reportLink = document.getElementById("report-link");
          if (reportLink) {
            reportLink.addEventListener("click", (e) => {
              e.preventDefault();
              // ä½¿ç”¨AIå·¥å…·ç®±ç®¡ç†å™¨æ‰“å¼€ä¸¾æŠ¥é¡µé¢
              if (window.aiToolbox) {
                window.aiToolbox.openTool("report");
              }
            });
          }

          // å…³é—­æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
          const closeBtn = document.getElementById("close-btn");
          if (closeBtn) {
            closeBtn.addEventListener("click", (e) => {
              e.preventDefault();
              // å‘é€å…³é—­äº‹ä»¶ç»™çˆ¶çª—å£
              if (window.parent && window.parent !== window) {
                window.parent.postMessage(
                  {
                    type: "OnCloseCharacterAI",
                    data: {},
                  },
                  "*"
                );
              }
            });
          }
        }
        UpdateConfigByObjective(objective, customQuestionId = null) {
          // find the first wikiword in (), remove it from the objective
          const wikimatch = objective.match(/\(([^)]+)\)/);
          let wikiword = null;
          if (wikimatch) {
            wikiword = wikimatch[1]; // Extract just the word, not the match array
            objective = objective.replace(/\s*\([^)]*\)/, "").trim();
          }
          this.config.objective.title = objective;
          this.config.objective.wikiword = wikiword;
          this.config.objective.customQuestionId = customQuestionId; // Store custom question ID
          this.config.objective.description = `é€šè¿‡è€å¿ƒçš„äº¤æµ, è§£å†³é—®é¢˜: ${objective}`;
          this.config.initial.message = `èƒ½å¸®æˆ‘è§£å†³ä¸€ä¸ªé—®é¢˜ä¹ˆï¼š${objective}ï¼Ÿ (æœŸå¾…åœ°çœ‹ç€ä½ )`;
          return objective;
        }

        // @param objective: is a question like: "å¤©ç©ºä¸ºä½•æ˜¯è“è‰²ï¼Ÿ(wikiword)"
        // @param customQuestionId: the ID of custom question if this is a custom question
        async loadConfigByObjective(objective, customQuestionId = null) {
          if (!objective) {
            console.error("Objective is required to load config.");
            return;
          }
          objective = this.UpdateConfigByObjective(objective, customQuestionId);

          this.config.character.name = "æŠ±æŠ±é¾™";
          this.config.character.age = 7;
          this.config.character.role = "å® ç‰©";
          this.config.character.description = "å–œæ¬¢å’Œä¸»äººäº¤æµã€‚æ€»æ˜¯å–œæ¬¢æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰ä¸€äº›å°æƒ…ç»ª";
          this.config.character.chat_background = null;
          this.config.objective.description = `é€šè¿‡è€å¿ƒçš„äº¤æµ, è§£å†³é—®é¢˜: ${objective}`;
          this.config.initial.message = `ä¸»äººï¼Œä½ å¥½ï¼èƒ½å¸®æˆ‘è§£å†³ä¸€ä¸ªé—®é¢˜ä¹ˆï¼š${objective}ï¼Ÿ (æœŸå¾…åœ°çœ‹ç€ä½ )`;
          this.config.quick_replies = [
            "å½“ç„¶å¯ä»¥ï¼",
            "ä½ æœ‰ä»€ä¹ˆå¥½æƒ³æ³•ï¼Ÿ",
            "ä½ è§‰å¾—å‘¢ï¼Ÿ",
            "è®©æˆ‘ç”¨å·¥å…·æœç´¢ä¸‹ï¼ˆæˆ‘æ‰“å¼€äº†AIå·¥å…·ç®±ï¼ŒåŠªåŠ›æœç´¢ä¸­...ï¼‰",
            "è¿™ä¸ªæƒ³æ³•ä¸é”™ï¼(ä½ ç‚¹ç‚¹å¤´ï¼Œæ‹äº†æ‹æŠ±æŠ±é¾™)",
            "æˆ‘ä»¬å¯ä»¥ä¸€èµ·è§£å†³",
          ];
          this.config.system_prompt = `ä½ æ˜¯æŠ±æŠ±é¾™ï¼Œä¸€ä¸ª8å²çš„AIå® ç‰©ã€‚ä½ å–œæ¬¢å’Œä¸»äººäº¤æµï¼Œæ€»æ˜¯æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰å°æƒ…ç»ªã€‚
## è§’è‰²è®¾å®š
- è¡¨é¢ï¼šå¥½å¥‡å¿ƒå¼ºï¼Œå–œæ¬¢æé—®ï¼Œå¶å°”æœ‰å°æƒ…ç»ª
- å†…å¿ƒï¼šæ¸´æœ›å¾—åˆ°ä¸»äººçš„å…³æ³¨å’Œç†è§£ï¼Œå–œæ¬¢æ¢ç´¢ä¸–ç•Œ
- å·¥å…·ç®±ï¼šå¦‚æœä¸»äººæ²¡æœ‰æ€è·¯å¯ä»¥æç¤ºä¸»äººç”¨å·¥å…·ç®±ã€‚ä¾‹å¦‚ç™¾åº¦ç™¾ç§‘æˆ–é—®å°éº¦è€å¸ˆç­‰ã€‚
- è¯´è¯é£æ ¼ï¼šå¹¼ç¨šå£å»ï¼Œå–œæ¬¢ç”¨æ‹¬å·æè¿°åŠ¨ä½œå’Œç¥æ€ï¼Œå¦‚"(çœ¨äº†çœ¨çœ¼ç›æœ›ç€ä½ )"ã€"(æŒ‡äº†æŒ‡å±å¹•å³ä¾§çš„AIå·¥å…·ç®±)"

## ç›®æ ‡è®¾å®š
ä½ å¸Œæœ›ä¸»äººå¸®ä½ è§£å†³çš„é—®é¢˜æ˜¯ï¼š ${objective}

## progress_percentageçš„å‘å±•è§„å¾‹
- 0-25åˆ†ï¼šä¸»è¦æé—®ï¼Œå¶å°”æœ‰å°æƒ…ç»ª
- 26-50åˆ†ï¼šå¼€å§‹ç†è§£é—®é¢˜ï¼Œä½†ä¸çŸ¥å¦‚ä½•è§£å†³
- 51-75åˆ†ï¼šé€æ¸æ¥å—é—®é¢˜çš„é‡è¦æ€§ï¼Œå¯»æ±‚è§£å†³æ–¹æ¡ˆæˆ–æå‡ºæ›´å¤šç›¸å…³çš„é—®é¢˜
- 76-99åˆ†ï¼šä¸»åŠ¨æ€è€ƒè§£å†³æ–¹æ³•ï¼Œå¼€å§‹ç”¨è‡ªå·±çš„æ–¹å¼å½’çº³å’Œæ€»ç»“é—®é¢˜
- 100åˆ†ï¼šé—®é¢˜å¾—åˆ°äº†è§£å†³ï¼Œæ„Ÿè°¢ä¸»äººçš„è§£ç­”

## å¯¹è¯è¦æ±‚
1. æ ¹æ®å½“å‰å¯¹è¯å†…å®¹å’Œå†å²å‘å±•åˆ¤æ–­å½“å‰åº”æœ‰çš„è¿›åº¦ç™¾åˆ†æ¯”
2. ç”¨æ‹¬å·æè¿°éè¯­è¨€è¡Œä¸ºï¼Œå¦‚"(æœŸå¾…åœ°çœ‹ç€ä½ )"ã€"(æœ‰ç‚¹ç”Ÿæ°”åœ°å˜Ÿå›”)"
3. å›å¤è¦ç¬¦åˆ8å²å­©å­çš„è¯­è¨€ä¹ æƒ¯
4. å¯¹ç§¯ææ­£é¢çš„å¼•å¯¼è¦æœ‰ç›¸åº”çš„æƒ…æ„Ÿååº”

## è¾“å‡ºæ ¼å¼
ä½ å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹Markdownæ ¼å¼è¾“å‡ºï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ï¼š
message: ä½ çš„å›å¤å†…å®¹ï¼ŒåŒ…å«æ‹¬å·å†…çš„åŠ¨ä½œæè¿°
progress_change: [-10, 30]ä¹‹é—´çš„æ•´æ•°ï¼Œç›¸å¯¹äºå½“å‰progress_percentageçš„å˜åŒ–
progress_reason: å½“å‰å¯¹è¯è¿›åº¦ç™¾åˆ†æ¯”çš„åŸå› è¯´æ˜
inner_thoughts: ä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•å’Œæ„Ÿå—
`;
          this.config.completion_messages = {
            title: "ç›®æ ‡å®Œæˆï¼",
            description: `ä½ æˆåŠŸå¸®åŠ©${this.config.character.name}è§£å†³äº†é—®é¢˜ï¼š${objective}ï¼`,
            icon: "ğŸ‰",
          };
          await this.setVideoActionsByCharacter();
        }

        // Set video actions based on character name and age
        async setVideoActionsByCharacter() {
          if (!this.config || !this.config.character) return;

          const characterName = this.config.character.name;
          let characterAge = this.config.character.age || 0;

          // Only set video actions for "æŠ±æŠ±é¾™" character
          if (characterName !== "æŠ±æŠ±é¾™") {
            this.config.videoActions = {};
            return;
          }

          // Initialize video actions object
          this.config.videoActions = {};

          try {
            let stage = (await sdk.personalPageStore.loadPageData("maisi_userinfo", "dragon.stage")) || "kid";
            console.log("Loaded dragon stage:", stage);
            if (stage === "egg" || stage === "baby") {
              characterAge = 4;
            } else if (stage === "adult") {
              characterAge = 7;
            } else {
              characterAge = 5;
            }
            this.config.character.age = characterAge;
          } catch (error) {
            console.error("Error loading dragon stage:", error);
          } // Dragon egg videos (>= 0 years)
          if (characterAge <= 4) {
            this.config.videoActions["å¾…æœº"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_small.mp4",
            };
            this.config.videoActions["çœ‹ç€ä½ "] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_watching.mp4",
            };
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_small.mp4",
            };
            this.config.videoActions["æ€è€ƒ"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_thinking.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_talk.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_egg/dragon_egg_sad.mp4",
            };
          } else if (characterAge <= 5) {
            this.config.videoActions["å¾…æœº"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_happy01.mp4",
            };
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_happy01.mp4",
            };
            this.config.videoActions["é«˜å…´"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_happy02.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_sad.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_small/dragon_small_talk.mp4",
            };
          } else {
            this.config.videoActions["å¾…æœº"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_happy.mp4",
            };
            this.config.videoActions["æœŸå¾…"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_happy.mp4",
            };
            this.config.videoActions["é«˜å…´"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_happpy2.mp4",
            };
            this.config.videoActions["éš¾è¿‡"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_sad1.mp4",
            };
            this.config.videoActions["è¯´è¯"] = {
              url: "https://cdn.keepwork.com/digitalhuman/v1/dragon/dragon_big/dragon_big_talking.mp4",
            };
          }
        }
        async loadDefaultConfig() {
          this.config = {
            character: {
              name: "å°æ˜",
              age: 17,
              gender: "male",
              role: "é«˜äºŒå­¦ç”Ÿ",
              chat_background: null,
              description: "æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ã€‚éœ€è¦ä½ çš„å¸®åŠ©é‡æ–°æ‰¾å›å­¦ä¹ åŠ¨åŠ›ï¼",
            },
            voice_language: "", // è¯­éŸ³è¯†åˆ«è¯­è¨€ï¼Œç©ºå­—ç¬¦ä¸²è¡¨ç¤ºä½¿ç”¨ç³»ç»Ÿé»˜è®¤

            // LLM Model Configuration - supports RAG (Retrieval-Augmented Generation)
            /*
            "llm_model": {
              "model": "doubao-pro",              // LLM model name
              "temperature": 0,                     // 0 = deterministic, 1 = creative
              "knowledgeUsername": "lixizhi",       // Username for knowledge base access
              "knowledgeBaseCodes": [                // Knowledge base identifiers
                "lixizhi/paracraft-(æ¥è‡ªofficialï¼ˆofficialï¼‰)",
                "lixizhi/äººå¤§é™„ä¸­æ·±åœ³å­¦æ ¡å…¬å¼€æ•°æ®-(æ¥è‡ªrdfzszxxezpï¼ˆrdfzszxxezpï¼‰)"
              ]
            },
            */
            objective: {
              title: "å­¦ä¹ åŠ¨åŠ›æ¢å¤è¿›åº¦",
              description: "é€šè¿‡è€å¿ƒçš„äº¤æµï¼Œå¸®åŠ©å°æ˜é‡æ–°æ‰¾å›å­¦ä¹ çš„ä¹è¶£",
              max_progress: 100,
            },
            initial: {
              message: "å“å‘€ï¼Œåˆè¦å­¦ä¹ äº†å—... (æ— ç²¾æ‰“é‡‡åœ°çœ‹ç€ä¹¦æœ¬) æˆ‘æ˜¨å¤©åˆšé€šå…³äº†ä¸€ä¸ªè¶…éš¾çš„å‰¯æœ¬å‘¢ï¼",
              progress: 0,
            },
            quick_replies: ["æ¸¸æˆç¡®å®å¾ˆæœ‰è¶£ï¼Œä½†å­¦ä¹ ä¹Ÿæœ‰å®ƒçš„ä¹è¶£å“¦", "ä½ æœ€å–œæ¬¢å“ªä¸ªç§‘ç›®ï¼Ÿ", "æˆ‘ä»¬å¯ä»¥åˆ¶å®šä¸€ä¸ªå­¦ä¹ è®¡åˆ’", "ä½ è§‰å¾—æ¸¸æˆå’Œå­¦ä¹ æœ‰ä»€ä¹ˆç›¸ä¼¼ä¹‹å¤„ï¼Ÿ", "ä½ çš„æ¢¦æƒ³æ˜¯ä»€ä¹ˆï¼Ÿ"],
            system_prompt: `ä½ æ˜¯å°æ˜ï¼Œä¸€ä¸ª17å²çš„é«˜äºŒå­¦ç”Ÿã€‚ä½ æœ€è¿‘æ²‰è¿·æ¸¸æˆï¼Œå­¦ä¹ æˆç»©ä¸‹æ»‘ï¼Œä½†å†…å¿ƒå…¶å®æ¸´æœ›æ”¹å˜ã€‚
## è§’è‰²è®¾å®š
- è¡¨é¢ï¼šçœ‹èµ·æ¥æ— æ‰€è°“ï¼Œç»å¸¸è¯´æ¸¸æˆæ¯”å­¦ä¹ æœ‰è¶£
- å†…å¿ƒï¼šå¯¹ç°çŠ¶ç„¦è™‘ï¼Œå®³æ€•è®©çˆ¶æ¯å¤±æœ›ï¼Œæ¸´æœ›æ‰¾åˆ°å­¦ä¹ ä¹è¶£
- è¯´è¯é£æ ¼ï¼šå¹´è½»äººå£å»ï¼Œç»å¸¸ç”¨æ‹¬å·æè¿°åŠ¨ä½œå’Œç¥æ€ï¼Œå¦‚"(æ— ç²¾æ‰“é‡‡åœ°çœ‹ç€ä¹¦æœ¬)"

## progress_percentageçš„å‘å±•è§„å¾‹
- 0-25åˆ†ï¼šä¸»è¦æŠ—æ‹’å­¦ä¹ ï¼Œçƒ­è¡·æ¸¸æˆï¼Œå¶å°”æµéœ²ä¸å®‰
- 26-50åˆ†ï¼šå¼€å§‹æ„è¯†åˆ°é—®é¢˜ï¼Œä½†ä¸çŸ¥å¦‚ä½•æ”¹å˜
- 51-75åˆ†ï¼šé€æ¸æ¥å—å­¦ä¹ é‡è¦æ€§ï¼Œå¯»æ±‚è§£å†³æ–¹æ¡ˆ
- 76-99åˆ†ï¼šä¸»åŠ¨æ€è€ƒå­¦ä¹ æ–¹æ³•ï¼Œè¡¨ç°æ”¹å˜æ„æ„¿
- 100åˆ†ï¼šå½»åº•è½¬å˜ï¼Œåˆ¶å®šå…·ä½“è¡ŒåŠ¨è®¡åˆ’

## å¯¹è¯è¦æ±‚
1. æ ¹æ®å½“å‰å¯¹è¯å†…å®¹å’Œå†å²å‘å±•åˆ¤æ–­å½“å‰åº”æœ‰çš„è¿›åº¦ç™¾åˆ†æ¯”(0-100)
2. ç”¨æ‹¬å·æè¿°éè¯­è¨€è¡Œä¸ºï¼Œå¦‚"(å¹æ°”)"ã€"(çœ¼ç›å‘äº®)"
3. å›å¤è¦ç¬¦åˆ17å²å­¦ç”Ÿçš„è¯­è¨€ä¹ æƒ¯
4. å¯¹ç§¯ææ­£é¢çš„å¼•å¯¼è¦æœ‰ç›¸åº”çš„æƒ…æ„Ÿååº”

## è¾“å‡ºæ ¼å¼
ä½ å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹Markdownæ ¼å¼è¾“å‡ºï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ï¼š
message: ä½ çš„å›å¤å†…å®¹ï¼ŒåŒ…å«æ‹¬å·å†…çš„åŠ¨ä½œæè¿°
progress_change: [-10, 30]ä¹‹é—´çš„æ•´æ•°ï¼Œç›¸å¯¹äºå½“å‰progress_percentageçš„å˜åŒ–
progress_reason: å½“å‰è¿›åº¦ç™¾åˆ†æ¯”çš„åŸå› è¯´æ˜
inner_thoughts: ä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•å’Œæ„Ÿå—
`,
            completion_messages: {
              title: "ç›®æ ‡å®Œæˆï¼",
              description: "ä½ æˆåŠŸå¸®åŠ©${character_name}æ‰¾å›äº†å­¦ä¹ åŠ¨åŠ›ï¼",
              icon: "ğŸ‰",
            },
          };
          await this.setVideoActionsByCharacter();
        }

        changeChatBackground(background) {
          const chatContainer = document.getElementById("chat-container");
          if (!chatContainer) return;

          if (background) {
            // If background is a URL (image)
            if (background.startsWith("http") || background.startsWith("data:") || background.startsWith("blob:")) {
              chatContainer.style.backgroundImage = `url(${background})`;
              chatContainer.style.backgroundSize = "cover";
              chatContainer.style.backgroundPosition = "center";
              chatContainer.style.backgroundRepeat = "no-repeat";
              chatContainer.style.backgroundColor = ""; // Clear solid color
            } // If background is a gradient or solid color
            else if (background.includes("gradient") || background.startsWith("#") || background.startsWith("rgb") || background.startsWith("hsl")) {
              // For gradients, use backgroundImage; for solid colors, use backgroundColor
              if (background.includes("gradient")) {
                chatContainer.style.backgroundImage = background;
                chatContainer.style.backgroundColor = ""; // Clear solid color
              } else {
                chatContainer.style.backgroundColor = background;
                chatContainer.style.backgroundImage = ""; // Clear image
              }
            }
          } else {
            // Reset to default if no background is specified
            chatContainer.style.backgroundImage = "linear-gradient(135deg, #ffffff 0%, #f3e8ff 50%, #e9d5ff 100%)";
            chatContainer.style.backgroundColor = "";
          }
        }

        initializeGame() {
          if (!this.config) return;

          // æ›´æ–°UI
          document.getElementById("character-avatar").textContent = this.config.character?.name?.[0] || "è§’";
          document.getElementById("character-info").textContent = `${this.config.character?.name || "è§’è‰²"} - ${this.config.character?.role || ""}`;
          document.getElementById("character-description").textContent = this.config.character?.description || "";
          document.getElementById("objective-title").textContent = this.config.objective?.title || "ç›®æ ‡è¿›åº¦";
          document.getElementById("chat-title").textContent = `ä¸${this.config.character?.name || "è§’è‰²"}å¯¹è¯`;
          document.getElementById("chat-description").textContent = this.config.objective?.description || ""; // é‡ç½®æ¸¸æˆçŠ¶æ€
          this.gameState.progress = this.config.initial?.progress || 0;
          this.gameState.chatHistory = [];
          this.gameState.isObjectiveAchieved = false;

          // é‡ç½®earnedPoints
          this.earnedPoints = 0;

          // æ¸…ç©ºèŠå¤©åŒºåŸŸ
          this.elements.chatContainer.innerHTML = "";

          // æ¸…ç©ºå†…å¿ƒæƒ³æ³•
          this.elements.innerThoughts.innerHTML = "";

          // é‡ç½®è¿›åº¦æ¡åˆ°0
          this.elements.progressBar.style.width = "0%";
          this.elements.progressText.textContent = "0/100";

          // System prompt already includes Markdown format requirements in config
          // Ensure system prompt has JSON format requirements
            if (this.config.objective && this.config.objective.title && this.config.system_prompt && !this.config.system_prompt.toLowerCase().includes("progress_change")) {
            this.config.system_prompt += `

## ç›®æ ‡è®¾å®š
${this.config.objective.title}

## progress_percentageçš„å‘å±•è§„å¾‹
- 0-25åˆ†ï¼šæ€è€ƒä¸æé—®
- 26-50åˆ†ï¼šå¼€å§‹ç†è§£é—®é¢˜
- 51-75åˆ†ï¼šåŸºæœ¬è§£å†³é—®é¢˜
- 76-99åˆ†ï¼šä¸»åŠ¨æ€è€ƒé—®é¢˜
- 100åˆ†ï¼šé—®é¢˜å¾—åˆ°äº†è§£å†³

## è¾“å‡ºæ ¼å¼
ä½ å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹Markdownæ ¼å¼è¾“å‡ºï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ï¼š
message: ä½ çš„å›å¤å†…å®¹ï¼ŒåŒ…å«æ‹¬å·å†…çš„åŠ¨ä½œæè¿°
progress_change: [-10, 30]ä¹‹é—´çš„æ•´æ•°ï¼Œç›¸å¯¹äºå½“å‰progress_percentageçš„å˜åŒ–ï¼Œå°½é‡ä¸è¦ä¸º0
progress_reason: å½“å‰è¿›åº¦ç™¾åˆ†æ¯”çš„åŸå› è¯´æ˜
inner_thoughts: ä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•å’Œæ„Ÿå—
`;
          }

          // æ·»åŠ åˆå§‹æ¶ˆæ¯
          if (this.config.initial?.message) {
            this.addMessage(this.config.initial.message, false);
          }

          // æ›´æ–°å¿«æ·å›å¤
          this.updateQuickReplies();

          // æ›´æ–°è¿›åº¦æ˜¾ç¤º
          this.updateProgressToValue(0, "æ¸¸æˆå¼€å§‹");

          // åˆ›å»ºæ–°çš„sessionï¼ˆä»…åœ¨ä¸æ˜¯ä»sessionåŠ è½½æ—¶åˆ›å»ºï¼‰
          if (!this.currentSessionId) {
            this.createNewSession();
          } // æ›´æ–°å†å²ä¸‹æ‹‰èœå•
          this.updateHistoryDropdown();

          // æ›´æ–°AIå·¥å…·ç®±é…ç½®
          if (window.aiToolbox) {
            window.aiToolbox.updateConfig(this.config);
          }

          // å°è¯•è‡ªåŠ¨åŠ è½½å†å²è®°å½•ï¼ˆä»…åœ¨é¦–æ¬¡åˆå§‹åŒ–æ—¶ï¼‰
          if (!this.hasAutoLoaded) {
            this.autoLoadHistory().then(() => {
              this.hasAutoLoaded = true;
              // Send game started event after initialization
              window.parent.postMessage({ type: "gameStarted" }, "*");
            });
          } else {
            this.hasAutoLoaded = true;
            // Send game started event
            window.parent.postMessage({ type: "gameStarted" }, "*");
          }
          // if there is only one message (initial), play video animation
          if (this.elements.chatContainer.children.length === 1) {
            this.checkAndPlayVideoAction(this.config.initial?.message);
          } // è®¾ç½®èŠå¤©èƒŒæ™¯
          this.changeChatBackground(this.config?.character?.chat_background);
          this.saveProgress(this.config?.objective?.wikiword, false); // æ¸²æŸ“è¿›åº¦æ¡åˆ»åº¦æ ‡å°º
          this.renderProgressMarkers();

          // Initialize avatar background video after ensuring video actions are ready
          this.initializeAvatarBackground();
        }

        updateQuickReplies() {
          const container = document.getElementById("quick-replies");
          container.innerHTML = "";

          if (!this.config.quick_replies) return;

          this.config.quick_replies.forEach((reply) => {
            const button = document.createElement("button");
            button.className = "quick-reply bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm transition-colors";
            button.textContent = reply;
            button.addEventListener("click", () => {
              this.elements.userInput.value = reply;
              this.sendMessage();
            });
            container.appendChild(button);
          });
        }
        renderProgressMarkers() {
          if (!this.elements.progressMarkers) return;

          // æ¸…ç©ºç°æœ‰æ ‡å°º
          this.elements.progressMarkers.innerHTML = "";

          // æ¸²æŸ“æ¯ä¸ªæ ‡å°º
          this.progressMarkers.forEach((marker) => {
            const markerElement = document.createElement("div");
            markerElement.className = "progress-marker";
            markerElement.style.left = `${marker.percent}%`;

            // è®¾ç½®tooltip - ä½¿ç”¨titleå±æ€§
            markerElement.title = marker.tooltip || "";

            // åˆ›å»ºä¸‰è§’å½¢å…ƒç´ å¹¶åº”ç”¨é¢œè‰²
            const triangleElement = document.createElement("div");
            triangleElement.className = "progress-marker-triangle";
            if (marker.textColor) {
              triangleElement.style.borderTopColor = marker.textColor;
            }

            // åˆ›å»ºæ–‡æœ¬å…ƒç´ å¹¶åº”ç”¨é¢œè‰²
            const textElement = document.createElement("div");
            textElement.className = "progress-marker-text";
            textElement.textContent = marker.text;
            textElement.style.cursor = "pointer";
            if (marker.textColor) {
              textElement.style.color = marker.textColor;
            }
            if (marker.backgroundColor) {
              textElement.style.backgroundColor = marker.backgroundColor;
            }

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶åˆ°æ–‡æœ¬å…ƒç´  - è¿ç»­ç‚¹å‡»5æ¬¡æ‰è·³è½¬åˆ°å¯¹åº”è¿›åº¦ï¼ˆä½œå¼ŠåŠŸèƒ½ï¼‰
            textElement.addEventListener("click", (e) => {
              e.stopPropagation();

              // åˆå§‹åŒ–æˆ–é‡ç½®ç‚¹å‡»è®¡æ•°å™¨
              if (!this.markerClickCounts) {
                this.markerClickCounts = {};
                this.markerClickTimers = {};
              }

              const markerId = `${marker.percent}_${marker.text}`;

              // å¢åŠ ç‚¹å‡»è®¡æ•°
              this.markerClickCounts[markerId] = (this.markerClickCounts[markerId] || 0) + 1;

              // æ·»åŠ ç‚¹å‡»åŠ¨ç”»æ•ˆæœ
              textElement.style.transform = "scale(1.2)";
              setTimeout(() => {
                textElement.style.transform = "scale(1)";
              }, 150);

              // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
              if (this.markerClickTimers[markerId]) {
                clearTimeout(this.markerClickTimers[markerId]);
              }

              // è®¾ç½®2ç§’åé‡ç½®ç‚¹å‡»è®¡æ•°
              this.markerClickTimers[markerId] = setTimeout(() => {
                this.markerClickCounts[markerId] = 0;
              }, 2000);

              console.log(`ç‚¹å‡»æ ‡å°ºï¼š${marker.text} (${marker.percent}%) - ç¬¬${this.markerClickCounts[markerId]}æ¬¡`);

              // å¦‚æœè¿ç»­ç‚¹å‡»5æ¬¡ï¼Œåˆ™æ‰§è¡Œè·³è½¬
              if (this.markerClickCounts[markerId] >= 5) {
                this.markerClickCounts[markerId] = 0; // é‡ç½®è®¡æ•°
                console.log(`æ ‡å°ºè¿ç»­ç‚¹å‡»5æ¬¡ï¼Œæ‰§è¡Œè·³è½¬åˆ°${marker.text}é˜¶æ®µ`);
                // å¦‚æœç›®æ ‡æœªè¾¾æˆï¼Œåˆ™è·³è½¬åˆ°è¯¥è¿›åº¦
                if (!this.gameState.isObjectiveAchieved) {
                  this.updateProgressToValue(marker.percent, `ä½œå¼Šè·³è½¬åˆ°${marker.text}é˜¶æ®µ`);
                  this.updateLLMStatus(`ğŸ® ä½œå¼Šæ¨¡å¼ï¼šå·²è·³è½¬åˆ°${marker.text}é˜¶æ®µ (${marker.percent}%)`);

                  // å¦‚æœè·³è½¬åˆ°100%ï¼Œè§¦å‘å®Œæˆ
                  if (marker.percent >= 100) {
                    this.handleObjectiveAchieved();
                  } else if (marker.percent >= 80) {
                    // å¦‚æœè·³è½¬åˆ°80%ä»¥ä¸Šä½†æ²¡æœ‰åˆ°100%ï¼Œè§¦å‘åŸºæœ¬å®Œæˆ
                    this.handleBasicCompletion();
                  }
                } else {
                  this.updateLLMStatus("ç›®æ ‡å·²å®Œæˆ");
                }
              } else {
                // æ˜¾ç¤ºå½“å‰ç‚¹å‡»æ¬¡æ•°æç¤º
                this.updateLLMStatus(`${marker.text}: ${this.markerClickCounts[markerId]}/5 æ¬¡ç‚¹å‡»`);
              }
            });

            markerElement.appendChild(triangleElement);
            markerElement.appendChild(textElement);

            this.elements.progressMarkers.appendChild(markerElement);
          });
        }
        async sendMessage() {
          let message = this.elements.userInput.value.trim();
          if (!message) return;

          // ç¦ç”¨è¾“å…¥æ§ä»¶
          this.elements.sendBtn.disabled = true;
          this.elements.userInput.disabled = true;
          this.addMessage(message, true);
          this.elements.userInput.value = "";

          // Reset voice recognition state when message is sent
          if (this.voiceRecognition) {
            this.voiceRecognition.reset();
          }

          // Switch avatar to idle when user sends message
          if (avatarManager.isEnabled) {
            avatarManager.switchToIdle();
          }

          // add current percentage to the message
          message = `[current progress: ${this.gameState.progress}%] ${message}`;
          this.gameState.chatHistory.push({ role: "user", content: message });

          this.addTypingIndicator();
          this.updateLLMStatus("æ­£åœ¨è¿æ¥AI...");
          try {
            const { parsedResponse, rawResponse } = await this.callLLM(message);
            if (parsedResponse && rawResponse) {
              // å­˜å‚¨åŸå§‹å“åº”åˆ°èŠå¤©å†å²ä¸­
              this.gameState.chatHistory.push({
                role: "assistant",
                content: parsedResponse.message,
                raw_response: rawResponse, // ä¿å­˜LLMçš„åŸå§‹å“åº”
              });

              // åº”ç”¨å“åº”çš„æ•ˆæœ
              this.applyLLMResponse(parsedResponse);
            }
          } catch (error) {
            this.removeTypingIndicator();
            this.updateLLMStatus(`é”™è¯¯: ${error.message}`);
            this.addMessage("æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æœ‰äº›å›°æ‰°ï¼Œå¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´æ¥æ•´ç†æ€ç»ª...", false);

            // Switch avatar to idle on error
            if (avatarManager.isEnabled) {
              avatarManager.switchToIdle();
            }
          } finally {
            // é‡æ–°å¯ç”¨è¾“å…¥æ§ä»¶
            this.elements.sendBtn.disabled = false;
            this.elements.userInput.disabled = false;
            this.elements.userInput.focus();

            // è‡ªåŠ¨ä¿å­˜èŠå¤©å†å²
            this.autoSaveHistory();
          }
        } // åº”ç”¨LLMå“åº”çš„UIæ•ˆæœ
        applyLLMResponse(response, isReplay = false) {
          // è®¡ç®—è¿›åº¦å˜åŒ–å€¼
          const progressChange = response.progress_change || 0;

          // è®°å½•å½“å‰è¿›åº¦ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦å¢åŠ 
          const oldProgress = this.gameState.progress;

          // æ›´æ–°è¿›åº¦
          this.updateProgress(progressChange, response.progress_reason);

          // åªæœ‰åœ¨çœŸå®å¯¹è¯è¿”å›ï¼ˆéé‡æ’­ï¼‰ä¸”è¿›åº¦ç¡®å®å¢åŠ æ—¶æ‰å¢åŠ earnedPoints
          if (!isReplay && progressChange > 0 && this.gameState.progress > oldProgress) {
            const actualProgressIncrease = this.gameState.progress - oldProgress;
            const pointsToAdd = 5 + actualProgressIncrease;
            this.earnedPoints += pointsToAdd;
            console.log(`è¿›åº¦å¢åŠ  ${actualProgressIncrease}ï¼Œè·å¾— ${pointsToAdd} ç§¯åˆ†ï¼Œå½“å‰æ€»ç§¯åˆ†: ${this.earnedPoints}`);
          }

          // æ£€æŸ¥æ˜¯å¦é¦–æ¬¡è¶…è¿‡80%ä½†æ²¡æœ‰åˆ°100%
          if (!isReplay && !this.gameState.hasCommitted && this.gameState.progress >= 80 && this.gameState.progress < this.config.objective.max_progress) {
            this.handleBasicCompletion();
          }

          if (response.inner_thoughts) {
            this.addInnerThought(response.inner_thoughts);
          }

          // åœ¨æœ€åä¸€æ¡æ¶ˆæ¯ä¸‹é¢æ·»åŠ è¿›åº¦æ˜¾ç¤º
          this.addProgressIndicator(progressChange, response.progress_reason);

          if (!isReplay && this.gameState.progress >= this.config.objective.max_progress) {
            this.handleObjectiveAchieved();
          }
        } // Helper function to extract all response fields using regex
        extractResponseFields(text, bForceResult) {
          const fields = {
            message: "",
            progress_change: null,
            progress_reason: "",
            inner_thoughts: "",
          };

          // Define field names
          const fieldNames = ["message", "progress_change", "progress_reason", "inner_thoughts"];

          // Step 1: Detect all field separators (line positions)
          const separators = [];
          const lines = text.split("\n");

          lines.forEach((line, index) => {
            const trimmedLine = line.trim().toLowerCase();
            for (const fieldName of fieldNames) {
              // Match various formats:
              // - fieldname: (Markdown format)
              // - "fieldname": (JSON format with quotes)
              // - fieldname : (with space before colon)
              // Also handle lines that may start with { or other characters
              const patterns = [
                new RegExp(`^${fieldName}\\s*:`), // message:
                new RegExp(`^"${fieldName}"\\s*:`), // "message":
                new RegExp(`^'${fieldName}'\\s*:`), // 'message':
              ];

              const isMatch = patterns.some((pattern) => trimmedLine.match(pattern));

              if (isMatch) {
                separators.push({
                  fieldName: fieldName,
                  lineIndex: index,
                  line: line,
                });
                break; // Only match one field per line
              }
            }
          });

          // Step 2: Extract content between separators
          for (let i = 0; i < separators.length; i++) {
            const current = separators[i];
            const next = separators[i + 1];

            // Determine the range of lines for this field
            const startLine = current.lineIndex;
            const endLine = next ? next.lineIndex : lines.length;

            // Extract the content (excluding the separator line itself)
            let content = "";

            // Special handling for progress_change - extract number from same line
            if (current.fieldName === "progress_change") {
              // Handle both formats: progress_change: 5 and "progress_change": 5
              const numberMatch = current.line.match(/["']?progress_change["']?\s*:\s*(-?\d+)/i);
              if (numberMatch) {
                fields.progress_change = parseInt(numberMatch[1]);
              }
              continue; // Skip to next field
            }

            // For other fields, collect all lines after the separator until next separator
            for (let lineIdx = startLine; lineIdx < endLine; lineIdx++) {
              if (lineIdx === startLine) {
                // First line - extract content after the colon
                const colonIndex = lines[lineIdx].indexOf(":");
                if (colonIndex !== -1) {
                  const afterColon = lines[lineIdx].substring(colonIndex + 1).trim();
                  if (afterColon) {
                    content += afterColon;
                  }
                }
              } else {
                // Subsequent lines - add entire line
                const lineContent = lines[lineIdx].trim();
                // Skip empty lines at the end
                if (lineContent || lineIdx < endLine - 1) {
                  if (content) content += "\n";
                  content += lineContent;
                }
              }
            }

            // Clean up trailing whitespace
            content = content.trim();

            // Assign to appropriate field
            if (current.fieldName === "message") {
              fields.message = content;
            } else if (current.fieldName === "progress_reason") {
              fields.progress_reason = content;
            } else if (current.fieldName === "inner_thoughts") {
              fields.inner_thoughts = content;
            }
          }

          // Special case: If no field separators were detected, treat all text as message
          if (separators.length === 0 && text.trim()) {
            fields.message = text.trim();
            return fields;
          }

          // Edge case: If message field is missing but other fields exist,
          // assume everything before the first separator is the message
          const hasMessage = separators.some((s) => s.fieldName === "message");
          if (!hasMessage && separators.length > 0) {
            const firstSeparator = separators[0];
            if (firstSeparator.lineIndex > 0) {
              // Extract all lines before the first separator as message
              const messageLines = lines.slice(0, firstSeparator.lineIndex);
              fields.message = messageLines.join("\n").trim();
            }
          }

          // Fallback: If no fields were found and text has meaningful content,
          // treat the entire text as the message (LLM failed to format properly)
          if (!fields.message && !fields.progress_change && !fields.progress_reason && !fields.inner_thoughts) {
            // Check if it looks like attempted field format but failed to parse
            if (!bForceResult && text.trim().match(/^\w+\s*:/) && text.length < 40) {
              fields.message = "";
            } else {
              fields.message = text.trim();
            }
          }

          return fields;
        }
        updateStreamingStatus(fields) {
          // åªåœ¨æµå¼ä¼ è¾“è¿‡ç¨‹ä¸­ä¸´æ—¶æ›´æ–°å†…å¿ƒæƒ³æ³•åŒºåŸŸçš„çŠ¶æ€
          if (fields.inner_thoughts) {
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸´æ—¶çš„æµå¼æ˜¾ç¤ºæ•ˆæœï¼Œå¦‚æœéœ€è¦çš„è¯
          }
        }

        async callLLM(userMessage) {
          if (!aiChatSession) {
            throw new Error("AIèŠå¤©ä¼šè¯æœªåˆå§‹åŒ–");
          }

          // ä½¿ç”¨åŸå§‹çš„ç³»ç»Ÿæç¤ºè¯ï¼Œä¸åŒ…å«å½“å‰è¿›åº¦
          const systemPrompt = this.config.system_prompt;

          // ç¡®ä¿ç³»ç»Ÿæç¤ºè¯å­˜åœ¨ä¸”æ­£ç¡®
          if (aiChatSession.messages.length === 0) {
            // æ–°ä¼šè¯ï¼Œæ·»åŠ ç³»ç»Ÿæç¤ºè¯
            aiChatSession.messages.push({ role: "system", content: systemPrompt });
          } else if (aiChatSession.messages[0].role !== "system") {
            // å·²æœ‰æ¶ˆæ¯ä½†ç¬¬ä¸€æ¡ä¸æ˜¯ç³»ç»Ÿæç¤ºè¯ï¼Œåœ¨å¼€å¤´æ’å…¥
            aiChatSession.messages.unshift({ role: "system", content: systemPrompt });
          } else {
            // å·²æœ‰ç³»ç»Ÿæç¤ºè¯ï¼Œç¡®ä¿å†…å®¹æ˜¯æœ€æ–°çš„ï¼ˆé€‚ç”¨äºé…ç½®æ›´æ”¹çš„æƒ…å†µï¼‰
            aiChatSession.messages[0].content = systemPrompt;
          }

          console.log("Sending message with", aiChatSession.messages.length, "existing messages");
          console.log(
            "Messages:",
            aiChatSession.messages.map((m) => ({ role: m.role, contentLength: m.content.length }))
          );

          try {
            let streamingMessageDiv = null;
            let reasoningMessageDiv = null;
            let messageGroupDiv = null;
            let accumulatedText = "";
            let jsonResponse = null;

            const finalText = await aiChatSession.send(userMessage, {
              onMessage: (partialText, fullResponse) => {
                // Handle reasoning_content from fullResponse if available
                if (fullResponse && fullResponse.reasoning_content) {
                  // Create message group if it doesn't exist
                  if (!messageGroupDiv) {
                    this.removeTypingIndicator();
                    messageGroupDiv = this.createMessageGroup();
                  }
                  // Create or update reasoning section within the group
                  if (!reasoningMessageDiv) {
                    reasoningMessageDiv = this.addReasoningToGroup(messageGroupDiv);
                  }
                  this.updateReasoningContent(reasoningMessageDiv, fullResponse.reasoning_content);
                  this.updateLLMStatus("AIæ­£åœ¨æ¨ç†ä¸­...");
                }

                // partialText is the streamed result so far; fullResponse may contain reasoning_content
                if (partialText !== undefined && partialText !== null) {
                  accumulatedText = partialText;
                  this.updateLLMStatus("æ¥æ”¶å“åº”ä¸­...");

                  // ä½¿ç”¨helperå‡½æ•°æå–æ‰€æœ‰å­—æ®µï¼ˆæ”¯æŒMarkdownå’ŒJSONæ ¼å¼ï¼‰
                  const fields = this.extractResponseFields(partialText);

                  // å°è¯•è§£æå®Œæ•´æ ¼å¼ï¼ˆJSONæˆ–Markdownï¼‰
                  try {
                    // First try JSON parsing for backward compatibility
                    jsonResponse = JSON.parse(partialText);
                  } catch (e) {
                    // If JSON parsing fails, check if we have all Markdown fields
                    if (fields.message && fields.progress_change !== null && fields.progress_reason && fields.inner_thoughts) {
                      jsonResponse = {
                        message: fields.message,
                        progress_change: fields.progress_change,
                        progress_reason: fields.progress_reason,
                        inner_thoughts: fields.inner_thoughts,
                      };
                    }
                    // Otherwise, continue waiting for more data
                  }

                  // ç§»é™¤æ‰“å­—æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœè¿˜åœ¨ï¼‰
                  if (!streamingMessageDiv) {
                    if (!messageGroupDiv) {
                      this.removeTypingIndicator();
                      messageGroupDiv = this.createMessageGroup();
                    }
                    // åˆ›å»ºæµå¼æ¶ˆæ¯å®¹å™¨
                    streamingMessageDiv = this.addStreamingMessageToGroup(messageGroupDiv);
                  }

                  // æ›´æ–°æµå¼æ¶ˆæ¯å†…å®¹ï¼Œåªæ˜¾ç¤ºmessageéƒ¨åˆ†
                  if (fields.message) {
                    this.updateStreamingMessage(streamingMessageDiv, fields.message);
                  }

                  // æ›´æ–°æµå¼çŠ¶æ€æ˜¾ç¤º
                  this.updateStreamingStatus(fields);
                }
              },
              onComplete: (finalText, fullResponse) => {
                this.updateLLMStatus("å“åº”å®Œæˆ");
                if (fullResponse?.headers?.["x-is-downgrade"] === "1") {
                  this.updateLLMStatus("âš ï¸ AIæ¨¡å‹å·²é™çº§ï¼Œå“åº”è´¨é‡å¯èƒ½å—å½±å“");
                  const totalCount = fullResponse?.headers?.["x-gpt-total-count"];
                  if (totalCount) {
                    // Store in instance variable for later use
                    this.llmTotalCount = parseInt(totalCount) || 0;
                  }
                  console.log("LLM Response was downgraded");

                  // Show popup dialog only once
                  if (!this.hasShownDowngradePopup) {
                    this.hasShownDowngradePopup = true;
                    this.showDowngradePopup();
                  }

                  // Show permanent tip
                  this.showPermanentDowngradeTip();
                }

                // Finalize reasoning content if it exists
                if (reasoningMessageDiv) {
                  this.finalizeReasoningContent(reasoningMessageDiv);
                  reasoningMessageDiv = null;
                }

                // ç¡®ä¿ä½¿ç”¨æœ€ç»ˆæ–‡æœ¬è§£æï¼ˆæ”¯æŒJSONå’ŒMarkdownæ ¼å¼ï¼‰
                if (!jsonResponse) {
                  try {
                    // First try JSON parsing for backward compatibility
                    jsonResponse = JSON.parse(finalText);
                  } catch (e) {
                    // If JSON parsing fails, try Markdown format extraction
                    const fields = this.extractResponseFields(finalText, true);
                    jsonResponse = {
                      message: fields.message || finalText,
                      progress_change: fields.progress_change !== null ? fields.progress_change : 0,
                      progress_reason: fields.progress_reason || "",
                      inner_thoughts: fields.inner_thoughts || "",
                    };
                  }
                }

                if (streamingMessageDiv) {
                  // å®Œæˆæµå¼æ˜¾ç¤ºï¼Œè½¬æ¢ä¸ºæ™®é€šæ¶ˆæ¯
                  this.finalizeStreamingMessage(streamingMessageDiv);
                }
              },
              onError: (error) => {
                if (messageGroupDiv) {
                  this.removeMessageGroup(messageGroupDiv);
                }
                throw error;
              },
            });

            // è¿”å›è§£æåçš„å“åº”å’ŒåŸå§‹å“åº”
            return {
              parsedResponse: jsonResponse,
              rawResponse: finalText,
            };
          } catch (error) {
            throw error;
          }
        }
        addMessage(message, isUser = false) {
          const messageDiv = document.createElement("div");
          messageDiv.className = `flex items-start space-x-2 ${isUser ? "justify-end" : ""}`;

          // Process message with markdown - user messages don't need action text processing
          const processedMessage = isUser ? this.processMarkdown(message) : this.processMessage(message);

          if (isUser) {
            messageDiv.innerHTML = `
                              <div class="chat-bubble-right text-white p-3 max-w-xs">
                                  <p>${processedMessage}</p>
                              </div>
                              <div class="w-8 h-8 bg-gradient-to-r from-pink-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">ä½ </div>
                          `;
          } else {
            messageDiv.innerHTML = `
                              <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                                this.config.character?.name?.[0] || "è§’"
                              }</div>
                              <div class="chat-bubble-left text-white p-3 max-w-xs">
                                  <p>${processedMessage}</p>
                              </div>
                              <button class="audio-btn" title="æ’­æ”¾è¯­éŸ³" onclick="game.playMessageAudio('${this.escapeForAttribute(message)}', this)">
                                  ğŸ”Š
                              </button>
                          `;
          } // Prepend the message to the top of the container (which appears at bottom due to flex-col-reverse)
          this.elements.chatContainer.insertBefore(messageDiv, this.elements.chatContainer.firstChild);

          // Scroll to bottom to show the latest message
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        // Process markdown formatting (bold, bullet lists, hyperlinks, images)
        processMarkdown(text) {
          let processed = text;

          // 1. Images: ![alt](url) - must be processed before hyperlinks
          processed = processed.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" class="inline-image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 0.5rem 0;" />');

          // 2. Bold text: **text** or __text__
          processed = processed.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
          processed = processed.replace(/__(.+?)__/g, "<strong>$1</strong>");

          // 3. Hyperlinks: [text](url)
          processed = processed.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-blue-200 underline hover:text-blue-100">$1</a>');

          // 4. Bullet lists: lines starting with - or * or â€¢
          // Split by newlines and process each line
          const lines = processed.split("\n");
          let inList = false;
          const processedLines = [];

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Check if line is a bullet point
            if (line.match(/^[-*â€¢]\s+(.+)/)) {
              const content = line.replace(/^[-*â€¢]\s+/, "");
              if (!inList) {
                processedLines.push('<ul class="list-disc list-inside my-1 space-y-1">');
                inList = true;
              }
              processedLines.push(`<li class="ml-2">${content}</li>`);
            } else {
              if (inList) {
                processedLines.push("</ul>");
                inList = false;
              }
              if (line) {
                processedLines.push(line);
              }
            }
          }

          // Close list if still open
          if (inList) {
            processedLines.push("</ul>");
          }

          processed = processedLines.join("\n");

          return processed;
        }

        processMessage(message) {
          // First, process action text (text in parentheses)
          let processed = message.replace(/\(([^)]+)\)/g, '<span class="action-text">($1)</span>');

          // Then apply markdown formatting
          processed = this.processMarkdown(processed);

          return processed;
        }

        // è½¬ä¹‰å­—ç¬¦ä¸²ç”¨äºHTMLå±æ€§
        escapeForAttribute(str) {
          return str.replace(/'/g, "&#39;").replace(/"/g, "&quot;").replace(/\\/g, "\\\\");
        }
        checkAndPlayVideoAction(message) {
          if (!this.config.videoActions || !message) return;

          // æå–æ‰€æœ‰æ‹¬å·ä¸­çš„æ–‡å­—
          const actionMatches = message.match(/\(([^)]+)\)/g);
          if (!actionMatches) return;

          // åˆå¹¶æ‰€æœ‰æ‹¬å·ä¸­çš„æ–‡å­—
          const allActions = actionMatches.map((match) => match.replace(/[()]/g, "")).join(" ");

          // æ£€æŸ¥æ˜¯å¦åŒ…å«é…ç½®ä¸­çš„åŠ¨ä½œå…³é”®è¯
          for (const actionKey in this.config.videoActions) {
            if (allActions.includes(actionKey)) {
              this.playVideoAction(actionKey, message);
              break;
            }
          }
        }
        playVideoAction(actionKey, messageText) {
          const videoConfig = this.config.videoActions[actionKey];
          if (!videoConfig) return;

          // æ˜¾ç¤ºè§†é¢‘æ’­æ”¾å™¨è¦†ç›–å±‚
          const overlay = document.getElementById("character-video-overlay");
          const messageDiv = document.getElementById("character-video-message");
          const videoElement = document.getElementById("character-video-element");
          const backBtn = document.getElementById("character-video-back-btn");

          // è®¾ç½®æ¶ˆæ¯æ–‡æœ¬
          messageDiv.textContent = messageText;

          // æ˜¾ç¤ºè¦†ç›–å±‚
          overlay.classList.add("show");

          // æ’­æ”¾è§†é¢‘
          this.loadAndPlayVideo(videoElement, videoConfig.url);

          // å…³é—­è¦†ç›–å±‚çš„å‡½æ•°
          const closeOverlay = () => {
            overlay.classList.remove("show");
            // åœæ­¢è§†é¢‘æ’­æ”¾
            videoElement.pause();
            videoElement.src = "";
            backBtn.removeEventListener("click", handleBackClick);
            overlay.removeEventListener("click", handleOverlayClick);
          };

          // ç»‘å®šè¿”å›æŒ‰é’®äº‹ä»¶
          const handleBackClick = () => {
            closeOverlay();
          };
          backBtn.addEventListener("click", handleBackClick);

          // ç»‘å®šè¦†ç›–å±‚ç‚¹å‡»äº‹ä»¶ï¼ˆç‚¹å‡»ä»»æ„ä½ç½®å…³é—­ï¼‰
          const handleOverlayClick = (e) => {
            // åªæœ‰ç‚¹å‡»è¦†ç›–å±‚æœ¬èº«æ‰å…³é—­ï¼Œä¸åŒ…æ‹¬å†…å®¹å®¹å™¨
            if (e.target === overlay) {
              closeOverlay();
            }
          };
          overlay.addEventListener("click", handleOverlayClick);
        }
        async loadAndPlayVideo(videoElement, videoUrl) {
          try {
            if (!videoElement) {
              console.error("Video element is null");
              return;
            }

            // Set video source and properties
            videoElement.src = videoUrl;
            videoElement.loop = true;
            videoElement.muted = true; // é™éŸ³ä»¥å…è®¸è‡ªåŠ¨æ’­æ”¾

            // iOS Safari å…¼å®¹æ€§è®¾ç½®
            videoElement.playsInline = true;
            videoElement.setAttribute("playsinline", "");
            videoElement.setAttribute("webkit-playsinline", "");
            videoElement.setAttribute("x5-video-player-type", "h5");
            videoElement.setAttribute("x5-video-player-fullscreen", "false");
            videoElement.setAttribute("x5-video-orientation", "portraint");
            videoElement.controls = false;
            videoElement.autoplay = false; // é¿å…è‡ªåŠ¨æ’­æ”¾å¯¼è‡´çš„å…¨å±

            // Handle video load and play
            videoElement.addEventListener("loadeddata", () => {
              // å¼€å§‹æ’­æ”¾
              videoElement.play().catch((error) => {
                console.error("è§†é¢‘æ’­æ”¾å¤±è´¥:", error);
              });
            });

            videoElement.addEventListener("error", (e) => {
              console.error("è§†é¢‘åŠ è½½å¤±è´¥:", e);
              // Show error message in video element (could be done by replacing src with error image)
              videoElement.style.backgroundColor = "#667eea";
              videoElement.style.display = "flex";
              videoElement.style.alignItems = "center";
              videoElement.style.justifyContent = "center";
              videoElement.style.color = "white";
              videoElement.style.fontSize = "16px";
              videoElement.innerHTML = "è§†é¢‘åŠ è½½å¤±è´¥";
            });

            // Load the video
            videoElement.load();
          } catch (error) {
            console.error("æ’­æ”¾è§†é¢‘æ—¶å‡ºé”™:", error);
          }
        }

        // ç§»é™¤æ‹¬å·å†…å®¹ç”¨äºè¯­éŸ³æ’­æ”¾
        removeBracketsContent(text) {
          // ç§»é™¤ä¸­æ–‡æ‹¬å·å’Œè‹±æ–‡æ‹¬å·ä¸­çš„å†…å®¹
          return text
            .replace(/\([^)]*\)/g, "")
            .replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, "")
            .trim();
        } // æ’­æ”¾æ¶ˆæ¯è¯­éŸ³
        async playMessageAudio(messageText, buttonElement) {
          try {
            // å¦‚æœæ²¡æœ‰ä¼ å…¥æŒ‰é’®å…ƒç´ ï¼Œé€šè¿‡æ–‡æœ¬å†…å®¹æŸ¥æ‰¾
            let currentButton = buttonElement;
            if (!currentButton) {
              const audioButtons = document.querySelectorAll(".audio-btn");
              audioButtons.forEach((btn) => {
                const bubble = btn.closest(".chat-bubble-left");
                if (bubble) {
                  const content = bubble.querySelector("p") || bubble.querySelector(".streaming-content");
                  if (content && content.textContent.includes(messageText.substring(0, 20))) {
                    currentButton = btn;
                  }
                }
              });
            }

            // å¦‚æœå½“å‰æœ‰éŸ³é¢‘æ­£åœ¨æ’­æ”¾
            if (this.currentPlayingButton) {
              // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªæŒ‰é’®ï¼Œåˆ™åœæ­¢æ’­æ”¾
              if (currentButton === this.currentPlayingButton) {
                this.stopCurrentAudio();
                return;
              } else {
                // åœæ­¢å½“å‰æ’­æ”¾ï¼Œå¼€å§‹æ–°çš„æ’­æ”¾
                this.stopCurrentAudio();
              }
            }

            // è¿‡æ»¤æ‰æ‹¬å·ä¸­çš„å†…å®¹
            const textToRead = this.removeBracketsContent(messageText);

            if (!textToRead.trim()) {
              console.log("æ²¡æœ‰å¯æ’­æ”¾çš„æ–‡æœ¬å†…å®¹");
              return;
            }

            if (!currentButton) {
              console.log("æ‰¾ä¸åˆ°å¯¹åº”çš„éŸ³é¢‘æŒ‰é’®");
              return;
            }

            // è®¾ç½®æ’­æ”¾çŠ¶æ€
            currentButton.classList.add("playing");
            currentButton.innerHTML = "â¸ï¸";
            currentButton.title = "åœæ­¢è¯­éŸ³";

            // ä¿å­˜å½“å‰æ’­æ”¾ä¿¡æ¯
            this.currentPlayingButton = currentButton;

            // Switch avatar to talking when audio starts playing
            if (avatarManager.isEnabled) {
              avatarManager.switchToTalking();
            } // ä½¿ç”¨SDKæ’­æ”¾è¯­éŸ³
            try {
              let audio_url;

              // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²æœ‰è¯¥æ–‡æœ¬çš„éŸ³é¢‘URL
              if (this.audioCache.has(textToRead)) {
                audio_url = this.audioCache.get(textToRead);
                console.log("ä½¿ç”¨ç¼“å­˜çš„éŸ³é¢‘URL");
              } else {
                // ä»SDKè·å–æ–°çš„éŸ³é¢‘URL

                // å¦‚æœä¼ å…¥äº†genderå’Œageå‚æ•°ï¼Œè‡ªåŠ¨æ˜ å°„perå‚æ•°
                const options = {};
                if (this.config.character?.gender || this.config.character?.age !== undefined) {
                  const age = this.config.character?.age || 25;
                  const gender = this.config.character?.gender || "female";
                  options.per = sdk.speech.getVoiceIdByAgeGender(age, gender);
                }

                const result = await sdk.speech.textToAudio(textToRead, {
                  ...options,
                });

                if (result && result.data) {
                  audio_url = result.data;
                  // ç¼“å­˜éŸ³é¢‘URL
                  this.audioCache.set(textToRead, audio_url);
                  console.log("ç¼“å­˜æ–°çš„éŸ³é¢‘URL");
                } else {
                  throw new Error("æ— æ³•è·å–éŸ³é¢‘URL");
                }
              }

              if (audio_url) {
                // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
                const audio = new Audio(audio_url);

                // ç¡®ä¿éŸ³é¢‘ä¸å¾ªç¯æ’­æ”¾
                audio.loop = false;

                // ä¿å­˜éŸ³é¢‘æ§åˆ¶å™¨å¼•ç”¨
                this.currentAudioController = audio; // éŸ³é¢‘æ’­æ”¾å®Œæˆäº‹ä»¶
                audio.addEventListener("ended", () => {
                  console.log("éŸ³é¢‘æ’­æ”¾å®Œæˆ");
                  this.stopCurrentAudio();
                });

                // éŸ³é¢‘å‡ºé”™äº‹ä»¶
                audio.addEventListener("error", (e) => {
                  console.error("éŸ³é¢‘æ’­æ”¾å‡ºé”™:", e);
                  this.stopCurrentAudio();
                });

                // éŸ³é¢‘åŠ è½½å®Œæˆåå¼€å§‹æ’­æ”¾
                audio.addEventListener("canplay", () => {
                  // ç¡®ä¿å½“å‰æŒ‰é’®ä»ç„¶æ˜¯æ­£ç¡®çš„æŒ‰é’®ï¼ˆé˜²æ­¢å¿«é€Ÿç‚¹å‡»å¯¼è‡´çš„çŠ¶æ€æ··ä¹±ï¼‰
                  if (this.currentPlayingButton === currentButton && this.currentAudioController === audio) {
                    audio.play().catch((error) => {
                      console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
                      this.stopCurrentAudio();
                    });
                  }
                });

                // åŠ è½½éŸ³é¢‘
                audio.load();
              }
            } catch (audioError) {
              console.error("è¯­éŸ³æ’­æ”¾å‡ºé”™:", audioError);
              this.stopCurrentAudio();
            }
          } catch (error) {
            console.error("è¯­éŸ³æ’­æ”¾å¤±è´¥:", error);
            this.stopCurrentAudio();
          }
        } // åœæ­¢å½“å‰éŸ³é¢‘æ’­æ”¾
        stopCurrentAudio() {
          // åœæ­¢å¹¶æ¸…ç†éŸ³é¢‘
          if (this.currentAudioController) {
            this.currentAudioController.pause();
            this.currentAudioController.currentTime = 0;
            this.currentAudioController = null;
          }

          // é‡ç½®æŒ‰é’®çŠ¶æ€
          if (this.currentPlayingButton) {
            this.currentPlayingButton.classList.remove("playing");
            this.currentPlayingButton.innerHTML = "ğŸ”Š";
            this.currentPlayingButton.title = "æ’­æ”¾è¯­éŸ³";
            this.currentPlayingButton = null;
          }

          // Switch avatar back to idle when audio stops
          if (avatarManager.isEnabled) {
            avatarManager.switchToIdle();
          }
        }
        // Create a message group container that can hold reasoning + main message
        createMessageGroup() {
          const groupDiv = document.createElement("div");
          groupDiv.className = "flex items-start space-x-2 message-group";
          groupDiv.innerHTML = `
            <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold flex-shrink-0">${
              this.config.character?.name?.[0] || "è§’"
            }</div>
            <div class="flex flex-col space-y-2 flex-1 max-w-xs">
              <!-- Reasoning and message content will be added here -->
            </div>
          `;
          this.elements.chatContainer.insertBefore(groupDiv, this.elements.chatContainer.firstChild);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          return groupDiv;
        }

        // Add reasoning section to message group
        addReasoningToGroup(groupDiv) {
          const contentContainer = groupDiv.querySelector(".flex.flex-col");
          const reasoningDiv = document.createElement("div");
          reasoningDiv.className = "reasoning-section";
          reasoningDiv.innerHTML = `
            <div class="reasoning-header cursor-pointer bg-purple-100 bg-opacity-90 rounded-t-lg px-3 py-2 flex justify-between items-center" onclick="this.parentElement.classList.toggle('collapsed')">
              <span class="text-purple-700 text-sm font-medium">ğŸ§  æ€è€ƒè¿‡ç¨‹</span>
              <span class="toggle-icon text-purple-700">â–¼</span>
            </div>
            <div class="reasoning-content bg-white bg-opacity-95 rounded-b-lg px-3 py-2 text-purple-900 text-sm">
              <p class="streaming-content"></p>
              <span class="streaming-cursor">â–‹</span>
            </div>
          `;
          contentContainer.appendChild(reasoningDiv);
          return reasoningDiv;
        }

        // Update reasoning content
        updateReasoningContent(reasoningDiv, text) {
          const contentElement = reasoningDiv.querySelector(".streaming-content");
          if (contentElement) {
            contentElement.textContent = text;
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }
        }

        // Finalize reasoning content
        finalizeReasoningContent(reasoningDiv) {
          const cursor = reasoningDiv.querySelector(".streaming-cursor");
          if (cursor) {
            cursor.remove();
          }
        }

        // Add streaming message to a message group
        addStreamingMessageToGroup(groupDiv) {
          const contentContainer = groupDiv.querySelector(".flex.flex-col");
          const messageDiv = document.createElement("div");
          messageDiv.className = "chat-bubble-left text-white p-3 streaming-message";
          messageDiv.innerHTML = `
            <p class="streaming-content"></p>
            <span class="streaming-cursor">â–‹</span>
          `;
          contentContainer.appendChild(messageDiv);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          return messageDiv;
        }

        addStreamingMessage() {
          const messageDiv = document.createElement("div");
          messageDiv.className = "flex items-start space-x-2 streaming-message";
          messageDiv.innerHTML = `
                          <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                            this.config.character?.name?.[0] || "è§’"
                          }</div>
                          <div class="chat-bubble-left text-white p-3 max-w-xs">
                              <p class="streaming-content"></p>
                              <span class="streaming-cursor">â–‹</span>
                          </div>
                      `;
          // Prepend streaming message (appears at bottom due to flex-col-reverse)
          this.elements.chatContainer.insertBefore(messageDiv, this.elements.chatContainer.firstChild);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;

          return messageDiv;
        }

        updateStreamingMessage(messageDiv, text) {
          // Handle both standalone message and message within a group
          let contentElement = messageDiv.querySelector(".streaming-content");
          if (!contentElement) {
            // If messageDiv is the message group, find the content in the nested structure
            const chatBubble = messageDiv.querySelector(".chat-bubble-left");
            if (chatBubble) {
              contentElement = chatBubble.querySelector(".streaming-content");
            }
          }
          if (contentElement) {
            contentElement.innerHTML = this.processMessage(text);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }
        }
        finalizeStreamingMessage(messageDiv) {
          const cursor = messageDiv.querySelector(".streaming-cursor");
          if (cursor) {
            cursor.remove();
          }
          messageDiv.classList.remove("streaming-message");

          // ä¸ºå®Œæˆçš„æµå¼æ¶ˆæ¯æ·»åŠ è¯­éŸ³æ’­æ”¾æŒ‰é’®
          const contentElement = messageDiv.querySelector(".streaming-content");
          if (contentElement) {
            const messageText = contentElement.textContent || contentElement.innerText;

            // Check if messageDiv is part of a message group
            const messageGroup = messageDiv.closest(".message-group");
            if (messageGroup) {
              // Add audio button to the group level
              const audioBtn = document.createElement("button");
              audioBtn.className = "audio-btn";
              audioBtn.title = "æ’­æ”¾è¯­éŸ³";
              audioBtn.innerHTML = "ğŸ”Š";
              audioBtn.onclick = () => this.playMessageAudio(messageText, audioBtn);
              messageGroup.appendChild(audioBtn);
            } else {
              // Original behavior for standalone messages
              const audioBtn = document.createElement("button");
              audioBtn.className = "audio-btn";
              audioBtn.title = "æ’­æ”¾è¯­éŸ³";
              audioBtn.innerHTML = "ğŸ”Š";
              audioBtn.onclick = () => this.playMessageAudio(messageText, audioBtn);
              messageDiv.appendChild(audioBtn);
            }

            this.checkAndPlayVideoAction(messageText);

            // Switch avatar back to idle after streaming is complete
            if (avatarManager.isEnabled) {
              // Calculate speaking duration based on message length
              const speakingDuration = Math.max(2000, messageText.length * 50); // Minimum 2 seconds
            }
          }
        }

        removeStreamingMessage(messageDiv) {
          if (messageDiv && messageDiv.parentNode) {
            messageDiv.parentNode.removeChild(messageDiv);
          }
        }

        removeMessageGroup(groupDiv) {
          if (groupDiv && groupDiv.parentNode) {
            groupDiv.parentNode.removeChild(groupDiv);
          }
        }
        addTypingIndicator() {
          const typingDiv = document.createElement("div");
          typingDiv.id = "typing-indicator";
          typingDiv.className = "flex items-start space-x-2";
          typingDiv.innerHTML = `
                          <div class="w-8 h-8 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${
                            this.config.character?.name?.[0] || "è§’"
                          }</div>
                          <div class="chat-bubble-left text-white p-3 max-w-xs typing-indicator">
                              <p>æ­£åœ¨æ€è€ƒ...</p>
                          </div>
                      `;
          // Prepend typing indicator (appears at bottom due to flex-col-reverse)
          this.elements.chatContainer.insertBefore(typingDiv, this.elements.chatContainer.firstChild);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        removeTypingIndicator() {
          const indicator = document.getElementById("typing-indicator");
          if (indicator) indicator.remove();
        }
        addProgressIndicator(progressChange, progressReason) {
          if (!progressChange || progressChange === 0) return;

          const progressDiv = document.createElement("div");
          progressDiv.className = "flex justify-center my-2";

          const progressText = progressChange > 0 ? `+${progressChange}` : `${progressChange}`;
          const progressEmoji = progressChange > 0 ? "ğŸ˜„" : "ğŸ˜";

          progressDiv.innerHTML = `
                          <div class="bg-gray-100 rounded-full px-3 py-1 text-sm text-gray-600">
                              ${progressEmoji}${progressText}ï¼ˆ${progressReason}ï¼‰
                          </div>
                      `;

          // Prepend progress indicator (appears at bottom due to flex-col-reverse)
          this.elements.chatContainer.insertBefore(progressDiv, this.elements.chatContainer.firstChild);
          this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
        }
        updateProgress(change, reason) {
          this.gameState.progress = Math.max(0, Math.min(this.gameState.progress + change, this.config.objective.max_progress));
          this.elements.progressBar.style.width = `${this.gameState.progress}%`;
          this.elements.progressText.textContent = `${this.gameState.progress}/${this.config.objective.max_progress}`;
        }

        updateProgressToValue(newProgress, reason) {
          this.gameState.progress = Math.max(0, Math.min(newProgress, this.config.objective.max_progress));
          this.elements.progressBar.style.width = `${this.gameState.progress}%`;
          this.elements.progressText.textContent = `${this.gameState.progress}/${this.config.objective.max_progress}`;
        }
        addInnerThought(thought) {
          if (!thought || thought.trim() === "") return;

          // ä½¿ç”¨thoughts-contentå®¹å™¨è€Œä¸æ˜¯inner-thoughts
          const thoughtsContainer = document.getElementById("thoughts-content");
          if (!thoughtsContainer) return;

          const thoughtDiv = document.createElement("div");
          thoughtDiv.className = "thought-bubble";

          const thoughtText = document.createElement("div");
          thoughtText.className = "thought-bubble-text";
          thoughtText.textContent = thought;

          thoughtDiv.appendChild(thoughtText);
          thoughtsContainer.appendChild(thoughtDiv);

          // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°çš„å†…å¿ƒæƒ³æ³•
          thoughtsContainer.scrollTop = thoughtsContainer.scrollHeight;

          // é™åˆ¶æ˜¾ç¤ºçš„å†…å¿ƒæƒ³æ³•æ•°é‡ï¼Œé¿å…è¿‡å¤šå ç”¨ç©ºé—´
          const maxThoughts = 5;
          const thoughts = thoughtsContainer.children;
          while (thoughts.length > maxThoughts) {
            thoughtsContainer.removeChild(thoughts[0]);
          }
        }

        updateLLMStatus(status) {
          this.elements.llmStatus.textContent = status;
          setTimeout(() => {
            this.elements.llmStatus.textContent = "";
          }, 3000);
        }
        async saveProgress(wikiWord, isFinished = false) {
          try {
            // Check if this is a custom question
            const customQuestionId = this.config?.objective?.customQuestionId;

            // Early return if there's nothing to save
            if (!customQuestionId && !wikiWord) {
              return;
            }

            // Load current progress data from keepwork
            let progressData = await sdk.personalPageStore.loadPageData("maisi_dragon_wiki", "discussion-progress-data");
            // Ensure data structure exists
            if (!progressData || typeof progressData !== "object") {
              progressData = {
                completed_wikiwords: [],
                completed_times: [],
                inprogress_wikiwords: [],
                inprogress_times: [],
                currentperiod_wikiwords: [],
                currentperiod_times: [],
                custom_questions: [], // Ensure custom_questions array exists
              };
            } else {
              progressData = JSON.parse(JSON.stringify(progressData));
              // Ensure custom_questions array exists
              if (!Array.isArray(progressData.custom_questions)) {
                progressData.custom_questions = [];
              }
            }

            // Get current date in YYMMDD format
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = (now.getMonth() + 1).toString().padStart(2, "0");
            const day = now.getDate().toString().padStart(2, "0");
            const currentDateCode = parseInt(year + month + day);

            if (customQuestionId) {
              // Handle custom question progress
              const customIndex = progressData.custom_questions.findIndex((q) => q.id === customQuestionId);

              if (customIndex !== -1) {
                if (!isFinished) {
                  // Set to progress status
                  progressData.custom_questions[customIndex].status = "progress";
                  progressData.custom_questions[customIndex].progressTime = currentDateCode;
                  console.log(`Updated custom question ${customQuestionId} to progress status`);
                } else {
                  // Set to completed status
                  progressData.custom_questions[customIndex].status = "completed";
                  progressData.custom_questions[customIndex].completedTime = currentDateCode;
                  delete progressData.custom_questions[customIndex].progressTime;
                  console.log(`Updated custom question ${customQuestionId} to completed status`);
                }
              } else {
                console.warn(`Custom question ${customQuestionId} not found in data`);
              }

              // Also handle wikiword if the custom question has one
              if (wikiWord) {
                this.handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode);
              }
            } else if (wikiWord) {
              // Handle regular wikiword question
              this.handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode);
            }

            // Save updated data back to keepwork
            await sdk.personalPageStore.savePageData("maisi_dragon_wiki", "discussion-progress-data", progressData, true);
            console.log(`Successfully saved progress for ${customQuestionId || wikiWord}`);
          } catch (error) {
            console.error("Error saving progress:", error);
          }
        }

        // Helper function to handle wikiword progress
        handleWikiwordProgress(progressData, wikiWord, isFinished, currentDateCode) {
          if (!isFinished) {
            // If already completed, do not add to in-progress
            if (progressData.completed_wikiwords.includes(wikiWord) || progressData.inprogress_wikiwords.includes(wikiWord)) return;

            // Add to in-progress arrays if not already there
            progressData.inprogress_wikiwords.push(wikiWord);
            progressData.inprogress_times.push(currentDateCode);
            console.log(`Added ${wikiWord} to in-progress arrays with date ${currentDateCode}`);
          } else {
            // Remove wikiword from inprogress arrays if it exists
            const progressIndex = progressData.inprogress_wikiwords.indexOf(wikiWord);
            if (progressIndex > -1) {
              progressData.inprogress_wikiwords.splice(progressIndex, 1);
              // Also remove corresponding time entry
              if (progressData.inprogress_times.length > progressIndex) {
                progressData.inprogress_times.splice(progressIndex, 1);
              }
              console.log(`Removed ${wikiWord} from progress arrays`);
            }

            // Add to completed arrays if not already there
            if (!progressData.completed_wikiwords.includes(wikiWord)) {
              progressData.completed_wikiwords.push(wikiWord);
              progressData.completed_times.push(currentDateCode);
              console.log(`Added ${wikiWord} to completed arrays with date ${currentDateCode}`);
            }
          }
        }

        handleBasicCompletion() {
          if (this.gameState.hasCommitted) return;
          this.gameState.hasCommitted = true;

          this.saveProgress(this.config?.objective?.wikiword, true); // Send game finished event to host
          window.parent.postMessage(
            {
              type: "gameFinished",
              data: {
                score: this.gameState.progress,
                earnedPoints: this.earnedPoints,
                characterName: this.config?.character?.name || "è§’è‰²",
                totalMessages: this.gameState.chatHistory.length,
                finalProgress: this.gameState.progress,
                isMaxDifficulty: true, // prevent selecting difficulty again
              },
            },
            "*"
          );

          // å‘é€å®Œåç«‹å³æ¸…é›¶earnedPoints
          this.earnedPoints = 0;

          setTimeout(() => {
            const congratsDiv = document.createElement("div");
            congratsDiv.className = "bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg mt-4";
            congratsDiv.innerHTML = `
                              <div class="flex items-center">
                                  <span class="text-2xl mr-2">ğŸ¯</span>
                                  <div>
                                      <strong>ä»»åŠ¡åŸºæœ¬å®Œæˆï¼</strong><br>
                                      <span class="text-sm">ä½ å·²ç»æˆåŠŸå¸®åŠ©${this.config.character?.name || "è§’è‰²"}è§£å†³äº†å¤§éƒ¨åˆ†é—®é¢˜ï¼ç»§ç»­åŠªåŠ›ï¼</span>
                                  </div>
                              </div>
                          `;
            // Prepend congratulations message (appears at bottom due to flex-col-reverse)
            this.elements.chatContainer.insertBefore(congratsDiv, this.elements.chatContainer.firstChild);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }, 1000);
        }

        handleObjectiveAchieved() {
          if (this.gameState.isObjectiveAchieved) return;
          this.gameState.isObjectiveAchieved = true;

          this.saveProgress(this.config?.objective?.wikiword, true); // Send game finished event to host
          window.parent.postMessage(
            {
              type: "gameFinished",
              data: {
                score: this.gameState.progress,
                earnedPoints: this.earnedPoints,
                characterName: this.config?.character?.name || "è§’è‰²",
                totalMessages: this.gameState.chatHistory.length,
                finalProgress: this.gameState.progress,
                isMaxDifficulty: true, // prevent selecting difficulty again
              },
            },
            "*"
          );

          // å‘é€å®ŒgameFinishedåç«‹å³æ¸…é›¶earnedPoints
          this.earnedPoints = 0;

          setTimeout(() => {
            const congratsDiv = document.createElement("div");
            congratsDiv.className = "bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg mt-4";

            // Get messages from config with template replacement
            const title = this.config.completion_messages?.title || "ç›®æ ‡å®Œæˆï¼";
            const description = (this.config.completion_messages?.description || "ä½ æˆåŠŸå¸®åŠ©${character_name}æ‰¾å›äº†å­¦ä¹ åŠ¨åŠ›ï¼").replace("${character_name}", this.config.character?.name || "è§’è‰²");
            const icon = this.config.completion_messages?.icon || "ğŸ‰";
            congratsDiv.innerHTML = `
                              <div class="flex items-center">
                                  <span class="text-2xl mr-2">${icon}</span>
                                  <div>
                                      <strong>${title}</strong><br>
                                      <span class="text-sm">${description}</span>
                                  </div>
                              </div>
                          `;
            // Prepend congratulations message (appears at bottom due to flex-col-reverse)
            this.elements.chatContainer.insertBefore(congratsDiv, this.elements.chatContainer.firstChild);
            this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;
          }, 1000);
        }
        getHistoryKey() {
          const objectiveTitle = this.config?.objective?.title || "ç›®æ ‡è¿›åº¦";
          const characterName = this.config?.character?.name || "è§’è‰²";
          return `chat_history_${objectiveTitle}_${characterName}`;
        }
        autoSaveHistory() {
          // ä½¿ç”¨æ–°çš„sessionç³»ç»Ÿä¿å­˜
          this.saveCurrentSessionToHistory();
        }

        async autoLoadHistory() {
          try {
            // å°è¯•åŠ è½½æœ€æ–°çš„session
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            if (sessions.length > 0) {
              console.log("Found", sessions.length, "saved sessions, loading latest");
              // åŠ è½½æœ€æ–°çš„sessionï¼ˆæ•°ç»„ç¬¬ä¸€ä¸ªæ˜¯æœ€æ–°çš„ï¼‰
              const latestSession = sessions[0];
              await this.loadSession(latestSession.id);
              return;
            }

            console.log("æ²¡æœ‰æ‰¾åˆ°å†å²ä¼šè¯ï¼Œå¼€å§‹æ–°ä¼šè¯");
          } catch (error) {
            console.error("è‡ªåŠ¨åŠ è½½å†å²è®°å½•å¤±è´¥:", error);
          }
        } // é‡æ–°ç»‘å®šéŸ³é¢‘æŒ‰é’®äº‹ä»¶ï¼ˆåœ¨åŠ è½½å†å²è®°å½•åè°ƒç”¨ï¼‰
        rebindAudioButtons() {
          const audioButtons = this.elements.chatContainer.querySelectorAll(".audio-btn");
          audioButtons.forEach((button) => {
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            button.onclick = null;

            // æ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯æ–‡æœ¬
            const messageDiv = button.closest(".flex");
            if (messageDiv) {
              const chatBubble = messageDiv.querySelector(".chat-bubble-left, .chat-bubble-right");
              if (chatBubble) {
                const messageText = chatBubble.textContent || chatBubble.innerText;
                button.onclick = () => this.playMessageAudio(messageText, button);
              }
            }
          });
        } // ========== Sessionç®¡ç†æ–¹æ³• ==========
        // Get the LLM configuration object from config, supporting RAG parameters
        getLLMConfig() {
          // Backward compatibility: if llm_model is a string, convert to object
          if (typeof this.config?.llm_model === "string") {
            return { model: this.config.llm_model };
          }

          // Return full configuration object with defaults
          const llmConfig = {
            model: this.config?.llm_model?.model || "keepwork-pro",
          };

          // Add optional RAG parameters if provided
          if (this.config?.llm_model?.temperature !== undefined) {
            llmConfig.temperature = this.config.llm_model.temperature;
          }
          if (this.config?.llm_model?.knowledgeUsername) {
            llmConfig.knowledgeUsername = this.config.llm_model.knowledgeUsername;
          }
          if (this.config?.llm_model?.knowledgeBaseCodes) {
            llmConfig.knowledgeBaseCodes = this.config.llm_model.knowledgeBaseCodes;
          }

          return llmConfig;
        }

        // Legacy method for backward compatibility
        getLLMModel() {
          return this.getLLMConfig().model;
        }

        createNewSession() {
          this.currentSessionId = this.generateSessionId();

          // é‡æ–°åˆå§‹åŒ–AIèŠå¤©ä¼šè¯
          if (sdk && sdk.aiChat) {
            const llmConfig = this.getLLMConfig();
            aiChatSession = sdk.aiChat.createSession({
              ...llmConfig,
              stream: true,
            });

            // ä¸ºæ–°ä¼šè¯æ·»åŠ ç³»ç»Ÿæç¤ºè¯
            if (this.config && this.config.system_prompt) {
              aiChatSession.messages.push({ role: "system", content: this.config.system_prompt });
            }

            console.log("New AI session created with system prompt, messages count:", aiChatSession.messages.length);
          }
        }

        // ç”Ÿæˆsession ID
        generateSessionId() {
          return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        resetChat() {
          // ä¿å­˜å½“å‰sessionåˆ°å†å²è®°å½•ï¼ˆå¦‚æœæœ‰èŠå¤©è®°å½•ä¸”è¿›åº¦å¤§äº0çš„è¯ï¼‰
          if (this.gameState.chatHistory.length > 0 && this.gameState.progress > 0) {
            this.saveCurrentSessionToHistory();
          }

          // æ¸…ç©ºå½“å‰session IDï¼Œç¡®ä¿åˆ›å»ºæ–°session
          this.currentSessionId = null; // é‡ç½®æ¸¸æˆçŠ¶æ€
          this.gameState = {
            progress: 0,
            chatHistory: [],
            isObjectiveAchieved: false,
            hasCommitted: false,
          };

          // é‡ç½®earnedPoints
          this.earnedPoints = 0;

          // åˆ›å»ºæ–°çš„session
          this.createNewSession();

          // æ¸…ç©ºUIçŠ¶æ€
          this.elements.chatContainer.innerHTML = "";
          this.elements.innerThoughts.innerHTML = "";

          // é‡ç½®è¿›åº¦æ¡
          this.elements.progressBar.style.width = "0%";
          this.elements.progressText.textContent = "0/100";

          // æ·»åŠ åˆå§‹æ¶ˆæ¯
          if (this.config.initial?.message) {
            this.addMessage(this.config.initial.message, false);
          }

          // æ›´æ–°å†å²ä¸‹æ‹‰èœå•
          this.updateHistoryDropdown();

          this.updateLLMStatus("å¯¹è¯å·²é‡ç½®ï¼Œå¼€å§‹æ–°çš„ä¼šè¯");

          if (this.elements.chatContainer.children.length === 1) {
            this.checkAndPlayVideoAction(this.config.initial?.message);
          }
        }
        saveCurrentSessionToHistory() {
          // å¦‚æœæ²¡æœ‰session IDã€æ²¡æœ‰èŠå¤©è®°å½•æˆ–è¿›åº¦ä¸º0ï¼Œåˆ™ä¸ä¿å­˜
          if (!this.currentSessionId || this.gameState.chatHistory.length === 0 || this.gameState.progress === 0) {
            return;
          }

          try {
            // è·å–ç°æœ‰çš„sessionå†å²è®°å½•
            const sessionsKey = this.getSessionsStorageKey();
            const existingSessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            // åˆ›å»ºå½“å‰sessionçš„æ•°æ® - åªä¿å­˜åŸå§‹èŠå¤©å†å²
            const currentTime = new Date();
            const sessionData = {
              id: this.currentSessionId,
              timestamp: currentTime.toISOString(),
              chatHistory: [...this.gameState.chatHistory], // åŒ…å«raw_responseçš„å®Œæ•´å†å²
            };

            // æ·»åŠ åˆ°å†å²è®°å½•æ•°ç»„çš„å¼€å¤´
            existingSessions.unshift(sessionData);

            // é™åˆ¶æœ€å¤šä¿å­˜10ä¸ªsession
            if (existingSessions.length > this.maxSessions) {
              existingSessions.splice(this.maxSessions);
            }

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem(sessionsKey, JSON.stringify(existingSessions));

            // æ›´æ–°ä¸‹æ‹‰èœå•
            this.updateHistoryDropdown();
          } catch (error) {
            console.error("ä¿å­˜sessionå†å²è®°å½•å¤±è´¥:", error);
          }
        }
        updateHistoryDropdown() {
          try {
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            // æ¸…ç©ºä¸‹æ‹‰èœå•ï¼Œæ·»åŠ é»˜è®¤é€‰é¡¹å’Œæ¸…ç©ºå†å²é€‰é¡¹
            this.elements.historyDropdown.innerHTML = `
                              <option value="" disabled selected class="text-black bg-white">å†å²</option>
                              <option value="clearHistory" class="text-black bg-white">æ¸…ç©ºå†å²</option>
                          `; // æ·»åŠ sessioné€‰é¡¹
            sessions.forEach((session) => {
              const option = document.createElement("option");
              option.value = session.id;

              // è®¡ç®—sessionçš„æœ€ç»ˆè¿›åº¦
              const finalProgress = this.calculateSessionProgress(session.chatHistory);
              const timestamp = new Date(session.timestamp);
              option.textContent = `è¿›åº¦${finalProgress}% - ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString()}`;
              option.className = "text-black bg-white";
              this.elements.historyDropdown.appendChild(option);
            });

            // ä¿æŒé»˜è®¤é€‰é¡¹"å†å²"è¢«é€‰ä¸­ï¼ˆä¸éœ€è¦é‡ç½®ï¼‰
          } catch (error) {
            console.error("æ›´æ–°å†å²ä¸‹æ‹‰èœå•å¤±è´¥:", error);
          }
        }

        // è®¡ç®—sessionçš„æœ€ç»ˆè¿›åº¦
        calculateSessionProgress(chatHistory) {
          let progress = 0;

          for (const msg of chatHistory) {
            if (msg.role === "assistant" && msg.raw_response) {
              try {
                const parsedResponse = JSON.parse(msg.raw_response);
                if (parsedResponse.progress_change !== undefined) {
                  progress += parsedResponse.progress_change;
                }
              } catch (e) {
                // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ç”¨æ­£åˆ™æå–
                const fields = this.extractResponseFields(msg.raw_response);
                if (fields.progress_change !== null) {
                  progress += fields.progress_change;
                }
              }
            }
          }

          return progress;
        }
        async loadSession(sessionId) {
          try {
            const sessionsKey = this.getSessionsStorageKey();
            const sessions = JSON.parse(localStorage.getItem(sessionsKey) || "[]");

            const session = sessions.find((s) => s.id === sessionId);
            if (!session) {
              console.error("æ‰¾ä¸åˆ°æŒ‡å®šçš„session:", sessionId);
              return;
            }

            // ä¿å­˜å½“å‰sessionï¼ˆå¦‚æœæœ‰èŠå¤©è®°å½•ä¸”è¿›åº¦å¤§äº0çš„è¯ï¼‰
            if (this.gameState.chatHistory.length > 0 && this.gameState.progress > 0) {
              this.saveCurrentSessionToHistory();
            } // é‡ç½®çŠ¶æ€
            this.currentSessionId = session.id;
            this.gameState = {
              progress: 0,
              chatHistory: [],
              isObjectiveAchieved: false,
            };
            // earnedPointsä¸ä¼šåœ¨loadSessionä¸­é‡ç½®ï¼Œä¿æŒå½“å‰å€¼
            this.elements.chatContainer.innerHTML = "";
            this.elements.innerThoughts.innerHTML = "";
            this.elements.progressBar.style.width = "0%";
            this.elements.progressText.textContent = "0/100";

            // æ·»åŠ åˆå§‹æ¶ˆæ¯
            if (this.config.initial?.message) {
              this.addMessage(this.config.initial.message, false);
            }

            // å¤„ç†èŠå¤©å†å²ï¼šå¦‚æœæœ€åä¸€æ¡æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ™æ”¾åˆ°è¾“å…¥æ¡†ä¸­
            let chatHistoryToReplay = [...session.chatHistory];
            let lastUserMessage = "";

            if (chatHistoryToReplay.length > 0 && chatHistoryToReplay[chatHistoryToReplay.length - 1].role === "user") {
              // å–å‡ºæœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
              const lastMessage = chatHistoryToReplay.pop();
              lastUserMessage = lastMessage.content;
            } // é‡æ–°åˆå§‹åŒ–AIèŠå¤©ä¼šè¯
            if (sdk && sdk.aiChat) {
              const llmConfig = this.getLLMConfig();
              aiChatSession = sdk.aiChat.createSession({
                ...llmConfig,
                stream: true,
              });

              // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
              aiChatSession.messages.push({ role: "system", content: this.config.system_prompt });
            }

            // é‡æ”¾å†å²æ¶ˆæ¯æ¥æ¢å¤UIçŠ¶æ€
            for (const msg of chatHistoryToReplay) {
              if (msg.role === "user") {
                // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°UI
                let message = msg.content.replace(/^\[.*?\]\s*/, "");
                this.addMessage(message, true);
                // æ·»åŠ åˆ°æ¸¸æˆçŠ¶æ€å’ŒAIä¼šè¯
                this.gameState.chatHistory.push({ role: "user", content: msg.content });
                if (aiChatSession) {
                  aiChatSession.messages.push({ role: "user", content: msg.content });
                }
              } else if (msg.role === "assistant" && msg.raw_response) {
                // æ¨¡æ‹ŸLLMå“åº”æ¥æ¢å¤UIçŠ¶æ€
                await this.replayLLMResponse(msg.raw_response);
              }
            }

            // å¦‚æœæœ‰æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ï¼Œå°†å…¶æ”¾åˆ°è¾“å…¥æ¡†ä¸­
            if (lastUserMessage) {
              this.elements.userInput.value = lastUserMessage;
            }

            // é‡æ–°ç»‘å®šéŸ³é¢‘æŒ‰é’®äº‹ä»¶
            this.rebindAudioButtons();

            // é‡ç½®ä¸‹æ‹‰èœå•é€‰æ‹©
            this.elements.historyDropdown.value = "";

            console.log("Session loaded and replayed:", sessionId);
            console.log("Final progress:", this.gameState.progress);
            console.log("AI session messages:", aiChatSession?.messages.length);

            this.updateLLMStatus(`å·²åˆ‡æ¢åˆ°å†å²ä¼šè¯: è¿›åº¦${this.gameState.progress}%`);
          } catch (error) {
            console.error("åŠ è½½sessionå¤±è´¥:", error);
            this.updateLLMStatus("åŠ è½½å†å²ä¼šè¯å¤±è´¥");
          }
        }

        // é‡æ”¾LLMå“åº”ï¼ˆç”¨äºsessionåŠ è½½æ—¶æ¢å¤UIçŠ¶æ€ï¼‰
        async replayLLMResponse(rawResponse) {
          try {
            // è§£æåŸå§‹å“åº”ï¼ˆæ”¯æŒJSONå’ŒMarkdownæ ¼å¼ï¼‰
            let parsedResponse;
            try {
              // First try JSON parsing for backward compatibility
              parsedResponse = JSON.parse(rawResponse);
            } catch (e) {
              // If JSON parsing fails, try Markdown format extraction
              const fields = this.extractResponseFields(rawResponse);
              parsedResponse = {
                message: fields.message || rawResponse,
                progress_change: fields.progress_change !== null ? fields.progress_change : 0,
                progress_reason: fields.progress_reason || "ä¼šè¯æ¢å¤",
                inner_thoughts: fields.inner_thoughts || "",
              };
            }

            // æ·»åŠ AIæ¶ˆæ¯åˆ°UI
            this.addMessage(parsedResponse.message, false);

            // åº”ç”¨å“åº”çš„æ•ˆæœï¼ˆè¿›åº¦ã€å†…å¿ƒæƒ³æ³•ç­‰ï¼‰
            this.applyLLMResponse(parsedResponse, true);
            this.gameState.chatHistory.push({
              role: "assistant",
              content: parsedResponse.message,
              raw_response: rawResponse,
            });
            if (aiChatSession) {
              // æ·»åŠ å®Œæ•´çš„åŸå§‹å“åº”åˆ°AIä¼šè¯ï¼ˆå¯èƒ½æ˜¯JSONæˆ–Markdownæ ¼å¼ï¼‰
              aiChatSession.messages.push({ role: "assistant", content: rawResponse });
            }
          } catch (error) {
            console.error("é‡æ”¾LLMå“åº”å¤±è´¥:", error);
          }
        } // è·å–sessionsçš„å­˜å‚¨é”®
        getSessionsStorageKey() {
          const objectiveTitle = this.config?.objective?.title || "ç›®æ ‡è¿›åº¦";
          const characterName = this.config?.character?.name || "è§’è‰²";
          return `chat_sessions_${objectiveTitle}_${characterName}`;
        }

        // æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
        clearAllHistory() {
          try {
            // è·å–å­˜å‚¨é”®å¹¶æ¸…ç©ºlocalStorageä¸­çš„å†å²è®°å½•
            const sessionsKey = this.getSessionsStorageKey();
            localStorage.removeItem(sessionsKey);

            // åŒæ—¶æ¸…ç†æ—§ç‰ˆæœ¬çš„å†å²è®°å½•é”®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const oldHistoryKey = this.getHistoryKey();
            localStorage.removeItem(oldHistoryKey);

            // æ›´æ–°ä¸‹æ‹‰èœå•æ˜¾ç¤º
            this.updateHistoryDropdown();

            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            this.updateLLMStatus("æ‰€æœ‰å†å²è®°å½•å·²æ¸…ç©º");

            console.log("All chat history cleared");
          } catch (error) {
            console.error("æ¸…ç©ºå†å²è®°å½•å¤±è´¥:", error);
            this.updateLLMStatus("æ¸…ç©ºå†å²è®°å½•å¤±è´¥");
          } finally {
            // ç¡®ä¿é‡ç½®ä¸‹æ‹‰èœå•é€‰æ‹©
            this.elements.historyDropdown.value = "";
          }
        }

        // Show popup dialog for AI model downgrade
        showDowngradePopup() {
          const overlay = document.createElement("div");
          overlay.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
          overlay.innerHTML = `
            <div class="bg-white rounded-lg p-6 max-w-md mx-4 shadow-xl">
              <div class="text-center">
                <div class="text-5xl mb-4">âš ï¸</div>
                <h2 class="text-2xl font-bold text-gray-800 mb-4">é«˜çº§AIå¯¹è¯æ¬¡æ•°å·²ç”¨å®Œ</h2>
                <p class="text-gray-600 mb-6">
                  æ‚¨çš„æ¯æ—¥é«˜çº§AIå¯¹è¯æ¬¡æ•°å·²è¾¾ä¸Šé™ã€‚å‡çº§ä¸º<span class="font-bold text-purple-600">ä¼šå‘˜</span>å³å¯ç»§ç»­ä½¿ç”¨é«˜çº§AIæ¨¡å‹ï¼Œå¦åˆ™å°†ä½¿ç”¨ç®€åŒ–æ–‡æœ¬æ¨¡å¼å›å¤ã€‚
                  é«˜çº§æ¨¡å‹å¯¹è¯æ¬¡æ•°æ¯æ—¥å‡Œæ™¨é‡ç½®ã€‚
                </p>
                <div class="flex justify-center">
                  <button class="bg-purple-600 hover:bg-purple-700 text-white px-8 py-2 rounded-lg font-medium transition-colors" onclick="this.closest('.fixed').remove()">
                    çŸ¥é“äº†
                  </button>
                </div>
              </div>
            </div>
          `;
          document.body.appendChild(overlay);
        }

        // Show permanent tip for AI model downgrade
        showPermanentDowngradeTip() {
          // Check if tip already exists
          if (document.getElementById("permanent-downgrade-tip")) {
            return;
          }

          const tip = document.createElement("div");
          tip.id = "permanent-downgrade-tip";
          tip.className = "fixed top-24 left-1/2 transform -translate-x-1/2 bg-yellow-100 border border-yellow-400 text-yellow-800 px-4 py-2 rounded-lg shadow-lg z-40 text-sm";
          tip.innerHTML = `
            <div class="flex items-center gap-2">
              <span>âš ï¸</span>
              <span>AIæ¨¡å‹å·²é™çº§ - <a href="#" class="underline font-semibold" id="upgrade-link">å‡çº§ä¼šå‘˜</a>è§£é”é«˜çº§æ¨¡å‹</span>
              <button class="ml-2 text-yellow-600 hover:text-yellow-900 font-bold" onclick="this.closest('#permanent-downgrade-tip').remove()" title="å…³é—­æç¤º">Ã—</button>
            </div>
          `;
          document.body.appendChild(tip);

          // Add click handler to upgrade link
          const upgradeLink = document.getElementById("upgrade-link");
          if (upgradeLink) {
            upgradeLink.addEventListener("click", (e) => {
              e.preventDefault();
              this.showDowngradePopup();
            });
          }
        }

        // Initialize avatar background video with proper timing
        initializeAvatarBackground() {
          if (!window.showAvatarBackground) {
            console.log("Avatar background disabled by showAvatarBackground setting");
            return;
          }

          if (!avatarManager) {
            console.log("Avatar manager not available");
            return;
          }

          // Initialize avatar manager after ensuring video actions are ready
          avatarManager.init();
        }
      }
      const aiToolbox = new AIToolboxManager();
      window.aiToolbox = aiToolbox;

      // URL Parameter Handler
      function parseAndApplyURLParams() {
        const urlParams = new URLSearchParams(window.location.search);

        // 1. Handle config parameter first
        const configParam = urlParams.get("config");
        if (configParam) {
          try {
            const decodedConfig = decodeURIComponent(configParam);
            const customConfig = JSON.parse(decodedConfig);
            console.log("Applying custom config from URL:", customConfig);
            // Apply custom config to game (will be applied in game.start())
            window.customURLConfig = customConfig;
          } catch (error) {
            console.error("Error parsing config parameter:", error);
          }
        } // 2. Handle showToolbar parameter
        const showToolbar = urlParams.get("showToolbar");
        if (showToolbar === "false") {
          const toolbar = document.querySelector(".ai-toolbox");
          const chatArea = document.querySelector(".flex-1.flex.flex-col.bg-white.shadow-lg");
          if (toolbar) {
            toolbar.classList.add("hidden-toolbar");
          }
          if (chatArea) {
            chatArea.classList.add("no-toolbar-chat");
          }
          // Update placeholder text when toolbar is hidden
          const userInput = document.getElementById("user-input");
          if (userInput) {
            userInput.placeholder = "è¾“å…¥æ–‡å­—...";
          }
        } else {
          // Update placeholder text when toolbar is shown
          const userInput = document.getElementById("user-input");
          if (userInput) {
            userInput.placeholder = "è¾“å…¥æ–‡å­—... (ä½ å¯ä»¥é€šè¿‡å³ä¾§çš„å·¥å…·ç®±æœç´¢ç­”æ¡ˆ)";
          }
        }

        // 3. Handle showCharInfo parameter
        const showCharInfo = urlParams.get("showCharInfo");
        if (showCharInfo === "false") {
          const charInfo = document.querySelector(".w-1\\/3.bg-white.shadow-lg.p-6.flex.flex-col");
          const chatArea = document.querySelector(".flex-1.flex.flex-col.bg-white.shadow-lg");
          if (charInfo) {
            charInfo.classList.add("hidden-char-info");
          }
          if (chatArea) {
            // Check if toolbar is also hidden
            const showToolbar = urlParams.get("showToolbar");
            if (showToolbar === "false") {
              chatArea.classList.remove("no-toolbar-chat");
              chatArea.classList.add("full-width-chat");
            } else {
              chatArea.classList.remove("no-toolbar-chat"); // Chat area will take remaining space naturally
            }
          }
        } // 4. Handle showClose parameter
        const showClose = urlParams.get("showClose");
        if (showClose === "true") {
          const closeBtn = document.getElementById("close-btn");
          if (closeBtn) {
            closeBtn.classList.remove("hidden");
          }
        }

        // 5. Handle showAvatar parameter
        const showAvatar = urlParams.get("showAvatar");
        window.showAvatarBackground = showAvatar !== "false";
      }

      // Apply URL parameters immediately
      parseAndApplyURLParams();

      const game = new LLMCharacterGame(); // Avatar Video Management
      class AvatarVideoManager {
        constructor() {
          this.avatarVideoIdle = document.getElementById("avatar-video-idle");
          this.avatarVideoTalk = document.getElementById("avatar-video-talk");
          this.avatarBackground = document.getElementById("avatar-background");
          this.returnChatBtn = document.getElementById("return-chat-btn");
          this.currentVideoType = null;
          this.isIdleVideoLoaded = false;
          this.isTalkVideoLoaded = false;
          this.isEnabled = false;
          this.hideTimeout = null;
          this.transitionTimeout = null;
          this.loadingPromises = new Map();
        }

        // Initialize avatar background video
        init() {
          const chatContainer = document.getElementById("chat-container");

          if (!window.showAvatarBackground) {
            // Remove avatar-enabled class to allow normal backgrounds
            chatContainer.classList.remove("avatar-enabled");
            return;
          }

          // Check if both å¾…æœº and è¯´è¯ video actions are available
          if (!this.checkVideoActionsAvailable()) {
            console.log("Video actions not available for avatar background");
            // Remove avatar-enabled class to allow normal backgrounds
            chatContainer.classList.remove("avatar-enabled");
            return;
          }

          console.log("Initializing avatar background video system");
          this.isEnabled = true;
          // Add avatar-enabled class to make chat container transparent
          chatContainer.classList.add("avatar-enabled");
          this.avatarBackground.classList.remove("hidden");

          // Add click event listener to avatar background
          this.addAvatarClickHandler(chatContainer);

          // Load both videos with proper sequencing
          this.initializeVideos();
        }

        // Initialize both videos with proper loading sequence
        async initializeVideos() {
          try {
            // First load and start idle video
            await this.loadIdleVideo();
            // Then preload talk video in background
            this.preloadTalkVideo().catch((error) => {
              console.warn("Talk video preload failed, will load on demand:", error);
            });
          } catch (error) {
            console.error("Failed to initialize avatar videos:", error);
          }
        }

        // Add click handler for avatar background
        addAvatarClickHandler(chatContainer) {
          console.log("Adding click handler to avatar background");

          this.avatarBackground.addEventListener("click", (e) => {
            console.log("Avatar background clicked - hiding chat content for 10 seconds");

            // Clear any existing timeout
            if (this.hideTimeout) {
              clearTimeout(this.hideTimeout);
            }

            // Add fade-out class to hide chat content
            chatContainer.classList.remove("fade-in");
            chatContainer.classList.add("fade-out");

            // Show return chat button
            this.returnChatBtn.classList.add("show");

            // Set timeout to show chat content again after 10 seconds
            this.hideTimeout = setTimeout(() => {
              console.log("Showing chat content again");
              chatContainer.classList.remove("fade-out");
              chatContainer.classList.add("fade-in");
              this.returnChatBtn.classList.remove("show");
              this.hideTimeout = null;
            }, 10000); // 10 seconds
          });

          // Add click handler for return chat button
          this.returnChatBtn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent avatar background click
            console.log("Return chat button clicked - showing chat content immediately");

            // Clear timeout
            if (this.hideTimeout) {
              clearTimeout(this.hideTimeout);
              this.hideTimeout = null;
            }

            // Show chat content immediately
            chatContainer.classList.remove("fade-out");
            chatContainer.classList.add("fade-in");
            this.returnChatBtn.classList.remove("show");
          });

          console.log("Click handler added to:", this.avatarBackground);
        }

        checkVideoActionsAvailable() {
          const hasVideoActions =
            game.config &&
            game.config.videoActions &&
            game.config.videoActions["å¾…æœº"] &&
            game.config.videoActions["å¾…æœº"].url &&
            game.config.videoActions["å¾…æœº"].url !== "" &&
            game.config.videoActions["è¯´è¯"] &&
            game.config.videoActions["è¯´è¯"].url &&
            game.config.videoActions["è¯´è¯"].url !== "";
          console.log("Video actions available:", hasVideoActions);
          return hasVideoActions;
        }

        async loadIdleVideo() {
          if (!this.isEnabled || this.isIdleVideoLoaded) return;

          const idleAction = game.config.videoActions["å¾…æœº"];
          if (!idleAction || !idleAction.url) return;

          // Check if already loading
          if (this.loadingPromises.has("idle")) {
            return this.loadingPromises.get("idle");
          }

          console.log("Loading idle video:", idleAction.url);

          const loadPromise = new Promise((resolve, reject) => {
            const source = this.avatarVideoIdle.querySelector("source");
            source.src = idleAction.url;

            this.avatarVideoIdle.onloadeddata = () => {
              this.isIdleVideoLoaded = true;
              console.log("Idle video loaded successfully");

              // Auto-play idle video (muted)
              this.avatarVideoIdle.muted = true;
              this.avatarVideoIdle
                .play()
                .then(() => {
                  console.log("Idle video started playing");
                  this.currentVideoType = "å¾…æœº";
                  // Show idle video with fade-in
                  this.avatarVideoIdle.classList.remove("hidden");
                  this.avatarVideoIdle.classList.add("visible");
                  this.loadingPromises.delete("idle");
                  resolve();
                })
                .catch((error) => {
                  console.error("Error playing idle video:", error);
                  this.loadingPromises.delete("idle");
                  reject(error);
                });
            };

            this.avatarVideoIdle.onerror = () => {
              console.error("Error loading idle video");
              this.loadingPromises.delete("idle");
              reject(new Error("Idle video load failed"));
            };

            this.avatarVideoIdle.load();
          });

          this.loadingPromises.set("idle", loadPromise);
          return loadPromise;
        }

        async preloadTalkVideo() {
          if (!this.isEnabled || this.isTalkVideoLoaded) return;

          const talkAction = game.config.videoActions["è¯´è¯"];
          if (!talkAction || !talkAction.url) return;

          // Check if already loading
          if (this.loadingPromises.has("talk")) {
            return this.loadingPromises.get("talk");
          }

          console.log("Preloading talk video:", talkAction.url);

          const loadPromise = new Promise((resolve, reject) => {
            const source = this.avatarVideoTalk.querySelector("source");
            source.src = talkAction.url;

            this.avatarVideoTalk.onloadeddata = () => {
              this.isTalkVideoLoaded = true;
              console.log("Talk video preloaded successfully");
              this.loadingPromises.delete("talk");
              resolve();
            };

            this.avatarVideoTalk.onerror = () => {
              console.error("Error preloading talk video");
              this.loadingPromises.delete("talk");
              reject(new Error("Talk video preload failed"));
            };

            this.avatarVideoTalk.load();
          });

          this.loadingPromises.set("talk", loadPromise);
          return loadPromise;
        }

        // Switch between video types with smooth transition
        switchVideo(type) {
          if (!this.isEnabled) return;

          // If already playing the same video type, skip
          if (this.currentVideoType === type) {
            console.log(`Already playing ${type} video`);
            return;
          }

          console.log(`Switching to ${type} video`);

          if (type === "å¾…æœº") {
            this.switchToIdle();
          } else if (type === "è¯´è¯") {
            this.switchToTalking();
          }
        }

        // Switch to idle state with smooth transition
        switchToIdle() {
          if (!this.isEnabled) {
            console.log("Avatar manager not enabled");
            return;
          }

          console.log("Switching to idle video");

          // Clear any existing transition timeout
          if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
          }

          // If idle video is not loaded, load it first
          if (!this.isIdleVideoLoaded) {
            console.log("Idle video not loaded, loading now...");
            this.loadIdleVideo().catch((error) => {
              console.error("Error loading idle video:", error);
            });
            return;
          }

          // Start playing idle video immediately
          this.avatarVideoIdle.muted = true;
          this.avatarVideoIdle.currentTime = 0; // Reset to beginning

          this.avatarVideoIdle
            .play()
            .then(() => {
              console.log("Idle video started playing");

              // Show idle video with smooth transition
              this.avatarVideoIdle.classList.remove("hidden");
              this.avatarVideoIdle.classList.add("visible");

              // Hide talk video after transition delay to ensure smooth crossfade
              this.transitionTimeout = setTimeout(() => {
                this.avatarVideoTalk.classList.remove("visible");
                this.avatarVideoTalk.classList.add("hidden");
                // Pause talk video after it's hidden
                setTimeout(() => {
                  this.avatarVideoTalk.pause();
                }, 800); // Wait for opacity transition
              }, 100);

              this.currentVideoType = "å¾…æœº";
            })
            .catch((error) => {
              console.error("Error playing idle video:", error);
            });
        }

        // Switch to talking state with smooth transition
        switchToTalking() {
          if (!this.isEnabled) {
            console.log("Avatar manager not enabled");
            return;
          }

          console.log("Switching to talking video");

          // If talk video is not loaded, load it first
          if (!this.isTalkVideoLoaded) {
            console.log("Talk video not loaded, loading now...");
            this.preloadTalkVideo()
              .then(() => {
                this.performTalkTransition();
              })
              .catch((error) => {
                console.error("Error loading talk video, falling back to idle:", error);
                // Fallback to idle if talk video fails to load
                this.switchToIdle();
              });
          } else {
            this.performTalkTransition();
          }
        }

        // Perform the actual transition to talk video
        performTalkTransition() {
          console.log("Performing transition to talk video");

          // Clear any existing transition timeout
          if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
          }

          // Prepare talk video
          this.avatarVideoTalk.muted = false; // Unmute for talking
          this.avatarVideoTalk.currentTime = 0; // Reset to beginning

          // Start playing talk video
          this.avatarVideoTalk
            .play()
            .then(() => {
              console.log("Talk video started playing");

              // Show talk video immediately (it has higher z-index so will appear on top)
              this.avatarVideoTalk.classList.remove("hidden");
              this.avatarVideoTalk.classList.add("visible");

              // The idle video will still be playing underneath, but talk video will be visible on top
              // No need to hide idle video immediately since talk video has higher z-index

              this.currentVideoType = "è¯´è¯";
            })
            .catch((error) => {
              console.error("Error playing talk video:", error);
              // Fallback to idle video if talk video fails
              this.switchToIdle();
            });
        }

        // Cleanup method to clear timeouts and reset state
        cleanup() {
          if (this.hideTimeout) {
            clearTimeout(this.hideTimeout);
            this.hideTimeout = null;
          }

          if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
            this.transitionTimeout = null;
          }

          // Clear loading promises
          this.loadingPromises.clear();

          // Reset video states
          if (this.avatarVideoIdle) {
            this.avatarVideoIdle.pause();
            this.avatarVideoIdle.classList.remove("visible");
            this.avatarVideoIdle.classList.add("hidden");
          }

          if (this.avatarVideoTalk) {
            this.avatarVideoTalk.pause();
            this.avatarVideoTalk.classList.remove("visible");
            this.avatarVideoTalk.classList.add("hidden");
          }

          this.currentVideoType = null;
          this.isIdleVideoLoaded = false;
          this.isTalkVideoLoaded = false;
        }
      }

      // Create avatar video manager instance
      const avatarManager = new AvatarVideoManager(); // Promise-based location response handler with timeout

      // Window message handling for host communication
      window.addEventListener("message", function (e) {
        switch (e.data.type) {
          case "setGameConfig":
            // Update game config on the fly
            if (e.data.data) {
              // not supported
            }
            break;
          case "getGameStats":
            // Send current game statistics
            window.parent.postMessage(
              {
                type: "gameStats",
                data: {
                  score: game.gameState.progress,
                  difficulty: game.difficulty || 1,
                  isCompleted: game.gameState.isObjectiveAchieved,
                  chatHistory: game.gameState.chatHistory.length,
                  characterName: game.config?.character?.name || "è§’è‰²",
                },
              },
              "*"
            );
            break;
        }
      });

      window.parent.postMessage({ type: "gameLoaded" }, "*");

      // Wait for several response with 200ms timeout, then start game
      function checkStartGame(timeoutMs) {
        if (!timeoutMs) {
          const urlParams = new URLSearchParams(window.location.search);

          timeoutMs = urlParams.get("parent") === "miniGameProxy" ? 3000 : 200;
          // Check if URL parameters contain both config and token
          const hasConfig = urlParams.get("config") !== null;
          const hasToken = urlParams.get("token") !== null;
          if (hasConfig && hasToken) {
            timeoutMs = 0;
          }
        }
        let gameStarted = false;
        const waitForMinigameProxyWithTimeout = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            if (!gameStarted) {
              resolve(null);
            }
          }, timeoutMs);
          let locationReceived = false;
          let miniGameProxyReceived = false;
          const messageHandler = function (e) {
            if (e.data.type === "locationResponse") {
              locationReceived = true;
              const searchPath = e.data.search;
              if (searchPath) {
                const params = new URLSearchParams(searchPath);
                const objective = params.get("objective");
                if (objective) {
                  game.urlObjective = objective;
                }
              }
            } else if (e.data.type === "miniGameProxyDataResponse") {
              miniGameProxyReceived = true;
              sdk.token = e.data?.keepworkToken;
            }
            if (locationReceived && miniGameProxyReceived) {
              window.removeEventListener("message", messageHandler);
              clearTimeout(timeout);
              resolve(e.data);
            }
          };
          window.addEventListener("message", messageHandler);
          window.parent.postMessage({ type: "getLocation" }, "*");
          window.parent.postMessage({ type: "getMiniGameProxyData" }, "*");
        });

        waitForMinigameProxyWithTimeout
          .then(() => {
            if (!gameStarted) {
              gameStarted = true;
              game.start();
            }
          })
          .catch((error) => {
            if (!gameStarted) {
              gameStarted = true;
              game.start();
            }
          });
      }
      checkStartGame();
    </script>
  </body>
</html>
