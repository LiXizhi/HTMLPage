<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Connect - è¿çº¿æ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        .game-cell {
            transition: all 0.2s ease;
            z-index: 1;
        }

        .path-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .color-dot {
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .game-grid {
            position: relative;
            background: #f5f5f0;
            border-radius: 8px;
        }

        .inner-area {
            background-color: rgba(255, 255, 255, 0.1) !important;
        }

        .path-segment {
            position: absolute;
            background-color: currentColor;
            border-radius: 2px;
            z-index: 1;
            pointer-events: none;
        }

        /* Toast é€šçŸ¥æ ·å¼ */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            background-color: #10b981;
        }

        .toast.info {
            background-color: #3b82f6;
        }

        .toast.warning {
            background-color: #f59e0b;
        }

        /* Modal dialog z-index fixes */
        #winModal,
        #completeModal {
            z-index: 9999 !important;
        }

        /* Ensure modal backdrop is above all game elements */
        .fixed.inset-0.bg-black.bg-opacity-50 {
            z-index: 9998 !important;
        }
    </style>
</head>

<body class="bg-yellow-50 min-h-screen">
    <div class="container mx-auto p-4 max-w-full">
        <!-- å¤´éƒ¨ä¿¡æ¯ - æ¨ªå±å¸ƒå±€ -->
        <div class="bg-white rounded-lg shadow-lg p-4 mb-4">
            <div class="flex items-center justify-between w-full gap-6">
                <!-- æ¸¸æˆæ ‡é¢˜ -->
                <div class="flex-shrink-0">
                    <h1 class="text-xl font-bold text-gray-800">é¢œè‰²è¿çº¿</h1>
                    <p class="text-sm text-gray-600">ç¬¬ <span id="currentLevel">1</span> å…³ / 10 å…³</p>
                </div>

                <!-- éš¾åº¦é€‰æ‹© -->
                <div class="flex items-center gap-2 flex-1 max-w-xs">
                    <label class="text-sm font-semibold text-gray-700 whitespace-nowrap">éš¾åº¦:</label>
                    <select id="difficultySelect"
                        class="flex-1 bg-white border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="beginner">å…¥é—¨ (5Ã—5, 3è‰²)</option>
                        <option value="easy">ç®€å• (6Ã—6, 4è‰²)</option>
                        <option value="medium">ä¸­ç­‰ (7Ã—7, 5è‰²)</option>
                        <option value="hard">å›°éš¾ (8Ã—8, 6è‰²)</option>
                        <option value="expert">ä¸“å®¶ (9Ã—9, 7è‰²)</option>
                        <option value="master">å¤§å¸ˆ (10Ã—10, 8è‰²)</option>
                    </select>
                </div> <!-- è¿æ¥ç»Ÿè®¡ -->
                <div class="flex items-center gap-4 flex-shrink-0">
                    <p class="text-lg font-bold text-orange-500">è¿æ¥: <span id="connectedPairs">0</span>/<span
                            id="totalPairs">0</span></p>
                    <button id="showAnswerBtn"
                        class="text-sm bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded whitespace-nowrap">æ˜¾ç¤ºç­”æ¡ˆ</button>
                    <button id="resetBtn"
                        class="text-sm bg-gray-200 px-4 py-2 rounded hover:bg-gray-300 whitespace-nowrap">é‡ç½®</button>
                </div>
            </div>
        </div> <!-- æ¸¸æˆç•Œé¢ -->
        <div id="gameArea" class="flex justify-center">
            <div class="game-grid mx-auto" id="gameGrid">
            </div>
        </div>

        <div class="mt-4 text-center">
            <p class="text-sm text-gray-600 mb-2">æ‹–åŠ¨å°†ç›¸åŒé¢œè‰²çš„åœ†ç‚¹è¿æ¥èµ·æ¥ï¼Œçº¿æ¡ä¸èƒ½äº¤å‰</p>
        </div>

        <!-- è¿‡å…³æç¤º -->
        <div id="winModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
            <div class="bg-white rounded-lg p-6 text-center max-w-sm">
                <h2 class="text-2xl font-bold text-green-600 mb-4">ğŸ‰ æ­å–œè¿‡å…³ï¼</h2>
                <p id="winMessage" class="mb-4">ä½ æˆåŠŸå®Œæˆäº†è¿™ä¸€å…³ï¼</p>
                <div class="text-lg font-bold text-blue-600 mb-4">3ç§’åè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³...</div>
                <button id="winNextLevel"
                    class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">ç«‹å³ä¸‹ä¸€å…³</button>
            </div>
        </div>

        <!-- é€šå…³æç¤º -->
        <div id="completeModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
            <div class="bg-white rounded-lg p-6 text-center max-w-sm">
                <h2 class="text-3xl font-bold text-yellow-500 mb-4">ğŸ† å®Œç¾é€šå…³ï¼</h2>
                <p class="mb-4">æ­å–œä½ å®Œæˆäº†å½“å‰éš¾åº¦çš„æ‰€æœ‰10å…³ï¼<br>å¯ä»¥å°è¯•æ›´é«˜éš¾åº¦ç»§ç»­æŒ‘æˆ˜ï¼</p>
                <div class="flex gap-2">
                    <button id="completeRestart"
                        class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg">é‡æ–°å¼€å§‹</button>
                    <button id="completeNextDiff"
                        class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg">æå‡éš¾åº¦</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class FlowConnectGame {
            constructor() {
                this.currentDifficulty = 'beginner';
                this.currentLevel = 1;
                this.maxLevel = 10;
                this.grid = [];
                this.paths = new Map();
                this.isDrawing = false;
                this.isProcessingStop = false; // æ·»åŠ æ ‡å¿—ä½é˜²æ­¢é‡å¤å¤„ç†stopDrawing
                this.currentPath = []; this.currentColor = null; this.startPoint = null;
                this.autoNextTimer = null;                this.cellSize = 0;
                this.toastContainer = null;
                this.currentSolution = new Map(); // å­˜å‚¨å½“å‰å…³å¡çš„ç­”æ¡ˆ
                this.answerShown = false; // æ ‡è®°å½“å‰å…³å¡æ˜¯å¦å·²æ˜¾ç¤ºç­”æ¡ˆ

                this.colors = {
                    'red': '#ef4444',
                    'blue': '#3b82f6',
                    'green': '#22c55e',
                    'purple': '#a855f7',
                    'orange': '#f97316',
                    'yellow': '#eab308',
                    'cyan': '#06b6d4',
                    'magenta': '#ec4899',
                    'lime': '#84cc16',
                    'pink': '#f472b6',
                    'indigo': '#6366f1',
                    'teal': '#14b8a6'
                };

                this.colorKeys = Object.keys(this.colors);

                // éš¾åº¦é…ç½®ï¼šç½‘æ ¼å¤§å°å’Œé¢œè‰²æ•°é‡
                this.difficultyConfig = {
                    'beginner': { size: 5, colors: 3 },
                    'easy': { size: 6, colors: 4 },
                    'medium': { size: 7, colors: 5 },
                    'hard': { size: 8, colors: 6 },
                    'expert': { size: 9, colors: 7 },
                    'master': { size: 10, colors: 8 }
                };

                this.init();
            } init() {
                this.createToastContainer();
                this.setupEventListeners();
                this.generateRandomLevel();
                this.updateUI();
                this.showToast('æ¸¸æˆå¼€å§‹ï¼è¿æ¥ç›¸åŒé¢œè‰²çš„ç‚¹å§ï¼', 'info');
            }

            createToastContainer() {
                this.toastContainer = document.createElement('div');
                this.toastContainer.id = 'toastContainer';
                this.toastContainer.style.position = 'fixed';
                this.toastContainer.style.top = '20px';
                this.toastContainer.style.right = '20px';
                this.toastContainer.style.zIndex = '1000';
                document.body.appendChild(this.toastContainer);
            }

            showToast(message, type = 'info', duration = 3000) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;

                this.toastContainer.appendChild(toast);

                // è§¦å‘æ˜¾ç¤ºåŠ¨ç”»
                setTimeout(() => {
                    toast.classList.add('show');
                }, 100);

                // è‡ªåŠ¨ç§»é™¤
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }

            setupEventListeners() {
                // éš¾åº¦é€‰æ‹©
                document.getElementById('difficultySelect').addEventListener('change', (e) => {
                    this.changeDifficulty(e.target.value);
                });                // æŒ‰é’®äº‹ä»¶
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('showAnswerBtn').addEventListener('click', () => this.showAnswer());
                document.getElementById('winNextLevel').addEventListener('click', () => {
                    this.clearAutoNextTimer();
                    this.hideWinModal();
                    this.nextLevel();
                });
                document.getElementById('completeRestart').addEventListener('click', () => {
                    this.hideCompleteModal();
                    this.restartGame();
                });
                document.getElementById('completeNextDiff').addEventListener('click', () => {
                    this.hideCompleteModal();
                    this.nextDifficulty();
                });
            } changeDifficulty(difficulty) {
                this.currentDifficulty = difficulty;
                this.currentLevel = 1;
                this.generateRandomLevel();
                this.updateUI();
                this.showToast(`åˆ‡æ¢åˆ°${this.getDifficultyName(difficulty)}éš¾åº¦`, 'info');
            }

            getDifficultyName(difficulty) {
                const names = {
                    'beginner': 'å…¥é—¨',
                    'easy': 'ç®€å•',
                    'medium': 'ä¸­ç­‰',
                    'hard': 'å›°éš¾',
                    'expert': 'ä¸“å®¶',
                    'master': 'å¤§å¸ˆ'
                };
                return names[difficulty] || difficulty;
            }

            getCurrentConfig() {
                return this.difficultyConfig[this.currentDifficulty];
            } generateRandomLevel() {
                const config = this.getCurrentConfig();
                const gridSize = config.size;
                const colorCount = config.colors;

                // æ˜¾ç¤ºç”Ÿæˆå…³å¡çš„æç¤º
                this.showToast('ç”Ÿæˆæ–°å…³å¡ä¸­...', 'info', 1000);

                let attempts = 0;
                const maxAttempts = 50;

                // å¤šæ¬¡å°è¯•ç”Ÿæˆæœ‰è§£çš„å…³å¡
                while (attempts < maxAttempts) {
                    attempts++;

                    // åˆ›å»ºç©ºç½‘æ ¼
                    this.grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));

                    if (this.generateSolvableLevel(gridSize, colorCount)) {
                        break;
                    }
                }

                if (attempts >= maxAttempts) {
                    // å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨ç®€å•å¸ƒå±€
                    this.generateFallbackLevel(gridSize, colorCount);
                    this.showToast('ä½¿ç”¨å¤‡ç”¨å…³å¡å¸ƒå±€', 'warning', 2000);
                }                this.paths.clear();
                this.createGameGrid();
                this.setupGridEventListeners();
                this.answerShown = false; // é‡ç½®ç­”æ¡ˆæ˜¾ç¤ºæ ‡è®°
            } generateSolvableLevel(gridSize, colorCount) {
                // ä½¿ç”¨å›æº¯ç®—æ³•ç”Ÿæˆç¡®ä¿æœ‰è§£çš„å…³å¡
                const usedColors = this.colorKeys.slice(0, colorCount);

                // å…ˆç”Ÿæˆä¸€ç»„è§£å†³æ–¹æ¡ˆï¼Œç„¶åæå–ç«¯ç‚¹
                const solution = this.generateSolutionPaths(gridSize, usedColors);
                if (!solution) return false;

                // ä¿å­˜ç­”æ¡ˆ
                this.currentSolution = new Map(solution);

                // æ¸…ç©ºç½‘æ ¼ï¼Œåªä¿ç•™ç«¯ç‚¹
                this.grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));

                for (const [color, path] of solution.entries()) {
                    if (path.length >= 2) {
                        const start = path[0];
                        const end = path[path.length - 1];
                        this.grid[start.row][start.col] = color;
                        this.grid[end.row][end.col] = color;
                    }
                }

                // éªŒè¯æ¯ç§é¢œè‰²éƒ½æœ‰ä¸”ä»…æœ‰2ä¸ªç‚¹
                return this.validateColorPairs(usedColors);
            }

            validateColorPairs(expectedColors) {
                const colorCounts = {};
                const config = this.getCurrentConfig();
                const gridSize = config.size;

                // ç»Ÿè®¡æ¯ç§é¢œè‰²çš„ç‚¹æ•°
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (this.grid[row][col]) {
                            const color = this.grid[row][col];
                            colorCounts[color] = (colorCounts[color] || 0) + 1;
                        }
                    }
                }

                // æ£€æŸ¥æ¯ç§é¢„æœŸé¢œè‰²æ˜¯å¦éƒ½æœ‰ä¸”ä»…æœ‰2ä¸ªç‚¹
                for (const color of expectedColors) {
                    if (colorCounts[color] !== 2) {
                        return false;
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä½™çš„é¢œè‰²
                const actualColors = Object.keys(colorCounts);
                return actualColors.length === expectedColors.length;
            }

            generateSolutionPaths(gridSize, colors) {
                // ä½¿ç”¨å›æº¯ç®—æ³•ç”Ÿæˆä¸ç›¸äº¤çš„è·¯å¾„
                const paths = new Map();
                const occupied = new Set();

                // éšæœºåŒ–é¢œè‰²é¡ºåº
                const shuffledColors = [...colors].sort(() => Math.random() - 0.5);

                if (this.backtrackGeneratePaths(shuffledColors, 0, paths, occupied, gridSize)) {
                    return paths;
                }
                return null;
            } backtrackGeneratePaths(colors, colorIndex, paths, occupied, gridSize) {
                if (colorIndex >= colors.length) {
                    return true; // æ‰€æœ‰é¢œè‰²éƒ½æˆåŠŸç”Ÿæˆäº†è·¯å¾„
                }

                const color = colors[colorIndex];
                const attempts = 30; // å¢åŠ å°è¯•æ¬¡æ•°

                for (let attempt = 0; attempt < attempts; attempt++) {
                    // éšæœºé€‰æ‹©èµ·ç‚¹å’Œç»ˆç‚¹
                    const startPos = this.getRandomFreePosition(gridSize, occupied);
                    const endPos = this.getRandomFreePosition(gridSize, occupied);

                    if (!startPos || !endPos) continue;

                    // ç¡®ä¿èµ·ç‚¹å’Œç»ˆç‚¹æœ‰è¶³å¤Ÿè·ç¦»
                    const distance = Math.abs(startPos.row - endPos.row) + Math.abs(startPos.col - endPos.col);
                    if (distance < 3) continue; // å¢åŠ æœ€å°è·ç¦»è¦æ±‚

                    // æ ‡è®°èµ·ç‚¹å’Œç»ˆç‚¹ä¸ºå ç”¨ï¼Œé¿å…å…¶ä»–è·¯å¾„ç»è¿‡
                    const startKey = `${startPos.row},${startPos.col}`;
                    const endKey = `${endPos.row},${endPos.col}`;

                    if (occupied.has(startKey) || occupied.has(endKey)) continue;

                    // ä¸´æ—¶æ ‡è®°ç«¯ç‚¹ä¸ºå ç”¨
                    occupied.add(startKey);
                    occupied.add(endKey);

                    // å°è¯•æ‰¾åˆ°è¿æ¥è·¯å¾„
                    const path = this.findPath(startPos, endPos, occupied, gridSize);
                    if (path && path.length >= 3) { // ç¡®ä¿è·¯å¾„ä¸ä¼šå¤ªçŸ­
                        // æ ‡è®°è·¯å¾„ä¸ºå ç”¨ï¼ˆåŒ…æ‹¬ç«¯ç‚¹ï¼‰
                        const pathOccupied = new Set();
                        for (let i = 0; i < path.length; i++) {
                            const key = `${path[i].row},${path[i].col}`;
                            if (!occupied.has(key)) {
                                occupied.add(key);
                                pathOccupied.add(key);
                            }
                        }

                        paths.set(color, path);

                        // é€’å½’å°è¯•ä¸‹ä¸€ä¸ªé¢œè‰²
                        if (this.backtrackGeneratePaths(colors, colorIndex + 1, paths, occupied, gridSize)) {
                            return true;
                        }

                        // å›æº¯ï¼šç§»é™¤å½“å‰è·¯å¾„
                        paths.delete(color);
                        for (const key of pathOccupied) {
                            occupied.delete(key);
                        }
                    } else {
                        // å¦‚æœæ‰¾ä¸åˆ°è·¯å¾„ï¼Œç§»é™¤ç«¯ç‚¹æ ‡è®°
                        occupied.delete(startKey);
                        occupied.delete(endKey);
                    }
                }

                return false;
            } getRandomFreePosition(gridSize, occupied) {
                const maxAttempts = 50;
                // Color dots can only be placed in the inner (N-2)x(N-2) area
                const innerSize = gridSize - 2;
                const startRow = 1;
                const startCol = 1;

                for (let i = 0; i < maxAttempts; i++) {
                    const row = startRow + Math.floor(Math.random() * innerSize);
                    const col = startCol + Math.floor(Math.random() * innerSize);
                    const key = `${row},${col}`;

                    if (!occupied.has(key)) {
                        return { row, col };
                    }
                }
                return null;
            } findPath(start, end, occupied, gridSize) {
                // ä½¿ç”¨A*ç®—æ³•å¯»æ‰¾è·¯å¾„
                const openSet = [{ ...start, g: 0, f: this.heuristic(start, end), path: [start] }];
                const closedSet = new Set();

                while (openSet.length > 0) {
                    // æ‰¾åˆ°få€¼æœ€å°çš„èŠ‚ç‚¹
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();

                    if (current.row === end.row && current.col === end.col) {
                        return current.path;
                    }

                    const key = `${current.row},${current.col}`;
                    closedSet.add(key);

                    // æ¢ç´¢é‚»å±…
                    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    for (const [dr, dc] of directions) {
                        const neighbor = {
                            row: current.row + dr,
                            col: current.col + dc
                        };

                        if (neighbor.row < 0 || neighbor.row >= gridSize ||
                            neighbor.col < 0 || neighbor.col >= gridSize) continue;

                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        if (closedSet.has(neighborKey)) continue;

                        // æ£€æŸ¥æ˜¯å¦è¢«å ç”¨ï¼ˆç»ˆç‚¹é™¤å¤–ï¼‰
                        const isEndPoint = neighbor.row === end.row && neighbor.col === end.col;
                        const isStartPoint = neighbor.row === start.row && neighbor.col === start.col;

                        // ä¸èƒ½ç»è¿‡å·²å ç”¨çš„ä½ç½®ï¼ˆé™¤äº†èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
                        if (!isEndPoint && !isStartPoint && occupied.has(neighborKey)) continue;

                        // ä¸èƒ½ç»è¿‡å…¶ä»–é¢œè‰²çš„ç‚¹ï¼ˆé™¤äº†èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
                        if (!isEndPoint && !isStartPoint && this.grid[neighbor.row] && this.grid[neighbor.row][neighbor.col]) {
                            continue;
                        }

                        const g = current.g + 1;
                        const h = this.heuristic(neighbor, end);
                        const f = g + h;

                        // æ£€æŸ¥æ˜¯å¦å·²åœ¨openSetä¸­
                        const existingIndex = openSet.findIndex(node =>
                            node.row === neighbor.row && node.col === neighbor.col);

                        if (existingIndex === -1 || openSet[existingIndex].f > f) {
                            const newNode = {
                                ...neighbor,
                                g: g,
                                f: f,
                                path: [...current.path, neighbor]
                            };

                            if (existingIndex !== -1) {
                                openSet[existingIndex] = newNode;
                            } else {
                                openSet.push(newNode);
                            }
                        }
                    }
                } return null; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
            }

            heuristic(a, b) {
                return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
            } generateFallbackLevel(gridSize, colorCount) {
                // ç”Ÿæˆç®€å•çš„å…³å¡ä½œä¸ºå¤‡ç”¨ï¼Œç¡®ä¿æ¯ç§é¢œè‰²éƒ½æœ‰ä¸”ä»…æœ‰2ä¸ªç‚¹
                this.grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
                const usedColors = this.colorKeys.slice(0, colorCount);

                // å†…éƒ¨åŒºåŸŸï¼š(N-2) x (N-2)
                const innerSize = gridSize - 2;
                const startRow = 1;
                const startCol = 1;

                // ä¸ºæ¯ç§é¢œè‰²ç”Ÿæˆä¸€å¯¹ç‚¹
                for (let i = 0; i < colorCount; i++) {
                    const color = usedColors[i];
                    let attempts = 0;
                    const maxAttempts = 100;

                    while (attempts < maxAttempts) {
                        attempts++;

                        // åœ¨å†…éƒ¨åŒºåŸŸéšæœºé€‰æ‹©ä¸¤ä¸ªä½ç½®
                        const row1 = startRow + Math.floor(Math.random() * innerSize);
                        const col1 = startCol + Math.floor(Math.random() * innerSize);
                        const row2 = startRow + Math.floor(Math.random() * innerSize);
                        const col2 = startCol + Math.floor(Math.random() * innerSize);

                        // ç¡®ä¿ä¸¤ä¸ªä½ç½®ä¸åŒä¸”éƒ½ä¸ºç©º
                        if ((row1 !== row2 || col1 !== col2) &&
                            !this.grid[row1][col1] && !this.grid[row2][col2]) {

                            // ç¡®ä¿ä¸¤ä¸ªç‚¹ä¹‹é—´æœ‰è¶³å¤Ÿè·ç¦»
                            const distance = Math.abs(row1 - row2) + Math.abs(col1 - col2);
                            if (distance >= 2) {
                                this.grid[row1][col1] = color;
                                this.grid[row2][col2] = color;
                                break;
                            }
                        }
                    }                    // å¦‚æœæ— æ³•æ‰¾åˆ°åˆé€‚ä½ç½®ï¼Œä½¿ç”¨ç®€å•å¸ƒå±€ç¡®ä¿æœ‰2ä¸ªç‚¹
                    if (attempts >= maxAttempts) {
                        let placedFirst = false;
                        let placedSecond = false;
                        let firstRow = -1, firstCol = -1;

                        // å°è¯•åœ¨å†…éƒ¨åŒºåŸŸæ‰¾åˆ°ä¸¤ä¸ªç©ºä½ç½®
                        for (let row = startRow; row < startRow + innerSize && !placedSecond; row++) {
                            for (let col = startCol; col < startCol + innerSize && !placedSecond; col++) {
                                if (!this.grid[row][col]) {
                                    if (!placedFirst) {
                                        this.grid[row][col] = color;
                                        firstRow = row;
                                        firstCol = col;
                                        placedFirst = true;
                                    } else {
                                        // ç¡®ä¿ä¸¤ä¸ªç‚¹ä¹‹é—´æœ‰è·ç¦»
                                        const distance = Math.abs(row - firstRow) + Math.abs(col - firstCol);
                                        if (distance >= 1) {
                                            this.grid[row][col] = color;
                                            placedSecond = true;
                                        }
                                    }
                                }
                            }
                        }

                        // å¦‚æœè¿˜æ˜¯æ²¡èƒ½æ”¾ç½®2ä¸ªç‚¹ï¼Œå¼ºåˆ¶æ”¾ç½®
                        if (!placedFirst || !placedSecond) {
                            // ä½¿ç”¨ç®€å•çš„å¯¹è§’çº¿å¸ƒå±€ç¡®ä¿æœ‰2ä¸ªç‚¹
                            const row1 = startRow + (i % innerSize);
                            const col1 = startCol + (i % innerSize);
                            const row2 = startRow + ((i + 1) % innerSize);
                            const col2 = startCol + ((i + 1) % innerSize);

                            if (!placedFirst && !this.grid[row1][col1]) {
                                this.grid[row1][col1] = color;
                                placedFirst = true;
                            }
                            if (!placedSecond && !this.grid[row2][col2] && (row1 !== row2 || col1 !== col2)) {
                                this.grid[row2][col2] = color;
                                placedSecond = true;
                            }

                            // æœ€åçš„å…œåº•æ–¹æ¡ˆ
                            if (!placedFirst || !placedSecond) {
                                for (let r = startRow; r < startRow + innerSize; r++) {
                                    for (let c = startCol; c < startCol + innerSize; c++) {
                                        if (!this.grid[r][c]) {
                                            if (!placedFirst) {
                                                this.grid[r][c] = color;
                                                placedFirst = true;
                                                firstRow = r;
                                                firstCol = c;
                                            } else if (!placedSecond && (r !== firstRow || c !== firstCol)) {
                                                this.grid[r][c] = color;
                                                placedSecond = true;
                                                break;
                                            }
                                        }
                                    } if (placedSecond) break;
                                }
                            }
                        }
                    }
                }

                // æœ€åéªŒè¯æ¯ç§é¢œè‰²éƒ½æœ‰ä¸”ä»…æœ‰2ä¸ªç‚¹
                if (!this.validateColorPairs(usedColors)) {
                    console.warn('Fallback level generation failed validation, attempting manual fix...');
                    this.fixColorPairs(usedColors, gridSize);
                }
            }

            fixColorPairs(expectedColors, gridSize) {
                // æ‰‹åŠ¨ä¿®å¤é¢œè‰²å¯¹ï¼Œç¡®ä¿æ¯ç§é¢œè‰²éƒ½æœ‰ä¸”ä»…æœ‰2ä¸ªç‚¹
                const innerSize = gridSize - 2;
                const startRow = 1;
                const startCol = 1;

                for (const color of expectedColors) {
                    const positions = [];

                    // æ‰¾åˆ°è¯¥é¢œè‰²çš„æ‰€æœ‰ä½ç½®
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            if (this.grid[row][col] === color) {
                                positions.push({ row, col });
                            }
                        }
                    }

                    if (positions.length === 0) {
                        // æ²¡æœ‰è¿™ç§é¢œè‰²ï¼Œæ·»åŠ 2ä¸ªç‚¹
                        for (let attempts = 0; attempts < 50; attempts++) {
                            const row1 = startRow + Math.floor(Math.random() * innerSize);
                            const col1 = startCol + Math.floor(Math.random() * innerSize);
                            const row2 = startRow + Math.floor(Math.random() * innerSize);
                            const col2 = startCol + Math.floor(Math.random() * innerSize);

                            if (!this.grid[row1][col1] && !this.grid[row2][col2] &&
                                (row1 !== row2 || col1 !== col2)) {
                                this.grid[row1][col1] = color;
                                this.grid[row2][col2] = color;
                                break;
                            }
                        }
                    } else if (positions.length === 1) {
                        // åªæœ‰1ä¸ªç‚¹ï¼Œæ·»åŠ ç¬¬2ä¸ªç‚¹
                        for (let attempts = 0; attempts < 50; attempts++) {
                            const row = startRow + Math.floor(Math.random() * innerSize);
                            const col = startCol + Math.floor(Math.random() * innerSize);

                            if (!this.grid[row][col] &&
                                (row !== positions[0].row || col !== positions[0].col)) {
                                this.grid[row][col] = color;
                                break;
                            }
                        }
                    } else if (positions.length > 2) {
                        // è¶…è¿‡2ä¸ªç‚¹ï¼Œç§»é™¤å¤šä½™çš„ç‚¹ï¼Œåªä¿ç•™å‰2ä¸ª
                        for (let i = 2; i < positions.length; i++) {
                            this.grid[positions[i].row][positions[i].col] = '';
                        }
                    }
                }
            }

            generateColorPair(gridSize) {
                const attempts = 100;
                for (let i = 0; i < attempts; i++) {
                    const pos1 = this.getRandomEmptyPosition(gridSize);
                    const pos2 = this.getRandomEmptyPosition(gridSize);

                    if (pos1 && pos2 && !this.positionsEqual(pos1, pos2)) {
                        // ç¡®ä¿ä¸¤ä¸ªç‚¹ä¹‹é—´æœ‰è¶³å¤Ÿçš„è·ç¦»ï¼Œé¿å…è¿‡äºç®€å•
                        const distance = Math.abs(pos1[0] - pos2[0]) + Math.abs(pos1[1] - pos2[1]);
                        if (distance >= 2) {
                            return [pos1, pos2];
                        }
                    }
                }
                return null;
            } getRandomEmptyPosition(gridSize) {
                const attempts = 50;
                // Color dots can only be placed in the inner (N-2)x(N-2) area
                const innerSize = gridSize - 2;
                const startRow = 1;
                const startCol = 1;

                for (let i = 0; i < attempts; i++) {
                    const row = startRow + Math.floor(Math.random() * innerSize);
                    const col = startCol + Math.floor(Math.random() * innerSize);

                    if (!this.grid[row][col]) {
                        return [row, col];
                    }
                }
                return null;
            }

            positionsEqual(pos1, pos2) {
                return pos1[0] === pos2[0] && pos1[1] === pos2[1];
            }

            isLevelSolvable(colorPairs, gridSize) {
                // ç®€å•çš„è¿é€šæ€§æ£€æŸ¥ - ç¡®ä¿æ¯å¯¹é¢œè‰²ç‚¹ä¹‹é—´å­˜åœ¨è·¯å¾„
                for (const pair of colorPairs) {
                    const [pos1, pos2] = pair.positions;
                    if (!this.hasPath(pos1, pos2, gridSize)) {
                        return false;
                    }
                }
                return true;
            }

            hasPath(start, end, gridSize) {
                // ä½¿ç”¨BFSæ£€æŸ¥ä¸¤ç‚¹é—´æ˜¯å¦å­˜åœ¨è·¯å¾„
                const queue = [start];
                const visited = new Set();
                visited.add(`${start[0]},${start[1]}`);

                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

                while (queue.length > 0) {
                    const [row, col] = queue.shift();

                    if (row === end[0] && col === end[1]) {
                        return true;
                    }

                    for (const [dr, dc] of directions) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        const key = `${newRow},${newCol}`;

                        if (newRow >= 0 && newRow < gridSize &&
                            newCol >= 0 && newCol < gridSize &&
                            !visited.has(key)) {

                            // å¯ä»¥ç»è¿‡ç©ºæ ¼å­æˆ–ç›®æ ‡é¢œè‰²ç‚¹
                            if (!this.grid[newRow][newCol] ||
                                (newRow === end[0] && newCol === end[1])) {
                                visited.add(key);
                                queue.push([newRow, newCol]);
                            }
                        }
                    }
                }
                return false;
            } createGameGrid() {
                const gameGrid = document.getElementById('gameGrid');
                gameGrid.innerHTML = '';

                const config = this.getCurrentConfig();
                const gridSize = config.size;

                // æ ¹æ®ç½‘æ ¼å¤§å°è‡ªé€‚åº”å•å…ƒæ ¼å¤§å° - æ¨ªå±ä¼˜åŒ–
                const maxGridWidth = Math.min(500, window.innerWidth * 0.6); // é€‚åº”æ¨ªå±
                this.cellSize = Math.floor(maxGridWidth / gridSize);

                gameGrid.style.width = `${this.cellSize * gridSize}px`;
                gameGrid.style.height = `${this.cellSize * gridSize}px`;
                gameGrid.style.display = 'grid';
                gameGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                gameGrid.style.gap = '1px';

                // è®¡ç®—å†…éƒ¨åŒºåŸŸï¼š(N-2) x (N-2)
                const innerSize = gridSize - 2;
                const startRow = 1;
                const startCol = 1;

                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const cell = document.createElement('div');
                        let cellClass = 'game-cell relative bg-gray-100 border border-gray-200 cursor-pointer';

                        // æ ‡è®°å†…éƒ¨åŒºåŸŸ
                        if (row >= startRow && row < startRow + innerSize &&
                            col >= startCol && col < startCol + innerSize) {
                            cellClass += ' inner-area';
                        }

                        cell.className = cellClass;
                        cell.style.width = `${this.cellSize}px`;
                        cell.style.height = `${this.cellSize}px`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        if (this.grid[row][col]) {
                            const dot = document.createElement('div');
                            const dotSize = this.cellSize * 0.6;
                            dot.className = 'color-dot absolute inset-0 m-auto';
                            dot.style.width = `${dotSize}px`;
                            dot.style.height = `${dotSize}px`;
                            dot.style.backgroundColor = this.colors[this.grid[row][col]];
                            cell.appendChild(dot);
                        }

                        gameGrid.appendChild(cell);
                    }
                }
            }
            setupGridEventListeners() {
                const cells = document.querySelectorAll('.game-cell');
                const gameGrid = document.getElementById('gameGrid');

                cells.forEach(cell => {
                    cell.addEventListener('mousedown', (e) => this.startDrawing(e));
                    cell.addEventListener('mouseenter', (e) => this.continueDrawing(e));
                    cell.addEventListener('mouseup', (e) => this.stopDrawing(e));

                    // ç§»åŠ¨ç«¯æ”¯æŒ
                    cell.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.startDrawing(e);
                    });
                    cell.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.closest('.game-cell')) {
                            this.continueDrawing({ target: element.closest('.game-cell') });
                        } else {
                            // å¦‚æœè§¦æ‘¸ç§»åŠ¨åˆ°ç½‘æ ¼å¤–ï¼Œåœæ­¢ç»˜åˆ¶
                            this.stopDrawing(null);
                        }
                    });
                    cell.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.stopDrawing(e);
                    });
                });
                document.addEventListener('mousemove', (e) => {
                    if (this.isDrawing) {
                        const gameGridRect = gameGrid.getBoundingClientRect();
                        const mouseX = e.clientX;
                        const mouseY = e.clientY;

                        // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨æ¸¸æˆç½‘æ ¼å¤–
                        if (mouseX < gameGridRect.left || mouseX > gameGridRect.right ||
                            mouseY < gameGridRect.top || mouseY > gameGridRect.bottom) {
                            console.log('Mouse moved outside game grid, stopping drawing');
                            this.stopDrawing(null);
                        }
                    }
                });                // å…¨å±€mouseupäº‹ä»¶åªåœ¨æ¸¸æˆç½‘æ ¼å¤–æ—¶åœæ­¢ç»˜åˆ¶
                document.addEventListener('mouseup', (e) => {
                    if (this.isDrawing) {
                        const gameGridRect = gameGrid.getBoundingClientRect();
                        const mouseX = e.clientX;
                        const mouseY = e.clientY;

                        // åªæœ‰åœ¨æ¸¸æˆç½‘æ ¼å¤–æ¾æ‰‹æ—¶æ‰åœæ­¢ç»˜åˆ¶
                        if (mouseX < gameGridRect.left || mouseX > gameGridRect.right ||
                            mouseY < gameGridRect.top || mouseY > gameGridRect.bottom) {
                            console.log('Mouse up outside game grid, stopping drawing');
                            this.stopDrawing(null);
                        }
                    }
                });

                document.addEventListener('touchend', (e) => {
                    if (this.isDrawing && e.touches.length === 0) {
                        // è§¦æ‘¸ç»“æŸæ—¶æ£€æŸ¥æ˜¯å¦åœ¨æ¸¸æˆç½‘æ ¼å†…
                        const touch = e.changedTouches[0];
                        const gameGridRect = gameGrid.getBoundingClientRect();
                        const touchX = touch.clientX;
                        const touchY = touch.clientY;

                        if (touchX < gameGridRect.left || touchX > gameGridRect.right ||
                            touchY < gameGridRect.top || touchY > gameGridRect.bottom) {
                            console.log('Touch end outside game grid, stopping drawing');
                            this.stopDrawing(null);
                        }
                    }
                });
            } startDrawing(e) {
                e.preventDefault();
                const cell = e.target.closest('.game-cell');
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                if (this.grid[row][col]) {
                    // å¦‚æœæ­£åœ¨å¤„ç†åœæ­¢æ“ä½œï¼Œå…ˆé‡ç½®çŠ¶æ€
                    if (this.isProcessingStop) {
                        this.isProcessingStop = false;
                        this.isDrawing = false;
                        this.currentPath = [];
                        this.currentColor = null;
                        this.startPoint = null;
                    } const clickedColor = this.grid[row][col];

                    // ç«‹å³æ¸…é™¤è¯¥é¢œè‰²çš„å®Œæ•´è·¯å¾„ï¼ˆåŒ…æ‹¬æ•°æ®å’Œè§†è§‰æ•ˆæœï¼‰
                    this.clearPath(clickedColor);

                    // è®¾ç½®ç»˜åˆ¶çŠ¶æ€
                    this.isDrawing = true;
                    console.log(`Starting drawing at cell (${row}, ${col}) with color ${clickedColor}`);
                    this.currentColor = clickedColor;
                    this.startPoint = { row, col };
                    this.currentPath = [{ row, col }];
                }
            }


            continueDrawing(e) {
                e.preventDefault();
                if (!this.isDrawing) return;

                const cell = e.target.closest('.game-cell');
                if (!cell) {
                    // å¦‚æœé¼ æ ‡ç§»åŠ¨åˆ°éæ¸¸æˆå•å…ƒæ ¼åŒºåŸŸï¼Œåœæ­¢ç»˜åˆ¶å¹¶å®Œå…¨é‡ç½®çŠ¶æ€
                    this.stopDrawing(null);
                    return;
                }

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                if (this.canAddToPath(row, col)) {
                    this.currentPath.push({ row, col });
                    this.drawPath();
                }
            }

            stopDrawing(e) {
                e && e.preventDefault();
                if (!this.isDrawing || this.isProcessingStop) return;

                this.isProcessingStop = true; // è®¾ç½®æ ‡å¿—ä½é˜²æ­¢é‡å¤å¤„ç†
                this.isDrawing = false;

                // æ£€æŸ¥å½“å‰è·¯å¾„æ˜¯å¦æ„æˆæœ‰æ•ˆè¿æ¥
                const isValidEnd = this.isValidPath();

                if (isValidEnd) {
                    // ä¿å­˜æœ‰æ•ˆè·¯å¾„
                    this.paths.set(this.currentColor, [...this.currentPath]);
                    this.showToast(`${this.currentColor} è¿æ¥æˆåŠŸï¼`, 'success', 1500);
                } else {
                    // åªæœ‰åœ¨è·¯å¾„æ— æ•ˆæ—¶æ‰æ¸…é™¤è§†è§‰æ•ˆæœ
                    if (this.currentColor) {
                        this.clearPathVisual(this.currentColor);
                        console.log('Path cleared - invalid connection');
                    }
                }

                // å¼ºåˆ¶é‡ç½®æ‰€æœ‰æ‹–åŠ¨çŠ¶æ€ï¼Œç¡®ä¿ä¸‹æ¬¡å¯ä»¥é‡æ–°å¼€å§‹æ‹–åŠ¨
                this.currentPath = [];
                this.currentColor = null;
                this.startPoint = null;

                this.checkWinCondition();
                this.updateUI();

                // å¼‚æ­¥é‡ç½®æ ‡å¿—ä½ï¼Œç¡®ä¿ä¸‹æ¬¡å¯ä»¥æ­£å¸¸å¼€å§‹ç»˜åˆ¶
                setTimeout(() => {
                    this.isProcessingStop = false;
                }, 50);
            } canAddToPath(row, col) {
                const config = this.getCurrentConfig();
                const gridSize = config.size;

                if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) return false;

                const lastPos = this.currentPath[this.currentPath.length - 1];
                const distance = Math.abs(row - lastPos.row) + Math.abs(col - lastPos.col);

                if (distance !== 1) return false;

                // å…è®¸å›é€€
                if (this.currentPath.length > 1 &&
                    this.currentPath[this.currentPath.length - 2].row === row &&
                    this.currentPath[this.currentPath.length - 2].col === col) {
                    this.currentPath.pop();
                    this.drawPath();
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–è·¯å¾„ç›¸äº¤
                if (this.isPathCrossing(row, col)) {
                    return false;
                }

                const cellColor = this.grid[row][col];
                if (cellColor && cellColor !== this.currentColor) return false;

                return true;
            }

            isPathCrossing(row, col) {
                // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦è¢«å…¶ä»–é¢œè‰²çš„è·¯å¾„å ç”¨
                for (const [color, path] of this.paths) {
                    if (color === this.currentColor) continue;

                    // æ£€æŸ¥è·¯å¾„ä¸­é—´éƒ¨åˆ†ï¼ˆä¸åŒ…æ‹¬ç«¯ç‚¹ï¼‰
                    for (let i = 1; i < path.length - 1; i++) {
                        if (path[i].row === row && path[i].col === col) {
                            return true;
                        }
                    }
                }
                return false;
            } isValidPath() {
                if (this.currentPath.length < 2) {
                    console.log('Path invalid: too short', this.currentPath.length);
                    return false;
                }

                const startPos = this.currentPath[0];
                const endPos = this.currentPath[this.currentPath.length - 1];
                const startColor = this.grid[startPos.row][startPos.col];
                const endColor = this.grid[endPos.row][endPos.col];

                console.log('Path validation:', {
                    pathLength: this.currentPath.length,
                    currentColor: this.currentColor,
                    startColor,
                    endColor,
                    startPos,
                    endPos
                });

                // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹éƒ½æ˜¯åŒä¸€é¢œè‰²ä¸”ä¸ºå½“å‰é¢œè‰²
                const isValid = startColor === this.currentColor && endColor === this.currentColor;
                console.log('Path valid:', isValid);

                return isValid;
            }

            drawPath() {
                this.clearPathVisual(this.currentColor);

                // ç»˜åˆ¶æ¯ä¸ªè·¯å¾„æ®µ
                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const from = this.currentPath[i];
                    const to = this.currentPath[i + 1];
                    this.drawLineSegment(from, to, this.currentColor);
                }
            }

            drawLineSegment(from, to, color) {
                const gameGrid = document.getElementById('gameGrid');

                // è®¡ç®—ä¸­å¿ƒç‚¹åæ ‡
                const fromCenterX = from.col * this.cellSize + this.cellSize / 2;
                const fromCenterY = from.row * this.cellSize + this.cellSize / 2;
                const toCenterX = to.col * this.cellSize + this.cellSize / 2;
                const toCenterY = to.row * this.cellSize + this.cellSize / 2;

                const line = document.createElement('div');
                line.className = `path-segment path-${color}`;
                line.style.backgroundColor = this.colors[color];
                line.style.position = 'absolute';

                const lineWidth = Math.max(3, Math.floor(this.cellSize * 0.12));

                if (from.row === to.row) {
                    // æ°´å¹³çº¿æ®µ
                    const width = Math.abs(toCenterX - fromCenterX);
                    const left = Math.min(fromCenterX, toCenterX);

                    line.style.width = `${width}px`;
                    line.style.height = `${lineWidth}px`;
                    line.style.left = `${left}px`;
                    line.style.top = `${fromCenterY - lineWidth / 2}px`;
                } else {
                    // å‚ç›´çº¿æ®µ
                    const height = Math.abs(toCenterY - fromCenterY);
                    const top = Math.min(fromCenterY, toCenterY);

                    line.style.width = `${lineWidth}px`;
                    line.style.height = `${height}px`;
                    line.style.left = `${fromCenterX - lineWidth / 2}px`;
                    line.style.top = `${top}px`;
                }

                gameGrid.appendChild(line);
            } clearPath(color) {
                this.paths.delete(color);
                this.clearPathVisual(color);
                this.updateUI(); // ç«‹å³æ›´æ–°UIæ˜¾ç¤ºè¿æ¥çŠ¶æ€
            }

            clearPathVisual(color) {
                document.querySelectorAll(`.path-${color}`).forEach(line => line.remove());
            }            resetGame() {
                this.paths.clear();
                document.querySelectorAll('.path-segment').forEach(line => line.remove());
                this.answerShown = false; // é‡ç½®ç­”æ¡ˆæ˜¾ç¤ºæ ‡è®°
                this.updateUI();
                this.showToast('æ¸¸æˆå·²é‡ç½®', 'info');
            }

            restartGame() {
                this.currentLevel = 1;
                this.generateRandomLevel();
                this.updateUI();
                this.showToast('é‡æ–°å¼€å§‹æ¸¸æˆ', 'info');
            }            nextLevel() {
                if (this.answerShown) {
                    // å¦‚æœå·²ç»æ˜¾ç¤ºäº†ç­”æ¡ˆï¼Œé‡æ–°ç”Ÿæˆå½“å‰å…³å¡è€Œä¸æ˜¯è¿›å…¥ä¸‹ä¸€å…³
                    this.generateRandomLevel();
                    this.updateUI();
                    this.showToast(`ç¬¬${this.currentLevel}å…³é‡æ–°ç”Ÿæˆ`, 'info');
                } else if (this.currentLevel < this.maxLevel) {
                    this.currentLevel++;
                    this.generateRandomLevel();
                    this.updateUI();
                    this.showToast(`è¿›å…¥ç¬¬${this.currentLevel}å…³`, 'info');
                } else {
                    this.showCompleteModal();
                }
            }

            nextDifficulty() {
                const difficulties = ['beginner', 'easy', 'medium', 'hard', 'expert', 'master'];
                const currentIndex = difficulties.indexOf(this.currentDifficulty);
                if (currentIndex < difficulties.length - 1) {
                    const nextDiff = difficulties[currentIndex + 1];
                    document.getElementById('difficultySelect').value = nextDiff;
                    this.changeDifficulty(nextDiff);
                    this.showToast(`ğŸŠ æå‡åˆ°${this.getDifficultyName(nextDiff)}éš¾åº¦ï¼`, 'success');
                } else {
                    // å·²ç»æ˜¯æœ€é«˜éš¾åº¦ï¼Œé‡æ–°å¼€å§‹
                    this.restartGame();
                    this.showToast('ğŸ† å·²ç»æ˜¯æœ€é«˜éš¾åº¦ï¼é‡æ–°å¼€å§‹æŒ‘æˆ˜', 'warning');
                }
            } checkWinCondition() {
                const colors = new Set();
                const config = this.getCurrentConfig();
                const gridSize = config.size;

                // æ”¶é›†æ‰€æœ‰é¢œè‰²
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (this.grid[row][col]) {
                            colors.add(this.grid[row][col]);
                        }
                    }
                }

                const uniqueColors = [...colors];
                const totalPairs = uniqueColors.length;
                const connectedPairs = uniqueColors.filter(color => this.paths.has(color)).length;

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰é¢œè‰²éƒ½å·²è¿æ¥ï¼Œä¸”è·¯å¾„æœ‰æ•ˆ
                if (connectedPairs === totalPairs && this.validateAllPaths()) {
                    // å»¶è¿Ÿä¸€ç‚¹æ˜¾ç¤ºé€šå…³æç¤ºï¼Œè®©ç©å®¶çœ‹åˆ°å®Œæˆçš„è·¯å¾„
                    setTimeout(() => {
                        this.showToast(`ğŸ‰ ç¬¬${this.currentLevel}å…³é€šè¿‡ï¼`, 'success', 2000);
                        setTimeout(() => {
                            this.showWinModal();
                        }, 500);
                    }, 200);
                }
            }

            validateAllPaths() {
                // æ£€æŸ¥æ‰€æœ‰è·¯å¾„æ˜¯å¦æœ‰æ•ˆä¸”ä¸ç›¸äº¤
                const occupiedCells = new Set();

                for (const [color, path] of this.paths) {
                    // æ£€æŸ¥è·¯å¾„çš„æœ‰æ•ˆæ€§
                    if (!this.isValidCompletePath(path, color)) {
                        return false;
                    }

                    // æ£€æŸ¥è·¯å¾„ä¸­é—´éƒ¨åˆ†æ˜¯å¦ä¸å…¶ä»–è·¯å¾„ç›¸äº¤
                    for (let i = 1; i < path.length - 1; i++) {
                        const cellKey = `${path[i].row},${path[i].col}`;
                        if (occupiedCells.has(cellKey)) {
                            return false; // è·¯å¾„ç›¸äº¤
                        }
                        occupiedCells.add(cellKey);
                    }
                }

                return true;
            }

            isValidCompletePath(path, color) {
                if (path.length < 2) return false;

                // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦éƒ½æ˜¯ç›®æ ‡é¢œè‰²
                const startPos = path[0];
                const endPos = path[path.length - 1];

                const startColor = this.grid[startPos.row][startPos.col];
                const endColor = this.grid[endPos.row][endPos.col];

                return startColor === color && endColor === color;
            }            showWinModal() {
                let message;
                if (this.answerShown) {
                    // å¦‚æœå·²æ˜¾ç¤ºç­”æ¡ˆï¼Œæç¤ºå°†é‡æ–°ç”Ÿæˆå…³å¡
                    message = `ç¬¬ ${this.currentLevel} å…³å®Œæˆï¼ç”±äºä½¿ç”¨äº†ç­”æ¡ˆï¼Œå°†é‡æ–°ç”Ÿæˆæœ¬å…³ï¼`;
                } else {
                    // æ­£å¸¸è¿›å…¥ä¸‹ä¸€å…³çš„æç¤º
                    const remaining = this.maxLevel - this.currentLevel;
                    message = remaining > 0 ?
                        `ç¬¬ ${this.currentLevel} å…³å®Œæˆï¼è¿˜æœ‰ ${remaining} å…³ç­‰ä½ æŒ‘æˆ˜ï¼` :
                        `ç¬¬ ${this.currentLevel} å…³å®Œæˆï¼å‡†å¤‡è¿›å…¥æ›´é«˜éš¾åº¦ï¼`;
                }

                document.getElementById('winMessage').textContent = message;
                document.getElementById('winModal').classList.remove('hidden');

                // 3ç§’åè‡ªåŠ¨ä¸‹ä¸€å…³
                this.autoNextTimer = setTimeout(() => {
                    this.hideWinModal();
                    this.nextLevel();
                }, 3000);
            }

            showCompleteModal() {
                const difficultyName = this.getDifficultyName(this.currentDifficulty);
                this.showToast(`ğŸ† ${difficultyName}éš¾åº¦å…¨éƒ¨é€šå…³ï¼`, 'success', 4000);
                document.getElementById('completeModal').classList.remove('hidden');
            } hideWinModal() {
                document.getElementById('winModal').classList.add('hidden');
                this.clearAutoNextTimer();
            }

            clearAutoNextTimer() {
                if (this.autoNextTimer) {
                    clearTimeout(this.autoNextTimer);
                    this.autoNextTimer = null;
                }
            }

            hideCompleteModal() {
                document.getElementById('completeModal').classList.add('hidden');
            }            showAnswer() {
                // æ¸…é™¤æ‰€æœ‰ç°æœ‰è·¯å¾„
                this.paths.clear();
                document.querySelectorAll('.path-segment').forEach(line => line.remove());

                // æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆ
                if (this.currentSolution && this.currentSolution.size > 0) {
                    for (const [color, solutionPath] of this.currentSolution) {
                        // å°†è§£ç­”è·¯å¾„è®¾ç½®ä¸ºå½“å‰è·¯å¾„
                        this.paths.set(color, [...solutionPath]);

                        // ç»˜åˆ¶è§£ç­”è·¯å¾„
                        this.drawSolutionPath(solutionPath, color);
                    }

                    // æ›´æ–°UIæ˜¾ç¤º
                    this.updateUI();
                    this.answerShown = true; // æ ‡è®°å·²æ˜¾ç¤ºç­”æ¡ˆ
                    this.showToast('ğŸ” ç­”æ¡ˆå·²æ˜¾ç¤º', 'info', 2000);
                } else {
                    this.showToast('âŒ å½“å‰å…³å¡æ²¡æœ‰ç­”æ¡ˆæ•°æ®', 'warning', 2000);
                }
            }

            drawSolutionPath(path, color) {
                // ç»˜åˆ¶è§£ç­”è·¯å¾„çš„æ¯ä¸ªçº¿æ®µ
                for (let i = 0; i < path.length - 1; i++) {
                    const from = path[i];
                    const to = path[i + 1];
                    this.drawLineSegment(from, to, color);
                }
            }

            updateUI() {
                document.getElementById('currentLevel').textContent = this.currentLevel;

                const colors = new Set();
                const config = this.getCurrentConfig();
                const gridSize = config.size;

                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (this.grid[row][col]) {
                            colors.add(this.grid[row][col]);
                        }
                    }
                }

                const totalPairs = [...colors].length;
                const connectedPairs = [...colors].filter(color => this.paths.has(color)).length;

                document.getElementById('totalPairs').textContent = totalPairs;
                document.getElementById('connectedPairs').textContent = connectedPairs;
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        new FlowConnectGame();
    </script>
</body>

</html>