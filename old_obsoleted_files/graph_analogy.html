<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾å½¢æ‰¾èŒ¬</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        /* æ¸…é™¤æµè§ˆå™¨é»˜è®¤æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* é€šç”¨å­—ä½“æ ·å¼ */
        html {
            /* è®¾ç½®æ ¹å…ƒç´ å­—ä½“å¤§å°ï¼Œä¾¿äº rem å•ä½æ¢ç®—ï¼š1rem = 10px */
            font-size: 10px;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #83A4FF;
            
            /* å­—ä½“æ—è®¾ç½® - æŒ‰ä¼˜å…ˆçº§æ’åˆ— */
            font-family: 
                /* iOS ä¸­æ–‡ */
                "PingFang SC", "PingFang TC",
                /* iOS è‹±æ–‡ */
                "-apple-system", "BlinkMacSystemFont", "SF Pro Text", "SF Pro Display",
                /* Android ä¸­æ–‡ */
                "Noto Sans SC", "Noto Sans CJK SC",
                /* Android è‹±æ–‡ */
                "Roboto",
                /* é€šç”¨åå¤‡å­—ä½“ */
                "Helvetica Neue", "Arial", "Microsoft YaHei", "å¾®è½¯é›…é»‘",
                sans-serif;
            
            /* åŸºç¡€å­—å·å’Œè¡Œé«˜ */
            font-size: 1.4rem;
            line-height: 2.2rem; /* å­—å· + 8px */
            
            /* ä¼˜åŒ–å­—ä½“æ¸²æŸ“ */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* æ•°å­—ä½¿ç”¨ DIN å­—ä½“ */
        .number,
        input[type="number"],
        .price,
        .count {
            font-family: 
                "DIN Alternate", "DIN", "DIN-Medium", "DIN-Bold",
                "SF Pro Display", "Roboto",
                monospace;
            font-variant-numeric: tabular-nums; /* ç­‰å®½æ•°å­— */
        }

        /* ==================== å­—å·è§„èŒƒ ==================== */
        /* é’ˆå¯¹ä¸åŒå­—å·ä¿æŒè¡Œé«˜è§„åˆ™ï¼ˆå­—å· + 8pxï¼‰ */
        .text-10 { font-size: 1rem; line-height: 1.8rem; }
        .text-12 { font-size: 1.2rem; line-height: 2rem; }
        .text-14 { font-size: 1.4rem; line-height: 2.2rem; }
        .text-16 { font-size: 1.6rem; line-height: 2.4rem; }
        .text-18 { font-size: 1.8rem; line-height: 2.6rem; }
        .text-20 { font-size: 2rem; line-height: 2.8rem; }
        .text-22 { font-size: 2.2rem; line-height: 3rem; }
        .text-24 { font-size: 2.4rem; line-height: 3.2rem; }

        /* ==================== é¢œè‰²è§„èŒƒ ==================== */
        /* æ ‡é¢˜ æ­£æ–‡ - é»‘è‰² */
        .text-title,
        .text-primary {
            color: #000000;
        }

        /* æ­£æ–‡ åˆ—è¡¨ - æ·±ç°è‰² */
        .text-secondary,
        .text-list {
            color: #333333;
        }

        /* è¯´æ˜ å¤‡æ³¨ - ä¸­ç°è‰² */
        .text-note,
        .text-remark,
        .text-description {
            color: #999999;
        }

        /* åˆ†å‰²çº¿ - æµ…ç°è‰² */
        .text-divider,
        .text-disabled {
            color: #D6DEE4;
        }

        /* èƒŒæ™¯è‰²ç‰ˆæœ¬ */
        .bg-primary { background-color: #000000; }
        .bg-secondary { background-color: #333333; }
        .bg-note { background-color: #999999; }
        .bg-divider { background-color: #D6DEE4; }

        /* è¾¹æ¡†è‰²ç‰ˆæœ¬ */
        .border-primary { border-color: #000000; }
        .border-secondary { border-color: #333333; }
        .border-note { border-color: #999999; }
        .border-divider { border-color: #D6DEE4; }

        /* å¯é€‰ï¼šé’ˆå¯¹ç‰¹å®šå¹³å°çš„å­—ä½“ä¼˜åŒ– */
        @supports (-webkit-touch-callout: none) {
            /* iOS ç‰¹å®šæ ·å¼ */
            body {
                font-family: 
                    "PingFang SC", "PingFang TC",
                    "-apple-system", "BlinkMacSystemFont",
                    sans-serif;
            }
        }

        .game-container {
            position: relative;
            width: 65.2rem;
            height: 37.5rem;
            padding: 1.2rem;
        }

        .game-panel {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 65.62.8rem;
            height: 35.1rem;
            padding: 1.3rem 1.6rem 2.2rem;
            background-color: #D5E9FF;
            border-radius: 1.2rem;
        }
        
        .game-panel-header {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .game-panel-header .info-item {
            display: flex;
            align-items: center;
            font-weight: 600;
        }

        .game-panel-header .info-item .vertical-bar {
            width: 0.4rem;
            height: 1.4rem;
            margin-right: 0.4rem;
            border-radius: 0.4rem;
        }

        .game-panel-body {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 59.6rem;
            height: 24.1rem;
            padding: 1.9rem 1.2rem 0;
            background-color: #fff;
            border-radius: 1.2rem;
        }

        .game-panel-title {
            font-weight: 600;
            font-size: 1.6rem;
            margin-bottom: 3.2rem;
        }

        .game-panel-body #optionsContainer {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
        }

        .game-panel .interactive-button {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 12rem;
            height: 3rem;
            background-color: #4E9DFC;
            border-radius: 0.8rem;
            box-shadow: 0 0.4rem 0 0 #1E77E6;
            font-weight: 500;
            color: #FFF;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-panel .interactive-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .game-panel .button-group {
            display: flex;
            justify-content: center;
            gap: 3rem;
        }

        .game-panel .button-group .tip:active {
            transform: translateY(0.2rem);
            box-shadow: 0 0.2rem 0 0 #1E77E6;
        }

        .game-panel .button-group .submit {
            background-color: #8EC625;
            box-shadow: 0 0.4rem 0 0 #17A34A;
        }

        .game-panel .button-group .submit:active {
            transform: translateY(0.2rem);
            box-shadow: 0 0.2rem 0 0 #17A34A;
        }

        .game-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 4.6rem;
            height: 4.6rem;
            border: 0.1rem solid #83A4FF;
            border-radius: 0.4rem;
        }

        .option-group.selected .game-cell {
            border: 0.2rem solid #83A4FF;
        }

        .shapes-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 0.2rem;
            width: 100%;
            height: 100%;
        }
        .shape {
            width: 1.4rem;
            height: 1.4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* é˜²æ­¢å½¢çŠ¶è¢«å‹ç¼© */
        }
       
        .shape.single {
            width: 3rem;
            height: 3rem;
        }
        
        .triangle {
            width: 0;
            height: 0;
            border-left: 0.6rem solid transparent;
            border-right: 0.6rem solid transparent;
            border-bottom: 1rem solid #333; /* é»˜è®¤é¢œè‰²ï¼Œä¼šè¢«JavaScriptåŠ¨æ€è®¾ç½® */
            border-radius: 0;
            background: transparent !important; /* ç¡®ä¿èƒŒæ™¯é€æ˜ */
        }
        
        .triangle.single {
            border-left: 1.5rem solid transparent;
            border-right: 1.5rem solid transparent;
            border-bottom: 3rem solid #333;
        }
        
        .square {
            border: none;
            border-radius: 0;
        }
        .circle {
            border: 0.1rem solid #333;
            border-radius: 50%;
        }
        .diamond {
            transform: rotate(45deg);
            border: 0.2rem solid #333;
        }
        .pentagon {
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
            border: none;
        }
        .hexagon {
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
            border: none;
        }
        
        .number {
            position: absolute;
            font-weight: 600;
            font-size: 1.4rem;
            line-height: 1.8rem;
            color: #000;
        }
    
        .top-left { top: 0; left: 0.3rem; }
        .top-right { top: 0; right: 0.3rem; }
        .bottom-left { bottom: 0; left: 0.3rem; }
        .bottom-right { bottom: 0; right: 0.3rem; }
        
        .option-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 10.8rem;
            height: 13rem;
            padding: 0.6rem;
            background-color: #F9FAFB;
            border: 0.1rem solid #D5E9FF;
            border-radius: 0.8rem;
            cursor: pointer;
        }
        .option-group.selected {
            border: 0.2rem solid #83A4FF;
        }
        .option-group.correct {
            border: 0.2rem solid #10b981;
        }
        .option-group.incorrect {
            border: 0.2rem solid #ef4444;
        }
        .option-group.disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        .option-label {
            text-align: center;
            font-weight: 600;
            font-size: 1.8rem;
            line-height: 1.8rem;
            margin-bottom: 0.4rem;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.4rem;
            justify-items: center;
        }
        
        /* æç¤ºæ¡†æ ·å¼ */
        .hint-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .hint-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .hint-box {
            width: 37rem;
            height: 16rem;
            background: white;
            padding: 2.4rem 3.2rem 1.6rem;
            border-radius: 1.2rem;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .hint-overlay.show .hint-box {
            transform: scale(1);
        }
        
        .hint-icon {
            font-size: 1.8rem;
            line-height: 2.2rem;
            text-align: center;
            margin-bottom: 1.2rem;
        }
        
        .hint-text {
            font-size: 1.4rem;
            line-height: 2.2rem;
            text-align: center;
            margin-bottom: 1.2rem;
        }
        
        .hint-close-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 12rem;
            height: 3rem;
            margin: 0 auto;
            background-color: #7AA3FF;
            border-radius: 0.4rem;
            font-weight: 600;
            font-size: 1.2rem;
            color: #FFF;
            cursor: pointer;
        }

        /* ç§¯åˆ†æŒ‰é’®æ ·å¼ */
        .points-button {
            position: absolute;
            width: 3.8rem;
            height: 3.8rem;
            right: 0.4rem;
            bottom: 4.2rem;
            background-image: url("https://qiniu-public.keepwork.com/paracraft-cdn-resource/Web/ms_games/icon/game_points.png");
            background-size: cover;
            background-position: center;
            border: none;
            cursor: pointer;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* æ¸¸æˆè§„åˆ™æŒ‰é’®æ ·å¼ */
        .rules-button {
            position: absolute;
            width: 3.8rem;
            height: 3.8rem;
            right: 0.4rem;
            bottom: 0.4rem;
            background-image: url("https://qiniu-public.keepwork.com/paracraft-cdn-resource/Web/ms_games/icon/game_rule.png");
            background-size: cover;
            background-position: center;
            border: none;
            cursor: pointer;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ç§¯åˆ†å¼¹çª—æ ·å¼ */
        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .rules-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .rules-content {
            background: linear-gradient(135deg, #1f2937, #374151);
            border-radius: 1.6rem;
            width: 90%;
            max-width: 50rem;
            max-height: 80vh;
            box-shadow: 0 2rem 4rem rgba(0, 0, 0, 0.5);
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .rules-modal.show .rules-content {
            transform: scale(1);
        }

        .rules-header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            padding: 2rem 2.4rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rules-header h2 {
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0;
        }

        .rules-header button {
            background: none;
            border: none;
            color: #d1d5db;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .rules-header button:hover {
            color: white;
        }

        .rules-body {
            padding: 2.4rem;
            max-height: 60vh;
            overflow-y: scroll;
        }

        .modal-body::-webkit-scrollbar,
        .rules-body::-webkit-scrollbar {
            display: none;
        }

        .rules-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .rules-list li {
            margin-bottom: 1.2rem;
            padding: 0.8rem 0;
            border-bottom: 0.1rem solid #374151;
        }

        .rules-list li:last-child {
            border-bottom: none;
        }

        /* æ–°å¢å¼¹çª—æ ·å¼ - å‚è€ƒè¥¿è’™è¯´æ¸¸æˆ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
            padding: 1rem;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-content {
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            width: 39rem;
            padding: 2.2rem 2.2rem 1.8rem;
            background-color: #FFFFFF;
            border-radius: 0.8rem;
            box-shadow: 0 2rem 4rem rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.6rem;
        }

        .modal-title {
            display: flex;
            align-items: center;
            font-weight: 600;
            margin: 0;
        }

        .rules-sign {
            width: 0.6rem;
            height: 1.8rem;
            margin-right: 0.6rem;
            background-color: #009DFF;
            border-radius: 0.6rem;
        }

        .modal-close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            font-weight: normal;
        }

        .modal-rules-list {
            list-style-type: decimal;
            margin-left: 1.4rem;
            margin-bottom: 1rem;
        }

        .modal-rules-list li {
            margin-bottom: 1rem;
        }

        .modal-button {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem auto 0;
            width: 12rem;
            height: 3rem;
            background-color: #009DFF;
            border-radius: 0.8rem;
            font-weight: 600;
            color: #FFF;
            border: none;
            cursor: pointer;
        }

        /* ç§¯åˆ†å¼¹çª—æ ·å¼ */
        .points-modal {
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            width: 39rem;
            padding: 2.2rem 2.2rem 1.8rem;
            background-color: #FFFFFF;
            border-radius: 0.8rem;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
        }

        .points-sign {
            width: 0.6rem;
            height: 1.8rem;
            margin-right: 0.6rem;
            background-color: #FF9A00;
            border-radius: 0.6rem;
        }

        .points-title {
            display: flex;
            align-items: center;
            font-weight: 600;
        }

        .points-close {
            cursor: pointer;
            font-weight: normal;
            width: 1rem;
            height: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
        }

        .points-modal-content {
            display: flex;
            flex-direction: column;
        }

        .points-stats-section {
            background-color: #FDECE2;
            border-radius: 0.8rem;
            padding: 0.8rem 1.3rem 1rem 2.5rem;
            margin-bottom: 0.2rem;
        }

        .points-stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
        }

        .points-subtitle {
            position: relative;
            margin-bottom: 0.6rem;
            font-weight: 600;
            color: #333;
        }

        .points-subtitle::before {
            content: '';
            display: inline-block;
            position: absolute;
            left: -1.2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 0.4rem;
            height: 0.4rem;
            background-color: #FF9A00;
            border-radius: 50%;
        }

        .points-stats-grid {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .points-stat-item {
            display: flex;
            align-items: center;
            width: 14.6rem;
            height: 3.6rem;
            padding: 0 1.2rem;
            background-color: #ffffff;
            border-radius: 0.8rem;
        }

        .points-stat-label {
            color: #999999;
            font-size: 1.2rem;
        }

        .points-stat-value {
            margin-left: 1.2rem;
            font-weight: 600;
            font-size: 1.8rem;
        }

        .points-stat-value.total {
            color: #FF5800;
        }

        .points-stat-value.daily {
            color: #22C55E;
        }

        .points-rules-section {
            padding: 0.8rem 1.3rem 0 2.5rem;
        }

        .points-rules-list-warpper {
            width: 100%;
            max-height: 7.2rem;
            overflow-y: auto;
        }

        .points-rules-list {
            list-style-type: none;
            display: inline-block;
        }

        .points-rules-list-warpper::-webkit-scrollbar {
            width: 0.2rem;
        }

        .points-rules-list-warpper::-webkit-scrollbar-thumb {
            background: #999;
            border-radius: 0.2rem;
        }

        .points-rules-list li {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
            color: #333333;
        }

        .points-rules-list li:last-child {
            margin-bottom: 0;
        }

        .points-rule-name {
            display: inline-block;
        }

        .points-rule-value {
            margin-left: 2rem;
            color: #FF9500;
            font-weight: 600;
        }

        .modal-body {
            overflow-y: auto;
            max-height: 60vh;
        }

        .modal-body::-webkit-scrollbar,
        .rules-body::-webkit-scrollbar {
            display: none;
        }

        /* éš¾åº¦é€‰æ‹©å™¨æ ·å¼ */
        .difficulty-selector {
            position: relative;
            width: 8.8rem;
            height: 2.6rem;
            color: #333;
        }

        .difficulty-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.2rem 0.6rem;
            background-color: #FFF1DF;
            border-radius: 0.4rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-selector-header.active {
            border-color: #4196FF;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .difficulty-selector-arrow {
            width: 0;
            height: 0;
            border-left: 0.3rem solid transparent;
            border-right: 0.3rem solid transparent;
            border-top: 0.4rem solid #333;
            transition: transform 0.2s ease;
        }

        .difficulty-selector-header.active .difficulty-selector-arrow {
            transform: rotate(180deg);
        }

        .difficulty-selector-dropdown {
            position: absolute;
            top: 2.6rem;
            left: 0;
            right: 0;
            background-color: #FFF1DF;
            border-top: none;
            border-bottom-left-radius: 0.4rem;
            border-bottom-right-radius: 0.4rem;
            z-index: 100;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .difficulty-selector-dropdown.show {
            max-height: 20rem;
            opacity: 1;
        }

        .difficulty-selector-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 2.6rem;
            padding: 0.2rem 0.6rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-selector-option:last-child {
            border-bottom: none;
        }

        .difficulty-selector-option.selected {
            background-color: #DBEAFE;
            border: 0.2rem solid #FFF1DF;
            border-top: none;
            border-bottom: none;
            color: #4196FF;
            font-weight: 600;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-panel">
            <!-- é¡¶éƒ¨çŠ¶æ€æ ï¼ˆæ–°ï¼‰ -->
            <div class="game-panel-header">
                <div class="info-item" style="color: #6A60FF;">
                    <div class="vertical-bar" style="background-color: #6A60FF;"></div>
                    <div class="text-14">é¢˜ç›®ï¼š</div>
                    <div class="text-24">
                        <span id="progress">1</span>/<span id="totalQuestions">10</span>
                    </div>
                </div> 
                <div class="info-item" style="color: #17A34A;">
                    <div class="vertical-bar" style="background-color: #17A34A;"></div>
                    <div class="text-14">ç§¯åˆ†ï¼š</div>
                    <div class="text-24" id="totalHistoryPoints">-</div>
                </div> 
                <!-- æ–°çš„éš¾åº¦é€‰æ‹©å™¨ -->
                <div class="difficulty-selector text-14">
                    <div class="difficulty-selector-header">
                        <span>éš¾åº¦</span>
                        <span id="currentDifficultyText" style="font-weight: 500;">åŸºç¡€</span>
                        <div class="difficulty-selector-arrow"></div>
                    </div>
                    <div class="difficulty-selector-dropdown">
                        <div class="difficulty-selector-option selected" data-stage="1">
                            <span style="opacity: 0;">éš¾åº¦</span>
                            <span style="font-weight: 500;">åŸºç¡€</span>
                            <div class="difficulty-selector-arrow" style="opacity: 0;"></div>
                        </div>
                        <div class="difficulty-selector-option" data-stage="2">
                            <span style="opacity: 0;">éš¾åº¦</span>
                            <span style="font-weight: 500;">è¿›é˜¶</span>
                            <div class="difficulty-selector-arrow" style="opacity: 0;"></div>
                        </div>
                        <div class="difficulty-selector-option" data-stage="3">
                            <span style="opacity: 0;">éš¾åº¦</span>
                            <span style="font-weight: 500;">é«˜çº§</span>
                            <div class="difficulty-selector-arrow" style="opacity: 0;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="game-panel-body">
                <!-- é¢˜ç›®æè¿° -->
                <div class="game-panel-title" id="questionTitle">
                    æ‰¾å‡ºé”™è¯¯çš„ä¸€ç»„
                </div>

                <!-- é€‰é¡¹åŒºåŸŸ -->
                <div id="optionsContainer">
                    <!-- é€‰é¡¹å°†ç”±JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <div class="button-group">
                <div class="interactive-button tip">æç¤º</div>
                <div class="interactive-button submit">æäº¤ç­”æ¡ˆ</div>
            </div>
        </div>

        <!-- ç§¯åˆ†æŒ‰é’® -->
        <button id="pointsButton" class="points-button" title="æŸ¥çœ‹ç§¯åˆ†"></button>
        <!-- æ¸¸æˆè§„åˆ™æŒ‰é’® -->
        <button id="rulesButton" class="rules-button" title="æŸ¥çœ‹æ¸¸æˆè§„åˆ™"></button>
    </div>

    <!-- æç¤ºæ¡† -->
    <div id="hintOverlay" class="hint-overlay">
        <div class="hint-box">
            <div id="hintIcon" class="hint-icon">ğŸ’¡æç¤º</div>
            <div id="hintText" class="hint-text"></div>
            <button id="hintCloseBtn" class="hint-close-btn">çŸ¥é“äº†</button>
        </div>
    </div>

    <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
    <div id="rulesModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header text-18">
                <h2 class="modal-title text-secondary">
                    <div class="rules-sign"></div>
                    <span>å›¾å½¢æ‰¾èŒ¬</span>
                </h2>
                <button id="closeRules" class="modal-close-btn text-primary">Ã—</button>
            </div>
            
            <ol class="modal-rules-list text-14 text-list">
                <li>è¯·æ ¹æ®é¢˜ç›®è¦æ±‚,é€‰æ‹©ç¬¦åˆé€»è¾‘çš„æ­£ç¡®ç­”æ¡ˆ</li>
                <li id="recommendedDifficultyRow" style="display: none;">æ ¹æ®ä½ çš„æ¨¡å‹,å½“å‰ä¸ºä½ æ¨èçš„éš¾åº¦ä¸º<span id="recommendedDifficulty" style="color: #4189FF; font-weight: 600;">ã€åŸºç¡€ã€‘</span>,ä½ å¯ä»¥éšæ—¶æ ¹æ®ä½œç­”æƒ…å†µ,è°ƒæ•´éš¾åº¦ã€‚</li>
            </ol>
            
            <button id="startTraining" class="modal-button text-12">
                å¼€å§‹è®­ç»ƒ
            </button>
        </div>
    </div>

    <!-- ç§¯åˆ†å¼¹çª— -->
    <div id="pointsModal" class="modal-overlay hidden">
        <div class="points-modal">
            <div class="points-header">
                <div class="points-title text-18 text-secondary">
                    <div class="points-sign"></div>
                    <span>ç§¯åˆ†ç³»ç»Ÿ</span>
                </div>
                <button id="closePoints" class="points-close text-primary">Ã—</button>
            </div>
            <div class="points-modal-content text-14 text-list">
                <div class="points-stats-section">
                    <div class="points-stats-header">
                        <div class="points-subtitle" style="margin: 0;">ç§¯åˆ†ç»Ÿè®¡</div>
                        <div class="text-10 text-note">
                            æœ€åæ›´æ–°: <span id="lastUpdateDateDisplay">--</span>
                        </div>
                    </div>
                    <div class="points-stats-grid">
                        <div class="points-stat-item">
                            <div class="points-stat-label">æ€»ç§¯åˆ†</div>
                            <div id="totalPointsDisplay" class="points-stat-value total">0</div>
                        </div>
                        <div class="points-stat-item">
                            <div class="points-stat-label">ä»Šæ—¥ç§¯åˆ†</div>
                            <div id="dailyPointsDisplay" class="points-stat-value daily">+0</div>
                        </div>
                    </div>
                </div>
                <div class="points-rules-section">
                    <div class="points-subtitle">ç§¯åˆ†è·å¾—è§„åˆ™</div>
                    <div class="points-rules-list-warpper">
                        <ul class="points-rules-list">
                            <li class="text-12">
                                <span class="points-rule-name">åŸºç¡€éš¾åº¦ï¼šæ¯é¢˜</span>
                                <span class="points-rule-value">5ç§¯åˆ†</span>
                            </li>
                            <li class="text-12">
                                <span class="points-rule-name">è¿›é˜¶éš¾åº¦ï¼šæ¯é¢˜</span>
                                <span class="points-rule-value">10ç§¯åˆ†</span>
                            </li>
                            <li class="text-12">
                                <span class="points-rule-name">é«˜çº§éš¾åº¦ï¼šæ¯é¢˜</span>
                                <span class="points-rule-value">15ç§¯åˆ†</span>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AbstractReasoningGame {
            constructor() {
                // æ¸¸æˆä¸»å®¹å™¨çš„è®¾è®¡å°ºå¯¸
                this.DESIGN_WIDTH = 652;
                this.DESIGN_HEIGHT = 375;
                this.rootFontSize = 10;
                
                // å¤§å…³å¡ç³»ç»Ÿï¼š3ä¸ªå¤§å…³å¡ï¼Œæ¯ä¸ªè‡³å°‘10é¢˜
                this.currentStage = 1; // å½“å‰å¤§å…³å¡ (1=3é€‰é¡¹, 2=4é€‰é¡¹, 3=5é€‰é¡¹)
                this.currentQuestion = 1; // å½“å‰å¤§å…³å¡å†…çš„é¢˜ç›®ç¼–å·
                this.questionsPerStage = 10; // æ¯ä¸ªå¤§å…³å¡çš„é¢˜ç›®æ•°é‡
                this.maxStages = 3; // æ€»å…±3ä¸ªå¤§å…³å¡
                
                this.score = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
                this.wrongAnswers = 0; // å½“å‰å¤§å…³å¡çš„é”™è¯¯æ¬¡æ•°
                this.maxWrongAnswers = 4; // å¤§å…³å¡æœ€å¤§é”™è¯¯æ¬¡æ•°
                
                this.selectedOption = null;
                this.currentShuffledOptions = [];
                this.wrongAnswerIndex = 0;
                this.autoNextTimeout = null;
                this.gameCompleted = false;
                this.highestScore = 0;
                this.gameStarted = false;
                this.difficulty = 1;
                this.game_config = null;
                this.isTransitioning = false; // é˜²æ­¢é‡å¤æ‰§è¡Œè½¬æ¢é€»è¾‘
                
                // æ¨èéš¾åº¦ç›¸å…³å±æ€§
                this.recommendedStage = null;
                this.recommendedStageName = null;
                this.hasShownInitialRules = false; // æ ‡è®°æ˜¯å¦å·²æ˜¾ç¤ºè¿‡åˆå§‹è§„åˆ™å¼¹çª—
                
                // ç§¯åˆ†ç›¸å…³å±æ€§
                this.totalGamePoints = 0; // æ¸¸æˆå†…æ€»ç§¯åˆ†
                this.earnedPoints = 0; // æœ¬æ¬¡æ¸¸æˆè·å¾—çš„ç§¯åˆ†
                this.globalTotalPoints = 0; // å…¨å±€æ€»ç§¯åˆ†
                this.globalDailyPoints = 0; // ä»Šæ—¥ç§¯åˆ†
                this.lastUpdateDate = '--';
                
                // å¤§å…³å¡é…ç½®
                this.stageConfig = {
                    1: { options: 3, name: "åŸºç¡€", description: "3é€‰é¡¹æŒ‘æˆ˜" },
                    2: { options: 4, name: "è¿›é˜¶", description: "4é€‰é¡¹æŒ‘æˆ˜" },
                    3: { options: 5, name: "é«˜çº§", description: "5é€‰é¡¹æŒ‘æˆ˜" }
                };
                
                this.shapeEdges = {
                    triangle: 3,
                    square: 4,
                    pentagon: 5,
                    hexagon: 6,
                    circle: 0,
                    diamond: 4
                };
                
                this.colors = {
                    green: '#10b981',
                    yellow: '#f59e0b',
                    blue: '#3b82f6',
                    red: '#ef4444',
                    purple: '#8b5cf6'
                };
                
                this.rules = this.generateRules();
                
                // è°ƒæ•´æ ¹å­—ä½“å¤§å°
                this.adjustRootFontSize();
                
                this.initializeGame();
                
                // å‘é€æ¸¸æˆåŠ è½½å®Œæˆæ¶ˆæ¯
                window.parent.postMessage({ type: 'gameLoaded' }, '*');
            }

            generateRules() {
                return [
                    {
                        type: "number_equals_edges",
                        name: "æ•°å­—ç­‰äºå›¾å½¢è¾¹æ•°",
                        generateCorrect: () => {
                            const shapes = ['triangle', 'square', 'pentagon', 'hexagon'];
                            const colors = ['green', 'blue', 'red', 'yellow', 'purple'];
                            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                            
                            // æ ¹æ®å¤§å…³å¡è®¡ç®—å›¾å½¢æ•°é‡ï¼š3-5ä¸ªå›¾å½¢
                            const shapeCount = Math.min(5, 2 + this.currentStage);
                            const availableShapes = shapes.slice(0, shapeCount);
                            
                            return {
                                shapes: positions.map((pos, i) => {
                                    const shape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                    return {
                                        shapes: [{ type: shape, color: colors[i] }],
                                        pos: pos,
                                        num: this.shapeEdges[shape]
                                    };
                                })
                            };
                        },
                        generateWrong: (correctOption) => {
                            const wrong = JSON.parse(JSON.stringify(correctOption));
                            // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®ï¼Œè®©æ•°å­—ä¸ç­‰äºè¾¹æ•°
                            const randomIndex = Math.floor(Math.random() * 4);
                            const currentNum = wrong.shapes[randomIndex].num;
                            
                            // ç”Ÿæˆæ˜æ˜¾é”™è¯¯çš„æ•°å­—ï¼Œç¡®ä¿ä¸ç­‰äºå›¾å½¢è¾¹æ•°
                            const shapeType = wrong.shapes[randomIndex].shapes[0].type;
                            const correctEdges = this.shapeEdges[shapeType];
                            
                            // é€‰æ‹©ä¸€ä¸ªæ˜æ˜¾ä¸åŒçš„æ•°å­—
                            const possibleWrongNums = [1, 2, 3, 4, 5, 6, 7, 8, 9].filter(n => 
                                n !== correctEdges && Math.abs(n - correctEdges) >= 2
                            );
                            
                            if (possibleWrongNums.length > 0) {
                                wrong.shapes[randomIndex].num = possibleWrongNums[Math.floor(Math.random() * possibleWrongNums.length)];
                            } else {
                                // å¦‚æœæ²¡æœ‰åˆé€‚çš„é€‰æ‹©ï¼Œå°±ä½¿ç”¨ä¸€ä¸ªæ˜æ˜¾é”™è¯¯çš„æ•°å­—
                                wrong.shapes[randomIndex].num = correctEdges === 3 ? 7 : 1;
                            }
                            
                            return wrong;
                        },
                        explanation: "æ­£ç¡®è§„å¾‹ï¼šæ•°å­—åº”è¯¥ç­‰äºå›¾å½¢çš„è¾¹æ•°ï¼ˆä¸‰è§’å½¢3è¾¹ï¼Œæ­£æ–¹å½¢4è¾¹ï¼Œäº”è¾¹å½¢5è¾¹ï¼Œå…­è¾¹å½¢6è¾¹ï¼‰"
                    },
                    {
                        type: "multiple_shapes_sum",
                        name: "æ•°å­—ç­‰äºæ‰€æœ‰å›¾å½¢è¾¹æ•°ä¹‹å’Œ",
                        generateCorrect: () => {
                            const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'circle'];
                            const colors = ['green', 'blue', 'red', 'yellow', 'purple'];
                            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                            
                            // æ ¹æ®å¤§å…³å¡è®¡ç®—å›¾å½¢æ•°é‡ï¼š3-5ä¸ªå›¾å½¢
                            const shapeCount = Math.min(5, 2 + this.currentStage);
                            const availableShapes = shapes.slice(0, shapeCount);
                            
                            return {
                                shapes: positions.map(pos => {
                                    const numShapes = Math.random() < 0.5 ? 1 : 2;
                                    const cellShapes = [];
                                    let totalEdges = 0;
                                    
                                    for (let i = 0; i < numShapes; i++) {
                                        const shape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                        const color = colors[Math.floor(Math.random() * colors.length)];
                                        cellShapes.push({ type: shape, color: color });
                                        totalEdges += this.shapeEdges[shape];
                                    }
                                    
                                    return {
                                        shapes: cellShapes,
                                        pos: pos,
                                        num: totalEdges
                                    };
                                })
                            };
                        },
                        generateWrong: (correctOption) => {
                            const wrong = JSON.parse(JSON.stringify(correctOption));
                            const randomIndex = Math.floor(Math.random() * 4);
                            const currentNum = wrong.shapes[randomIndex].num;
                            
                            // ç¡®ä¿ä¿®æ”¹å¹…åº¦è¶³å¤Ÿå¤§ï¼Œé¿å…æ„å¤–æ­£ç¡®
                            const minChange = 2;
                            const changeDirection = Math.random() < 0.5 ? 1 : -1;
                            let newNum = currentNum + (changeDirection * minChange);
                            
                            // ç¡®ä¿æ–°æ•°å­—åœ¨åˆç†èŒƒå›´å†…ä¸”æ˜æ˜¾ä¸åŒ
                            if (newNum < 1) newNum = currentNum + minChange;
                            if (newNum > 12) newNum = currentNum - minChange;
                            if (newNum === currentNum) newNum = currentNum + minChange;
                            
                            wrong.shapes[randomIndex].num = newNum;
                            return wrong;
                        },
                        explanation: "æ­£ç¡®è§„å¾‹ï¼šæ•°å­—åº”è¯¥ç­‰äºæ ¼å­å†…æ‰€æœ‰å›¾å½¢è¾¹æ•°ä¹‹å’Œ"
                    },
                    {
                        type: "color_filter_green",
                        name: "æ•°å­—ç­‰äºç»¿è‰²å›¾å½¢è¾¹æ•°ä¹‹å’Œ",
                        generateCorrect: () => {
                            const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'circle'];
                            const colors = ['green', 'blue', 'red', 'yellow', 'purple'];
                            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                            
                            // æ ¹æ®å¤§å…³å¡è®¡ç®—å›¾å½¢æ•°é‡ï¼š3-5ä¸ªå›¾å½¢
                            const shapeCount = Math.min(5, 2 + this.currentStage);
                            const availableShapes = shapes.slice(0, shapeCount);
                            
                            return {
                                shapes: positions.map(pos => {
                                    const hasGreen = Math.random() < 0.7;
                                    const cellShapes = [];
                                    let greenEdges = 0;
                                    
                                    if (hasGreen) {
                                        const greenShape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                        cellShapes.push({ type: greenShape, color: 'green' });
                                        greenEdges += this.shapeEdges[greenShape];
                                    }
                                    
                                    // æ·»åŠ ä¸€ä¸ªéç»¿è‰²å›¾å½¢
                                    if (Math.random() < 0.6) {
                                        const otherShape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                        const otherColors = colors.filter(c => c !== 'green');
                                        const otherColor = otherColors[Math.floor(Math.random() * otherColors.length)];
                                        cellShapes.push({ type: otherShape, color: otherColor });
                                    }
                                    
                                    if (cellShapes.length === 0) {
                                        // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªå›¾å½¢
                                        const shape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                        cellShapes.push({ type: shape, color: 'green' });
                                        greenEdges = this.shapeEdges[shape];
                                    }
                                    
                                    return {
                                        shapes: cellShapes,
                                        pos: pos,
                                        num: greenEdges
                                    };
                                })
                            };
                        },
                        generateWrong: (correctOption) => {
                            const wrong = JSON.parse(JSON.stringify(correctOption));
                            const randomIndex = Math.floor(Math.random() * 4);
                            const currentNum = wrong.shapes[randomIndex].num;
                            
                            // ä½¿ç”¨æ›´å¤§çš„å˜åŒ–å¹…åº¦ç¡®ä¿é”™è¯¯æ˜æ˜¾
                            const changeAmount = Math.floor(Math.random() * 3) + 2; // 2-4çš„å˜åŒ–
                            const changeDirection = Math.random() < 0.5 ? 1 : -1;
                            let newNum = currentNum + (changeDirection * changeAmount);
                            
                            // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
                            if (newNum < 0) newNum = currentNum + changeAmount;
                            if (newNum > 15) newNum = currentNum - changeAmount;
                            
                            wrong.shapes[randomIndex].num = newNum;
                            return wrong;
                        },
                        explanation: "æ­£ç¡®è§„å¾‹ï¼šæ•°å­—åº”è¯¥åªè®¡ç®—ç»¿è‰²å›¾å½¢çš„è¾¹æ•°ä¹‹å’Œï¼Œå¿½ç•¥å…¶ä»–é¢œè‰²çš„å›¾å½¢"
                    },
                    {
                        type: "shape_count_match",
                        name: "æ•°å­—ç­‰äºå›¾å½¢ç§ç±»æ•°é‡",
                        generateCorrect: () => {
                            const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'circle'];
                            const colors = ['green', 'blue', 'red', 'yellow', 'purple'];
                            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                            
                            // æ ¹æ®å¤§å…³å¡è®¡ç®—å›¾å½¢æ•°é‡ï¼š3-5ä¸ªå›¾å½¢
                            const shapeCount = Math.min(5, 2 + this.currentStage);
                            const availableShapes = shapes.slice(0, shapeCount);
                            
                            return {
                                shapes: positions.map(pos => {
                                    const numShapes = Math.floor(Math.random() * 3) + 1; // 1-3ä¸ªå›¾å½¢
                                    const cellShapes = [];
                                    const usedShapeTypes = new Set();
                                    
                                    for (let i = 0; i < numShapes; i++) {
                                        let shape;
                                        do {
                                            shape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
                                        } while (usedShapeTypes.has(shape) && usedShapeTypes.size < availableShapes.length);
                                        
                                        usedShapeTypes.add(shape);
                                        const color = colors[Math.floor(Math.random() * colors.length)];
                                        cellShapes.push({ type: shape, color: color });
                                    }
                                    
                                    return {
                                        shapes: cellShapes,
                                        pos: pos,
                                        num: usedShapeTypes.size
                                    };
                                })
                            };
                        },
                        generateWrong: (correctOption) => {
                            const wrong = JSON.parse(JSON.stringify(correctOption));
                            const randomIndex = Math.floor(Math.random() * 4);
                            const currentNum = wrong.shapes[randomIndex].num;
                            
                            // ç¡®ä¿å˜åŒ–æ˜æ˜¾ï¼Œè‡³å°‘Â±2
                            const minChange = 2;
                            let newNum;
                            if (currentNum <= 1) {
                                newNum = currentNum + minChange + Math.floor(Math.random() * 2); // +2åˆ°+3
                            } else if (currentNum >= 4) {
                                newNum = currentNum - minChange - Math.floor(Math.random() * 2); // -2åˆ°-3
                            } else {
                                newNum = Math.random() < 0.5 ? 
                                    currentNum + minChange + Math.floor(Math.random() * 2) : 
                                    Math.max(1, currentNum - minChange - Math.floor(Math.random() * 2));
                            }
                            
                            // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
                            newNum = Math.max(1, Math.min(8, newNum));
                            
                            wrong.shapes[randomIndex].num = newNum;
                            return wrong;
                        },
                        explanation: "æ­£ç¡®è§„å¾‹ï¼šæ•°å­—åº”è¯¥ç­‰äºæ ¼å­å†…ä¸åŒå›¾å½¢ç§ç±»çš„æ•°é‡ï¼ˆä¸é‡å¤è®¡ç®—ç›¸åŒå½¢çŠ¶ï¼‰"
                    },
                    {
                        type: "diagonal_sum",
                        name: "å¯¹è§’çº¿å›¾å½¢è¾¹æ•°å¯¹åº”",
                        generateCorrect: () => {
                            const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'circle'];
                            const colors = ['green', 'blue', 'red', 'yellow', 'purple'];
                            
                            // æ ¹æ®å¤§å…³å¡è®¡ç®—å›¾å½¢æ•°é‡ï¼š3-5ä¸ªå›¾å½¢
                            const shapeCount = Math.min(5, 2 + this.currentStage);
                            const availableShapes = shapes.slice(0, shapeCount);
                            
                            // å…ˆç”Ÿæˆå·¦ä¸‹å’Œå³ä¸‹çš„å›¾å½¢
                            const bottomLeftShapes = [{ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[0] }];
                            const bottomRightShapes = [{ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[1] }];
                            
                            if (Math.random() < 0.4) {
                                bottomLeftShapes.push({ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[2] });
                            }
                            if (Math.random() < 0.4) {
                                bottomRightShapes.push({ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[3] });
                            }
                            
                            const bottomLeftSum = bottomLeftShapes.reduce((sum, shape) => sum + this.shapeEdges[shape.type], 0);
                            const bottomRightSum = bottomRightShapes.reduce((sum, shape) => sum + this.shapeEdges[shape.type], 0);
                            
                            return {
                                shapes: [
                                    { shapes: [{ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[0] }], pos: "top-left", num: bottomRightSum },
                                    { shapes: [{ type: availableShapes[Math.floor(Math.random() * availableShapes.length)], color: colors[1] }], pos: "top-right", num: bottomLeftSum },
                                    { shapes: bottomLeftShapes, pos: "bottom-left", num: 0 },
                                    { shapes: bottomRightShapes, pos: "bottom-right", num: 0 }
                                ]
                            };
                        },
                        generateWrong: (correctOption) => {
                            const wrong = JSON.parse(JSON.stringify(correctOption));
                            const randomIndex = Math.random() < 0.5 ? 0 : 1; // åªæ”¹å˜å·¦ä¸Šè§’æˆ–å³ä¸Šè§’
                            const currentNum = wrong.shapes[randomIndex].num;
                            
                            // ä½¿ç”¨æ›´æ˜æ˜¾çš„å˜åŒ–ï¼Œç¡®ä¿é”™è¯¯é€‰é¡¹å®¹æ˜“è¯†åˆ«
                            const changeAmount = Math.floor(Math.random() * 4) + 2; // 2-5çš„å˜åŒ–
                            const changeDirection = Math.random() < 0.5 ? 1 : -1;
                            let newNum = currentNum + (changeDirection * changeAmount);
                            
                            // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
                            if (newNum < 0) newNum = currentNum + changeAmount;
                            if (newNum > 20) newNum = currentNum - changeAmount;
                            
                            wrong.shapes[randomIndex].num = newNum;
                            return wrong;
                        },
                        explanation: "æ­£ç¡®è§„å¾‹ï¼šå·¦ä¸Šæ•°å­— = å³ä¸‹å›¾å½¢è¾¹æ•°ä¹‹å’Œï¼Œå³ä¸Šæ•°å­— = å·¦ä¸‹å›¾å½¢è¾¹æ•°ä¹‹å’Œ"
                    }
                ];
            }

            adjustRootFontSize() {
                // è·å–è§†å£å°ºå¯¸
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // è®¡ç®—åŸºäºå®½åº¦å’Œé«˜åº¦çš„ç¼©æ”¾æ¯”ä¾‹
                const scaleByWidth = viewportWidth / this.DESIGN_WIDTH;
                const scaleByHeight = viewportHeight / this.DESIGN_HEIGHT;
                
                // å–è¾ƒå°çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œç¡®ä¿å†…å®¹å®Œå…¨å¯è§ï¼ˆç­‰æ¯”ä¾‹ç¼©æ”¾ï¼‰
                const scale = Math.min(scaleByWidth, scaleByHeight);
                
                // è®¾ç½®æ ¹å…ƒç´ çš„ font-size
                // å‡è®¾è®¾è®¡ç¨¿åŸºå‡†æ˜¯ 1rem = 10pxï¼Œåˆ™è°ƒæ•´åçš„ font-size = 10 * scale
                const baseFontSize = 10; // è®¾è®¡ç¨¿åŸºå‡†
                const finalFontSize = baseFontSize * scale;
                
                document.documentElement.style.fontSize = `${finalFontSize}px`;
                this.rootFontSize = finalFontSize;
            }

            initializeGame() {
                this.setupLevelSelect();
                this.bindEvents();
                this.loadLevel();
                
                // å»¶è¿Ÿæ˜¾ç¤ºæ¸¸æˆè§„åˆ™å¼¹çª—ï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
                setTimeout(() => {
                    this.showRulesModal();
                }, 100);
            }

            setupLevelSelect() {
                // æ›´æ–°é¢˜ç›®è¿›åº¦æ˜¾ç¤º
                this.updateProgress();
                // æ›´æ–°éš¾åº¦é€‰æ‹©å™¨æ˜¾ç¤º
                this.updateDifficultyDisplay();
            }

            bindEvents() {
                // æ–°çš„æŒ‰é’®ç»„äº‹ä»¶ç»‘å®š
                const submitButton = document.querySelector('.interactive-button.submit');
                const tipButton = document.querySelector('.interactive-button.tip');
                
                if (submitButton) {
                    submitButton.onclick = () => this.submitAnswer();
                }
                if (tipButton) {
                    tipButton.onclick = () => this.showHint();
                }
                
                document.getElementById('pointsButton').addEventListener('click', () => this.showPointsModal());
                document.getElementById('closePoints').addEventListener('click', () => this.hidePointsModal());
                document.getElementById('rulesButton').addEventListener('click', () => this.showRulesModal());
                document.getElementById('closeRules').addEventListener('click', () => this.hideRulesModal());
                document.getElementById('startTraining').addEventListener('click', () => this.hideRulesModal());
                
                // éš¾åº¦é€‰æ‹©å™¨äº‹ä»¶
                this.setupDifficultySelector();
                
                // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => this.adjustRootFontSize());
            }

            setupDifficultySelector() {
                const header = document.querySelector('.difficulty-selector-header');
                const dropdown = document.querySelector('.difficulty-selector-dropdown');
                const options = document.querySelectorAll('.difficulty-selector-option');
                const currentText = document.getElementById('currentDifficultyText');
                
                // ç‚¹å‡»å¤´éƒ¨åˆ‡æ¢ä¸‹æ‹‰èœå•
                header.addEventListener('click', (e) => {
                    console.log('asdadas')
                    e.stopPropagation();
                    header.classList.toggle('active');
                    dropdown.classList.toggle('show');
                });
                
                // ç‚¹å‡»é€‰é¡¹
                options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const stage = parseInt(option.dataset.stage);
                        const stageName = option.querySelector('span[style*="font-weight"]').textContent;
                        
                        // æ›´æ–°é€‰ä¸­çŠ¶æ€
                        options.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                        
                        // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
                        currentText.textContent = stageName;
                        
                        // åˆ‡æ¢éš¾åº¦
                        if (stage !== this.currentStage) {
                            this.currentStage = stage;
                            this.currentQuestion = 1;
                            this.wrongAnswers = 0;
                            this.score = 0;
                            this.totalQuestions = 0;
                            this.correctAnswers = 0;
                            this.gameCompleted = false;
                            this.selectedOption = null;
                            this.clearAutoNext();
                            this.updateStats();
                            this.loadLevel();
                        }
                        
                        // å…³é—­ä¸‹æ‹‰èœå•
                        header.classList.remove('active');
                        dropdown.classList.remove('show');
                    });
                });
                
                // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹å…³é—­ä¸‹æ‹‰èœå•
                document.addEventListener('click', () => {
                    header.classList.remove('active');
                    dropdown.classList.remove('show');
                });
                
                // åˆå§‹åŒ–æ˜¾ç¤ºå½“å‰éš¾åº¦
                this.updateDifficultyDisplay();
            }

            updateDifficultyDisplay() {
                const currentText = document.getElementById('currentDifficultyText');
                const options = document.querySelectorAll('.difficulty-selector-option');
                
                if (currentText && this.stageConfig[this.currentStage]) {
                    currentText.textContent = this.stageConfig[this.currentStage].name;
                    
                    // æ›´æ–°é€‰é¡¹çš„é€‰ä¸­çŠ¶æ€
                    options.forEach(option => {
                        const stage = parseInt(option.dataset.stage);
                        if (stage === this.currentStage) {
                            option.classList.add('selected');
                        } else {
                            option.classList.remove('selected');
                        }
                    });
                }
            }

            clearAutoNext() {
                if (this.autoNextTimeout) {
                    clearTimeout(this.autoNextTimeout);
                    this.autoNextTimeout = null;
                }
            }

            generateLevel(rule) {
                // æ ¹æ®å½“å‰å¤§å…³å¡ç¡®å®šé€‰é¡¹æ•°é‡
                const optionCount = this.stageConfig[this.currentStage].options;
                
                // ç”Ÿæˆ(optionCount-1)ä¸ªæ­£ç¡®ç­”æ¡ˆå’Œ1ä¸ªé”™è¯¯ç­”æ¡ˆ
                const correctOptions = [];
                for (let i = 0; i < optionCount - 1; i++) {
                    correctOptions.push(rule.generateCorrect());
                }
                
                // å¤šæ¬¡å°è¯•ç”Ÿæˆä¸€ä¸ªçœŸæ­£é”™è¯¯çš„é€‰é¡¹
                let wrongOption;
                let attempts = 0;
                const maxAttempts = 10;
                
                do {
                    wrongOption = rule.generateWrong(correctOptions[0]);
                    attempts++;
                    
                    // éªŒè¯é”™è¯¯é€‰é¡¹ç¡®å®ä¸æ­£ç¡®é€‰é¡¹ä¸åŒ
                    const isDifferent = !correctOptions.some(correct => 
                        JSON.stringify(correct) === JSON.stringify(wrongOption)
                    );
                    
                    if (isDifferent) break;
                    
                } while (attempts < maxAttempts);
                
                // å¦‚æœå¤šæ¬¡å°è¯•ä»ç„¶æ— æ³•ç”Ÿæˆæœ‰æ•ˆçš„é”™è¯¯é€‰é¡¹ï¼Œå¼ºåˆ¶ä¿®æ”¹
                if (attempts >= maxAttempts) {
                    wrongOption = JSON.parse(JSON.stringify(correctOptions[0]));
                    // å¼ºåˆ¶ä¿®æ”¹ç¬¬ä¸€ä¸ªä½ç½®çš„æ•°å­—ï¼Œç¡®ä¿å®ƒæ˜¯é”™è¯¯çš„
                    const currentNum = wrongOption.shapes[0].num;
                    wrongOption.shapes[0].num = currentNum === 0 ? 9 : 0;
                }
                
                // æ„å»ºé€‰é¡¹æ•°ç»„ï¼Œå…ˆè®°å½•é”™è¯¯ç­”æ¡ˆçš„ä½ç½®
                const wrongAnswerPosition = Math.floor(Math.random() * optionCount);
                const allOptions = [];
                
                // æŒ‰é¡ºåºæ’å…¥é€‰é¡¹ï¼Œåœ¨æŒ‡å®šä½ç½®æ’å…¥é”™è¯¯ç­”æ¡ˆ
                let correctIndex = 0;
                for (let i = 0; i < optionCount; i++) {
                    if (i === wrongAnswerPosition) {
                        allOptions.push(wrongOption);
                    } else {
                        allOptions.push(correctOptions[correctIndex]);
                        correctIndex++;
                    }
                }
                
                // è®°å½•é”™è¯¯ç­”æ¡ˆçš„æœ€ç»ˆä½ç½®
                this.wrongAnswerIndex = wrongAnswerPosition;
                
                return {
                    options: allOptions,
                    rule: rule
                };
            }

            loadLevel() {
                // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œé‡ç½® isTransitioningï¼Œç”±è°ƒç”¨æ–¹è´Ÿè´£ç®¡ç†
                
                // æ¢å¤æç¤ºå¼¹çª—çš„æ ‡é¢˜ä¸º"æç¤º"
                const hintIcon = document.getElementById('hintIcon');
                if (hintIcon) {
                    hintIcon.textContent = 'ğŸ’¡æç¤º';
                }
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰å¤§å…³å¡
                if (this.currentStage > this.maxStages) {
                    this.endGame();
                    return;
                }
                
                // å¦‚æœæ˜¯ç¬¬ä¸€é¢˜ä¸”æ¸¸æˆå°šæœªå¼€å§‹ï¼Œå‘é€æ¸¸æˆå¼€å§‹æ¶ˆæ¯
                if (this.currentStage === 1 && this.currentQuestion === 1 && !this.gameStarted) {
                    this.gameStarted = true;
                    window.parent.postMessage({ type: 'gameStarted' }, '*');
                }

                const ruleIndex = (this.totalQuestions) % this.rules.length;
                const rule = this.rules[ruleIndex];
                const level = this.generateLevel(rule);
                
                document.getElementById('questionTitle').textContent = "æ‰¾å‡ºé”™è¯¯çš„ä¸€ç»„";
                this.setupLevelSelect(); // æ›´æ–°å…³å¡é€‰æ‹©å™¨æ˜¾ç¤º
                
                this.currentLevel_rule = rule;
                this.renderOptions(level.options);
                this.selectedOption = null;
                this.gameCompleted = false;
                
                // é‡ç½®æŒ‰é’®çŠ¶æ€
                const submitButton = document.querySelector('.interactive-button.submit');
                if (submitButton) {
                    submitButton.textContent = 'æäº¤ç­”æ¡ˆ';
                    submitButton.classList.add('disabled');
                    submitButton.style.pointerEvents = 'none';
                    submitButton.style.opacity = '0.5';
                    // é‡æ–°ç»‘å®šæäº¤ç­”æ¡ˆäº‹ä»¶
                    submitButton.onclick = () => this.submitAnswer();
                }
                
                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©çŠ¶æ€
                document.querySelectorAll('.option-group').forEach(group => {
                    group.classList.remove('selected', 'correct', 'incorrect', 'disabled');
                });
            }

            renderOptions(options) {
                const container = document.getElementById('optionsContainer');
                container.innerHTML = '';
                
                options.forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option-group';
                    optionDiv.dataset.index = index;
                    
                    const label = document.createElement('div');
                    label.className = 'option-label';
                    label.textContent = String.fromCharCode(65 + index); // A, B, C, D, E
                    
                    const grid = document.createElement('div');
                    grid.className = 'game-grid';
                    
                    option.shapes.forEach(cellData => {
                        const cell = document.createElement('div');
                        cell.className = 'game-cell';
                        
                        const shapesContainer = document.createElement('div');
                        shapesContainer.className = 'shapes-container';
                        
                        cellData.shapes.forEach(shapeData => {
                            const shapeDiv = document.createElement('div');
                            const shapeClass = cellData.shapes.length === 1 ? 'shape single' : 'shape';
                            shapeDiv.className = `${shapeClass} ${shapeData.type}`;
                            
                            if (shapeData.type === 'triangle') {
                                shapeDiv.style.borderBottomColor = this.colors[shapeData.color];
                            } else {
                                shapeDiv.style.backgroundColor = this.colors[shapeData.color];
                            }
                            
                            shapesContainer.appendChild(shapeDiv);
                        });
                        
                        const numberDiv = document.createElement('div');
                        numberDiv.className = `number ${cellData.pos}`;
                        numberDiv.textContent = cellData.num;
                        
                        cell.appendChild(shapesContainer);
                        cell.appendChild(numberDiv);
                        grid.appendChild(cell);
                    });
                    
                    optionDiv.appendChild(label);
                    optionDiv.appendChild(grid);
                    container.appendChild(optionDiv);
                    
                    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                    optionDiv.addEventListener('click', () => this.selectOption(index));
                });
            }

            selectOption(index) {
                if (this.gameCompleted) return;
                
                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
                document.querySelectorAll('.option-group').forEach(group => {
                    group.classList.remove('selected');
                });
                
                // é€‰æ‹©æ–°çš„é€‰é¡¹
                document.querySelector(`[data-index="${index}"]`).classList.add('selected');
                this.selectedOption = index;
                
                // å¯ç”¨æäº¤æŒ‰é’®
                const submitButton = document.querySelector('.interactive-button.submit');
                if (submitButton) {
                    submitButton.classList.remove('disabled');
                    submitButton.style.pointerEvents = 'auto';
                    submitButton.style.opacity = '1';
                }
            }

            submitAnswer() {
                if (this.selectedOption === null || this.gameCompleted) return;
                
                const isCorrect = this.selectedOption === this.wrongAnswerIndex;
                // åˆ¤æ–­æ˜¯å¦æ˜¯æœ€åä¸€é¢˜
                const isLastQuestion = this.currentQuestion >= this.questionsPerStage;
                
                if (isCorrect) {
                    // ç­”å¯¹äº†ï¼Œæ‰¾åˆ°äº†é”™è¯¯çš„é€‰é¡¹
                    this.totalQuestions++;
                    this.correctAnswers++;
                    this.score += 10;
                    this.gameCompleted = true;
                    
                    // æ·»åŠ ç§¯åˆ†
                    const pointsEarned = this.calculatePointsForCorrectAnswer();
                    this.addTrainingPoints(pointsEarned);
                    
                    // æ›´æ–°æœ€é«˜åˆ†æ•°
                    if (this.score > this.highestScore) {
                        this.highestScore = this.score;
                    }
                    
                    // æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆå¹¶ç¦ç”¨é€‰æ‹©
                    document.querySelectorAll('.option-group').forEach((group, index) => {
                        if (index === this.wrongAnswerIndex) {
                            group.classList.add('correct');
                        }
                        group.classList.add('disabled');
                    });
                    
                    // æ ¹æ®æ˜¯å¦æ˜¯æœ€åä¸€é¢˜ï¼Œæ”¹å˜æŒ‰é’®æ–‡æœ¬å’Œäº‹ä»¶
                    const submitButton = document.querySelector('.interactive-button.submit');
                    if (submitButton) {
                        if (isLastQuestion) {
                            submitButton.textContent = 'å®Œæˆ';
                            submitButton.onclick = () => this.endGame();
                        } else {
                            submitButton.textContent = 'ä¸‹ä¸€é¢˜';
                            submitButton.onclick = () => this.nextLevel();
                        }
                        submitButton.classList.remove('disabled');
                        submitButton.style.pointerEvents = 'auto';
                        submitButton.style.opacity = '1';
                    }
                    
                    this.updateStats();
                    this.showFeedback(true, this.currentLevel_rule.explanation);
                } else {
                    // ç­”é”™äº†ï¼Œé€‰æ‹©äº†æ­£ç¡®çš„é€‰é¡¹
                    this.wrongAnswers++;
                    this.totalQuestions++;
                    this.gameCompleted = true;
                    
                    // æ˜¾ç¤ºé”™è¯¯çš„é€‰é¡¹å’Œæ­£ç¡®ç­”æ¡ˆ
                    document.querySelector(`[data-index="${this.selectedOption}"]`).classList.add('incorrect');
                    document.querySelector(`[data-index="${this.wrongAnswerIndex}"]`).classList.add('correct');
                    
                    // ç¦ç”¨æ‰€æœ‰é€‰æ‹©
                    document.querySelectorAll('.option-group').forEach(group => {
                        group.classList.add('disabled');
                    });
                    
                    // æ ¹æ®æ˜¯å¦æ˜¯æœ€åä¸€é¢˜ï¼Œæ”¹å˜æŒ‰é’®æ–‡æœ¬å’Œäº‹ä»¶
                    const submitButton = document.querySelector('.interactive-button.submit');
                    if (submitButton) {
                        if (isLastQuestion) {
                            submitButton.textContent = 'å®Œæˆ';
                            submitButton.onclick = () => this.endGame();
                        } else {
                            submitButton.textContent = 'ä¸‹ä¸€é¢˜';
                            submitButton.onclick = () => this.nextLevel();
                        }
                        submitButton.classList.remove('disabled');
                        submitButton.style.pointerEvents = 'auto';
                        submitButton.style.opacity = '1';
                    }
                    
                    // æ˜¾ç¤ºé”™è¯¯åé¦ˆ
                    this.showFeedback(false, this.currentLevel_rule.explanation);
                    
                    this.updateStats();
                }
            }
            
            showFeedback(isCorrect, explanation) {
                // ä½¿ç”¨æç¤ºå¼¹çª—æ˜¾ç¤ºåé¦ˆ
                const overlay = document.getElementById('hintOverlay');
                const hintIcon = document.getElementById('hintIcon');
                const hintTextElement = document.getElementById('hintText');
                const closeBtn = document.getElementById('hintCloseBtn');
                
                // åˆ¤æ–­æ˜¯å¦æ˜¯æœ€åä¸€é¢˜
                const isLastQuestion = this.currentQuestion >= this.questionsPerStage;
                
                if (isCorrect) {
                    hintIcon.textContent = 'ğŸ‰ æ­£ç¡®ï¼';
                    hintTextElement.textContent = explanation;
                    // å¦‚æœæ˜¯æœ€åä¸€é¢˜ï¼Œä¸æ˜¾ç¤ºæŒ‰é’®æ–‡æœ¬ï¼ˆæˆ–æ˜¾ç¤º"å®Œæˆ"ï¼‰
                    if (isLastQuestion) {
                        closeBtn.textContent = 'å®Œæˆ';
                    } else {
                        closeBtn.textContent = 'ä¸‹ä¸€é¢˜';
                    }
                } else {
                    hintIcon.textContent = 'âŒ é”™è¯¯ï¼';
                    hintTextElement.textContent = explanation;
                    // é”™è¯¯æ—¶ä¿æŒ"çŸ¥é“äº†"
                    closeBtn.textContent = 'çŸ¥é“äº†';
                }
                
                overlay.classList.add('show');
                
                // ç‚¹å‡»å…³é—­æŒ‰é’®æˆ–é®ç½©å±‚å…³é—­æç¤ºæ¡†
                const closeHandler = () => {
                    overlay.classList.remove('show');
                    closeBtn.removeEventListener('click', closeHandler);
                    overlay.removeEventListener('click', overlayClickHandler);
                    
                    // å¦‚æœç­”å¯¹äº†ï¼Œæ ¹æ®æ˜¯å¦æ˜¯æœ€åä¸€é¢˜å†³å®šè¡Œä¸º
                    if (isCorrect) {
                        if (isLastQuestion) {
                            // æœ€åä¸€é¢˜ï¼Œç›´æ¥è§¦å‘æ¸¸æˆç»“æŸ
                            this.endGame();
                        } else {
                            // ä¸æ˜¯æœ€åä¸€é¢˜ï¼Œè¿›å…¥ä¸‹ä¸€é¢˜
                            this.nextLevel();
                        }
                    }
                };
                
                const overlayClickHandler = (e) => {
                    if (e.target === overlay) {
                        closeHandler();
                    }
                };
                
                closeBtn.addEventListener('click', closeHandler);
                overlay.addEventListener('click', overlayClickHandler);
            }

            // é‡å¤ä»£ç å·²åˆ é™¤ï¼Œä¿ç•™å¤§å…³å¡ç³»ç»Ÿå®ç°

            nextLevel() {
                this.clearAutoNext();
                
                // å¢åŠ å½“å‰å¤§å…³å¡çš„é¢˜ç›®ç¼–å·
                this.currentQuestion++;
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆå½“å‰å¤§å…³å¡
                if (this.currentQuestion > this.questionsPerStage) {
                    // å®Œæˆå½“å‰å¤§å…³å¡ï¼Œç›´æ¥ç»“æŸæ¸¸æˆ
                    this.endGame();
                    return;
                }
                
                // ç»§ç»­å½“å‰å¤§å…³å¡çš„ä¸‹ä¸€é¢˜
                this.loadLevel();
            }

            showHint() {
                const optionCount = this.stageConfig[this.currentStage].options;
                const correctCount = optionCount - 1;
                
                const defaultHint = `è§‚å¯Ÿ${correctCount}ä¸ªæ­£ç¡®é€‰é¡¹æ‰¾å‡ºè§„å¾‹ï¼Œç„¶åæ‰¾å‡ºé‚£ä¸ªä¸ç¬¦åˆè§„å¾‹çš„é€‰é¡¹ã€‚`;
                
                const hintText = this.currentLevel_rule ? 
                    this.currentLevel_rule.explanation : 
                    defaultHint;
                
                this.showHintModal(hintText);
            }
            
            showHintModal(text) {
                const overlay = document.getElementById('hintOverlay');
                const hintTextElement = document.getElementById('hintText');
                
                hintTextElement.textContent = text;
                overlay.classList.add('show');
                
                // ç‚¹å‡»å…³é—­æŒ‰é’®æˆ–é®ç½©å±‚å…³é—­æç¤ºæ¡†
                const closeBtn = document.getElementById('hintCloseBtn');
                const closeHandler = () => {
                    overlay.classList.remove('show');
                    closeBtn.removeEventListener('click', closeHandler);
                    overlay.removeEventListener('click', overlayClickHandler);
                };
                
                const overlayClickHandler = (e) => {
                    if (e.target === overlay) {
                        closeHandler();
                    }
                };
                
                closeBtn.addEventListener('click', closeHandler);
                overlay.addEventListener('click', overlayClickHandler);
            }

            showPointsModal() {
                // æŸ¥è¯¢æœ€æ–°çš„ç§¯åˆ†æ•°æ®
                this.queryTotalTrainingPoints();
                
                const modal = document.getElementById('pointsModal');
                modal.classList.remove('hidden');
                
                // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
                const overlayClickHandler = (e) => {
                    if (e.target === modal) {
                        this.hidePointsModal();
                        modal.removeEventListener('click', overlayClickHandler);
                    }
                };
                modal.addEventListener('click', overlayClickHandler);
            }

            hidePointsModal() {
                const modal = document.getElementById('pointsModal');
                modal.classList.add('hidden');
            }

            showRulesModal() {
                const modal = document.getElementById('rulesModal');
                modal.classList.remove('hidden');
                
                // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
                const overlayClickHandler = (e) => {
                    if (e.target === modal) {
                        this.hideRulesModal();
                        modal.removeEventListener('click', overlayClickHandler);
                    }
                };
                modal.addEventListener('click', overlayClickHandler);
            }

            hideRulesModal() {
                const modal = document.getElementById('rulesModal');
                modal.classList.add('hidden');
                
                // å¦‚æœè¿™æ˜¯ç¬¬ä¸€æ¬¡å…³é—­è§„åˆ™å¼¹çª—ä¸”æœ‰æ¨èéš¾åº¦ï¼Œé«˜äº®éš¾åº¦é€‰æ‹©å™¨
                if (!this.hasShownInitialRules && this.recommendedStage !== null) {
                    this.hasShownInitialRules = true;
                    this.highlightLevelSelect();
                }
            }

            updateRecommendedDifficultyDisplay() {
                const recommendedRow = document.getElementById('recommendedDifficultyRow');
                const recommendedSpan = document.getElementById('recommendedDifficulty');
                
                if (this.recommendedStage !== null && this.recommendedStageName) {
                    recommendedSpan.textContent = `ã€${this.recommendedStageName}ã€‘`;
                    recommendedRow.style.display = 'list-item';
                } else {
                    recommendedRow.style.display = 'none';
                }
            }

            highlightLevelSelect() {
                const levelSelect = document.getElementById('levelSelect');
                if (levelSelect) {
                    // æ·»åŠ é«˜äº®æ ·å¼
                    const boxShadowSize = 1.5 * this.rootFontSize / 10; // è½¬æ¢ä¸ºå®é™…pxå€¼
                    levelSelect.style.transition = 'all 0.3s ease';
                    levelSelect.style.boxShadow = `0 0 ${boxShadowSize}rem rgba(59, 130, 246, 0.8)`;
                    levelSelect.style.borderColor = '#3b82f6';
                    levelSelect.style.transform = 'scale(1.05)';
                    
                    // 2ç§’åç§»é™¤é«˜äº®
                    setTimeout(() => {
                        levelSelect.style.boxShadow = '';
                        levelSelect.style.borderColor = '';
                        levelSelect.style.transform = '';
                    }, 2000);
                }
            }

            queryTotalTrainingPoints() {
                window.parent.postMessage({ type: 'getTotalTrainingPoints' }, '*');
            }

            updatePointsDisplay() {
                document.getElementById('totalPointsDisplay').textContent = this.globalTotalPoints;
                document.getElementById('dailyPointsDisplay').textContent = '+' + this.globalDailyPoints;
                document.getElementById('lastUpdateDateDisplay').textContent = this.lastUpdateDate;
                document.getElementById('totalHistoryPoints').textContent = this.globalTotalPoints;
            }

            calculatePointsForCorrectAnswer() {
                // æ ¹æ®å½“å‰å¤§å…³å¡è®¡ç®—ç§¯åˆ†
                const stagePoints = {
                    1: 5,  // åŸºç¡€éš¾åº¦
                    2: 10, // è¿›é˜¶éš¾åº¦
                    3: 15  // é«˜çº§éš¾åº¦
                };
                return stagePoints[this.currentStage] || 5;
            }

            addTrainingPoints(points) {
                this.earnedPoints += points;
                this.totalGamePoints += points;
                
                // å‘é€æ¶ˆæ¯ç»™çˆ¶çª—å£æ˜¾ç¤ºè·å¾—ç§¯åˆ†çš„äº¤äº’
                window.parent.postMessage({
                    type: 'showTrainingPoints',
                    points: points
                }, '*');
            }

            updateStats() {
                const accuracy = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;
                this.updateProgress();
                this.updatePointsDisplay();
            }
            
            updateProgress() {
                // æ›´æ–°é¢˜ç›®è¿›åº¦æ˜¾ç¤º
                document.getElementById('progress').textContent = this.currentQuestion;
                document.getElementById('totalQuestions').textContent = this.questionsPerStage;
            }

            // è®¡ç®—ç™¾åˆ†åˆ¶åˆ†æ•°
            calculatePercentageScore() {
                const maxPossibleQuestions = this.maxStages * this.questionsPerStage; // æ€»é¢˜ç›®æ•°
                const accuracy = this.totalQuestions > 0 ? (this.correctAnswers / this.totalQuestions) : 0;
                const progressScore = ((this.currentStage - 1) * this.questionsPerStage + this.currentQuestion - 1) / maxPossibleQuestions; // è¿›åº¦åˆ†æ•°
                
                // ç»¼åˆè€ƒè™‘å‡†ç¡®ç‡å’Œè¿›åº¦ï¼Œæ¢ç®—æˆç™¾åˆ†åˆ¶
                const percentageScore = Math.round((accuracy * 0.7 + progressScore * 0.3) * 100);
                return Math.min(100, Math.max(0, percentageScore));
            }

            endGame() {
                this.clearAutoNext();
                
                const percentageScore = this.calculatePercentageScore();
                
                // æ›´æ–°æœ€é«˜åˆ†æ•°ï¼ˆç™¾åˆ†åˆ¶ï¼‰
                if (percentageScore > this.highestScore) {
                    this.highestScore = percentageScore;
                }
                
                const accuracy = Math.round((this.correctAnswers / this.totalQuestions) * 100);
                
                // å‘é€æ¸¸æˆå®Œæˆæ¶ˆæ¯
                window.parent.postMessage({ 
                    type: 'gameFinished', 
                    data: { 
                        score: percentageScore, // ä½¿ç”¨ç™¾åˆ†åˆ¶åˆ†æ•°
                        currentScore: this.score, // ä¿ç•™åŸå§‹åˆ†æ•°ç”¨äºè°ƒè¯•
                        accuracy: accuracy,
                        difficulty: this.currentStage,
                        stagesCompleted: this.currentStage - 1,
                        totalQuestions: this.totalQuestions,
                        correctAnswers: this.correctAnswers,
                        earnedPoints: this.earnedPoints, // æ–°å¢ï¼šæœ¬æ¬¡æ¸¸æˆè·å¾—çš„æ€»ç§¯åˆ†
                        showAccuracy: true,
                        accuracy: accuracy,
                        accuracyTitle: 'é¢˜ç›®',
                        isMaxDifficulty: this.currentStage === 3,
                        levelCount: this.totalQuestions,
                    }
                }, '*');
            }

            // ä»¥å½“å‰éš¾åº¦é‡æ–°å¼€å§‹æ¸¸æˆ
            restartCurrentDifficulty() {
                this.clearAutoNext();
                
                // ä¿æŒå½“å‰éš¾åº¦ï¼ˆcurrentStageï¼‰ï¼Œé‡ç½®å…¶ä»–æ¸¸æˆçŠ¶æ€
                this.currentQuestion = 1;
                this.wrongAnswers = 0;
                this.score = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.selectedOption = null;
                this.earnedPoints = 0; // é‡ç½®æœ¬æ¬¡è·å¾—ç§¯åˆ†
                this.totalGamePoints = 0; // é‡ç½®æ¸¸æˆå†…æ€»ç§¯åˆ†
                
                // æ›´æ–°UIæ˜¾ç¤º
                this.updateStats();
                this.setupLevelSelect();
                
                // é‡æ–°åŠ è½½å…³å¡
                this.loadLevel();
                
                console.log(`é‡æ–°å¼€å§‹æ¸¸æˆ - å½“å‰éš¾åº¦: ${this.stageConfig[this.currentStage].name}`);
            }

            // ä»¥ä¸‹ä¸€ä¸ªéš¾åº¦å¼€å§‹æ¸¸æˆ
            challengeNextDifficulty() {
                this.clearAutoNext();
                
                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸‹ä¸€ä¸ªéš¾åº¦
                if (this.currentStage < this.maxStages) {
                    // å‡çº§åˆ°ä¸‹ä¸€ä¸ªéš¾åº¦
                    this.currentStage += 1;
                    console.log(`æŒ‘æˆ˜ä¸‹ä¸€éš¾åº¦: ${this.stageConfig[this.currentStage].name}`);
                } else {
                    // å·²ç»æ˜¯æœ€é«˜éš¾åº¦ï¼Œä¿æŒå½“å‰éš¾åº¦
                    console.log(`å·²ç»æ˜¯æœ€é«˜éš¾åº¦: ${this.stageConfig[this.currentStage].name}ï¼Œä¿æŒå½“å‰éš¾åº¦é‡æ–°å¼€å§‹`);
                }
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.currentQuestion = 1;
                this.wrongAnswers = 0;
                this.score = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.selectedOption = null;
                this.earnedPoints = 0; // é‡ç½®æœ¬æ¬¡è·å¾—ç§¯åˆ†
                this.totalGamePoints = 0; // é‡ç½®æ¸¸æˆå†…æ€»ç§¯åˆ†
                
                // æ›´æ–°UIæ˜¾ç¤º
                this.updateStats();
                this.setupLevelSelect();
                
                // é‡æ–°åŠ è½½å…³å¡
                this.loadLevel();
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new AbstractReasoningGame();

        // æ·»åŠ æ¶ˆæ¯ç›‘å¬å™¨å¤„ç†æ¸¸æˆé…ç½®å’ŒçŠ¶æ€è¯·æ±‚
        window.addEventListener('message', function (e) {
            switch (e.data.type) {
                case 'setGameConfig':
                    game.game_config = e.data.data; // è¿™æ˜¯markdownæˆ–æ–‡æœ¬å­—ç¬¦ä¸²
                    
                    // æ ¹æ®levelNameè®¾ç½®æ¨èçš„åˆå§‹éš¾åº¦
                    let recommendedStage = null;
                    if (e.data.levelName) {
                        switch (e.data.levelName) {
                            case 'å¾…æå‡':
                                recommendedStage = 1; // åŸºç¡€
                                break;
                            case 'è‰¯å¥½':
                                recommendedStage = 2; // è¿›é˜¶
                                break;
                            case 'ä¼˜å¼‚':
                                recommendedStage = 3; // é«˜çº§
                                break;
                        }
                        console.log('æ¨èå…³å¡:', recommendedStage);
                    }
                    
                    // æ ¹æ®é…ç½®æ›´æ–°æ¸¸æˆè®¾ç½®
                    if (game.game_config) {
                        try {
                            // å¯ä»¥æ ¹æ®é…ç½®å­—ç¬¦ä¸²è§£æéš¾åº¦ç­‰è®¾ç½®
                            if (game.game_config.includes('difficulty:')) {
                                const difficultyMatch = game.game_config.match(/difficulty:\s*(\d+)/);
                                if (difficultyMatch) {
                                    game.difficulty = parseInt(difficultyMatch[1]);
                                    // æ ¹æ®éš¾åº¦è°ƒæ•´æ¸¸æˆå‚æ•°
                                    if (game.difficulty === 1) {
                                        game.questionsPerStage = 10; // ç®€å•éš¾åº¦ï¼šæ¯ä¸ªå¤§å…³å¡10é¢˜
                                    } else if (game.difficulty === 2) {
                                        game.questionsPerStage = 12; // ä¸­ç­‰éš¾åº¦ï¼šæ¯ä¸ªå¤§å…³å¡12é¢˜
                                    } else if (game.difficulty === 3) {
                                        game.questionsPerStage = 15; // å›°éš¾æ¨¡å¼ï¼šæ¯ä¸ªå¤§å…³å¡15é¢˜
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('è§£ææ¸¸æˆé…ç½®å¤±è´¥:', error);
                        }
                    }
                    
                    // åº”ç”¨æ¨èçš„åˆå§‹éš¾åº¦
                    if (recommendedStage !== null) {
                        // å¦‚æœå·²æœ‰é…ç½®éš¾åº¦ï¼Œå–æ›´é«˜çš„éš¾åº¦å€¼
                        if (game.difficulty && game.currentStage) {
                            game.currentStage = Math.max(game.currentStage, recommendedStage);
                        } else {
                            game.currentStage = recommendedStage;
                        }
                        
                        // ä¿å­˜æ¨èéš¾åº¦ä¿¡æ¯ï¼Œç”¨äºåœ¨è§„åˆ™å¼¹çª—ä¸­æ˜¾ç¤º
                        game.recommendedStage = recommendedStage;
                        game.recommendedStageName = game.stageConfig[recommendedStage].name;
                        
                        // æ›´æ–°å…³å¡é€‰æ‹©å™¨æ˜¾ç¤º
                        game.setupLevelSelect();
                        
                        // æ›´æ–°è§„åˆ™å¼¹çª—ä¸­çš„æ¨èéš¾åº¦æ˜¾ç¤º
                        game.updateRecommendedDifficultyDisplay();
                        
                        // æ›´æ–°æ­£ç¡®éš¾åº¦çš„é¢˜ç›®
                        game.loadLevel();
                    }
                    
                    // æŸ¥è¯¢æ€»ç§¯åˆ†
                    game.queryTotalTrainingPoints();
                    break;
                case 'getGameStats':
                    const percentageScore = game.calculatePercentageScore();
                    window.parent.postMessage({ 
                        type: 'gameStats', 
                        data: {
                            score: Math.max(percentageScore, game.highestScore), // è¿”å›ç™¾åˆ†åˆ¶åˆ†æ•°
                            currentScore: game.score, // ä¿ç•™åŸå§‹åˆ†æ•°
                            difficulty: game.difficulty,
                            accuracy: game.totalQuestions > 0 ? Math.round((game.correctAnswers / game.totalQuestions) * 100) : 0,
                            currentStage: game.currentStage,
                            currentQuestion: game.currentQuestion,
                            wrongAnswers: game.wrongAnswers,
                            totalQuestions: game.totalQuestions,
                            correctAnswers: game.correctAnswers,
                            earnedPoints: game.earnedPoints // æ–°å¢ï¼šæœ¬æ¬¡è·å¾—çš„ç§¯åˆ†
                        }
                    }, '*');
                    break;
                case 'gameContinue':
                    if (e.data.action === 'restart') {
                        // ä»¥å½“å‰éš¾åº¦é‡æ–°å¼€å§‹æ¸¸æˆ
                        game.restartCurrentDifficulty();
                    } else if (e.data.action === 'challenge') {
                        // ä»¥ä¸‹ä¸€ä¸ªéš¾åº¦å¼€å§‹æ¸¸æˆ
                        game.challengeNextDifficulty();
                    }
                    break;
                case 'trainingPointsResponse':
                    // æ”¶åˆ°ç§¯åˆ†æ·»åŠ æˆåŠŸçš„å›å¤
                    if (e.data.addedPoints !== undefined) {
                        game.globalTotalPoints = e.data.totalPoints || game.globalTotalPoints;
                        game.updatePointsDisplay();
                    }
                    break;
                case 'totalTrainingPointsResponse':
                    // æ”¶åˆ°æ€»ç§¯åˆ†æŸ¥è¯¢çš„å›å¤
                    game.globalTotalPoints = e.data.total || 0;
                    game.globalDailyPoints = e.data.dailyTotal || 0;
                    game.lastUpdateDate = e.data.lastUpdateDate || '--';
                    game.updatePointsDisplay();
                    break;
            }
        });
    </script>
</body>
</html>
