<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å½±å­éª‘å£«</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdnproxy.keepwork.com/jsdelivr/npm/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif;min-height:700px;height:90vh}
        #gameContainer { position: relative; width: 100%; height: 100%; }
        #ui { 
            position: fixed; 
            top: 0; 
            left: 15px; 
            z-index: 100; 
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none; /* è®©UIåŒºåŸŸé»˜è®¤ä¸é˜»æŒ¡é¼ æ ‡äº‹ä»¶ */
        }
        #gameCanvas {
            width: 100%;
            height: 100vh;
        }
        #successEffect { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #4ade80;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: all 0.5s ease;
        }
        .success-show {
            opacity: 1 !important;
            transform: translate(-50%, -50%) scale(1.2) !important;
        }
        
        /* æ¸¸æˆè§„åˆ™å¼¹çª—æ ·å¼ */
        .modal-overlay {
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            animation: slideIn 0.3s ease;
            max-width: 90vw;
            max-height: 90vh;
            width: 100%;
            height: auto;
        }
        
        .modal-body {
            max-height: calc(90vh - 160px);
            overflow-y: auto;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* å¸®åŠ©æŒ‰é’® */
        .help-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 40;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .help-btn:hover {
            transform: scale(1.1);
        }
        
        /* å·¦ä¾§æ‚¬æµ®é¢æ¿æ ·å¼ */
        .ui-section {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* æ¢å¤UIå…ƒç´ çš„é¼ æ ‡äº‹ä»¶ */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ui-section #cubeCount {
            font-size: 1.2rem;
        }
        
        .ui-button {
            width: 100%;
            padding: 10px 16px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            text-align: center;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .ui-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .ui-button:active {
            transform: translateY(0);
        }
        
        .ui-select {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border-radius: 8px;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            min-height: 44px;
        }
        
        .ui-label {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: 8px;
            display: block;
        }
        
        .info-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 14px;
            line-height: 1.4;
        }
        
        /* ä¸“é—¨ä¸ºç§»åŠ¨è®¾å¤‡ä¼˜åŒ–çš„æ ·å¼ */
        @media (max-width: 768px) {
            #ui {
                position: fixed;
                top: 10px;
                left: 10px;
                right: 10px;
                bottom: auto;
                width: auto;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
                max-height: 180px;
                overflow-y: auto;
            }
            
            #gameCanvas {
                width: 100%;
                height: 100vh;
            }
            
            .ui-section {
                flex: 1;
                min-width: calc(50% - 8px);
                padding: 10px;
            }
            
            .ui-button {
                padding: 10px 12px;
                font-size: 12px;
                min-height: 40px;
            }
            
            .ui-select {
                padding: 10px;
                font-size: 12px;
                min-height: 40px;
            }
            
            .ui-label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .info-display {
                font-size: 12px;
                padding: 10px;
            }
            
            .help-btn {
                width: 50px;
                height: 50px;
                bottom: 15px;
                right: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .ui-section {
                min-width: 100%;
                margin-bottom: 6px;
            }
            
            .ui-button {
                padding: 8px 12px;
                font-size: 11px;
                min-height: 36px;
            }
            
            .ui-select {
                padding: 8px;
                font-size: 11px;
                min-height: 36px;
            }
        }
        
        /* å°å±å¹•æ—¶éšè—éƒ¨åˆ†UIä»¥èŠ‚çœç©ºé—´ */
        @media (max-height: 600px) {
            .ui-section:last-child {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
    <div id="rulesModal" class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden flex items-center justify-center z-50 p-4" style="z-index: 9999;">
        <div class="modal-content bg-white rounded-2xl shadow-2xl max-w-4xl">
            <div class="p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-bold text-gray-800">å½±å­éª‘å£«è§„åˆ™</h2>
                    <button id="closeRules" class="text-gray-500 hover:text-gray-700 text-3xl">&times;</button>
                </div>
                
                <div class="modal-body">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="space-y-4">
                            <div class="bg-blue-50 p-4 rounded-lg">
                                <h3 class="font-bold text-blue-800 text-lg mb-2">ğŸ¯ æ¸¸æˆç›®æ ‡</h3>
                                <p class="text-gray-700">æ ¹æ®å¢™å£ä¸Šçš„æŠ•å½±ï¼Œåœ¨3Dç©ºé—´ä¸­æ”¾ç½®ç«‹æ–¹ä½“ï¼Œä½¿å…¶äº§ç”Ÿæ­£ç¡®çš„æ­£é¢å’Œå³ä¾§æŠ•å½±ã€‚</p>
                            </div>
                            
                            <div class="bg-green-50 p-4 rounded-lg">
                                <h3 class="font-bold text-green-800 text-lg mb-2">ğŸ® æ“ä½œæ–¹æ³•</h3>
                                <ul class="text-gray-700 space-y-1 text-sm">
                                    <li><strong>å·¦é”®ç‚¹å‡»</strong>ï¼šåœ¨å¹³å°ä¸Šæ”¾ç½®æ–¹å—</li>
                                    <li><strong>å³é”®/é•¿æŒ‰</strong>ï¼šåˆ é™¤æ–¹å—</li>
                                    <li><strong>æ—‹è½¬æŒ‰é’®</strong>ï¼šæ”¹å˜è§‚å¯Ÿè§’åº¦</li>
                                    <li><strong>æ’¤é”€æŒ‰é’®</strong>ï¼šæ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ</li>
                                </ul>
                            </div>
                            
                            <div class="bg-purple-50 p-4 rounded-lg">
                                <h3 class="font-bold text-purple-800 text-lg mb-2">ğŸ“Š æŠ•å½±è¯´æ˜</h3>
                                <ul class="text-gray-700 space-y-1 text-sm">
                                    <li><strong>é»‘è‰²æ–¹å—</strong>ï¼šæ­£ç¡®çš„æŠ•å½±ä½ç½®</li>
                                    <li><strong>ç°è‰²æ–¹å—</strong>ï¼šç›®æ ‡æŠ•å½±ä½†æœªå®ç°</li>
                                    <li><strong>çº¢è‰²X</strong>ï¼šé”™è¯¯çš„æŠ•å½±ä½ç½®</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="space-y-4">
                            <div class="bg-orange-50 p-4 rounded-lg">
                                <h3 class="font-bold text-orange-800 text-lg mb-2">ğŸ† è®¡åˆ†è§„åˆ™</h3>
                                <ul class="text-gray-700 space-y-1 text-sm">
                                    <li>ä½¿ç”¨æœ€å°‘çš„æ–¹å—å®ŒæˆæŒ‘æˆ˜è·å¾—é«˜åˆ†</li>
                                    <li>é”™è¯¯æ¬¡æ•°ä¼šå½±å“æœ€ç»ˆå¾—åˆ†</li>
                                    <li>å®Œæˆæ—¶é—´è¶ŠçŸ­å¾—åˆ†è¶Šé«˜</li>
                                    <li>å…±5å…³ï¼Œæœ€ç»ˆå¾—åˆ†ä¸ºç»¼åˆè¯„åˆ†</li>
                                </ul>
                            </div>
                            
                            <div class="bg-yellow-50 p-4 rounded-lg">
                                <h3 class="font-bold text-yellow-800 text-lg mb-2">ğŸ’¡ æ¸¸æˆæŠ€å·§</h3>
                                <ul class="text-gray-700 space-y-1 text-sm">
                                    <li>ä»”ç»†è§‚å¯Ÿä¸¤ä¸ªå¢™é¢çš„æŠ•å½±</li>
                                    <li>ä»åº•å±‚å¼€å§‹æ­å»ºï¼Œç¡®ä¿è¿é€šæ€§</li>
                                    <li>å¤šè§’åº¦æ—‹è½¬è§‚å¯Ÿç©ºé—´ç»“æ„</li>
                                    <li>å–„ç”¨æ’¤é”€åŠŸèƒ½è°ƒæ•´å¸ƒå±€</li>
                                </ul>
                            </div>
                            
                            <div class="bg-red-50 p-4 rounded-lg">
                                <h3 class="font-bold text-red-800 text-lg mb-2">âš ï¸ æ³¨æ„äº‹é¡¹</h3>
                                <ul class="text-gray-700 space-y-1 text-sm">
                                    <li>æ–¹å—å¿…é¡»è¿é€šï¼ˆç›¸é‚»æˆ–åœ¨åœ°é¢ï¼‰</li>
                                    <li>æŠ•å½±æ˜¯ä»æ­£é¢å’Œå³ä¾§è§‚å¯Ÿçš„ç»“æœ</li>
                                    <li>æ—‹è½¬ä¸ä¼šæ”¹å˜æŠ•å½±ï¼Œåªæ”¹å˜è§†è§’</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 text-center">
                    <button id="startGameFromRules" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg transition-all transform hover:scale-105">
                        å¼€å§‹æ¸¸æˆ
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="gameContainer">
        <!-- å·¦ä¾§UIé¢æ¿ -->
        <div id="ui" class="text-white">
            <!-- ç½‘æ ¼è®¾ç½®åŒºåŸŸ -->
            <div class="ui-section" style="height: 0; visibility: hidden">
                <label class="ui-label">ç½‘æ ¼å¤§å°</label>
                <select id="gridSize" class="ui-select">
                    <option value="3" selected>3Ã—3 ç½‘æ ¼</option>
                    <option value="4">4Ã—4 ç½‘æ ¼</option>
                    <option value="5">5Ã—5 ç½‘æ ¼</option>
                </select>
            </div>
            
            <!-- æ¸¸æˆæ§åˆ¶åŒºåŸŸ -->
            <div class="ui-section">
                <button id="newGame" class="ui-button bg-blue-600 hover:bg-blue-700 text-white mb-3">
                    ğŸ® æ–°æ¸¸æˆ
                </button>
                <button id="undo" class="ui-button bg-orange-600 hover:bg-orange-700 text-white">
                    â†©ï¸ æ’¤é”€æ“ä½œ
                </button>
            </div>
            
            <!-- è§†è§’æ§åˆ¶åŒºåŸŸ -->
            <div class="ui-section">
                <button id="rotateLeft" class="ui-button bg-purple-600 hover:bg-purple-700 text-white mb-3">
                    âŸ² å‘å·¦æ—‹è½¬
                </button>
                <button id="rotateRight" class="ui-button bg-purple-600 hover:bg-purple-700 text-white">
                    âŸ³ å‘å³æ—‹è½¬
                </button>
            </div>
            
            <!-- æ¸¸æˆä¿¡æ¯åŒºåŸŸ -->
            <div class="ui-section">
                <div id="cubeCount" class="info-display text-center">
                    <!-- æ¸¸æˆä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
            
            <!-- æ“ä½œè¯´æ˜åŒºåŸŸ -->
            <div class="ui-section">
                <div class="info-display text-base">
                    <div class="mb-2"><strong>æ“ä½œè¯´æ˜ï¼š</strong></div>
                    <div>â€¢ å·¦é”®ï¼šæ”¾ç½®æ–¹å—</div>
                    <div>â€¢ å³é”®/é•¿æŒ‰ï¼šåˆ é™¤æ–¹å—</div>
                    <div class="mt-2"><strong>æŠ•å½±è¯´æ˜ï¼š</strong></div>
                    <div>â€¢ é»‘è‰²ï¼šæ­£ç¡®æŠ•å½±</div>
                    <div>â€¢ ç°è‰²ï¼šç›®æ ‡æŠ•å½±</div>
                    <div>â€¢ çº¢è‰²Xï¼šé”™è¯¯æŠ•å½±</div>
                </div>
            </div>
        </div>
        
        <!-- æ¸¸æˆç”»å¸ƒåŒºåŸŸ -->
        <div id="gameCanvas"></div>
        
        <div id="successEffect">ğŸ‰ å®Œç¾ï¼ä¸‹ä¸€å…³...</div>
    </div>
    
    <!-- å¸®åŠ©æŒ‰é’® -->
    <button id="helpBtn" class="help-btn bg-blue-500 hover:bg-blue-600 text-white" title="æŸ¥çœ‹æ¸¸æˆè§„åˆ™">
        <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
    </button>

    <script>
        // æ¸¸æˆç»Ÿè®¡å’Œæ¶ˆæ¯é€šä¿¡
        let game_config = '';
        let bestScore = 0;
        let currentGameScore = 0;
        let gameStarted = false;

        // è®¡ç®—åˆ†æ•°ï¼šåŸºäºç½‘æ ¼å¤§å°ã€ç”¨æ—¶å’Œé”™è¯¯æ¬¡æ•°ï¼Œæœ€é«˜100åˆ†
        function calculateGameScore(gridSize, timeInSeconds, errorCount) {
            const maxScore = 100;
            
            // åŸºç¡€åˆ†æ•°ï¼šç½‘æ ¼è¶Šå¤§åˆ†æ•°è¶Šé«˜
            let baseScore = 0;
            if (gridSize === 3) baseScore = 30;      // ç®€å•ï¼š30åˆ†
            else if (gridSize === 4) baseScore = 50; // ä¸­ç­‰ï¼š50åˆ†
            else if (gridSize === 5) baseScore = 70; // å›°éš¾ï¼š70åˆ†
            
            // æ—¶é—´å¥–åŠ±ï¼šåœ¨åˆç†æ—¶é—´å†…å®Œæˆæœ‰æ—¶é—´å¥–åŠ±
            const timeTargets = { 3: 60, 4: 120, 5: 180 }; // å„éš¾åº¦çš„ç›®æ ‡æ—¶é—´(ç§’)
            const targetTime = timeTargets[gridSize] || 120;
            const timeBonus = Math.max(0, 20 - Math.floor(timeInSeconds / targetTime * 20)); // æœ€å¤š20åˆ†æ—¶é—´å¥–åŠ±
            
            // é”™è¯¯æƒ©ç½šï¼šæ¯æ¬¡é”™è¯¯æ‰£5åˆ†
            const errorPenalty = Math.min(errorCount * 5, 20); // æœ€å¤šæ‰£20åˆ†
            
            return Math.min(maxScore, Math.max(10, baseScore + timeBonus - errorPenalty));
        }

        // è·å–éš¾åº¦ç­‰çº§
        function getDifficultyLevel(gridSize) {
            if (gridSize === 3) return 1; // ç®€å•
            if (gridSize === 4) return 2; // ä¸­ç­‰
            return 3; // å›°éš¾
        }

        // æ¶ˆæ¯ç›‘å¬å™¨
        window.addEventListener('message', function (e) {
            switch (e.data.type) {
                case 'setGameConfig':
                    game_config = e.data.data; // this is markdown or text string
                    // æ›´æ–°æ¸¸æˆé…ç½®é€»è¾‘
                    console.log('Game config updated:', game_config);
                    break;
                case 'getGameStats':
                    window.parent.postMessage({ 
                        type: 'gameStats', 
                        data: {
                            score: bestScore, // æ°¸è¿œè¿”å›æœ€é«˜åˆ†
                            difficulty: getDifficultyLevel(game.gridSize)
                        }
                    }, '*');
                    break;
            }
        });

        // è§„åˆ™å¼¹çª—æ§åˆ¶
        function initRulesModal() {
            const rulesModal = document.getElementById('rulesModal');
            const closeRules = document.getElementById('closeRules');
            const startGameFromRules = document.getElementById('startGameFromRules');
            const helpBtn = document.getElementById('helpBtn');
            
            // å…³é—­è§„åˆ™å¼¹çª—
            function closeRulesModal() {
                rulesModal.classList.add('hidden');
            }
            
            // æ‰“å¼€è§„åˆ™å¼¹çª—
            function openRulesModal() {
                rulesModal.classList.remove('hidden');
            }
            
            closeRules.addEventListener('click', closeRulesModal);
            helpBtn.addEventListener('click', openRulesModal);
            
            // ä»è§„åˆ™å¼¹çª—å¼€å§‹æ¸¸æˆ
            startGameFromRules.addEventListener('click', () => {
                closeRulesModal();
                if (game) {
                    game.newGame();
                }
            });
            
            // ç‚¹å‡»é®ç½©å…³é—­
            rulesModal.addEventListener('click', (e) => {
                if (e.target === rulesModal) {
                    closeRulesModal();
                }
            });
        }
        
        class SpatialGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.gridSize = 3; // é»˜è®¤3x3
                this.cubes = new Map(); // å­˜å‚¨ç”¨æˆ·æ”¾ç½®çš„ç«‹æ–¹ä½“
                this.targetCubes = new Map(); // å­˜å‚¨ç›®æ ‡ç«‹æ–¹ä½“
                this.projectionCubes = []; // å­˜å‚¨æŠ•å½±ç«‹æ–¹ä½“
                this.cubeHistory = []; // å­˜å‚¨æ–¹å—æ”¾ç½®å†å²ï¼Œç”¨äºæ’¤é”€
                this.rotationSteps = 0; // ä½¿ç”¨æ­¥æ•°è€Œä¸æ˜¯è§’åº¦ï¼Œé¿å…æµ®ç‚¹æ•°ç´¯ç§¯è¯¯å·®
                this.isRotating = false; // æ˜¯å¦æ­£åœ¨æ—‹è½¬
                this.minCubesNeeded = 0; // æœ€å°‘éœ€è¦çš„æ–¹å—æ•°
                
                // é•¿æŒ‰ç›¸å…³
                this.longPressTimer = null;
                this.longPressThreshold = 600; // 600ms é•¿æŒ‰é˜ˆå€¼
                this.isLongPressing = false;
                this.touchStartPos = null;
                
                this.startTime = 0;
                this.errorCount = 0; // æ”¹ä¸ºé”™è¯¯æ¬¡æ•°
                this.gameLoaded = false;
                
                // æ–°å¢ï¼šæ¸¸æˆå…³å¡å’Œæ€»ä½“è®¡åˆ†ç³»ç»Ÿ
                this.currentLevel = 1;
                this.maxLevels = 5; // æ€»å…±5å…³
                this.levelScores = []; // è®°å½•å„å…³åˆ†æ•°
                this.gameStartTime = 0; // æ•´ä¸ªæ¸¸æˆå¼€å§‹æ—¶é—´
                this.totalErrors = 0; // æ€»é”™è¯¯æ¬¡æ•°
                this.isGameFinished = false; // æ¸¸æˆæ˜¯å¦å·²ç»“æŸ
                
                this.init();
                this.setupEventListeners();
                this.newGame();
                
                // åˆå§‹åŒ–è§„åˆ™å¼¹çª—
                initRulesModal();
            }
            
            init() {
                // ä¿®æ”¹æ¸²æŸ“å™¨é™„åŠ åˆ°æ¸¸æˆç”»å¸ƒåŒºåŸŸï¼Œä½¿ç”¨å…¨å±ç©ºé—´
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                document.getElementById('gameCanvas').appendChild(this.renderer.domElement);
                
                // è°ƒæ•´åˆå§‹ç›¸æœºä½ç½®ï¼Œå‘ä¸‹ç§»åŠ¨åœºæ™¯å¹¶æ”¾å¤§
                this.camera.position.set(-4, 4, 4);
                this.camera.lookAt(-this.gridSize/6, 0.5, this.gridSize/6);
                
                // æ·»åŠ ç¯å¢ƒå…‰å’Œæ–¹å‘å…‰ï¼ˆä¸äº§ç”Ÿé˜´å½±ï¼‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);
                
                // åˆ›å»ºå¯æ—‹è½¬çš„å¹³å°ç»„
                this.platformGroup = new THREE.Group();
                this.platformGroup.position.set(1.6, -1.6, 0); // å‘ä¸Šç§»åŠ¨ï¼Œå‡å°‘ä¸‹æ–¹ç©ºç™½
                this.platformGroup.scale.setScalar(1.5); // æ•´ä½“æ”¾å¤§1.8å€
                this.scene.add(this.platformGroup);
                
                // åˆ›å»ºå›ºå®šçš„æŠ•å½±å¢™ç»„
                this.wallGroup = new THREE.Group();
                this.wallGroup.position.set(1.6, -1.6, 0); // ä¸å¹³å°ç»„ä¿æŒä¸€è‡´
                this.wallGroup.scale.setScalar(1.5); // æ•´ä½“æ”¾å¤§1.8å€
                this.scene.add(this.wallGroup);
                
                this.createPlatform();
                this.createWalls();
                
                // Set optimal camera position after scene is created
                setTimeout(() => this.autoZoomCamera(), 100);
                
                this.animate();
                
                // å‘é€æ¸¸æˆåŠ è½½å®Œæˆäº‹ä»¶
                if (!this.gameLoaded) {
                    window.parent.postMessage({ type: 'gameLoaded' }, '*');
                    this.gameLoaded = true;
                }
            }
            
            // è·å–ç²¾ç¡®çš„æ—‹è½¬å˜æ¢å‚æ•°ï¼Œé¿å…æµ®ç‚¹æ•°è¯¯å·®
            getRotationParams() {
                // å°†æ—‹è½¬æ­¥æ•°æ ‡å‡†åŒ–åˆ°0-3èŒƒå›´å†…
                const normalizedSteps = ((this.rotationSteps % 4) + 4) % 4;
                
                switch(normalizedSteps) {
                    case 0: return { cos: 1, sin: 0 };    // 0åº¦
                    case 1: return { cos: 0, sin: -1 };    // 90åº¦
                    case 2: return { cos: -1, sin: 0 };   // 180åº¦
                    case 3: return { cos: 0, sin: 1 };   // 270åº¦
                    default: return { cos: 1, sin: 0 };
                }
            }
            
            createCheckerboardTexture() {
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext('2d');
                
                const tileSize = size / this.gridSize;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const isLight = (i + j) % 2 === 0;
                        context.fillStyle = isLight ? '#8B6F47' : '#6B5937'; // æµ…æ£•è‰²å’Œæ·±æ£•è‰²
                        context.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                return texture;
            }
            
            createPlatform() {
                // æ¸…é™¤ç°æœ‰å¹³å°
                while(this.platformGroup.children.length > 0) {
                    this.platformGroup.remove(this.platformGroup.children[0]);
                }
                
                // åˆ›å»ºæ£‹ç›˜æ ¼çº¹ç†
                const checkerTexture = this.createCheckerboardTexture();
                
                // åˆ›å»ºåº•éƒ¨å¹³å°
                const platformGeometry = new THREE.BoxGeometry(this.gridSize, 0.2, this.gridSize);
                const platformMaterial = new THREE.MeshLambertMaterial({ 
                    map: checkerTexture
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = -0.1;
                platform.userData = { type: 'platform' };
                this.platformGroup.add(platform);
                
                // åˆ›å»ºç½‘æ ¼çº¿
                this.createGridLines();
            }
            
            createGridLines() {
                const material = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.4, transparent: true });
                
                // æ°´å¹³çº¿
                for (let i = 0; i <= this.gridSize; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(-this.gridSize/2, 0.01, -this.gridSize/2 + i),
                        new THREE.Vector3(this.gridSize/2, 0.01, -this.gridSize/2 + i)
                    ];
                    geometry.setFromPoints(points);
                    this.platformGroup.add(new THREE.Line(geometry, material));
                }
                
                // å‚ç›´çº¿
                for (let i = 0; i <= this.gridSize; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(-this.gridSize/2 + i, 0.01, -this.gridSize/2),
                        new THREE.Vector3(-this.gridSize/2 + i, 0.01, this.gridSize/2)
                    ];
                    geometry.setFromPoints(points);
                    this.platformGroup.add(new THREE.Line(geometry, material));
                }
            }
            
            createWalls() {
                // æ¸…é™¤ç°æœ‰å¢™
                while(this.wallGroup.children.length > 0) {
                    this.wallGroup.remove(this.wallGroup.children[0]);
                }
                
                // å¢åŠ å¢™å£é«˜åº¦ä»¥é€‚åº”æ›´é«˜å±‚çš„æŠ•å½±æ˜¾ç¤ºï¼Œå¹¶è¿›ä¸€æ­¥æ”¾å¤§
                const wallHeight = this.gridSize; // ä»1.2å¢åŠ åˆ°1.5
                
                // æ­£é¢å¢™
                const frontWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight);
                const frontWallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xcccccc, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const frontWall = new THREE.Mesh(frontWallGeometry, frontWallMaterial);
                frontWall.position.set(0, wallHeight/2, -this.gridSize/2 - 0.4); // å‡å°‘è·ç¦»è®©å¢™æ›´è¿‘
                frontWall.userData = { type: 'wall' };
                this.wallGroup.add(frontWall);
                
                // å³ä¾§å¢™
                const rightWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight);
                const rightWallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xcccccc, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial);
                rightWall.position.set(this.gridSize/2 + 0.4, wallHeight/2, 0); // å‡å°‘è·ç¦»è®©å¢™æ›´è¿‘
                rightWall.rotation.y = Math.PI / 2;
                rightWall.userData = { type: 'wall' };
                this.wallGroup.add(rightWall);
            }
            
            generateTarget() {
                this.targetCubes.clear();
                const numCubes = Math.floor(Math.random() * (this.gridSize * 2)) + 2;
                
                // ç¡®ä¿ç¬¬ä¸€ä¸ªæ–¹å—åœ¨åœ°é¢ä¸Šï¼ˆä½œä¸ºè¿æ¥èµ·ç‚¹ï¼‰
                let firstX = Math.floor(Math.random() * this.gridSize);
                let firstZ = Math.floor(Math.random() * this.gridSize);
                let key = `${firstX},0,${firstZ}`;
                this.targetCubes.set(key, { x: firstX, y: 0, z: firstZ, color: this.getRandomColor() });
                
                // ç”Ÿæˆå…¶ä»–è”é€šçš„æ–¹å—
                for (let i = 1; i < numCubes; i++) {
                    let placed = false;
                    let attempts = 0;
                    
                    while (!placed && attempts < 50) {
                        // éšæœºé€‰æ‹©ä¸€ä¸ªå·²å­˜åœ¨çš„æ–¹å—
                        const existingCubes = Array.from(this.targetCubes.values());
                        const baseCube = existingCubes[Math.floor(Math.random() * existingCubes.length)];
                        
                        // åœ¨å…¶ç›¸é‚»ä½ç½®å°è¯•æ”¾ç½®æ–°æ–¹å—
                        const directions = [
                            {x: 1, y: 0, z: 0}, {x: -1, y: 0, z: 0},
                            {x: 0, y: 1, z: 0}, {x: 0, y: -1, z: 0},
                            {x: 0, y: 0, z: 1}, {x: 0, y: 0, z: -1}
                        ];
                        
                        const direction = directions[Math.floor(Math.random() * directions.length)];
                        const newX = baseCube.x + direction.x;
                        const newY = baseCube.y + direction.y;
                        const newZ = baseCube.z + direction.z;
                        
                        // æ£€æŸ¥è¾¹ç•Œå’Œæ˜¯å¦å·²å­˜åœ¨
                        if (newX >= 0 && newX < this.gridSize && 
                            newZ >= 0 && newZ < this.gridSize && 
                            newY >= 0 && newY < this.gridSize) {
                            
                            const newKey = `${newX},${newY},${newZ}`;
                            if (!this.targetCubes.has(newKey)) {
                                this.targetCubes.set(newKey, { 
                                    x: newX, y: newY, z: newZ, 
                                    color: this.getRandomColor() 
                                });
                                placed = true;
                            }
                        }
                        attempts++;
                    }
                }
                
                this.calculateMinCubes();
                this.updateProjections();
                this.updateCubeCount();
                this.autoCheckAnswer();
            }
            
            calculateMinCubes() {
                this.minCubesNeeded = this.targetCubes.size;
            }
            
            getRandomColor() {
                const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            updateProjections() {
                // æ¸…é™¤ç°æœ‰æŠ•å½±
                this.projectionCubes.forEach(cube => {
                    this.wallGroup.remove(cube);
                });
                this.projectionCubes = [];
                
                // è®¡ç®—æŠ•å½±
                this.createProjectionDisplay();
            }
            
            createProjectionDisplay() {
                // è·å–ç›®æ ‡æŠ•å½±
                const targetFrontProjection = new Set();
                const targetRightProjection = new Set();
                
                for (const [key, target] of this.targetCubes) {
                    const originalX = target.x - this.gridSize/2 + 0.5;
                    const originalZ = target.z - this.gridSize/2 + 0.5;
                    const originalY = target.y;
                    
                    // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
                    const { cos, sin } = this.getRotationParams();
                    const rotatedX = originalX * cos - originalZ * sin;
                    const rotatedZ = originalX * sin + originalZ * cos;
                    
                    const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    
                    targetFrontProjection.add(frontProjKey);
                    targetRightProjection.add(rightProjKey);
                }
                
                // è·å–å½“å‰ç”¨æˆ·æ–¹å—çš„æŠ•å½±
                const currentFrontProjection = new Set();
                const currentRightProjection = new Set();
                
                for (const [key, cube] of this.cubes) {
                    const originalX = cube.userData.gridX - this.gridSize/2 + 0.5;
                    const originalZ = cube.userData.gridZ - this.gridSize/2 + 0.5;
                    const originalY = cube.userData.gridY;
                    
                    // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
                    const { cos, sin } = this.getRotationParams();
                    const rotatedX = originalX * cos - originalZ * sin;
                    const rotatedZ = originalX * sin + originalZ * cos;
                    
                    const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    
                    currentFrontProjection.add(frontProjKey);
                    currentRightProjection.add(rightProjKey);
                }
                
                // åˆ›å»ºæ­£é¢æŠ•å½±æ˜¾ç¤º
                this.createWallProjectionDisplay(
                    targetFrontProjection, 
                    currentFrontProjection, 
                    'front'
                );
                
                // åˆ›å»ºå³ä¾§æŠ•å½±æ˜¾ç¤º
                this.createWallProjectionDisplay(
                    targetRightProjection, 
                    currentRightProjection, 
                    'right'
                );
            }
            
            createWallProjectionDisplay(targetProjection, currentProjection, wall) {
                // åˆå¹¶æ‰€æœ‰æŠ•å½±ä½ç½®
                const allPositions = new Set([...targetProjection, ...currentProjection]);
                
                for (const posKey of allPositions) {
                    const [coordStr, yStr] = posKey.split(',');
                    const coord = parseFloat(coordStr) / 2;
                    const y = parseFloat(yStr) / 2;
                    
                    const isTarget = targetProjection.has(posKey);
                    const isCurrent = currentProjection.has(posKey);
                    
                    let projCube;
                    
                    if (isTarget && isCurrent) {
                        // æ­£ç¡®æŠ•å½± - æ·±é»‘è‰²ï¼Œå¢å¤§å°ºå¯¸
                        const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1); // ä»0.8å¢åŠ åˆ°0.9
                        const projMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x222222
                        });
                        projCube = new THREE.Mesh(projGeometry, projMaterial);
                    } else if (isTarget && !isCurrent) {
                        // ç›®æ ‡æŠ•å½±ä½†ç”¨æˆ·æœªå®ç° - ç°è‰²ï¼Œå¢å¤§å°ºå¯¸
                        const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1); // ä»0.8å¢åŠ åˆ°0.9
                        const projMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xeeeeee, 
                            emissive: 0x888888,
                            emissiveIntensity: 0.3
                        });
                        projCube = new THREE.Mesh(projGeometry, projMaterial);
                    } else if (!isTarget && isCurrent) {
                        // é”™è¯¯æŠ•å½± - æ˜¾ç¤ºXï¼Œå¢å¤§å°ºå¯¸
                        projCube = this.createXMark(0.9); // ä»0.8å¢åŠ åˆ°0.9
                    }
                    
                    if (projCube) {
                        // æ”¾å®½æ˜¾ç¤ºèŒƒå›´é™åˆ¶ï¼Œå…è®¸æ›´é«˜å±‚çš„æŠ•å½±æ˜¾ç¤º
                        const maxWallHeight = this.gridSize * 1.5; // ä»1.2å¢åŠ åˆ°1.5
                        
                        if (wall === 'front') {
                            // æ­£é¢å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                            if (Math.abs(coord) <= this.gridSize/2 && y <= maxWallHeight && y > 0) {
                                projCube.position.set(coord, y, -this.gridSize/2 - 0.5); // è°ƒæ•´ä½ç½®
                                this.wallGroup.add(projCube);
                                this.projectionCubes.push(projCube);
                            }
                        } else if (wall === 'right') {
                            // å³ä¾§å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                            if (Math.abs(coord) <= this.gridSize/2 && y <= maxWallHeight && y > 0) {
                                projCube.position.set(this.gridSize/2 + 0.5, y, coord); // è°ƒæ•´ä½ç½®
                                if (projCube.rotation) {
                                    projCube.rotation.y = Math.PI / 2;
                                }
                                this.wallGroup.add(projCube);
                                this.projectionCubes.push(projCube);
                            }
                        }
                    }
                }
            }
            
            createXMark(size) {
                const group = new THREE.Group();
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0xcc3333,
                    emissive: 0x888888,
                    emissiveIntensity: 0.3
                });
                
                // åˆ›å»ºXçš„ä¸¤æ¡çº¿
                const lineGeometry1 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05);
                const lineGeometry2 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05);
                
                const line1 = new THREE.Mesh(lineGeometry1, material);
                const line2 = new THREE.Mesh(lineGeometry2, material);
                
                line1.rotation.z = Math.PI / 4;
                line2.rotation.z = -Math.PI / 4;
                
                group.add(line1);
                group.add(line2);
                
                return group;
            }
            
            isConnected(x, y, z) {
                // åœ°é¢ä¸Š(y=0)æ°¸è¿œå¯ä»¥æ”¾ç½®æ–¹å—
                if (y === 0) {
                    return true;
                }
                
                // å…¶ä»–ä½ç½®éœ€è¦æ£€æŸ¥è¿é€šæ€§
                if (this.cubes.size === 0) {
                    return true;
                }
                
                const neighbors = [
                    {x: x+1, y: y, z: z}, {x: x-1, y: y, z: z},
                    {x: x, y: y+1, z: z}, {x: x, y: y-1, z: z},
                    {x: x, y: y, z: z+1}, {x: x, y: y, z: z-1}
                ];
                
                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.x},${neighbor.y},${neighbor.z}`;
                    if (this.cubes.has(neighborKey)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            startLongPress(event) {
                this.isLongPressing = false;
                this.touchStartPos = {
                    x: event.touches ? event.touches[0].clientX : event.clientX,
                    y: event.touches ? event.touches[0].clientY : event.clientY
                };
                
                this.longPressTimer = setTimeout(() => {
                    this.isLongPressing = true;
                    this.handleLongPress(event);
                }, this.longPressThreshold);
            }
            
            endLongPress(event) {
                if (this.longPressTimer) {
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;
                }
                
                if (!this.isLongPressing) {
                    // çŸ­æŒ‰ï¼Œæ­£å¸¸ç‚¹å‡»
                    this.handleClick(event);
                }
                
                this.isLongPressing = false;
            }
            
            handleLongPress(event) {
                // é•¿æŒ‰åˆ é™¤æ–¹å—
                const mouse = new THREE.Vector2();
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const allObjects = [];
                this.platformGroup.traverse((child) => {
                    if (child.isMesh && child.userData.type === 'cube') {
                        allObjects.push(child);
                    }
                });
                
                const intersects = raycaster.intersectObjects(allObjects);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.type === 'cube') {
                        this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ);
                    }
                }
            }
            
            handleRightClick(event) {
                // å³é”®åˆ é™¤æ–¹å—
                event.preventDefault();
                
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const allObjects = [];
                this.platformGroup.traverse((child) => {
                    if (child.isMesh && child.userData.type === 'cube') {
                        allObjects.push(child);
                    }
                });
                
                const intersects = raycaster.intersectObjects(allObjects);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.type === 'cube') {
                        this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ);
                    }
                }
            }
            
            handleClick(event) {
                if (this.isRotating) return;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å³é”®ç‚¹å‡»
                if (event.button === 2) {
                    this.handleRightClick(event);
                    return;
                }
                
                const mouse = new THREE.Vector2();
                const clientX = event.touches ? event.changedTouches[0].clientX : event.clientX;
                const clientY = event.touches ? event.changedTouches[0].clientY : event.clientY;
                
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const allObjects = [];
                this.platformGroup.traverse((child) => {
                    if (child.isMesh) {
                        allObjects.push(child);
                    }
                });
                
                const intersects = raycaster.intersectObjects(allObjects);
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const object = intersect.object;
                    
                    if (object.userData.type === 'platform') {
                        this.handlePlatformClick(intersect);
                    } else if (object.userData.type === 'cube') {
                        this.handleCubeClick(intersect, object);
                    }
                }
            }
            
            handlePlatformClick(intersect) {
                const point = intersect.point;
                const localPoint = this.platformGroup.worldToLocal(point.clone());
                const gridX = Math.floor(localPoint.x + this.gridSize/2);
                const gridZ = Math.floor(localPoint.z + this.gridSize/2);
                
                if (gridX >= 0 && gridX < this.gridSize && gridZ >= 0 && gridZ < this.gridSize) {
                    // åœ¨åœ°é¢ä¸Šæ”¾ç½®ï¼ˆy=0ï¼‰ï¼Œæ°¸è¿œå…è®¸
                    this.placeCubeAt(gridX, 0, gridZ);
                }
            }
            
            handleCubeClick(intersect, cube) {
                const normal = intersect.face.normal.clone();
                normal.transformDirection(cube.matrixWorld);
                const platformMatrix = new THREE.Matrix4().copy(this.platformGroup.matrixWorld).invert();
                normal.transformDirection(platformMatrix);
                
                let targetX = cube.userData.gridX;
                let targetY = cube.userData.gridY;
                let targetZ = cube.userData.gridZ;
                
                if (Math.abs(normal.x) > 0.7) {
                    targetX += Math.sign(normal.x);
                } else if (Math.abs(normal.y) > 0.7) {
                    targetY += Math.sign(normal.y);
                } else if (Math.abs(normal.z) > 0.7) {
                    targetZ += Math.sign(normal.z);
                }
                
                if (targetX >= 0 && targetX < this.gridSize && 
                    targetZ >= 0 && targetZ < this.gridSize && 
                    targetY >= 0 && targetY < this.gridSize) {
                    
                    const key = `${targetX},${targetY},${targetZ}`;
                    if (!this.cubes.has(key) && this.isConnected(targetX, targetY, targetZ)) {
                        this.placeCubeAt(targetX, targetY, targetZ);
                    }
                }
            }
            
            placeCubeAt(x, y, z) {
                const key = `${x},${y},${z}`;
                if (this.cubes.has(key)) return;
                
                const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const material = new THREE.MeshLambertMaterial({ color: this.getRandomColor() });
                const cube = new THREE.Mesh(geometry, material);
                
                cube.position.set(x - this.gridSize/2 + 0.5, y + 0.5, z - this.gridSize/2 + 0.5);
                cube.userData = { gridX: x, gridY: y, gridZ: z, type: 'cube' };
                
                this.cubes.set(key, cube);
                this.platformGroup.add(cube);
                
                // æ·»åŠ åˆ°å†å²è®°å½•
                this.cubeHistory.push({ x, y, z });
                
                // æ£€æŸ¥é”™è¯¯ï¼šåªæœ‰å½“æ–¹å—æ•°ç­‰äºæœ€å°‘æ•°é‡ä¸”æŠ•å½±é”™è¯¯æ—¶è®¡ä¸ºé”™è¯¯
                // ä»æ›´å¤šæ–¹å—æ•°å‡å°‘åˆ°æœ€å°‘æ•°é‡çš„è¿‡ç¨‹ä¸­ä¸è®¡å…¥é”™è¯¯
                if (this.cubes.size === this.minCubesNeeded) {
                    const isProjectionCorrect = this.checkProjectionMatch();
                    if (!isProjectionCorrect) {
                        this.errorCount++;
                    }
                }
                
                this.updateCubeCount();
                this.updateProjections(); // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
                this.autoCheckAnswer();
                this.updateUndoButton();
            }
            
            removeCube(x, y, z) {
                const key = `${x},${y},${z}`;
                const cube = this.cubes.get(key);
                if (cube) {
                    // è®°å½•ç§»é™¤å‰çš„æ–¹å—æ•°é‡
                    const previousCubeCount = this.cubes.size;
                    
                    this.platformGroup.remove(cube);
                    this.cubes.delete(key);
                    
                    // ä»å†å²è®°å½•ä¸­ç§»é™¤
                    const index = this.cubeHistory.findIndex(item => item.x === x && item.y === y && item.z === z);
                    if (index !== -1) {
                        this.cubeHistory.splice(index, 1);
                    }
                    
                    // æ£€æŸ¥é”™è¯¯ï¼šåªæœ‰å½“ç§»é™¤åæ–¹å—æ•°ç­‰äºæœ€å°‘æ•°é‡ä¸”æŠ•å½±é”™è¯¯æ—¶è®¡ä¸ºé”™è¯¯
                    // ä½†å¦‚æœæ˜¯ä»å¤§äºæœ€å°‘æ•°é‡å‡å°‘åˆ°æœ€å°‘æ•°é‡ï¼Œåˆ™ä¸è®¡å…¥é”™è¯¯
                    const currentCubeCount = this.cubes.size;
                    const wasReducingFromExcess = previousCubeCount > this.minCubesNeeded && currentCubeCount === this.minCubesNeeded;
                    
                    if (currentCubeCount === this.minCubesNeeded && !wasReducingFromExcess) {
                        const isProjectionCorrect = this.checkProjectionMatch();
                        if (!isProjectionCorrect) {
                            this.errorCount++;
                        }
                    }
                    
                    this.updateCubeCount();
                    this.updateProjections(); // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
                    this.autoCheckAnswer();
                    this.updateUndoButton();
                }
            }
            
            undo() {
                if (this.cubeHistory.length === 0) return;
                
                // ç§»é™¤æœ€åæ”¾ç½®çš„æ–¹å—
                const lastCube = this.cubeHistory.pop();
                this.removeCube(lastCube.x, lastCube.y, lastCube.z);
                
                // é‡æ–°æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆå› ä¸ºremoveCubeä¼šåˆ é™¤å®ƒï¼‰
                // ä½†æˆ‘ä»¬ä¸éœ€è¦é‡æ–°æ·»åŠ ï¼Œå› ä¸ºè¿™å°±æ˜¯æ’¤é”€çš„ç›®çš„
            }
            
            updateUndoButton() {
                const undoButton = document.getElementById('undo');
                undoButton.disabled = this.cubeHistory.length === 0;
                if (undoButton.disabled) {
                    undoButton.classList.add('opacity-50', 'cursor-not-allowed');
                    undoButton.classList.remove('hover:bg-orange-700');
                } else {
                    undoButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    undoButton.classList.add('hover:bg-orange-700');
                }
            }
            
            updateCubeCount() {
                const currentCount = this.cubes.size;
                const gameTimeInSeconds = this.startTime > 0 ? (Date.now() - this.startTime) / 1000 : 0;
                
                document.getElementById('cubeCount').innerHTML = 
                    `ç”¨æœ€å°‘çš„æ–¹å—: ${currentCount}/${this.minCubesNeeded}<br>` +
                    `<span>æ—¶é—´: ${Math.floor(gameTimeInSeconds)}s | é”™è¯¯: ${this.errorCount}</span><br>` +
                    `<span>å…³å¡: ${this.currentLevel}/${this.maxLevels}</span>`;
                
                if (currentCount > this.minCubesNeeded) {
                    document.getElementById('cubeCount').style.color = '#f87171';
                } else if (currentCount === this.minCubesNeeded) {
                    document.getElementById('cubeCount').style.color = '#4ade80';
                } else {
                    document.getElementById('cubeCount').style.color = '#fbbf24';
                }
            }
            
            // æ£€æŸ¥å½“å‰æ–¹å—æ˜¯å¦äº§ç”Ÿæ­£ç¡®çš„æŠ•å½±
            checkProjectionMatch() {
                const currentFrontProjection = new Set();
                const currentRightProjection = new Set();
                
                // è®¡ç®—å½“å‰æ–¹å—çš„æŠ•å½±
                for (const [key, cube] of this.cubes) {
                    const originalX = cube.userData.gridX - this.gridSize/2 + 0.5;
                    const originalZ = cube.userData.gridZ - this.gridSize/2 + 0.5;
                    const originalY = cube.userData.gridY;
                    
                    // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
                    const { cos, sin } = this.getRotationParams();
                    const rotatedX = originalX * cos - originalZ * sin;
                    const rotatedZ = originalX * sin + originalZ * cos;
                    
                    const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    
                    currentFrontProjection.add(frontProjKey);
                    currentRightProjection.add(rightProjKey);
                }
                
                // è®¡ç®—ç›®æ ‡æŠ•å½±
                const targetFrontProjection = new Set();
                const targetRightProjection = new Set();
                
                for (const [key, target] of this.targetCubes) {
                    const originalX = target.x - this.gridSize/2 + 0.5;
                    const originalZ = target.z - this.gridSize/2 + 0.5;
                    const originalY = target.y;
                    
                    // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
                    const { cos, sin } = this.getRotationParams();
                    const rotatedX = originalX * cos - originalZ * sin;
                    const rotatedZ = originalX * sin + originalZ * cos;
                    
                    const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`;
                    
                    targetFrontProjection.add(frontProjKey);
                    targetRightProjection.add(rightProjKey);
                }
                
                // æ¯”è¾ƒæŠ•å½±æ˜¯å¦åŒ¹é…
                const frontMatch = this.setsEqual(currentFrontProjection, targetFrontProjection);
                const rightMatch = this.setsEqual(currentRightProjection, targetRightProjection);
                
                return frontMatch && rightMatch;
            }
            
            setsEqual(set1, set2) {
                if (set1.size !== set2.size) return false;
                for (const item of set1) {
                    if (!set2.has(item)) return false;
                }
                return true;
            }
            
            showSuccessEffect() {
                if (this.isGameFinished) return; // é˜²æ­¢é‡å¤è§¦å‘
                
                const effect = document.getElementById('successEffect');
                
                // è®¡ç®—å½“å‰å…³å¡åˆ†æ•°
                const levelTimeInSeconds = (Date.now() - this.startTime) / 1000;
                const levelScore = calculateGameScore(this.gridSize, levelTimeInSeconds, this.errorCount);
                this.levelScores.push(levelScore);
                this.totalErrors += this.errorCount;
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰å…³å¡
                if (this.currentLevel >= this.maxLevels) {
                    // æ¸¸æˆç»“æŸï¼Œè®¡ç®—æœ€ç»ˆåˆ†æ•°
                    this.finishGame();
                    return;
                }
                
                // æ˜¾ç¤ºå…³å¡å®Œæˆæ•ˆæœ
                effect.classList.add('success-show');
                effect.innerHTML = `ğŸ‰ ç¬¬${this.currentLevel}å…³å®Œæˆï¼<br><span style="font-size: 1.5rem;">æœ¬å…³: ${levelScore}åˆ†</span><br>å‡†å¤‡ä¸‹ä¸€å…³...`;
                
                // 3ç§’åéšè—ç‰¹æ•ˆå¹¶è¿›å…¥ä¸‹ä¸€å…³
                setTimeout(() => {
                    effect.classList.remove('success-show');
                    setTimeout(() => {
                        this.currentLevel++;
                        this.newGame();
                    }, 1000);
                }, 3000);
            }
            
            finishGame() {
                if (this.isGameFinished) return; // é˜²æ­¢é‡å¤è§¦å‘
                this.isGameFinished = true;
                
                const effect = document.getElementById('successEffect');
                const totalGameTime = (Date.now() - this.gameStartTime) / 1000;
                
                // è®¡ç®—æœ€ç»ˆç™¾åˆ†åˆ¶åˆ†æ•°
                const finalScore = this.calculateFinalScore();
                
                // æ›´æ–°æœ€é«˜åˆ†
                if (finalScore > bestScore) {
                    bestScore = finalScore;
                    localStorage.setItem('spatialGameBestScore', bestScore.toString());
                }
                
                // æ˜¾ç¤ºæ¸¸æˆå®Œæˆæ•ˆæœ
                effect.classList.add('success-show');
                effect.innerHTML = `ğŸŠ æ¸¸æˆå®Œæˆï¼<br><span style="font-size: 1.5rem;">æœ€ç»ˆå¾—åˆ†: ${finalScore}åˆ†</span><br><span style="font-size: 1rem;">æœ€é«˜çºªå½•: ${bestScore}åˆ†</span>`;
                
                // å‘é€æ¸¸æˆå®Œæˆäº‹ä»¶
                window.parent.postMessage({ 
                    type: 'gameFinished', 
                    data: { 
                        score: finalScore, // ç¡®ä¿æ˜¯ç™¾åˆ†åˆ¶åˆ†æ•°
                        bestScore: bestScore,
                        difficulty: getDifficultyLevel(this.gridSize),
                        gridSize: this.gridSize,
                        totalTime: Math.round(totalGameTime),
                        totalErrors: this.totalErrors,
                        levelsCompleted: this.currentLevel,
                        maxLevels: this.maxLevels,
                        levelScores: this.levelScores
                    }
                }, '*');
                
                // 5ç§’åå¯ä»¥é‡æ–°å¼€å§‹æ¸¸æˆ
                setTimeout(() => {
                    effect.innerHTML += '<br><span style="font-size: 1rem;">ç‚¹å‡»"æ–°æ¸¸æˆ"é‡æ–°å¼€å§‹</span>';
                }, 5000);
            }
            
            calculateFinalScore() {
                // å°†æ¸¸æˆåˆ†æ•°ç»Ÿä¸€æ¢ç®—ä¸ºç™¾åˆ†åˆ¶
                if (this.levelScores.length === 0) return 0;
                
                // åŸºç¡€åˆ†æ•°ï¼šå„å…³å¡å¹³å‡åˆ†
                const averageScore = this.levelScores.reduce((sum, score) => sum + score, 0) / this.levelScores.length;
                
                // å®Œæˆåº¦å¥–åŠ±ï¼šå®Œæˆå…³å¡è¶Šå¤šå¥–åŠ±è¶Šé«˜
                const completionBonus = (this.currentLevel / this.maxLevels) * 20; // æœ€å¤š20åˆ†å¥–åŠ±
                
                // æ€»æ—¶é—´å› ç´ ï¼šæ§åˆ¶åœ¨åˆç†æ—¶é—´å†…æœ‰å¥–åŠ±
                const totalGameTime = (Date.now() - this.gameStartTime) / 1000;
                const expectedTime = this.maxLevels * 90; // æ¯å…³é¢„æœŸ90ç§’
                const timeBonus = Math.max(0, 10 - Math.floor((totalGameTime - expectedTime) / expectedTime * 10)); // æœ€å¤š10åˆ†æ—¶é—´å¥–åŠ±
                
                // é”™è¯¯æƒ©ç½šï¼šæ€»é”™è¯¯æ•°è¶Šå¤šæ‰£åˆ†è¶Šå¤š
                const errorPenalty = Math.min(this.totalErrors * 2, 20); // æ¯ä¸ªé”™è¯¯æ‰£2åˆ†ï¼Œæœ€å¤šæ‰£20åˆ†
                
                // è®¡ç®—æœ€ç»ˆåˆ†æ•°å¹¶ç¡®ä¿åœ¨0-100èŒƒå›´å†…
                let finalScore = averageScore + completionBonus + timeBonus - errorPenalty;
                finalScore = Math.min(100, Math.max(0, Math.round(finalScore)));
                
                return finalScore;
            }
            
            rotatePlatform(direction) {
                if (this.isRotating) return;
                
                this.isRotating = true;
                const startRotationSteps = this.rotationSteps;
                const targetRotationSteps = this.rotationSteps + direction;
                
                // è®¡ç®—å®é™…çš„è§’åº¦ç”¨äºåŠ¨ç”»
                const startAngle = startRotationSteps * 90;
                const targetAngle = targetRotationSteps * 90;
                
                const duration = 500;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                    
                    const currentAngle = startAngle + (targetAngle - startAngle) * easeProgress;
                    this.platformGroup.rotation.y = THREE.MathUtils.degToRad(currentAngle);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // æ›´æ–°æ—‹è½¬æ­¥æ•°è€Œä¸æ˜¯è§’åº¦
                        this.rotationSteps = targetRotationSteps;
                        this.isRotating = false;
                        this.calculateMinCubes();
                        this.updateProjections();
                        this.updateCubeCount();
                        this.autoCheckAnswer();
                    }
                };
                
                animate();
            }
            
            autoCheckAnswer() {
                const projectionMatch = this.checkProjectionMatch();
                const cubeCount = this.cubes.size;
                
                // åªåœ¨æˆåŠŸæ—¶æ˜¾ç¤ºç‰¹æ•ˆå¹¶è‡ªåŠ¨ä¸‹ä¸€å…³
                if (projectionMatch && cubeCount <= this.minCubesNeeded) {
                    this.showSuccessEffect();
                }
            }
            
            newGame() {
                // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œé‡ç½®æ‰€æœ‰çŠ¶æ€
                if (this.isGameFinished) {
                    this.currentLevel = 1;
                    this.levelScores = [];
                    this.totalErrors = 0;
                    this.isGameFinished = false;
                    this.gameStartTime = Date.now();
                }
                
                this.gridSize = parseInt(document.getElementById('gridSize').value);
                
                // é‡ç½®å½“å‰å…³å¡ç»Ÿè®¡
                this.startTime = Date.now();
                this.errorCount = 0; // é‡ç½®é”™è¯¯æ¬¡æ•°
                
                // å¦‚æœæ˜¯ç¬¬ä¸€å…³ï¼Œè®°å½•æ¸¸æˆå¼€å§‹æ—¶é—´
                if (this.currentLevel === 1 && this.gameStartTime === 0) {
                    this.gameStartTime = Date.now();
                }
                
                // é‡ç½®æ‰€æœ‰çŠ¶æ€
                this.rotationSteps = 0;
                this.isRotating = false;
                this.cubeHistory = []; // æ¸…ç©ºå†å²è®°å½•
                
                // å®Œå…¨æ¸…ç©ºæ‰€æœ‰æ–¹å—
                for (const [key, cube] of this.cubes) {
                    this.platformGroup.remove(cube);
                }
                this.cubes.clear();
                
                // é‡å»ºæ¸¸æˆåœºæ™¯
                this.createPlatform();
                this.createWalls();
                this.platformGroup.rotation.y = 0;
                
                // Auto-adjust camera for new grid size
                this.autoZoomCamera();
                
                // ç”Ÿæˆæ–°çš„ç›®æ ‡
                this.generateTarget();
                this.updateUndoButton();
                
                // å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶
                if (!gameStarted) {
                    window.parent.postMessage({ type: 'gameStarted' }, '*');
                    gameStarted = true;
                }
            }
            
            setupEventListeners() {
                document.getElementById('newGame').addEventListener('click', () => this.newGame());
                document.getElementById('undo').addEventListener('click', () => this.undo());
                document.getElementById('rotateLeft').addEventListener('click', () => this.rotatePlatform(-1));
                document.getElementById('rotateRight').addEventListener('click', () => this.rotatePlatform(1));
                
                // é¼ æ ‡äº‹ä»¶
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    if (event.button === 2) {
                        // å³é”®ç‚¹å‡»ï¼Œç›´æ¥å¤„ç†åˆ é™¤
                        this.handleRightClick(event);
                    } else {
                        // å·¦é”®ç‚¹å‡»ï¼Œå¼€å§‹é•¿æŒ‰æ£€æµ‹
                        this.startLongPress(event);
                    }
                });
                
                this.renderer.domElement.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    if (event.button !== 2) {
                        // åªå¤„ç†å·¦é”®æ¾å¼€
                        this.endLongPress(event);
                    }
                });
                
                // è§¦æ‘¸äº‹ä»¶
                this.renderer.domElement.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    this.startLongPress(event);
                });
                
                this.renderer.domElement.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    this.endLongPress(event);
                });
                
                // é˜»æ­¢å³é”®èœå•
                this.renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
                
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }
            
            handleResize() {
                // å“åº”å¼å¤„ç† - ä½¿ç”¨å…¨å±ç©ºé—´
                const canvasWidth = window.innerWidth;
                const canvasHeight = window.innerHeight;
                
                // Update camera aspect ratio
                this.camera.aspect = canvasWidth / canvasHeight;
                this.camera.updateProjectionMatrix();
                
                // Update renderer size
                this.renderer.setSize(canvasWidth, canvasHeight);
                
                // Auto-adjust camera position for optimal viewing
                this.autoZoomCamera();
            }

            autoZoomCamera() {
                const aspect = window.innerWidth / window.innerHeight;
                const sceneSize = this.gridSize + 2; // å¢åŠ åœºæ™¯å¤§å°è®¡ç®—
                
                // Calculate optimal distance based on grid size and aspect ratio
                const fov = this.camera.fov * (Math.PI / 180); // Convert to radians
                const targetDistance = sceneSize / (2 * Math.tan(fov / 2));
                
                // Adjust distance based on aspect ratio - ä½¿åœºæ™¯æ›´å¤§æ›´æ˜“æ“ä½œ
                let optimalDistance;
                if (aspect > 1) {
                    // Landscape: use height as limiting factor
                    optimalDistance = targetDistance * 0.6; // è¿›ä¸€æ­¥å‡å°è®©åœºæ™¯æ›´å¤§
                } else {
                    // Portrait: use width as limiting factor and move camera further
                    optimalDistance = targetDistance * 0.8 / aspect; // è¿›ä¸€æ­¥å‡å°
                }
                
                // Ensure minimum and maximum distances - è°ƒæ•´èŒƒå›´è®©åœºæ™¯æ›´å¤§
                optimalDistance = Math.max(optimalDistance, this.gridSize * 1.2); // å‡å°æœ€å°è·ç¦»
                optimalDistance = Math.min(optimalDistance, this.gridSize * 5); // å‡å°æœ€å¤§è·ç¦»
                
                // Smoothly animate camera to new position - å‘ä¸‹ç§»åŠ¨åœºæ™¯
                this.animateCameraToPosition(
                    -optimalDistance * 0.8, 
                    optimalDistance * 1.2, // è¿›ä¸€æ­¥é™ä½Yè½´ä½ç½®
                    optimalDistance * 0.8
                );
            }

            animateCameraToPosition(targetX, targetY, targetZ) {
                const startPosition = this.camera.position.clone();
                const targetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                
                const duration = 800; // Animation duration in ms
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing function
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : -1 + (4 - 2 * progress) * progress;
                    
                    // Interpolate camera position
                    this.camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    
                    // Update camera to look at the scene center - è°ƒæ•´è§‚å¯Ÿç‚¹
                    this.camera.lookAt(0, 1, 0); // ç®€åŒ–è§‚å¯Ÿç‚¹ï¼Œè®©è§†è§’æ›´å±…ä¸­
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æœ€é«˜åˆ†
        bestScore = parseInt(localStorage.getItem('spatialGameBestScore') || '0');
        
        // å¯åŠ¨æ¸¸æˆ
        const game = new SpatialGame();
    </script>
</body>
</html>

