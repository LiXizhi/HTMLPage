<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å½±å­éª‘å£«</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <style>
      /* æ¸…é™¤æµè§ˆå™¨é»˜è®¤æ ·å¼ */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* é€šç”¨å­—ä½“æ ·å¼ */
      html {
        /* è®¾ç½®æ ¹å…ƒç´ å­—ä½“å¤§å°ï¼Œä¾¿äº rem å•ä½æ¢ç®—ï¼š1rem = 10px */
        font-size: 10px;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        width: 100vw;
        background-color: #D5E9FF;
        overflow: hidden;
        
        /* å­—ä½“æ—è®¾ç½® - æŒ‰ä¼˜å…ˆçº§æ’åˆ— */
        font-family: 
          /* iOS ä¸­æ–‡ */
          "PingFang SC", "PingFang TC",
          /* iOS è‹±æ–‡ */
          "-apple-system", "BlinkMacSystemFont", "SF Pro Text", "SF Pro Display",
          /* Android ä¸­æ–‡ */
          "Noto Sans SC", "Noto Sans CJK SC",
          /* Android è‹±æ–‡ */
          "Roboto",
          /* é€šç”¨åå¤‡å­—ä½“ */
          "Helvetica Neue", "Arial", "Microsoft YaHei", "å¾®è½¯é›…é»‘",
          sans-serif;
        
        /* åŸºç¡€å­—å·å’Œè¡Œé«˜ */
        font-size: 1.4rem;
        line-height: 2.2rem; /* å­—å· + 8px */
        
        /* ä¼˜åŒ–å­—ä½“æ¸²æŸ“ */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
      }

      /* æ•°å­—ä½¿ç”¨ DIN å­—ä½“ */
      .number,
      input[type="number"],
      .price,
      .count {
        font-family: 
          "DIN Alternate", "DIN", "DIN-Medium", "DIN-Bold",
          "SF Pro Display", "Roboto",
          monospace;
        font-variant-numeric: tabular-nums; /* ç­‰å®½æ•°å­— */
      }

      /* ==================== å­—å·è§„èŒƒ ==================== */
      /* é’ˆå¯¹ä¸åŒå­—å·ä¿æŒè¡Œé«˜è§„åˆ™ï¼ˆå­—å· + 8pxï¼‰ */
      .text-10 { font-size: 1rem; line-height: 1.8rem; }
      .text-12 { font-size: 1.2rem; line-height: 2rem; }
      .text-14 { font-size: 1.4rem; line-height: 2.2rem; }
      .text-16 { font-size: 1.6rem; line-height: 2.4rem; }
      .text-18 { font-size: 1.8rem; line-height: 2.6rem; }
      .text-20 { font-size: 2rem; line-height: 2.8rem; }
      .text-22 { font-size: 2.2rem; line-height: 3rem; }
      .text-24 { font-size: 2.4rem; line-height: 3.2rem; }

      /* ==================== é¢œè‰²è§„èŒƒ ==================== */
      /* æ ‡é¢˜ æ­£æ–‡ - é»‘è‰² */
      .text-title,
      .text-primary {
        color: #000000;
      }

      /* æ­£æ–‡ åˆ—è¡¨ - æ·±ç°è‰² */
      .text-secondary,
      .text-list {
        color: #333333;
      }

      /* è¯´æ˜ å¤‡æ³¨ - ä¸­ç°è‰² */
      .text-note,
      .text-remark,
      .text-description {
        color: #999999;
      }

      /* åˆ†å‰²çº¿ - æµ…ç°è‰² */
      .text-divider,
      .text-disabled {
        color: #D6DEE4;
      }

      /* èƒŒæ™¯è‰²ç‰ˆæœ¬ */
      .bg-primary { background-color: #000000; }
      .bg-secondary { background-color: #333333; }
      .bg-note { background-color: #999999; }
      .bg-divider { background-color: #D6DEE4; }

      /* è¾¹æ¡†è‰²ç‰ˆæœ¬ */
      .border-primary { border-color: #000000; }
      .border-secondary { border-color: #333333; }
      .border-note { border-color: #999999; }
      .border-divider { border-color: #D6DEE4; }

      /* å¯é€‰ï¼šé’ˆå¯¹ç‰¹å®šå¹³å°çš„å­—ä½“ä¼˜åŒ– */
      @supports (-webkit-touch-callout: none) {
        /* iOS ç‰¹å®šæ ·å¼ */
        body {
          font-family: 
            "PingFang SC", "PingFang TC",
            "-apple-system", "BlinkMacSystemFont",
            sans-serif;
        }
      }

      #gameContainer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: relative;
        width: 65.2rem;
        height: 37.5rem;
        padding: 1.2rem;
        padding-right: 4.2rem;
        overflow: hidden;
      }

      .left-panel {
        display: flex;
        flex-direction: column;
        position: relative;
        width: 15.4rem;
        height: 29.6rem;
        padding: 1.6rem 1.4rem 2.4rem; 
        background-color: #FFF;
        border-radius: 1.2rem;
      }

      .left-panel .info-item {
        display: flex;
        align-items: center;
        font-weight: 500;
      }

      .left-panel .info-item .vertical-bar {
        width: 0.4rem;
        height: 1.4rem;
        margin-right: 0.8rem;
        border-radius: 0.4rem;
      }

      .left-panel .instruction {
        display: flex;
        flex-direction: column;
        justify-content: center;
        width: 12.6rem;
        height: 10.2rem;
        padding: 1rem;
        background-color: #D5E9FF33;
        border: 0.1rem solid #D5E9FF;
        border-radius: 0.8rem;
        font-weight: 600;
      }

      .right-panel {
        display: flex;
        flex-direction: column;
        width: 8.4rem;
      }

      .right-panel .tap-button {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 5.4rem;
        margin-bottom: 0.8rem;
        border-radius: 0.8rem;
        font-weight: 600;
        color: #FFF;
        cursor: pointer;
      }

      #gameCanvas {
        width: 36rem;
        height: 29.6rem;
        flex-shrink: 0;
      }

      #gameCanvas canvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
      }

      #successEffect {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2rem;
        font-weight: bold;
        color: #4ade80;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 200;
        pointer-events: none;
        opacity: 0;
        transition: all 0.5s ease;
        text-align: center;
        max-width: 80%;
        line-height: 1.3;
      }

      .success-show {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.2) !important;
      }

      /* æ¸¸æˆè§„åˆ™å¼¹çª—æ ·å¼ */
      .modal-overlay {
        backdrop-filter: blur(4px);
        animation: fadeIn 0.3s ease;
      }

      .modal-content {
        animation: slideIn 0.3s ease;
        max-width: 85vw;
        max-height: 80vh;
        width: 100%;
        height: auto;
      }

      .modal-body {
        max-height: calc(80vh - 140px);
        overflow-y: auto;
      }

      /* æ–°çš„è§„åˆ™å¼¹çª—æ ·å¼ */
      .rules-content {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        width: 39rem;
        padding: 2.2rem 2.2rem 1.8rem;
        background-color: #FFFFFF;
        border-radius: 0.8rem;
      }

      .rules-sign {
        width: 0.6rem;
        height: 1.8rem;
        margin-right: 0.6rem;
        background-color: #009DFF;
        border-radius: 0.6rem;
      }

      .rules-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.6rem;
      }

      .rules-list {
        list-style-type: decimal;
        margin-left: 1.4rem;
      }

      .rules-list li {
        margin-bottom: 1rem;
      }

      .rules-footer {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
        width: 12rem;
        height: 3rem;
        background-color: #009DFF;
        border-radius: 0.8rem;
        font-weight: 600;
        color: #FFF;
        margin-top: 1rem;
      }

      .rules-body {
        overflow-y: auto;
        max-height: calc(80vh - 120px);
      }

      .rules-body::-webkit-scrollbar {
        display: none;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* ç§¯åˆ†å¼¹çª—æ ·å¼ */
      .points-modal {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        width: 39rem;
        padding: 2.2rem 2.2rem 1.8rem;
        background-color: #FFFFFF;
        border-radius: 0.8rem;
      }

      .points-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.8rem;
      }

      .points-sign {
        width: 0.6rem;
        height: 1.8rem;
        margin-right: 0.6rem;
        background-color: #FF9A00;
        border-radius: 0.6rem;
      }

      .points-title {
        display: flex;
        align-items: center;
        font-weight: 600;
      }

      .points-close {
        cursor: pointer;
        font-weight: normal;
        width: 1rem;
        height: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .points-modal-content {
        display: flex;
        flex-direction: column;
      }

      .points-stats-section {
        background-color: #FDECE2;
        border-radius: 0.8rem;
        padding: 0.8rem 1.3rem 1rem 2.5rem;
        margin-bottom: 0.2rem;
      }

      .points-stats-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.6rem;
      }

      .points-subtitle {
        position: relative;
        margin-bottom: 0.6rem;
        font-weight: 600;
        color: #333;
      }

      .points-subtitle::before {
        content: '';
        display: inline-block;
        position: absolute;
        left: -1.2rem;
        top: 50%;
        transform: translateY(-50%);
        width: 0.4rem;
        height: 0.4rem;
        background-color: #FF9A00;
        border-radius: 50%;
      }

      .points-stats-grid {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
      }

      .points-stat-item {
        display: flex;
        align-items: center;
        width: 14.6rem;
        height: 3.6rem;
        padding: 0 1.2rem;
        background-color: #ffffff;
        border-radius: 0.8rem;
      }

      .points-stat-label {
        color: #999999;
        font-size: 1.2rem;
      }

      .points-stat-value {
        margin-left: 1.2rem;
        font-weight: 600;
        font-size: 1.8rem;
      }

      .points-stat-value.total {
        color: #FF5800;
      }

      .points-stat-value.daily {
        color: #22C55E;
      }

      .points-rules-section {
        padding: 0.8rem 1.3rem 0 2.5rem;
      }

      .points-rules-list-warpper {
        width: 100%;
        max-height: 7.2rem;
        overflow-y: auto;
      }

      .points-rules-list {
        list-style-type: none;
        display: inline-block;
      }

      .points-rules-list-warpper::-webkit-scrollbar {
        width: 0.2rem;
      }

      .points-rules-list-warpper::-webkit-scrollbar-thumb {
        background: #999;
        border-radius: 0.2rem;
      }

      .points-rules-list li {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.4rem;
        color: #333333;
      }

      .points-rules-list li:last-child {
        margin-bottom: 0;
      }

      .points-rule-name {
        display: inline-block;
      }

      .points-rule-value {
        margin-left: 2rem;
        color: #FF9500;
        font-weight: 600;
      }

      /* å¸®åŠ©æŒ‰é’® */
      .help-btn {
        position: absolute;
        z-index: 40;
        width: 3.8rem;
        height: 3.8rem;
        right: 0.4rem;
        cursor: pointer;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      #helpBtn {
        bottom: 0.4rem;
        background-image: url("https://qiniu-public.keepwork.com/paracraft-cdn-resource/Web/ms_games/icon/game_rule.png");
      }

      #pointsBtn {
        bottom: 4.2rem;
        background-image: url("https://qiniu-public.keepwork.com/paracraft-cdn-resource/Web/ms_games/icon/game_points.png");
      }



      /* é«˜äº®åŠ¨ç”»æ ·å¼ */
      .difficulty-highlight {
        animation: highlightPulse 2s ease-in-out;
      }

      @keyframes highlightPulse {
        0% { 
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
          border-color: rgb(59, 130, 246);
        }
        50% { 
          box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
          border-color: rgb(59, 130, 246);
        }
        100% { 
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
          border-color: rgb(59, 130, 246);
        }
      }

      /* éš¾åº¦é€‰æ‹©å™¨æ ·å¼ */
      .difficulty-selector {
        position: relative;
        width: 100%;
        height: 2.6rem;
        margin-bottom: 2.8rem;
        color: #333;
      }

      .difficulty-selector-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.2rem 0.6rem;
        background-color: #FFF1DF;
        border-radius: 0.4rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .difficulty-selector-header.active {
        border-color: #4196FF;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }

      .difficulty-selector-arrow {
        width: 0;
        height: 0;
        border-left: 0.3rem solid transparent;
        border-right: 0.3rem solid transparent;
        border-top: 0.4rem solid #333;
        transition: transform 0.2s ease;
      }

      .difficulty-selector-header.active .difficulty-selector-arrow {
        transform: rotate(180deg);
      }

      .difficulty-selector-dropdown {
        position: absolute;
        top: 2.6rem;
        left: 0;
        right: 0;
        background-color: #FFF1DF;
        border-top: none;
        border-bottom-left-radius: 0.4rem;
        border-bottom-right-radius: 0.4rem;
        z-index: 100;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .difficulty-selector-dropdown.show {
        max-height: 20rem;
        opacity: 1;
      }

      .difficulty-selector-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 2.6rem;
        padding: 0.2rem 0.6rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .difficulty-selector-option:last-child {
        border-bottom: none;
      }

      .difficulty-selector-option.selected {
        background-color: #DBEAFE;
        color: #4196FF;
        font-weight: 600;
      }

      /* å¼¹çª—å“åº”å¼æ ·å¼ */
      @media (max-width: 768px) {
        .modal-content {
          max-width: 95vw;
          margin: 1rem;
        }

        .modal-content .p-8 {
          padding: 1.5rem !important;
        }

        .modal-body .text-lg {
          font-size: 1rem !important;
        }

        .modal-content h2 {
          font-size: 1.5rem !important;
        }
      }

      @media (max-width: 480px) {
        .modal-content .p-8 {
          padding: 1.25rem !important;
        }

        .modal-body .text-lg {
          font-size: 0.95rem !important;
        }

        .modal-content h2 {
          font-size: 1.375rem !important;
        }
      }
    </style>

  </head>
  <body>
    <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
    <div
      id="rulesModal"
      class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden flex items-center justify-center z-50 p-4"
      style="z-index: 9999"
    >
      <div class="rules-content">
        <div class="rules-header text-18">
          <div class="text-secondary" style="font-weight: 600; display: flex; align-items: center;">
            <div class="rules-sign"></div>
            <span>å½±å­éª‘å£«</span>
          </div>
          <button id="closeRules" class="text-primary" style="cursor: pointer; font-weight: normal; width: 1rem; height: 1rem; display: flex; align-items: center; justify-content: center;">Ã—</button>
        </div>

        <ol class="rules-list text-14 text-list">
          <li>åœ¨ä½ è®¤ä¸ºæ­£ç¡®çš„ä½ç½®è‡ªä¸‹å‘ä¸Šæ­å»ºæ–¹å—ï¼Œä½¿å…¶æŠ•å½±ä¸ä¸¤ä¾§å¢™å£ä¸Šçš„æŠ•å½±ä½ç½®ä¸€è‡´</li>
          <li>å¯åˆ©ç”¨å·¦å³æ—‹è½¬æŒ‰é”®è§‚å¯Ÿï¼Œæ­å»ºé”™è¯¯å¯æ’¤é”€ï¼Œè®¤ä¸ºæ­å»ºå®Œæˆæ—¶æäº¤ç­”æ¡ˆ</li>
          <li>äº‰å–åœ¨ç†æƒ³æ–¹å—æ•°å†…å®Œæˆï¼Œè¶…å‡ºæ—¶å®Œæˆä»å¯å¾—åˆ†</li>
          <li>æ ¹æ®ä½ çš„æ¨¡å‹ï¼Œå½“å‰ä¸ºä½ æ¨èçš„éš¾åº¦ä¸º<span id="recommendedDifficulty" style="color: #4189FF;">ã€å…¥é—¨ã€‘</span>ï¼Œä½ å¯ä»¥éšæ—¶æ ¹æ®ä½œç­”æƒ…å†µï¼Œè°ƒæ•´éš¾åº¦ã€‚</li>
        </ol>

        <button
          id="startGameFromRules"
          class="rules-footer text-12"
        >
          å¼€å§‹è®­ç»ƒ
        </button>
      </div>
    </div>

    <!-- ç§¯åˆ†å¼¹çª— -->
    <div
      id="pointsModal"
      class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden flex items-center justify-center z-50 p-4"
      style="z-index: 9999"
    >
      <div class="points-modal">
        <div class="points-header">
          <div class="points-title text-18 text-secondary">
            <div class="points-sign"></div>
            <span>ç§¯åˆ†ç³»ç»Ÿ</span>
          </div>
          <button id="closePoints" class="points-close text-primary">Ã—</button>
        </div>
        <div class="points-modal-content text-14 text-list">
          <div class="points-stats-section">
            <div class="points-stats-header">
              <div class="points-subtitle" style="margin: 0;">ç§¯åˆ†ç»Ÿè®¡</div>
              <div class="text-10 text-note">
                æœ€åæ›´æ–°: <span id="lastUpdateDateDisplay">--</span>
              </div>
            </div>
            <div class="points-stats-grid">
              <div class="points-stat-item">
                <div class="points-stat-label">æ€»ç§¯åˆ†</div>
                <div id="totalPointsDisplay" class="points-stat-value total">0</div>
              </div>
              <div class="points-stat-item">
                <div class="points-stat-label">ä»Šæ—¥ç§¯åˆ†</div>
                <div id="dailyPointsDisplay" class="points-stat-value daily">+0</div>
              </div>
            </div>
          </div>
          <div class="points-rules-section">
            <div class="points-subtitle">ç§¯åˆ†è·å¾—è§„åˆ™</div>
            <div class="points-rules-list-warpper">
              <ul class="points-rules-list">
                <li class="text-12">
                  <span class="points-rule-name">å…¥é—¨éš¾åº¦ (2Ã—2)ï¼šæ¯å…³</span>
                  <span class="points-rule-value">5ç§¯åˆ†</span>
                </li>
                <li class="text-12">
                  <span class="points-rule-name">ç®€å•éš¾åº¦ (3Ã—3)ï¼šæ¯å…³</span>
                  <span class="points-rule-value">5ç§¯åˆ†</span>
                </li>
                <li class="text-12">
                  <span class="points-rule-name">ä¸­ç­‰éš¾åº¦ (4Ã—4)ï¼šæ¯å…³</span>
                  <span class="points-rule-value">10ç§¯åˆ†</span>
                </li>
                <li class="text-12">
                  <span class="points-rule-name">å›°éš¾éš¾åº¦ (5Ã—5)ï¼šæ¯å…³</span>
                  <span class="points-rule-value">15ç§¯åˆ†</span>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="gameContainer">
      <!-- å·¦ä¾§UIé¢æ¿ï¼ˆæ–°ï¼‰ -->
      <div class="left-panel">
        <div class="info-item" style="margin-bottom: 1.6rem; color: #4196FF;">
          <div class="vertical-bar" style="background-color: #4196FF;"></div>
          <div class="text-14">å…³å¡ï¼š</div>
          <div class="text-24"><span id="newCurrentLevel">1</span>/<span id="newTotalLevels">10</span></div>
        </div>
        <div class="info-item" style="width: 16rem; margin-bottom: 2rem; color: #FFA600;">
          <div class="vertical-bar" style="background-color: #FFA600;"></div>
          <div class="text-14">ç†æƒ³å—æ•°ï¼š</div>
          <div class="text-24"><span id="newCurrentCubes">0</span>/<span id="newMinCubes">3</span></div>
        </div>
        <div id="newDifficultySelector" class="difficulty-selector text-14">
          <div class="difficulty-selector-header">
            <span>éš¾åº¦</span>
            <span style="font-weight: 500;">
              å…¥é—¨
              <span class="text-10 text-description">ï¼ˆ2x2ï¼‰</span>
            </span>
            <div class="difficulty-selector-arrow"></div>
          </div>
          <div class="difficulty-selector-dropdown">
            <div class="difficulty-selector-option" data-value="2">å…¥é—¨</div>
            <div class="difficulty-selector-option" data-value="3">ç®€å•</div>
            <div class="difficulty-selector-option" data-value="4">ä¸­ç­‰</div>
            <div class="difficulty-selector-option" data-value="5">å›°éš¾</div>
          </div>
        </div>
        <div class="instruction text-10">
          <div>å·¦é”®ï¼šæ”¾ç½®</div>
          <div>å³é”®/é•¿æŒ‰ï¼šåˆ é™¤</div>
          <div>é»‘è‰²ï¼šæ­£ç¡®æŠ•å½±</div>
          <div>ç°è‰²ï¼šç›®æ ‡æŠ•å½±</div>
          <div>çº¢è‰²Xï¼šé”™è¯¯æŠ•å½±</div>
        </div>
      </div>
      
      <!-- æ¸¸æˆç”»å¸ƒåŒºåŸŸ -->
      <div id="gameCanvas"></div>

      <!-- å³ä¾§UIé¢æ¿ï¼ˆæ–°ï¼‰ -->
      <div class="right-panel text-16">
        <div id="newGameBtn" class="tap-button" style="background-color: #FF6C45; box-shadow: 0 0.4rem 0 0 #DD3D1F;">é‡æ–°å¼€å§‹</div>
        <div id="undoBtn" class="tap-button" style="margin-bottom: 2rem; background-color: #626774; box-shadow: 0 0.4rem 0 0 #3E4454;">æ’¤é”€æ“ä½œ</div>
        <div id="rotateLeftBtn" class="tap-button" style="background-color: #4E9DFC; box-shadow: 0 0.4rem 0 0 #1E77E6;">å‘å·¦æ—‹è½¬</div>
        <div id="rotateRightBtn" class="tap-button" style="background-color: #E18845; box-shadow: 0 0.4rem 0 0 #C86825;">å‘å³æ—‹è½¬</div>
        <div id="submitAnswerBtn" class="tap-button" style="background-color: #8EC625; box-shadow: 0 0.4rem 0 0 #17A34A;">æäº¤ç­”æ¡ˆ</div>
      </div>

      <!-- ç§¯åˆ†æŒ‰é’® -->
      <button id="pointsBtn" class="help-btn" title="æŸ¥çœ‹ç§¯åˆ†"></button>
      <!-- å¸®åŠ©æŒ‰é’® -->
      <button id="helpBtn" class="help-btn" title="æŸ¥çœ‹è§„åˆ™"></button>

      <div id="successEffect">ğŸ‰ å®Œç¾ï¼ä¸‹ä¸€å…³...</div>
    </div>

    <!-- ç›¸æœºè°ƒè¯•é¢æ¿ -->
    <div id="cameraDebugPanel" style="
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      max-width: 320px;
      z-index: 10000;
      display: none;
      font-family: monospace;
    ">
      <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ğŸ“· ç›¸æœºè°ƒè¯•é¢æ¿</h3>
      
      <div style="margin-bottom: 10px;">
        <label>ğŸ“ ç›¸æœºXåæ ‡ (å·¦å³): <span id="camXValue">0</span></label>
        <input type="range" id="camX" min="-15" max="0" step="0.1" value="-3" style="width: 100%;">
        <small style="color: #888;">è´Ÿå€¼=å·¦ä¾§è§†è§’</small>
      </div>
      
      <div style="margin-bottom: 10px;">
        <label>ğŸ“ ç›¸æœºYåæ ‡ (é«˜åº¦): <span id="camYValue">0</span></label>
        <input type="range" id="camY" min="0" max="15" step="0.1" value="3" style="width: 100%;">
        <small style="color: #888;">å€¼è¶Šå¤§è¶Šé«˜</small>
      </div>
      
      <div style="margin-bottom: 10px;">
        <label>ğŸ“ ç›¸æœºZåæ ‡ (å‰å): <span id="camZValue">0</span></label>
        <input type="range" id="camZ" min="-15" max="15" step="0.1" value="3" style="width: 100%;">
        <small style="color: #888;">æ­£å€¼=åæ–¹è§†è§’</small>
      </div>
      
      <div style="margin-bottom: 10px;">
        <label>ğŸ‘ï¸ è§†çº¿ç„¦ç‚¹é«˜åº¦: <span id="lookAtYValue">0</span></label>
        <input type="range" id="lookAtY" min="-2" max="5" step="0.1" value="0.4" style="width: 100%;">
        <small style="color: #888;">ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹é«˜åº¦</small>
      </div>
      
      <div style="display: flex; gap: 5px; margin-top: 15px;">
        <button id="resetCamera" style="
          flex: 1;
          padding: 8px;
          background: #f59e0b;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 11px;
        ">é‡ç½®</button>
        
        <button id="logCameraParams" style="
          flex: 1;
          padding: 8px;
          background: #10b981;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 11px;
        ">æ‰“å°ä»£ç </button>
        
        <button id="closeCameraDebug" style="
          padding: 8px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 11px;
        ">å…³é—­</button>
      </div>
      
      <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 10px;">
        <div>å½“å‰éš¾åº¦: <span id="currentGridSize">3</span>x<span id="currentGridSize2">3</span></div>
        <div>å®é™…ä½ç½®: <span id="actualCamPos">-,-,-</span></div>
        <div style="color: #4ade80; margin-top: 3px;">ğŸ’¡ æ»‘åŠ¨æ»‘å—è‡ªåŠ¨ç”Ÿæ•ˆ</div>
      </div>
    </div>

    <script>
      // æ¸¸æˆç»Ÿè®¡å’Œæ¶ˆæ¯é€šä¿¡
      let game_config = ''
      let currentGameScore = 0
      let gameStarted = false

      // ç§¯åˆ†ç³»ç»Ÿç›¸å…³å˜é‡
      let totalTrainingPoints = 0 // æ€»ç§¯åˆ†
      let currentGamePoints = 0   // æœ¬æ¬¡æ¸¸æˆè·å¾—çš„ç§¯åˆ†
      let hasClosedRulesOnce = false // æ˜¯å¦å·²ç»å…³é—­è¿‡è§„åˆ™çª—å£
      let accuracy = 0 // å‡†ç¡®ç‡

      // è·å–éš¾åº¦åç§°
      function getDifficultyName(gridSize) {
        switch (gridSize) {
          case 2: return 'å…¥é—¨'
          case 3: return 'ç®€å•'
          case 4: return 'ä¸­ç­‰'
          case 5: return 'å›°éš¾'
          default: return 'å…¥é—¨'
        }
      }

      // æ›´æ–°æ¨èéš¾åº¦æ˜¾ç¤º
      function updateRecommendedDifficulty(gridSize) {
        const recommendedDifficultySpan = document.getElementById('recommendedDifficulty')
        if (recommendedDifficultySpan) {
          const difficultyName = getDifficultyName(gridSize)
          recommendedDifficultySpan.textContent = `ã€${difficultyName}ã€‘`
        }
      }

      // é«˜äº®éš¾åº¦é€‰æ‹©å™¨
      function highlightDifficultySelector() {
        const newSelector = document.getElementById('newDifficultySelector')
        if (newSelector) {
          newSelector.classList.add('difficulty-highlight')
          setTimeout(() => {
            newSelector.classList.remove('difficulty-highlight')
          }, 2000)
        }
      }

      // è®¡ç®—åˆ†æ•°ï¼šåŸºäºå…³å¡æ•°å¹³å‡åˆ†é…ï¼Œæ¯ä¸ªéš¾åº¦å®Œç¾å®Œæˆåæ€»åˆ†éƒ½æ˜¯100åˆ†
      function calculateGameScore(gridSize, actualCubes, minCubes, maxLevels = 10) {
        // æ¯å…³çš„åŸºç¡€åˆ†æ•° = 100åˆ† / æ€»å…³å¡æ•°
        const baseScore = 100 / maxLevels

        // æ•ˆç‡åŠ æˆï¼šä½¿ç”¨æœ€å°‘æ–¹å—æ•°å¾—æ»¡åˆ†ï¼Œä½¿ç”¨æ›´å¤šæ–¹å—æŒ‰æ¯”ä¾‹å‡åˆ†
        const efficiency = Math.min(1, minCubes / actualCubes)

        return Math.round(baseScore * efficiency)
      }

      // è®¡ç®—ç§¯åˆ†ï¼šæ ¹æ®éš¾åº¦ç¡®å®šæ¯å…³ç§¯åˆ†
      function calculateTrainingPoints(gridSize) {
        switch (gridSize) {
          case 2: return 5  // å…¥é—¨éš¾åº¦
          case 3: return 5  // ç®€å•éš¾åº¦
          case 4: return 10 // ä¸­ç­‰éš¾åº¦
          case 5: return 15 // å›°éš¾éš¾åº¦
          default: return 5
        }
      }

      // è·å–éš¾åº¦ç­‰çº§
      function getDifficultyLevel(gridSize) {
        if (gridSize === 2) return 0 // å…¥é—¨
        if (gridSize === 3) return 1 // ç®€å•
        if (gridSize === 4) return 2 // ä¸­ç­‰
        return 3 // å›°éš¾
      }

      // æ¶ˆæ¯ç›‘å¬å™¨
      window.addEventListener('message', function (e) {
        switch (e.data.type) {
          case 'setGameConfig':
            game_config = e.data.data // this is markdown or text string
            // æ›´æ–°æ¸¸æˆé…ç½®é€»è¾‘
            console.log('Game config updated:', game_config)
            // if (game) {
            //     game.applyExternalConfig(game_config);
            // }

                        
            // æ ¹æ®levelNameè®¾ç½®åˆå§‹éš¾åº¦
            let suggestedGridSize = null;
            
            if (e.data.levelName) {
              switch (e.data.levelName) {
                case 'å¾…æå‡':
                  suggestedGridSize = 2; // å…¥é—¨
                  break;
                case 'è‰¯å¥½':
                  suggestedGridSize = 3; // ç®€å•
                  break;
                case 'ä¼˜å¼‚':
                  suggestedGridSize = 4; // ä¸­ç­‰
                  break;
              }
            }
            
            if (suggestedGridSize !== null) {
              const currentGridSize = game.gridSize || 2; // é»˜è®¤ä¸º2
              // å–æ›´é«˜çš„éš¾åº¦å€¼ä½œä¸ºåˆå§‹éš¾åº¦
              const finalGridSize = Math.max(currentGridSize, suggestedGridSize);
              if (finalGridSize !== currentGridSize) {
                game.gridSize = finalGridSize;
                if (window.setCurrentDifficulty) {
                  window.setCurrentDifficulty(finalGridSize);
                }
                console.log(`æ ¹æ®levelName "${e.data.levelName}" è°ƒæ•´éš¾åº¦åˆ° gridSize: ${finalGridSize}`);
                if (game && typeof game.newGame === 'function') {
                  game.newGame();
                }
              }
              // æ›´æ–°æ¨èéš¾åº¦æ˜¾ç¤º
              updateRecommendedDifficulty(finalGridSize);
            }
            
            // æŸ¥è¯¢æ€»ç§¯åˆ†
            window.parent.postMessage({
              type: 'getTotalTrainingPoints',
            }, '*');
            break
          case 'gameContinue':
            if (e.data.action === 'restart') {
              if (game && game.isGameFinished) {
                // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œé‡æ–°å¼€å§‹æ¸¸æˆ
                game.newGame()
              }
            } else if (e.data.action === 'challenge') {
                // å¦‚æœæœ‰ä¸‹ä¸€ä¸ªéš¾åº¦ï¼Œä»ä¸‹ä¸€ä¸ªéš¾åº¦å¼€å§‹æ¸¸æˆ
                if (game && game.isGameFinished) {
                  const nextDifficulty = Math.min(game.gridSize + 1, 5) // æœ€å¤§éš¾åº¦ä¸º5
                  game.gridSize = nextDifficulty
                  if (window.setCurrentDifficulty) {
                    window.setCurrentDifficulty(nextDifficulty)
                  }
                  game.newGame()
                }
            }
            break
          case 'getGameStats':
            window.parent.postMessage(
              {
                type: 'gameStats',
                data: {
                  score: currentGameScore,
                  difficulty: getDifficultyLevel(game.gridSize),
                },
              },
              '*'
            )
            break
          case 'trainingPointsResponse':
            // æ”¶åˆ°ç§¯åˆ†æ›´æ–°å›å¤
            totalTrainingPoints = e.data.totalPoints
            updatePointsDisplay()
            break
          case 'totalTrainingPointsResponse':
            // æ”¶åˆ°æ€»ç§¯åˆ†æŸ¥è¯¢å›å¤
            totalTrainingPoints = e.data.total
            updatePointsStats(e.data)
            break
        }
      })

      // æ›´æ–°ç§¯åˆ†æ˜¾ç¤º
      function updatePointsDisplay() {
        // æ›´æ–°ç§¯åˆ†å¼¹çª—ä¸­çš„æ€»ç§¯åˆ†æ˜¾ç¤º
        const totalPointsDisplay = document.getElementById('totalPointsDisplay')
        if (totalPointsDisplay) {
          totalPointsDisplay.textContent = totalTrainingPoints
        }
      }

      // æ›´æ–°ç§¯åˆ†ç»Ÿè®¡æ˜¾ç¤ºï¼ˆåŒ…å«ä»Šæ—¥ç§¯åˆ†å’Œæœ€åæ›´æ–°æ—¶é—´ï¼‰
      function updatePointsStats(data) {
        if (data.total !== undefined) {
          const totalPointsDisplay = document.getElementById('totalPointsDisplay')
          if (totalPointsDisplay) {
            totalPointsDisplay.textContent = data.total
          }
        }
        
        if (data.dailyTotal !== undefined) {
          const dailyPointsDisplay = document.getElementById('dailyPointsDisplay')
          if (dailyPointsDisplay) {
            dailyPointsDisplay.textContent = '+' + data.dailyTotal
          }
        }
        
        if (data.lastUpdateDate) {
          const lastUpdateDisplay = document.getElementById('lastUpdateDateDisplay')
          if (lastUpdateDisplay) {
            lastUpdateDisplay.textContent = data.lastUpdateDate
          }
        }
      }

      // è§„åˆ™å¼¹çª—æ§åˆ¶
      function initRulesModal() {
        const rulesModal = document.getElementById('rulesModal')
        const closeRules = document.getElementById('closeRules')
        const startGameFromRules = document.getElementById('startGameFromRules')
        const helpBtn = document.getElementById('helpBtn')

        // ç§¯åˆ†å¼¹çª—ç›¸å…³å…ƒç´ 
        const pointsModal = document.getElementById('pointsModal')
        const closePoints = document.getElementById('closePoints')
        const pointsBtn = document.getElementById('pointsBtn')

        // å…³é—­è§„åˆ™å¼¹çª—
        function closeRulesModal() {
          rulesModal.classList.add('hidden')
          // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å…³é—­è§„åˆ™çª—å£ï¼Œé«˜äº®éš¾åº¦é€‰æ‹©å™¨
          if (!hasClosedRulesOnce) {
            hasClosedRulesOnce = true
            setTimeout(() => {
              highlightDifficultySelector()
            }, 300) // å»¶è¿Ÿä¸€ç‚¹è®©å¼¹çª—å…³é—­åŠ¨ç”»å®Œæˆ
          }
        }

        // æ‰“å¼€è§„åˆ™å¼¹çª—
        function openRulesModal() {
          rulesModal.classList.remove('hidden')
        }

        // å…³é—­ç§¯åˆ†å¼¹çª—
        function closePointsModalFunc() {
          pointsModal.classList.add('hidden')
        }

        // æ‰“å¼€ç§¯åˆ†å¼¹çª—
        function openPointsModal() {
          window.parent.postMessage({ type: 'getTotalTrainingPoints' }, '*');
          pointsModal.classList.remove('hidden')
        }

        openRulesModal()

        closeRules.addEventListener('click', closeRulesModal)
        helpBtn.addEventListener('click', openRulesModal)

        // ç§¯åˆ†å¼¹çª—äº‹ä»¶ç›‘å¬
        closePoints.addEventListener('click', closePointsModalFunc)
        pointsBtn.addEventListener('click', openPointsModal)

        // ä»è§„åˆ™å¼¹çª—å¼€å§‹æ¸¸æˆ
        startGameFromRules.addEventListener('click', () => {
          closeRulesModal()
          if (game) {
            game.newGame()
          }
        })

        // ç‚¹å‡»é®ç½©å…³é—­
        rulesModal.addEventListener('click', (e) => {
          if (e.target === rulesModal) {
            closeRulesModal()
          }
        })

        pointsModal.addEventListener('click', (e) => {
          if (e.target === pointsModal) {
            closePointsModalFunc()
          }
        })
      }

      // è°ƒæ•´æ ¹å­—ä½“å¤§å°çš„å‡½æ•°ï¼ˆç§»åˆ°classå¤–éƒ¨ï¼‰
      function adjustRootFontSize() {
        // æ¸¸æˆä¸»å®¹å™¨çš„è®¾è®¡å°ºå¯¸ (å•ä½ï¼šrem)
        const DESIGN_WIDTH = 65.2  // rem
        const DESIGN_HEIGHT = 37.5 // rem
        
        // è·å–è§†å£å°ºå¯¸
        const viewportWidth = window.innerWidth
        const viewportHeight = window.innerHeight
        
        // åŸºå‡†å­—ä½“å¤§å°
        const baseFontSize = 10 // è®¾è®¡ç¨¿åŸºå‡†: 1rem = 10px
        
        // è®¡ç®—åŸºäºå®½åº¦å’Œé«˜åº¦çš„ç¼©æ”¾æ¯”ä¾‹
        const scaleByWidth = viewportWidth / (DESIGN_WIDTH * baseFontSize)
        const scaleByHeight = viewportHeight / (DESIGN_HEIGHT * baseFontSize)
        
        // å–è¾ƒå°çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œç¡®ä¿å†…å®¹å®Œå…¨å¯è§ï¼ˆç­‰æ¯”ä¾‹ç¼©æ”¾ï¼‰
        const scale = Math.min(scaleByWidth, scaleByHeight)
        
        // è®¾ç½®æ ¹å…ƒç´ çš„ font-size
        const finalFontSize = baseFontSize * scale
        
        document.documentElement.style.fontSize = `${finalFontSize}px`
        
        console.log('Root font size adjusted:', finalFontSize, 'px, scale:', scale)
        
        return finalFontSize
      }

      class SpatialGame {
        constructor() {
          this.scene = new THREE.Scene()
          
          // ä½¿ç”¨gameCanvasçš„å®½é«˜æ¯”åˆå§‹åŒ–ç›¸æœºï¼ˆ36rem / 29.6rem â‰ˆ 1.216ï¼‰
          const canvasAspect = 36 / 29.6
          this.camera = new THREE.PerspectiveCamera(75, canvasAspect, 0.1, 1000)
          this.renderer = new THREE.WebGLRenderer({ antialias: true })
          this.gridSize = 3 // é»˜è®¤3x3
          this.cubes = new Map() // å­˜å‚¨ç”¨æˆ·æ”¾ç½®çš„ç«‹æ–¹ä½“
          this.targetCubes = new Map() // å­˜å‚¨ç›®æ ‡ç«‹æ–¹ä½“
          this.projectionCubes = [] // å­˜å‚¨æŠ•å½±ç«‹æ–¹ä½“
          this.cubeHistory = [] // å­˜å‚¨æ–¹å—æ”¾ç½®å†å²ï¼Œç”¨äºæ’¤é”€
          this.rotationSteps = 0 // ä½¿ç”¨æ­¥æ•°è€Œä¸æ˜¯è§’åº¦ï¼Œé¿å…æµ®ç‚¹æ•°ç´¯ç§¯è¯¯å·®
          this.isRotating = false // æ˜¯å¦æ­£åœ¨æ—‹è½¬
          this.minCubesNeeded = 0 // æœ€å°‘éœ€è¦çš„æ–¹å—æ•°

          // é•¿æŒ‰ç›¸å…³
          this.longPressTimer = null
          this.longPressThreshold = 600 // 600ms é•¿æŒ‰é˜ˆå€¼
          this.isLongPressing = false
          this.touchStartPos = null

          this.startTime = 0
          this.gameLoaded = false

          // æ–°å¢ï¼šæ¸¸æˆå…³å¡å’Œæ€»ä½“è®¡åˆ†ç³»ç»Ÿ
          this.currentLevel = 1
          this.maxLevels = 10
          this.levelScores = [] // è®°å½•å„å…³åˆ†æ•°
          this.gameStartTime = 0 // æ•´ä¸ªæ¸¸æˆå¼€å§‹æ—¶é—´
          this.isGameFinished = false // æ¸¸æˆæ˜¯å¦å·²ç»“æŸ

          // ç§¯åˆ†ç³»ç»Ÿ
          currentGamePoints = 0 // é‡ç½®æœ¬æ¬¡æ¸¸æˆç§¯åˆ†
          accuracy = 0 // é‡ç½®å‡†ç¡®ç‡

          this.init()
          this.setupEventListeners()
          this.newGame()

          // åˆå§‹åŒ–è§„åˆ™å¼¹çª—
          initRulesModal()

          // åˆå§‹åŒ–æ¨èéš¾åº¦æ˜¾ç¤º
          updateRecommendedDifficulty(this.gridSize)
        }

        init() {
          // è·å–gameCanvasçš„å®é™…å°ºå¯¸ï¼ˆ36rem Ã— 29.6remï¼‰
          const canvas = document.getElementById('gameCanvas')
          const canvasRect = canvas.getBoundingClientRect()
          
          console.log('Canvas size:', canvasRect.width, 'x', canvasRect.height)
          
          // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
          this.camera.aspect = canvasRect.width / canvasRect.height
          this.camera.updateProjectionMatrix()
          
          // ä¿®æ”¹æ¸²æŸ“å™¨é™„åŠ åˆ°æ¸¸æˆç”»å¸ƒåŒºåŸŸï¼Œä½¿ç”¨canvasçš„å®é™…å°ºå¯¸
          this.renderer.setSize(canvasRect.width, canvasRect.height)
          this.renderer.setClearColor(0xD5E9FF)
          canvas.appendChild(this.renderer.domElement)

          // è®¾ç½®åˆå§‹ç›¸æœºä½ç½®ï¼ˆå¯¹ç§°è§†è§’ï¼šX=-Zï¼Œå°†ç”±autoZoomCameraè°ƒæ•´ï¼‰
          this.camera.position.set(-4.5, 4.5, 4.5)
          this.camera.lookAt(0, 0.5, 0)

          // æ·»åŠ ç¯å¢ƒå…‰å’Œæ–¹å‘å…‰ï¼ˆä¸äº§ç”Ÿé˜´å½±ï¼‰
          const ambientLight = new THREE.AmbientLight(0x404040, 0.8)
          this.scene.add(ambientLight)

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6)
          directionalLight.position.set(10, 10, 5)
          this.scene.add(directionalLight)

          // åˆ›å»ºå¹³å°ç»„å’Œå¢™ç»„ï¼ˆå°†åœ¨updatePlatformTransformä¸­è®¾ç½®ä½ç½®å’Œç¼©æ”¾ï¼‰
          this.platformGroup = new THREE.Group()
          this.scene.add(this.platformGroup)

          // åˆ›å»ºå›ºå®šçš„æŠ•å½±å¢™ç»„
          this.wallGroup = new THREE.Group()
          this.scene.add(this.wallGroup)
          
          // è®¾ç½®åˆå§‹å¹³å°å˜æ¢
          this.updatePlatformTransform()

          this.createPlatform()
          this.createWalls()

          // Set optimal camera position after scene is created
          setTimeout(() => this.autoZoomCamera(), 100)

          this.animate()

          // å‘é€æ¸¸æˆåŠ è½½å®Œæˆäº‹ä»¶
          if (!this.gameLoaded) {
            window.parent.postMessage({ type: 'gameLoaded' }, '*')
            this.gameLoaded = true
          }
        }

        // æ ¹æ®gridSizeæ›´æ–°å¹³å°å’Œå¢™çš„ä½ç½®ä¸ç¼©æ”¾
        updatePlatformTransform() {
          // æ ¹æ®gridSizeåŠ¨æ€è°ƒæ•´å¹³å°å‚æ•°
          let platformX, platformY, platformZ, platformScale
          
          switch(this.gridSize) {
            case 2: // 2x2 å…¥é—¨éš¾åº¦ - æ›´å¤§çš„ç¼©æ”¾
              platformX = 0.2
              platformY = -1.2
              platformZ = -0.5
              platformScale = 1.8
              break
            case 3: // 3x3 ç®€å•éš¾åº¦ - æ ‡å‡†ç¼©æ”¾
              platformX = 0.3
              platformY = -1.4
              platformZ = -0.7
              platformScale = 1.5
              break
            case 4: // 4x4 ä¸­ç­‰éš¾åº¦ - è¾ƒå°ç¼©æ”¾
              platformX = 0.4
              platformY = -1.5
              platformZ = -0.8
              platformScale = 1.3
              break
            case 5: // 5x5 å›°éš¾éš¾åº¦ - æœ€å°ç¼©æ”¾
              platformX = 0.5
              platformY = -1.6
              platformZ = -1.0
              platformScale = 1.1
              break
            default:
              platformX = 0.3
              platformY = -1.4
              platformZ = -0.7
              platformScale = 1.5
          }
          
          // åº”ç”¨å˜æ¢åˆ°å¹³å°ç»„
          this.platformGroup.position.set(platformX, platformY, platformZ)
          this.platformGroup.scale.setScalar(platformScale)
          
          // åº”ç”¨ç›¸åŒå˜æ¢åˆ°å¢™ç»„
          this.wallGroup.position.set(platformX, platformY, platformZ)
          this.wallGroup.scale.setScalar(platformScale)
          
          console.log(`Platform transform for gridSize ${this.gridSize}: pos=(${platformX}, ${platformY}, ${platformZ}), scale=${platformScale}`)
        }

        // è·å–ç²¾ç¡®çš„æ—‹è½¬å˜æ¢å‚æ•°ï¼Œé¿å…æµ®ç‚¹æ•°è¯¯å·®
        getRotationParams() {
          // å°†æ—‹è½¬æ­¥æ•°æ ‡å‡†åŒ–åˆ°0-3èŒƒå›´å†…
          const normalizedSteps = ((this.rotationSteps % 4) + 4) % 4

          switch (normalizedSteps) {
            case 0:
              return { cos: 1, sin: 0 } // 0åº¦
            case 1:
              return { cos: 0, sin: -1 } // 90åº¦
            case 2:
              return { cos: -1, sin: 0 } // 180åº¦
            case 3:
              return { cos: 0, sin: 1 } // 270åº¦
            default:
              return { cos: 1, sin: 0 }
          }
        }

        // åº”ç”¨å¤–éƒ¨é…ç½®
        applyExternalConfig(configData) {
          if (!configData) return

          try {
            // å°è¯•è§£æJSONé…ç½®
            let config
            if (typeof configData === 'string') {
              config = JSON.parse(configData)
            } else {
              config = configData
            }
            if (!config) {
              console.error('applyExternalConfig: é…ç½®å¯¹è±¡æ— æ•ˆï¼Œä¿æŒå½“å‰é…ç½®')
              return
            }

            // éšè—éš¾åº¦é€‰æ‹©å™¨
            const difficultyContainer = document.querySelector('.ui-select_container')
            if (difficultyContainer) {
              // difficultyContainer.style.display = 'none';
            }

            // å…³é—­ä»»ä½•æ˜¾ç¤ºçš„æ•ˆæœçª—å£
            const effect = document.getElementById('successEffect')
            effect.classList.remove('success-show')

            // é‡ç½®æ¸¸æˆçŠ¶æ€åˆ°ç¬¬ä¸€å…³
            this.maxLevels = config.maxLevels
            this.gridSize = config.gridSize
            this.currentLevel = 1
            this.levelScores = []
            this.isGameFinished = false
            this.gameStartTime = 0 // é‡ç½®æ¸¸æˆå¼€å§‹æ—¶é—´ï¼Œä¸‹æ¬¡newGameæ—¶ä¼šé‡æ–°è®¾ç½®
            currentGamePoints = 0 // é‡ç½®æœ¬æ¬¡æ¸¸æˆç§¯åˆ†
            accuracy = 0 // é‡ç½®å‡†ç¡®ç‡
            if (window.setCurrentDifficulty) {
              window.setCurrentDifficulty(this.gridSize)
            }
            // é‡æ–°å¼€å§‹æ¸¸æˆ
            this.newGame()
            console.log('å¤–éƒ¨é…ç½®å·²åº”ç”¨:', config)
          } catch (error) {
            console.error('è§£æå¤–éƒ¨é…ç½®æ—¶å‡ºé”™:', error)
          }
        }

        createCheckerboardTexture() {
          const size = 256
          const canvas = document.createElement('canvas')
          canvas.width = size
          canvas.height = size
          const context = canvas.getContext('2d')

          const tileSize = size / this.gridSize

          for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
              const isLight = (i + j) % 2 === 0
              context.fillStyle = isLight ? '#8B6F47' : '#6B5937' // æµ…æ£•è‰²å’Œæ·±æ£•è‰²
              context.fillRect(i * tileSize, j * tileSize, tileSize, tileSize)
            }
          }

          const texture = new THREE.CanvasTexture(canvas)
          texture.wrapS = THREE.ClampToEdgeWrapping
          texture.wrapT = THREE.ClampToEdgeWrapping
          return texture
        }

        createPlatform() {
          // æ¸…é™¤ç°æœ‰å¹³å°
          while (this.platformGroup.children.length > 0) {
            this.platformGroup.remove(this.platformGroup.children[0])
          }

          // åˆ›å»ºæ£‹ç›˜æ ¼çº¹ç†
          const checkerTexture = this.createCheckerboardTexture()

          // åˆ›å»ºåº•éƒ¨å¹³å°
          const platformGeometry = new THREE.BoxGeometry(this.gridSize, 0.2, this.gridSize)
          const platformMaterial = new THREE.MeshLambertMaterial({
            map: checkerTexture,
          })
          const platform = new THREE.Mesh(platformGeometry, platformMaterial)
          platform.position.y = -0.1
          platform.userData = { type: 'platform' }
          this.platformGroup.add(platform)

          // åˆ›å»ºç½‘æ ¼çº¿
          this.createGridLines()
        }

        createGridLines() {
          const material = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.4, transparent: true })

          // æ°´å¹³çº¿
          for (let i = 0; i <= this.gridSize; i++) {
            const geometry = new THREE.BufferGeometry()
            const points = [
              new THREE.Vector3(-this.gridSize / 2, 0.01, -this.gridSize / 2 + i),
              new THREE.Vector3(this.gridSize / 2, 0.01, -this.gridSize / 2 + i),
            ]
            geometry.setFromPoints(points)
            this.platformGroup.add(new THREE.Line(geometry, material))
          }

          // å‚ç›´çº¿
          for (let i = 0; i <= this.gridSize; i++) {
            const geometry = new THREE.BufferGeometry()
            const points = [
              new THREE.Vector3(-this.gridSize / 2 + i, 0.01, -this.gridSize / 2),
              new THREE.Vector3(-this.gridSize / 2 + i, 0.01, this.gridSize / 2),
            ]
            geometry.setFromPoints(points)
            this.platformGroup.add(new THREE.Line(geometry, material))
          }
        }

        createWalls() {
          // æ¸…é™¤ç°æœ‰å¢™
          while (this.wallGroup.children.length > 0) {
            this.wallGroup.remove(this.wallGroup.children[0])
          }

          // æ ¹æ®gridSizeåŠ¨æ€è°ƒæ•´å¢™å£é«˜åº¦ï¼Œç¡®ä¿èƒ½æ˜¾ç¤ºæ‰€æœ‰æŠ•å½±
          // ä¸ºä¸åŒéš¾åº¦æä¾›åˆé€‚çš„å¢™å£é«˜åº¦
          let wallHeight
          switch(this.gridSize) {
            case 2:
              wallHeight = this.gridSize * 1.2 // 2x2: è¾ƒå°çš„å¢™
              break
            case 3:
              wallHeight = this.gridSize * 1.1 // 3x3: æ ‡å‡†å¢™é«˜
              break
            case 4:
              wallHeight = this.gridSize * 1.05 // 4x4: ç¨é«˜çš„å¢™
              break
            case 5:
              wallHeight = this.gridSize * 1.0 // 5x5: æ›´é«˜çš„å¢™
              break
            default:
              wallHeight = this.gridSize * 1.1
          }

          // å¢™å£è·ç¦»ä¹Ÿæ ¹æ®gridSizeè°ƒæ•´
          const wallDistance = 0.3 + this.gridSize * 0.05

          // æ­£é¢å¢™
          const frontWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight)
          const frontWallMaterial = new THREE.MeshLambertMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
          })
          const frontWall = new THREE.Mesh(frontWallGeometry, frontWallMaterial)
          frontWall.position.set(0, wallHeight / 2, -this.gridSize / 2 - wallDistance)
          frontWall.userData = { type: 'wall' }
          this.wallGroup.add(frontWall)

          // å³ä¾§å¢™
          const rightWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight)
          const rightWallMaterial = new THREE.MeshLambertMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
          })
          const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial)
          rightWall.position.set(this.gridSize / 2 + wallDistance, wallHeight / 2, 0)
          rightWall.rotation.y = Math.PI / 2
          rightWall.userData = { type: 'wall' }
          this.wallGroup.add(rightWall)
        }

        generateTarget() {
          this.targetCubes.clear()
          
          // æå‡å„éš¾åº¦çš„åˆå§‹æ–¹å—æ•°ï¼Œå¹¶è®©éšå…³å¡é€’å¢çš„æ•°é‡å…·æœ‰éšæœºæ€§
          let numCubes
          let baseGrowth, randomVariation
          
          switch (this.gridSize) {
            case 2: // å…¥é—¨éš¾åº¦ï¼šä»3ä¸ªå¼€å§‹ï¼ŒåŸºç¡€å¢é•¿+éšæœºæ³¢åŠ¨
              baseGrowth = 3 + (this.currentLevel - 1) * 0.25
              randomVariation = (Math.random() - 0.5) * 1.2 // Â±0.6çš„éšæœºæ³¢åŠ¨
              numCubes = Math.max(3, Math.floor(baseGrowth + randomVariation))
              break
            case 3: // ç®€å•éš¾åº¦ï¼šä»5ä¸ªå¼€å§‹ï¼ŒåŸºç¡€å¢é•¿+éšæœºæ³¢åŠ¨
              baseGrowth = 5 + (this.currentLevel - 1) * 0.4
              randomVariation = (Math.random() - 0.5) * 1.6 // Â±0.8çš„éšæœºæ³¢åŠ¨
              numCubes = Math.max(4, Math.floor(baseGrowth + randomVariation))
              break
            case 4: // ä¸­ç­‰éš¾åº¦ï¼šä»8ä¸ªå¼€å§‹ï¼ŒåŸºç¡€å¢é•¿+éšæœºæ³¢åŠ¨
              baseGrowth = 8 + (this.currentLevel - 1) * 0.7
              randomVariation = (Math.random() - 0.5) * 2.4 // Â±1.2çš„éšæœºæ³¢åŠ¨
              numCubes = Math.max(6, Math.floor(baseGrowth + randomVariation))
              break
            case 5: // å›°éš¾éš¾åº¦ï¼šä»10ä¸ªå¼€å§‹ï¼ŒåŸºç¡€å¢é•¿+éšæœºæ³¢åŠ¨
              baseGrowth = 10 + (this.currentLevel - 1) * 1.0
              randomVariation = (Math.random() - 0.5) * 3.2 // Â±1.6çš„éšæœºæ³¢åŠ¨
              numCubes = Math.max(8, Math.floor(baseGrowth + randomVariation))
              break
            default:
              baseGrowth = 3 + (this.currentLevel - 1) * 0.25
              randomVariation = (Math.random() - 0.5) * 1.2
              numCubes = Math.max(3, Math.floor(baseGrowth + randomVariation))
          }
          
          // ç¡®ä¿æ–¹å—æ•°ä¸è¶…è¿‡ç½‘æ ¼å®¹é‡çš„åˆç†ä¸Šé™
          const maxReasonableCubes = this.gridSize * this.gridSize * 2
          numCubes = Math.min(numCubes, maxReasonableCubes)
          console.log(`ç”Ÿæˆç›®æ ‡ç»“æ„: éš¾åº¦ ${this.gridSize}x${this.gridSize}, å…³å¡ ${this.currentLevel}, ç›®æ ‡æ–¹å—æ•°: ${numCubes}`)

          // ç¡®ä¿ç¬¬ä¸€ä¸ªæ–¹å—åœ¨åœ°é¢ä¸Šï¼ˆä½œä¸ºè¿æ¥èµ·ç‚¹ï¼‰
          let firstX = Math.floor(Math.random() * this.gridSize)
          let firstZ = Math.floor(Math.random() * this.gridSize)
          let key = `${firstX},0,${firstZ}`
          this.targetCubes.set(key, { x: firstX, y: 0, z: firstZ, color: this.getRandomColor() })

          // ç”Ÿæˆå…¶ä»–è”é€šçš„æ–¹å—ï¼Œé«˜éš¾åº¦ä¸‹å€¾å‘äºç”Ÿæˆæ›´å¤æ‚çš„3Dç»“æ„
          for (let i = 1; i < numCubes; i++) {
            let placed = false
            let attempts = 0

            while (!placed && attempts < 100) { // å¢åŠ å°è¯•æ¬¡æ•°ä»¥ç”Ÿæˆæ›´å¤æ‚ç»“æ„
              // éšæœºé€‰æ‹©ä¸€ä¸ªå·²å­˜åœ¨çš„æ–¹å—
              const existingCubes = Array.from(this.targetCubes.values())
              const baseCube = existingCubes[Math.floor(Math.random() * existingCubes.length)]

              // æ ¹æ®éš¾åº¦è°ƒæ•´æ–¹å‘æƒé‡ï¼Œé«˜éš¾åº¦ä¸‹æ›´å€¾å‘äºå‘ä¸Šå»ºé€ 
              let directions = []
              if (this.gridSize >= 4) {
                // ä¸­ç­‰å’Œå›°éš¾éš¾åº¦ï¼šæ›´å¤šå‘ä¸Šçš„æ¦‚ç‡ï¼Œåˆ›é€ å¤æ‚çš„3Dç»“æ„
                directions = [
                  { x: 1, y: 0, z: 0, weight: 1 },
                  { x: -1, y: 0, z: 0, weight: 1 },
                  { x: 0, y: 1, z: 0, weight: 3 }, // å‘ä¸Šæƒé‡å¢åŠ 
                  { x: 0, y: -1, z: 0, weight: 0.5 }, // å‘ä¸‹æƒé‡å‡å°‘
                  { x: 0, y: 0, z: 1, weight: 1 },
                  { x: 0, y: 0, z: -1, weight: 1 },
                ]
              } else if (this.gridSize === 3) {
                // ç®€å•éš¾åº¦ï¼šé€‚ä¸­çš„å‘ä¸Šæ¦‚ç‡
                directions = [
                  { x: 1, y: 0, z: 0, weight: 1 },
                  { x: -1, y: 0, z: 0, weight: 1 },
                  { x: 0, y: 1, z: 0, weight: 2 }, // å‘ä¸Šæƒé‡é€‚ä¸­
                  { x: 0, y: -1, z: 0, weight: 0.8 },
                  { x: 0, y: 0, z: 1, weight: 1 },
                  { x: 0, y: 0, z: -1, weight: 1 },
                ]
              } else {
                // å…¥é—¨éš¾åº¦ï¼šä¸»è¦åœ¨æ°´å¹³é¢å»ºé€ 
                directions = [
                  { x: 1, y: 0, z: 0, weight: 1 },
                  { x: -1, y: 0, z: 0, weight: 1 },
                  { x: 0, y: 1, z: 0, weight: 1 },
                  { x: 0, y: -1, z: 0, weight: 0.3 },
                  { x: 0, y: 0, z: 1, weight: 1 },
                  { x: 0, y: 0, z: -1, weight: 1 },
                ]
              }

              // æ ¹æ®æƒé‡é€‰æ‹©æ–¹å‘
              const weightedDirections = []
              directions.forEach(dir => {
                const count = Math.round(dir.weight * 10)
                for (let j = 0; j < count; j++) {
                  weightedDirections.push({ x: dir.x, y: dir.y, z: dir.z })
                }
              })

              const direction = weightedDirections[Math.floor(Math.random() * weightedDirections.length)]
              const newX = baseCube.x + direction.x
              const newY = baseCube.y + direction.y
              const newZ = baseCube.z + direction.z

              // æ£€æŸ¥è¾¹ç•Œå’Œæ˜¯å¦å·²å­˜åœ¨
              if (
                newX >= 0 &&
                newX < this.gridSize &&
                newZ >= 0 &&
                newZ < this.gridSize &&
                newY >= 0 &&
                newY < this.gridSize
              ) {
                const newKey = `${newX},${newY},${newZ}`
                if (!this.targetCubes.has(newKey)) {
                  this.targetCubes.set(newKey, {
                    x: newX,
                    y: newY,
                    z: newZ,
                    color: this.getRandomColor(),
                  })
                  placed = true
                }
              }
              attempts++
            }
          }

          // é«˜éš¾åº¦ä¸‹å¢åŠ é¢å¤–çš„å¤æ‚ç»“æ„
          if (this.gridSize >= 4) {
            const extraCubes = Math.floor(Math.random() * 3) + 1 // 1-3ä¸ªé¢å¤–ç«‹æ–¹ä½“
            
            for (let i = 0; i < extraCubes; i++) {
              let placed = false
              let attempts = 0
              
              while (!placed && attempts < 50) {
                // é€‰æ‹©è¾ƒé«˜å±‚çš„ç«‹æ–¹ä½“ä½œä¸ºåŸºç¡€ï¼Œåˆ›å»ºæ‚¬ç©ºç»“æ„
                const existingCubes = Array.from(this.targetCubes.values())
                const highCubes = existingCubes.filter(cube => cube.y >= 1) // é€‰æ‹©ä¸åœ¨åœ°é¢çš„ç«‹æ–¹ä½“
                
                if (highCubes.length > 0) {
                  const baseCube = highCubes[Math.floor(Math.random() * highCubes.length)]
                  
                  // åˆ›å»ºåˆ†æ”¯æˆ–æ‚¬ç©ºç»“æ„
                  const branchDirections = [
                    { x: 1, y: 0, z: 0 },
                    { x: -1, y: 0, z: 0 },
                    { x: 0, y: 0, z: 1 },
                    { x: 0, y: 0, z: -1 },
                    { x: 0, y: 1, z: 0 }, // å‘ä¸Šåˆ†æ”¯
                  ]
                  
                  const direction = branchDirections[Math.floor(Math.random() * branchDirections.length)]
                  const newX = baseCube.x + direction.x
                  const newY = baseCube.y + direction.y
                  const newZ = baseCube.z + direction.z
                  
                  if (
                    newX >= 0 &&
                    newX < this.gridSize &&
                    newZ >= 0 &&
                    newZ < this.gridSize &&
                    newY >= 0 &&
                    newY < this.gridSize
                  ) {
                    const newKey = `${newX},${newY},${newZ}`
                    if (!this.targetCubes.has(newKey)) {
                      this.targetCubes.set(newKey, {
                        x: newX,
                        y: newY,
                        z: newZ,
                        color: this.getRandomColor(),
                      })
                      placed = true
                    }
                  }
                }
                attempts++
              }
            }
          }

          this.calculateMinCubes()
          this.updateProjections()
          this.updateCubeCount()
          this.updateSubmitButton()
        }

        calculateMinCubes() {
          this.minCubesNeeded = this.targetCubes.size
        }

        getRandomColor() {
          const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff]
          return colors[Math.floor(Math.random() * colors.length)]
        }

        updateProjections() {
          // æ¸…é™¤ç°æœ‰æŠ•å½±
          this.projectionCubes.forEach((cube) => {
            this.wallGroup.remove(cube)
          })
          this.projectionCubes = []

          // è®¡ç®—æŠ•å½±
          this.createProjectionDisplay()
        }

        createProjectionDisplay() {
          // è·å–ç›®æ ‡æŠ•å½±
          const targetFrontProjection = new Set()
          const targetRightProjection = new Set()

          for (const [key, target] of this.targetCubes) {
            const originalX = target.x - this.gridSize / 2 + 0.5
            const originalZ = target.z - this.gridSize / 2 + 0.5
            const originalY = target.y

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            targetFrontProjection.add(frontProjKey)
            targetRightProjection.add(rightProjKey)
          }

          // è·å–å½“å‰ç”¨æˆ·æ–¹å—çš„æŠ•å½±
          const currentFrontProjection = new Set()
          const currentRightProjection = new Set()

          for (const [key, cube] of this.cubes) {
            const originalX = cube.userData.gridX - this.gridSize / 2 + 0.5
            const originalZ = cube.userData.gridZ - this.gridSize / 2 + 0.5
            const originalY = cube.userData.gridY

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            currentFrontProjection.add(frontProjKey)
            currentRightProjection.add(rightProjKey)
          }

          // åˆ›å»ºæ­£é¢æŠ•å½±æ˜¾ç¤º
          this.createWallProjectionDisplay(targetFrontProjection, currentFrontProjection, 'front')

          // åˆ›å»ºå³ä¾§æŠ•å½±æ˜¾ç¤º
          this.createWallProjectionDisplay(targetRightProjection, currentRightProjection, 'right')
        }

        createWallProjectionDisplay(targetProjection, currentProjection, wall) {
          // åˆå¹¶æ‰€æœ‰æŠ•å½±ä½ç½®
          const allPositions = new Set([...targetProjection, ...currentProjection])

          for (const posKey of allPositions) {
            const [coordStr, yStr] = posKey.split(',')
            const coord = parseFloat(coordStr) / 2
            const y = parseFloat(yStr) / 2

            const isTarget = targetProjection.has(posKey)
            const isCurrent = currentProjection.has(posKey)

            let projCube

            if (isTarget && isCurrent) {
              // æ­£ç¡®æŠ•å½± - æ·±é»‘è‰²ï¼Œå¢å¤§å°ºå¯¸
              const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1) // ä»0.8å¢åŠ åˆ°0.9
              const projMaterial = new THREE.MeshLambertMaterial({
                color: 0x222222,
              })
              projCube = new THREE.Mesh(projGeometry, projMaterial)
            } else if (isTarget && !isCurrent) {
              // ç›®æ ‡æŠ•å½±ä½†ç”¨æˆ·æœªå®ç° - ç°è‰²ï¼Œå¢å¤§å°ºå¯¸
              const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1) // ä»0.8å¢åŠ åˆ°0.9
              const projMaterial = new THREE.MeshLambertMaterial({
                color: 0xeeeeee,
                emissive: 0x888888,
                emissiveIntensity: 0.3,
              })
              projCube = new THREE.Mesh(projGeometry, projMaterial)
            } else if (!isTarget && isCurrent) {
              // é”™è¯¯æŠ•å½± - æ˜¾ç¤ºXï¼Œå¢å¤§å°ºå¯¸
              projCube = this.createXMark(0.9) // ä»0.8å¢åŠ åˆ°0.9
            }

            if (projCube) {
              // æ”¾å®½æ˜¾ç¤ºèŒƒå›´é™åˆ¶ï¼Œå…è®¸æ›´é«˜å±‚çš„æŠ•å½±æ˜¾ç¤º
              const maxWallHeight = this.gridSize * 1.5 // ä»1.2å¢åŠ åˆ°1.5

              if (wall === 'front') {
                // æ­£é¢å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                if (Math.abs(coord) <= this.gridSize / 2 && y <= maxWallHeight && y > 0) {
                  projCube.position.set(coord, y, -this.gridSize / 2 - 0.5) // è°ƒæ•´ä½ç½®
                  this.wallGroup.add(projCube)
                  this.projectionCubes.push(projCube)
                }
              } else if (wall === 'right') {
                // å³ä¾§å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                if (Math.abs(coord) <= this.gridSize / 2 && y <= maxWallHeight && y > 0) {
                  projCube.position.set(this.gridSize / 2 + 0.5, y, coord) // è°ƒæ•´ä½ç½®
                  if (projCube.rotation) {
                    projCube.rotation.y = Math.PI / 2
                  }
                  this.wallGroup.add(projCube)
                  this.projectionCubes.push(projCube)
                }
              }
            }
          }
        }

        createXMark(size) {
          const group = new THREE.Group()
          const material = new THREE.MeshLambertMaterial({
            color: 0xcc3333,
            emissive: 0x888888,
            emissiveIntensity: 0.3,
          })

          // åˆ›å»ºXçš„ä¸¤æ¡çº¿
          const lineGeometry1 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05)
          const lineGeometry2 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05)

          const line1 = new THREE.Mesh(lineGeometry1, material)
          const line2 = new THREE.Mesh(lineGeometry2, material)

          line1.rotation.z = Math.PI / 4
          line2.rotation.z = -Math.PI / 4

          group.add(line1)
          group.add(line2)

          return group
        }

        isConnected(x, y, z) {
          // åœ°é¢ä¸Š(y=0)æ°¸è¿œå¯ä»¥æ”¾ç½®æ–¹å—
          if (y === 0) {
            return true
          }

          // å…¶ä»–ä½ç½®éœ€è¦æ£€æŸ¥è¿é€šæ€§
          if (this.cubes.size === 0) {
            return true
          }

          const neighbors = [
            { x: x + 1, y: y, z: z },
            { x: x - 1, y: y, z: z },
            { x: x, y: y + 1, z: z },
            { x: x, y: y - 1, z: z },
            { x: x, y: y, z: z + 1 },
            { x: x, y: y, z: z - 1 },
          ]

          for (const neighbor of neighbors) {
            const neighborKey = `${neighbor.x},${neighbor.y},${neighbor.z}`
            if (this.cubes.has(neighborKey)) {
              return true
            }
          }

          return false
        }

        startLongPress(event) {
          this.isLongPressing = false
          this.touchStartPos = {
            x: event.touches ? event.touches[0].clientX : event.clientX,
            y: event.touches ? event.touches[0].clientY : event.clientY,
          }

          this.longPressTimer = setTimeout(() => {
            this.isLongPressing = true
            this.handleLongPress(event)
          }, this.longPressThreshold)
        }

        endLongPress(event) {
          if (this.longPressTimer) {
            clearTimeout(this.longPressTimer)
            this.longPressTimer = null
          }

          if (!this.isLongPressing) {
            // çŸ­æŒ‰ï¼Œæ­£å¸¸ç‚¹å‡»
            this.handleClick(event)
          }

          this.isLongPressing = false
        }

        handleLongPress(event) {
          // é•¿æŒ‰åˆ é™¤æ–¹å—
          const canvas = document.getElementById('gameCanvas')
          const canvasRect = canvas.getBoundingClientRect()
          
          const mouse = new THREE.Vector2()
          const clientX = event.touches ? event.touches[0].clientX : event.clientX
          const clientY = event.touches ? event.touches[0].clientY : event.clientY

          // è®¡ç®—ç›¸å¯¹äºcanvasçš„åæ ‡
          mouse.x = ((clientX - canvasRect.left) / canvasRect.width) * 2 - 1
          mouse.y = -((clientY - canvasRect.top) / canvasRect.height) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh && child.userData.type === 'cube') {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const object = intersects[0].object
            if (object.userData.type === 'cube') {
              this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ)
            }
          }
        }

        handleRightClick(event) {
          // å³é”®åˆ é™¤æ–¹å—
          event.preventDefault()

          const canvas = document.getElementById('gameCanvas')
          const canvasRect = canvas.getBoundingClientRect()
          
          const mouse = new THREE.Vector2()
          // è®¡ç®—ç›¸å¯¹äºcanvasçš„åæ ‡
          mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1
          mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh && child.userData.type === 'cube') {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const object = intersects[0].object
            if (object.userData.type === 'cube') {
              this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ)
            }
          }
        }

        handleClick(event) {
          if (this.isRotating) return

          // æ£€æŸ¥æ˜¯å¦æ˜¯å³é”®ç‚¹å‡»
          if (event.button === 2) {
            this.handleRightClick(event)
            return
          }

          const canvas = document.getElementById('gameCanvas')
          const canvasRect = canvas.getBoundingClientRect()
          
          const mouse = new THREE.Vector2()
          const clientX = event.touches ? event.changedTouches[0].clientX : event.clientX
          const clientY = event.touches ? event.changedTouches[0].clientY : event.clientY

          // è®¡ç®—ç›¸å¯¹äºcanvasçš„åæ ‡
          mouse.x = ((clientX - canvasRect.left) / canvasRect.width) * 2 - 1
          mouse.y = -((clientY - canvasRect.top) / canvasRect.height) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh) {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const intersect = intersects[0]
            const object = intersect.object

            if (object.userData.type === 'platform') {
              this.handlePlatformClick(intersect)
            } else if (object.userData.type === 'cube') {
              this.handleCubeClick(intersect, object)
            }
          }
        }

        handlePlatformClick(intersect) {
          const point = intersect.point
          const localPoint = this.platformGroup.worldToLocal(point.clone())
          const gridX = Math.floor(localPoint.x + this.gridSize / 2)
          const gridZ = Math.floor(localPoint.z + this.gridSize / 2)

          if (gridX >= 0 && gridX < this.gridSize && gridZ >= 0 && gridZ < this.gridSize) {
            // åœ¨åœ°é¢ä¸Šæ”¾ç½®ï¼ˆy=0ï¼‰ï¼Œæ°¸è¿œå…è®¸
            this.placeCubeAt(gridX, 0, gridZ)
          }
        }

        handleCubeClick(intersect, cube) {
          const normal = intersect.face.normal.clone()
          normal.transformDirection(cube.matrixWorld)
          const platformMatrix = new THREE.Matrix4().copy(this.platformGroup.matrixWorld).invert()
          normal.transformDirection(platformMatrix)

          let targetX = cube.userData.gridX
          let targetY = cube.userData.gridY
          let targetZ = cube.userData.gridZ

          if (Math.abs(normal.x) > 0.7) {
            targetX += Math.sign(normal.x)
          } else if (Math.abs(normal.y) > 0.7) {
            targetY += Math.sign(normal.y)
          } else if (Math.abs(normal.z) > 0.7) {
            targetZ += Math.sign(normal.z)
          }

          if (
            targetX >= 0 &&
            targetX < this.gridSize &&
            targetZ >= 0 &&
            targetZ < this.gridSize &&
            targetY >= 0 &&
            targetY < this.gridSize
          ) {
            const key = `${targetX},${targetY},${targetZ}`
            if (!this.cubes.has(key) && this.isConnected(targetX, targetY, targetZ)) {
              this.placeCubeAt(targetX, targetY, targetZ)
            }
          }
        }

        placeCubeAt(x, y, z) {
          const key = `${x},${y},${z}`
          if (this.cubes.has(key)) return

          const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9)
          const material = new THREE.MeshLambertMaterial({ color: this.getRandomColor() })
          const cube = new THREE.Mesh(geometry, material)

          cube.position.set(x - this.gridSize / 2 + 0.5, y + 0.5, z - this.gridSize / 2 + 0.5)
          cube.userData = { gridX: x, gridY: y, gridZ: z, type: 'cube' }

          this.cubes.set(key, cube)
          this.platformGroup.add(cube)

          // æ·»åŠ åˆ°å†å²è®°å½•
          this.cubeHistory.push({ x, y, z })

          this.updateCubeCount()
          this.updateProjections() // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
          this.updateSubmitButton()
          this.updateUndoButton()
        }

        removeCube(x, y, z) {
          const key = `${x},${y},${z}`
          const cube = this.cubes.get(key)
          if (cube) {
            // è®°å½•ç§»é™¤å‰çš„æ–¹å—æ•°é‡
            const previousCubeCount = this.cubes.size

            this.platformGroup.remove(cube)
            this.cubes.delete(key)

            // ä»å†å²è®°å½•ä¸­ç§»é™¤
            const index = this.cubeHistory.findIndex((item) => item.x === x && item.y === y && item.z === z)
            if (index !== -1) {
              this.cubeHistory.splice(index, 1)
            }

            this.updateCubeCount()
            this.updateProjections() // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
            this.updateSubmitButton()
            this.updateUndoButton()
          }
        }

        undo() {
          if (this.cubeHistory.length === 0) return

          // ç§»é™¤æœ€åæ”¾ç½®çš„æ–¹å—
          const lastCube = this.cubeHistory.pop()
          this.removeCube(lastCube.x, lastCube.y, lastCube.z)

          // é‡æ–°æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆå› ä¸ºremoveCubeä¼šåˆ é™¤å®ƒï¼‰
          // ä½†æˆ‘ä»¬ä¸éœ€è¦é‡æ–°æ·»åŠ ï¼Œå› ä¸ºè¿™å°±æ˜¯æ’¤é”€çš„ç›®çš„
        }

        updateUndoButton() {
          const newUndoButton = document.getElementById('undoBtn')
          const isDisabled = this.cubeHistory.length === 0
          
          // æ›´æ–°æ–°UIé¢æ¿æŒ‰é’®
          if (newUndoButton) {
            if (isDisabled) {
              newUndoButton.style.opacity = '0.5'
              newUndoButton.style.cursor = 'not-allowed'
              newUndoButton.style.pointerEvents = 'none'
            } else {
              newUndoButton.style.opacity = '1'
              newUndoButton.style.cursor = 'pointer'
              newUndoButton.style.pointerEvents = 'auto'
            }
          }
        }

        updateSubmitButton() {
          const newSubmitButton = document.getElementById('submitAnswerBtn')
          const isProjectionCorrect = this.checkProjectionMatch()
          const canSubmit = isProjectionCorrect && this.cubes.size > 0
          
          // æ›´æ–°æ–°UIé¢æ¿æŒ‰é’®
          if (newSubmitButton) {
            if (canSubmit) {
              newSubmitButton.style.opacity = '1'
              newSubmitButton.style.cursor = 'pointer'
              newSubmitButton.style.pointerEvents = 'auto'
            } else {
              newSubmitButton.style.opacity = '0.5'
              newSubmitButton.style.cursor = 'not-allowed'
              newSubmitButton.style.pointerEvents = 'none'
            }
          }
        }

        updateCubeCount() {
          const currentCount = this.cubes.size
          
          // æ›´æ–°æ–°UIé¢æ¿
          const newCurrentLevel = document.getElementById('newCurrentLevel')
          const newTotalLevels = document.getElementById('newTotalLevels')
          const newCurrentCubes = document.getElementById('newCurrentCubes')
          const newMinCubes = document.getElementById('newMinCubes')
          
          if (newCurrentLevel) newCurrentLevel.textContent = this.currentLevel
          if (newTotalLevels) newTotalLevels.textContent = this.maxLevels
          if (newCurrentCubes) newCurrentCubes.textContent = currentCount
          if (newMinCubes) newMinCubes.textContent = this.minCubesNeeded
        }

        // æ£€æŸ¥å½“å‰æ–¹å—æ˜¯å¦äº§ç”Ÿæ­£ç¡®çš„æŠ•å½±
        checkProjectionMatch() {
          const currentFrontProjection = new Set()
          const currentRightProjection = new Set()

          // è®¡ç®—å½“å‰æ–¹å—çš„æŠ•å½±
          for (const [key, cube] of this.cubes) {
            const originalX = cube.userData.gridX - this.gridSize / 2 + 0.5
            const originalZ = cube.userData.gridZ - this.gridSize / 2 + 0.5
            const originalY = cube.userData.gridY

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            currentFrontProjection.add(frontProjKey)
            currentRightProjection.add(rightProjKey)
          }

          // è®¡ç®—ç›®æ ‡æŠ•å½±
          const targetFrontProjection = new Set()
          const targetRightProjection = new Set()

          for (const [key, target] of this.targetCubes) {
            const originalX = target.x - this.gridSize / 2 + 0.5
            const originalZ = target.z - this.gridSize / 2 + 0.5
            const originalY = target.y

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            targetFrontProjection.add(frontProjKey)
            targetRightProjection.add(rightProjKey)
          }

          // æ¯”è¾ƒæŠ•å½±æ˜¯å¦åŒ¹é…
          const frontMatch = this.setsEqual(currentFrontProjection, targetFrontProjection)
          const rightMatch = this.setsEqual(currentRightProjection, targetRightProjection)

          return frontMatch && rightMatch
        }

        setsEqual(set1, set2) {
          if (set1.size !== set2.size) return false
          for (const item of set1) {
            if (!set2.has(item)) return false
          }
          return true
        }

        showSuccessEffect(message = 'ğŸ‰ å®Œç¾ï¼ä¸‹ä¸€å…³...') {
          if (this.isGameFinished) return // é˜²æ­¢é‡å¤è§¦å‘

          const effect = document.getElementById('successEffect')
          effect.innerHTML = message.replace(/\n/g, '<br>')
          effect.classList.add('success-show')

          setTimeout(() => {
            effect.classList.remove('success-show')
          }, 3000)
        }

        endGame() {
          if (this.isGameFinished) return // é˜²æ­¢é‡å¤è§¦å‘
          this.isGameFinished = true

          const effect = document.getElementById('successEffect')

          // è®¡ç®—æœ€ç»ˆåˆ†æ•°ï¼ˆæ‰€æœ‰å…³å¡åˆ†æ•°æ€»å’Œï¼‰
          let finalScore = this.levelScores.reduce((sum, score) => sum + score, 0)
          finalScore = Math.min(finalScore, 100)

          // æ˜¾ç¤ºæ¸¸æˆå®Œæˆæ•ˆæœ
          effect.classList.add('success-show')
          effect.innerHTML = `ğŸŠ è®­ç»ƒå®Œæˆï¼<br><span style="font-size: 1.5rem;">è·å¾—ç§¯åˆ†: ${currentGamePoints}åˆ†</span><br><span style="font-size: 1rem;">æ€»ç§¯åˆ†: ${totalTrainingPoints}åˆ†</span>`

          // å‘é€æ¸¸æˆå®Œæˆäº‹ä»¶
          window.parent.postMessage(
            {
              type: 'gameFinished',
              data: {
                score: finalScore,
                difficulty: getDifficultyLevel(this.gridSize),
                gridSize: this.gridSize,
                levelsCompleted: this.currentLevel,
                maxLevels: this.maxLevels,
                levelScores: this.levelScores,
                earnedPoints: currentGamePoints, // æœ¬æ¬¡æ¸¸æˆè·å¾—çš„æ€»ç§¯åˆ†
                showAccuracy: true,
                accuracyText: 'æœ¬éš¾åº¦ä¸‹ç†æƒ³æ–¹å—æ•°å†…çš„å®Œæˆç‡ä¸º',
                accuracy: accuracy,
                isMaxDifficulty: this.gridSize === 5, // æ˜¯å¦ä¸ºæœ€é«˜éš¾åº¦
                levelCount: this.maxLevels,
              },
            },
            '*'
          )

          // 5ç§’åå¯ä»¥é‡æ–°å¼€å§‹æ¸¸æˆ
          setTimeout(() => {
            effect.innerHTML += '<br><span style="font-size: 1rem;">ç‚¹å‡»"é‡æ–°å¼€å§‹"</span>'
          }, 5000)
        }

        rotatePlatform(direction) {
          if (this.isRotating) return

          this.isRotating = true
          const startRotationSteps = this.rotationSteps
          const targetRotationSteps = this.rotationSteps + direction

          // è®¡ç®—å®é™…çš„è§’åº¦ç”¨äºåŠ¨ç”»
          const startAngle = startRotationSteps * 90
          const targetAngle = targetRotationSteps * 90

          const duration = 500
          const startTime = Date.now()

          const animate = () => {
            const elapsed = Date.now() - startTime
            const progress = Math.min(elapsed / duration, 1)

            const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress

            const currentAngle = startAngle + (targetAngle - startAngle) * easeProgress
            this.platformGroup.rotation.y = THREE.MathUtils.degToRad(currentAngle)

            if (progress < 1) {
              requestAnimationFrame(animate)
            } else {
              // æ›´æ–°æ—‹è½¬æ­¥æ•°è€Œä¸æ˜¯è§’åº¦
              this.rotationSteps = targetRotationSteps
              this.isRotating = false
              this.calculateMinCubes()
              this.updateProjections()
              this.updateCubeCount()
              this.autoCheckAnswer()
            }
          }

          animate()
        }

        submitAnswer() {
          if (!this.checkProjectionMatch()) {
            return // æŠ•å½±ä¸æ­£ç¡®ï¼Œä¸èƒ½æäº¤
          }

          // è®¡ç®—å½“å‰å…³å¡å¾—åˆ†
          const actualCubes = this.cubes.size
          const minCubes = this.minCubesNeeded
          const levelScore = calculateGameScore(this.gridSize, actualCubes, minCubes, this.maxLevels)

          // è®¡ç®—ç§¯åˆ†
          const levelPoints = calculateTrainingPoints(this.gridSize)
          currentGamePoints += levelPoints

          // å‘é€ç§¯åˆ†æ›´æ–°æ¶ˆæ¯
          window.parent.postMessage({
            type: 'showTrainingPoints',
            points: levelPoints
          }, '*');

          // è®°å½•å…³å¡å¾—åˆ†
          this.levelScores.push(levelScore)

          // æ˜¾ç¤ºæˆåŠŸæ•ˆæœå’Œç§¯åˆ†ä¿¡æ¯
          let message = ''
          if (actualCubes > minCubes) {
            message += `ğŸ‰ æˆåŠŸï¼\nè·å¾—ç§¯åˆ†: +${levelPoints}åˆ† (å¯ç”¨${minCubes}ä¸ªæ–¹å—è·å¾—ç›¸åŒç§¯åˆ†)`
          } else {
            message += `ğŸ‰ å®Œç¾ï¼\nè·å¾—ç§¯åˆ†: +${levelPoints}åˆ† (å®Œç¾å®Œæˆ!)`
            accuracy += (100 / this.maxLevels)
          }

          if (this.currentLevel < this.maxLevels) {
            message += '\næ­£åœ¨è¿›å…¥ä¸‹ä¸€å…³...'
          } else {
            message += '\næ¸¸æˆå®Œæˆï¼'
          }

          this.showSuccessEffect(message)

          // å»¶è¿Ÿè¿›å…¥ä¸‹ä¸€å…³æˆ–ç»“æŸæ¸¸æˆ
          setTimeout(() => {
            if (this.currentLevel < this.maxLevels) {
              this.currentLevel++
              this.newGame()
            } else {
              this.endGame()
            }
          }, 2000)
        }

        newGame() {
          // å…³é—­æ¸¸æˆå®Œæˆæ•ˆæœçª—å£
          const effect = document.getElementById('successEffect')
          effect.classList.remove('success-show')

          // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œé‡ç½®æ‰€æœ‰çŠ¶æ€
          if (this.isGameFinished) {
            this.currentLevel = 1
            this.levelScores = []
            this.isGameFinished = false
            this.gameStartTime = Date.now()
            currentGamePoints = 0 // é‡ç½®æœ¬æ¬¡æ¸¸æˆç§¯åˆ†
            accuracy = 0 // é‡ç½®å‡†ç¡®ç‡
          }

          // è·å–å½“å‰éš¾åº¦ï¼ˆå¦‚æœæœªè®¾ç½®gridSizeï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼3ï¼‰
          if (!this.gridSize) {
            this.gridSize = window.getCurrentDifficulty ? window.getCurrentDifficulty() : 3
          }

          // é‡ç½®å½“å‰å…³å¡ç»Ÿè®¡
          this.startTime = Date.now()

          // å¦‚æœæ˜¯ç¬¬ä¸€å…³ï¼Œè®°å½•æ¸¸æˆå¼€å§‹æ—¶é—´
          if (this.currentLevel === 1 && this.gameStartTime === 0) {
            this.gameStartTime = Date.now()
          }

          // é‡ç½®æ‰€æœ‰çŠ¶æ€
          this.rotationSteps = 0
          this.isRotating = false
          this.cubeHistory = [] // æ¸…ç©ºå†å²è®°å½•

          // å®Œå…¨æ¸…ç©ºæ‰€æœ‰æ–¹å—
          for (const [key, cube] of this.cubes) {
            this.platformGroup.remove(cube)
          }
          this.cubes.clear()

          // æ ¹æ®æ–°çš„gridSizeæ›´æ–°å¹³å°å˜æ¢
          this.updatePlatformTransform()

          // é‡å»ºæ¸¸æˆåœºæ™¯
          this.createPlatform()
          this.createWalls()
          this.platformGroup.rotation.y = 0

          // Auto-adjust camera for new grid size
          this.autoZoomCamera()

          // ç”Ÿæˆæ–°çš„ç›®æ ‡
          this.generateTarget()
          this.updateUndoButton()
          this.updateSubmitButton()

          // å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶
          if (!gameStarted) {
            window.parent.postMessage({ type: 'gameStarted' }, '*')
            gameStarted = true
          }
        }

        setupEventListeners() {
          // æ–°UIé¢æ¿çš„æŒ‰é’®äº‹ä»¶
          document.getElementById('newGameBtn').addEventListener('click', () => this.newGame())
          document.getElementById('undoBtn').addEventListener('click', () => this.undo())
          document.getElementById('rotateLeftBtn').addEventListener('click', () => this.rotatePlatform(1))
          document.getElementById('rotateRightBtn').addEventListener('click', () => this.rotatePlatform(-1))
          document.getElementById('submitAnswerBtn').addEventListener('click', () => this.submitAnswer())

          // é¼ æ ‡äº‹ä»¶
          this.renderer.domElement.addEventListener('mousedown', (event) => {
            event.preventDefault()
            if (event.button === 2) {
              // å³é”®ç‚¹å‡»ï¼Œç›´æ¥å¤„ç†åˆ é™¤
              this.handleRightClick(event)
            } else {
              // å·¦é”®ç‚¹å‡»ï¼Œå¼€å§‹é•¿æŒ‰æ£€æµ‹
              this.startLongPress(event)
            }
          })

          this.renderer.domElement.addEventListener('mouseup', (event) => {
            event.preventDefault()
            if (event.button !== 2) {
              // åªå¤„ç†å·¦é”®æ¾å¼€
              this.endLongPress(event)
            }
          })

          // è§¦æ‘¸äº‹ä»¶
          this.renderer.domElement.addEventListener('touchstart', (event) => {
            event.preventDefault()
            this.startLongPress(event)
          })

          this.renderer.domElement.addEventListener('touchend', (event) => {
            event.preventDefault()
            this.endLongPress(event)
          })

          // é˜»æ­¢å³é”®èœå•
          this.renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault()
          })

          window.addEventListener('resize', () => {
            this.handleResize()
          })
        }

        handleResize() {
          // å…ˆè°ƒæ•´å­—ä½“å¤§å°
          adjustRootFontSize()
          
          // ç­‰å¾…DOMæ›´æ–°åå†è·å–å°ºå¯¸
          setTimeout(() => {
            // è·å–gameCanvasçš„å®é™…å°ºå¯¸ï¼ˆ36rem Ã— 29.6remï¼‰
            const canvas = document.getElementById('gameCanvas')
            const canvasRect = canvas.getBoundingClientRect()

            // ä½¿ç”¨canvasçš„å®é™…å°ºå¯¸
            const canvasWidth = canvasRect.width
            const canvasHeight = canvasRect.height

            // ç¡®ä¿å°ºå¯¸å¤§äº0
            if (canvasWidth > 0 && canvasHeight > 0) {
              // Update camera aspect ratio
              this.camera.aspect = canvasWidth / canvasHeight
              this.camera.updateProjectionMatrix()

              // Update renderer size
              this.renderer.setSize(canvasWidth, canvasHeight)

              // Auto-adjust camera position for optimal viewing
              this.autoZoomCamera()
              
              console.log('Canvas resized:', canvasWidth, 'x', canvasHeight)
            }
          }, 200)
        }

        autoZoomCamera() {
          const canvas = document.getElementById('gameCanvas')
          const canvasRect = canvas.getBoundingClientRect()
          const aspect = canvasRect.width / canvasRect.height
          
          // å¯¹ç§°è§†è§’è®¾ç½®ï¼š
          // - cameraX = cameraZï¼ˆä¿æŒå¯¹è§’çº¿å¯¹ç§°ï¼‰
          // - lookAtY å€¼å›ºå®šï¼ˆç»Ÿä¸€ç„¦ç‚¹é«˜åº¦ï¼‰
          // - åªé€šè¿‡è°ƒæ•´ cameraY å’Œ cameraZ æ¥é€‚åº”ä¸åŒ gridSize
          
          const lookAtY = 0.8  // å›ºå®šç„¦ç‚¹é«˜åº¦
          let cameraY, cameraZ
          
          switch(this.gridSize) {
            case 2: // 2x2 å…¥é—¨éš¾åº¦
              cameraY = 3.5   // Yåæ ‡ï¼ˆé«˜åº¦ï¼‰
              cameraZ = 2.4   // Zåæ ‡ï¼ˆå‰åè·ç¦»ï¼‰
              break
              
            case 3: // 3x3 ç®€å•éš¾åº¦
              cameraY = 4   // ç¨å¾®æ‹‰è¿œ
              cameraZ = 2.8
              break
              
            case 4: // 4x4 ä¸­ç­‰éš¾åº¦
              cameraY = 4.5   // ç»§ç»­æ‹‰è¿œ
              cameraZ = 3.2
              break
              
            case 5: // 5x5 å›°éš¾éš¾åº¦
              cameraY = 4.25
              cameraZ = 3
              break
              
            default:
              cameraY = 3.5
              cameraZ = 2.4
          }
          
          // Xåæ ‡ = Zåæ ‡çš„è´Ÿå€¼ï¼ˆä¿æŒå¯¹è§’çº¿å¯¹ç§°ï¼‰
          const cameraX = -cameraZ
          
          // åº”ç”¨ç›¸æœºä½ç½®
          this.animateCameraToPosition(cameraX, cameraY, cameraZ, lookAtY)
        }

        animateCameraToPosition(targetX, targetY, targetZ, lookAtY = 0.5) {
          const startPosition = this.camera.position.clone()
          const targetPosition = new THREE.Vector3(targetX, targetY, targetZ)
          const targetLookAt = new THREE.Vector3(0, lookAtY, 0)

          const duration = 800 // Animation duration in ms
          const startTime = Date.now()

          const animate = () => {
            const elapsed = Date.now() - startTime
            const progress = Math.min(elapsed / duration, 1)

            // Smooth easing function
            const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress

            // Interpolate camera position
            this.camera.position.lerpVectors(startPosition, targetPosition, easeProgress)

            // Update camera to look at the scene center with dynamic lookAt point
            this.camera.lookAt(targetLookAt)

            if (progress < 1) {
              requestAnimationFrame(animate)
            }
          }

          animate()
        }

        // ç›¸æœºæµ‹è¯•æ–¹æ³• - ç”¨äºå®æ—¶è°ƒè¯•ç›¸æœºå‚æ•°
        // å‚æ•°è¯´æ˜ï¼š
        // cameraX: ç›¸æœºXåæ ‡ï¼ˆè´Ÿå€¼=å·¦ä¾§ï¼Œæ­£å€¼=å³ä¾§ï¼‰
        // cameraY: ç›¸æœºYåæ ‡ï¼ˆé«˜åº¦ï¼Œå€¼è¶Šå¤§è¶Šé«˜ï¼‰
        // cameraZ: ç›¸æœºZåæ ‡ï¼ˆæ­£å€¼=åæ–¹ï¼Œè´Ÿå€¼=å‰æ–¹ï¼‰
        // lookAtY: ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹Yåæ ‡ï¼ˆç„¦ç‚¹é«˜åº¦ï¼‰
        // animate: æ˜¯å¦ä½¿ç”¨å¹³æ»‘åŠ¨ç”»è¿‡æ¸¡ï¼ˆtrue=å¹³æ»‘ï¼Œfalse=ç«‹å³è·³è½¬ï¼‰
        testCameraPosition(cameraX, cameraY, cameraZ, lookAtY = 0.4, animate = true) {
          if (animate) {
            // ä½¿ç”¨åŠ¨ç”»è¿‡æ¸¡åˆ°æ–°ä½ç½®
            this.animateCameraToPosition(cameraX, cameraY, cameraZ, lookAtY)
          } else {
            // ç«‹å³è®¾ç½®åˆ°æ–°ä½ç½®
            this.camera.position.set(cameraX, cameraY, cameraZ)
            this.camera.lookAt(0, lookAtY, 0)
          }
          
          console.log(`ğŸ“· ç›¸æœºä½ç½®: X=${cameraX.toFixed(2)}, Y=${cameraY.toFixed(2)}, Z=${cameraZ.toFixed(2)}, ç„¦ç‚¹Y=${lookAtY.toFixed(2)}`)
          
          // æ›´æ–°è°ƒè¯•é¢æ¿çš„å®é™…ä½ç½®æ˜¾ç¤º
          this.updateDebugPanelPosition()
        }
        
        // æ›´æ–°è°ƒè¯•é¢æ¿æ˜¾ç¤º
        updateDebugPanelPosition() {
          const posDisplay = document.getElementById('actualCamPos')
          if (posDisplay) {
            const pos = this.camera.position
            posDisplay.textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`
          }
          
          const gridDisplay = document.getElementById('currentGridSize')
          const gridDisplay2 = document.getElementById('currentGridSize2')
          if (gridDisplay) {
            gridDisplay.textContent = this.gridSize
          }
          if (gridDisplay2) {
            gridDisplay2.textContent = this.gridSize
          }
        }

        animate() {
          requestAnimationFrame(() => this.animate())
          this.renderer.render(this.scene, this.camera)
          
          // æŒç»­æ›´æ–°è°ƒè¯•é¢æ¿
          if (document.getElementById('cameraDebugPanel').style.display !== 'none') {
            this.updateDebugPanelPosition()
          }
        }
      }

      // åœ¨åˆ›å»ºæ¸¸æˆå®ä¾‹ä¹‹å‰å…ˆè°ƒæ•´æ ¹å­—ä½“å¤§å°
      adjustRootFontSize()

      // å¯åŠ¨æ¸¸æˆ
      const game = new SpatialGame()

      // åˆå§‹åŒ–éš¾åº¦é€‰æ‹©å™¨
      initDifficultySelector()
      
      // åˆå§‹åŒ–éš¾åº¦é€‰æ‹©å™¨åŠŸèƒ½
      function initDifficultySelector() {
        const newSelector = document.getElementById('newDifficultySelector')
        const header = newSelector.querySelector('.difficulty-selector-header')
        const dropdown = newSelector.querySelector('.difficulty-selector-dropdown')
        const options = newSelector.querySelectorAll('.difficulty-selector-option')

        // å½“å‰é€‰ä¸­çš„éš¾åº¦å€¼ï¼ˆé»˜è®¤ä¸º3ï¼‰
        let currentValue = '3'

        // éš¾åº¦æ˜ å°„
        const difficultyMap = {
          '2': { name: 'å…¥é—¨', size: '2x2' },
          '3': { name: 'ç®€å•', size: '3x3' },
          '4': { name: 'ä¸­ç­‰', size: '4x4' },
          '5': { name: 'å›°éš¾', size: '5x5' }
        }

        // æ›´æ–°é€‰æ‹©å™¨æ˜¾ç¤º
        function updateDisplay(value) {
          currentValue = value
          const difficulty = difficultyMap[value] || { name: 'ç®€å•', size: '3x3' }
          
          // æ›´æ–° header æ˜¾ç¤ºï¼ŒåŒ¹é… HTML ç»“æ„
          header.innerHTML = `
            <span>éš¾åº¦</span>
            <span style="font-weight: 500;">
              ${difficulty.name}
              <span class="text-10 text-description">ï¼ˆ${difficulty.size}ï¼‰</span>
            </span>
            <div class="difficulty-selector-arrow"></div>
          `
          
          // æ›´æ–°é€‰é¡¹æ˜¾ç¤ºå’Œé€‰ä¸­çŠ¶æ€
          options.forEach(option => {
            const optionValue = option.dataset.value
            const optionDifficulty = difficultyMap[optionValue]
            
            if (optionValue === value) {
              option.classList.add('selected')
            } else {
              option.classList.remove('selected')
            }
            
            // æ›´æ–°é€‰é¡¹æ–‡æœ¬ï¼ˆä¸æ˜¾ç¤ºç®­å¤´ï¼‰
            option.innerHTML = `
              <span style="opacity: 0;">éš¾åº¦</span>
              <span style="font-weight: 500;">
                ${optionDifficulty.name}
                <span class="text-10 text-description">ï¼ˆ${optionDifficulty.size}ï¼‰</span>
              </span>
              <div class="difficulty-selector-arrow" style="opacity: 0;"></div>
            `
          })
        }

        // è·å–å½“å‰é€‰ä¸­çš„éš¾åº¦å€¼
        window.getCurrentDifficulty = function() {
          return parseInt(currentValue)
        }

        // è®¾ç½®å½“å‰éš¾åº¦å€¼ï¼ˆç”¨äºå¤–éƒ¨è°ƒç”¨ï¼‰
        window.setCurrentDifficulty = function(value) {
          updateDisplay(value.toString())
        }

        // åˆå§‹åŒ–æ˜¾ç¤º
        updateDisplay(currentValue)

        // åˆ‡æ¢ä¸‹æ‹‰èœå•
        header.addEventListener('click', (e) => {
          e.stopPropagation()
          const isActive = header.classList.toggle('active')
          dropdown.classList.toggle('show', isActive)
        })

        // é€‰æ‹©é€‰é¡¹
        options.forEach(option => {
          option.addEventListener('click', (e) => {
            e.stopPropagation()
            const value = option.dataset.value
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplay(value)
            
            // è§¦å‘éš¾åº¦æ”¹å˜äº‹ä»¶
            handleDifficultyChange(parseInt(value))
            
            // å…³é—­ä¸‹æ‹‰èœå•
            header.classList.remove('active')
            dropdown.classList.remove('show')
          })
        })

        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        document.addEventListener('click', () => {
          header.classList.remove('active')
          dropdown.classList.remove('show')
        })
      }
      
      // å¤„ç†éš¾åº¦æ”¹å˜
      function handleDifficultyChange(newDifficulty) {
        // å…³é—­ä»»ä½•æ˜¾ç¤ºçš„æ•ˆæœçª—å£
        const effect = document.getElementById('successEffect')
        effect.classList.remove('success-show')

        // é‡ç½®æ¸¸æˆçŠ¶æ€åˆ°ç¬¬ä¸€å…³
        game.currentLevel = 1
        game.levelScores = []
        game.isGameFinished = false
        game.gameStartTime = 0
        currentGamePoints = 0
        accuracy = 0

        // æ›´æ–°æ¸¸æˆéš¾åº¦
        game.gridSize = newDifficulty
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        game.newGame()
      }
      
      // ç›¸æœºè°ƒè¯•é¢æ¿æ§åˆ¶
      // åœ¨æ§åˆ¶å°è¾“å…¥ showCameraDebug() æ¥æ˜¾ç¤ºè°ƒè¯•é¢æ¿
      window.showCameraDebug = function() {
        document.getElementById('cameraDebugPanel').style.display = 'block'
        
        // åˆå§‹åŒ–æ»‘å—å€¼ä¸ºå½“å‰ç›¸æœºä½ç½®
        const pos = game.camera.position
        document.getElementById('camX').value = pos.x
        document.getElementById('camY').value = pos.y
        document.getElementById('camZ').value = pos.z
        document.getElementById('camXValue').textContent = pos.x.toFixed(2)
        document.getElementById('camYValue').textContent = pos.y.toFixed(2)
        document.getElementById('camZValue').textContent = pos.z.toFixed(2)
        
        // åŠ¨æ€è·å–ç›¸æœºå½“å‰ lookAtYï¼ˆå°è¯•æ±‚ç›¸æœºè§†çº¿ä¸ x=0,z=0 ç›´çº¿çš„äº¤ç‚¹çš„ y å€¼ï¼‰
        const dir = new THREE.Vector3()
        game.camera.getWorldDirection(dir)

        let lookAtYValue
        // ä¼˜å…ˆç”¨ x åˆ†é‡æ±‚ tï¼ˆè‹¥ x åˆ†é‡è¾ƒå¤§ï¼‰ï¼Œå¦åˆ™ç”¨ z åˆ†é‡ï¼›ä½œä¸ºå…œåº•ä½¿ç”¨é»˜è®¤å€¼
        if (Math.abs(dir.x) > Math.abs(dir.z) && Math.abs(dir.x) > 1e-6) {
          const t = -game.camera.position.x / dir.x
          lookAtYValue = game.camera.position.y + t * dir.y
        } else if (Math.abs(dir.z) > 1e-6) {
          const t = -game.camera.position.z / dir.z
          lookAtYValue = game.camera.position.y + t * dir.y
        } else {
          // å½“è§†çº¿å‡ ä¹å‚ç›´æ—¶ä½¿ç”¨ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼
          lookAtYValue = 0.4
        }

        // é™åˆ¶åœ¨æ»‘å—å…è®¸èŒƒå›´å†…å¹¶æ ¼å¼åŒ–
        lookAtYValue = Math.max(parseFloat(document.getElementById('lookAtY').min || -2), Math.min(parseFloat(document.getElementById('lookAtY').max || 5), lookAtYValue))
        document.getElementById('lookAtY').value = lookAtYValue.toFixed(2)
        document.getElementById('lookAtYValue').textContent = lookAtYValue.toFixed(2)
        
        console.log('ğŸ“· ç›¸æœºè°ƒè¯•é¢æ¿å·²æ‰“å¼€')
        console.log('ğŸ’¡ æç¤ºï¼šæ»‘åŠ¨æ»‘å—ä¼šè‡ªåŠ¨åº”ç”¨å‚æ•°ï¼Œæ— éœ€ç‚¹å‡»æŒ‰é’®')
      }
      
      window.hideCameraDebug = function() {
        document.getElementById('cameraDebugPanel').style.display = 'none'
        console.log('ğŸ“· ç›¸æœºè°ƒè¯•é¢æ¿å·²å…³é—­')
      }
      
      // åº”ç”¨å½“å‰æ»‘å—çš„å‚æ•°åˆ°ç›¸æœºï¼ˆç«‹å³ç”Ÿæ•ˆï¼Œæ— åŠ¨ç”»ï¼‰
      function applyCameraFromSliders() {
        const camX = parseFloat(document.getElementById('camX').value)
        const camY = parseFloat(document.getElementById('camY').value)
        const camZ = parseFloat(document.getElementById('camZ').value)
        const lookAtY = parseFloat(document.getElementById('lookAtY').value)
        
        // ç«‹å³åº”ç”¨ï¼Œä¸ä½¿ç”¨åŠ¨ç”»
        game.testCameraPosition(camX, camY, camZ, lookAtY, false)
      }
      
      // æ»‘å—æ»‘åŠ¨æ—¶è‡ªåŠ¨æ›´æ–°æ˜¾ç¤ºå€¼å¹¶åº”ç”¨å‚æ•°
      document.getElementById('camX').addEventListener('input', (e) => {
        document.getElementById('camXValue').textContent = parseFloat(e.target.value).toFixed(2)
        applyCameraFromSliders()
      })
      
      document.getElementById('camY').addEventListener('input', (e) => {
        document.getElementById('camYValue').textContent = parseFloat(e.target.value).toFixed(2)
        applyCameraFromSliders()
      })
      
      document.getElementById('camZ').addEventListener('input', (e) => {
        document.getElementById('camZValue').textContent = parseFloat(e.target.value).toFixed(2)
        applyCameraFromSliders()
      })
      
      document.getElementById('lookAtY').addEventListener('input', (e) => {
        document.getElementById('lookAtYValue').textContent = parseFloat(e.target.value).toFixed(2)
        applyCameraFromSliders()
      })
      
      // é‡ç½®æŒ‰é’® - æ¢å¤åˆ°å½“å‰éš¾åº¦çš„é»˜è®¤ç›¸æœºä½ç½®
      document.getElementById('resetCamera').addEventListener('click', () => {
        game.autoZoomCamera()
        console.log('ğŸ“· å·²é‡ç½®åˆ°é»˜è®¤ç›¸æœºä½ç½®')
        
        // æ›´æ–°æ»‘å—å€¼
        setTimeout(() => {
          const pos = game.camera.position
          document.getElementById('camX').value = pos.x
          document.getElementById('camY').value = pos.y
          document.getElementById('camZ').value = pos.z
          document.getElementById('camXValue').textContent = pos.x.toFixed(2)
          document.getElementById('camYValue').textContent = pos.y.toFixed(2)
          document.getElementById('camZValue').textContent = pos.z.toFixed(2)
        }, 900)
      })
      
      // æ‰“å°å‚æ•°æŒ‰é’® - è¾“å‡ºå¯ä»¥ç›´æ¥å¤åˆ¶åˆ°ä»£ç ä¸­çš„æ ¼å¼
      document.getElementById('logCameraParams').addEventListener('click', () => {
        const camX = parseFloat(document.getElementById('camX').value)
        const camY = parseFloat(document.getElementById('camY').value)
        const camZ = parseFloat(document.getElementById('camZ').value)
        const lookAtY = parseFloat(document.getElementById('lookAtY').value)
        
        console.log('='.repeat(60))
        console.log('ğŸ“· å½“å‰ç›¸æœºå‚æ•°')
        console.log('='.repeat(60))
        console.log(`å½“å‰éš¾åº¦: ${game.gridSize}x${game.gridSize}`)
        console.log('')
        console.log('Three.js æ ¼å¼ï¼ˆå¯ç›´æ¥ç”¨äºä»£ç ï¼‰:')
        console.log(`  camera.position.set(${camX.toFixed(2)}, ${camY.toFixed(2)}, ${camZ.toFixed(2)})`)
        console.log(`  camera.lookAt(0, ${lookAtY.toFixed(2)}, 0)`)
        console.log('')
        console.log('è°ƒç”¨æµ‹è¯•å‡½æ•°:')
        console.log(`  testCamera(${camX.toFixed(2)}, ${camY.toFixed(2)}, ${camZ.toFixed(2)}, ${lookAtY.toFixed(2)})`)
        console.log('')
        console.log('å¤åˆ¶åˆ° autoZoomCamera() çš„ switch ä»£ç :')
        console.log(`  case ${game.gridSize}: // ${game.gridSize}x${game.gridSize} éš¾åº¦`)
        console.log(`    const cameraX = ${camX.toFixed(2)}  // Xåæ ‡ï¼ˆå·¦å³ä½ç½®ï¼‰`)
        console.log(`    const cameraY = ${camY.toFixed(2)}  // Yåæ ‡ï¼ˆé«˜åº¦ï¼‰`)
        console.log(`    const cameraZ = ${camZ.toFixed(2)}  // Zåæ ‡ï¼ˆå‰åä½ç½®ï¼‰`)
        console.log(`    const lookAtY = ${lookAtY.toFixed(2)}  // ç„¦ç‚¹é«˜åº¦`)
        console.log(`    this.animateCameraToPosition(cameraX, cameraY, cameraZ, lookAtY)`)
        console.log(`    break`)
        console.log('='.repeat(60))
      })
      
      // å…³é—­æŒ‰é’®
      document.getElementById('closeCameraDebug').addEventListener('click', () => {
        hideCameraDebug()
      })
      
      // å…¨å±€å¿«æ·æ–¹æ³•
      // å‚æ•°è¯´æ˜ï¼š
      // x: ç›¸æœºXåæ ‡ï¼ˆè´Ÿå€¼=å·¦ä¾§ï¼‰
      // y: ç›¸æœºYåæ ‡ï¼ˆé«˜åº¦ï¼‰
      // z: ç›¸æœºZåæ ‡ï¼ˆæ­£å€¼=åæ–¹ï¼‰
      // lookY: ç„¦ç‚¹é«˜åº¦
      window.testCamera = function(x, y, z, lookY = 0.4) {
        game.testCameraPosition(x, y, z, lookY, true)
        console.log('ğŸ’¡ å‚æ•°è¯´æ˜ï¼š')
        console.log(`  X=${x} (è´Ÿå€¼=å·¦ä¾§, æ­£å€¼=å³ä¾§)`)
        console.log(`  Y=${y} (é«˜åº¦ï¼Œè¶Šå¤§è¶Šé«˜)`)
        console.log(`  Z=${z} (æ­£å€¼=åæ–¹, è´Ÿå€¼=å‰æ–¹)`)
        console.log(`  ç„¦ç‚¹Y=${lookY} (ç›¸æœºçœ‹å‘çš„ç›®æ ‡é«˜åº¦)`)
      }
      
      // console.log('ğŸ’¡ ç›¸æœºè°ƒè¯•å·¥å…·å·²åŠ è½½ï¼')
      // console.log('â”'.repeat(50))
      // console.log('ğŸ“– ä½¿ç”¨æ–¹æ³•ï¼š')
      // console.log('  showCameraDebug()  - æ˜¾ç¤ºè°ƒè¯•é¢æ¿')
      // console.log('  hideCameraDebug()  - éšè—è°ƒè¯•é¢æ¿')
      // console.log('  Ctrl+Shift+C       - å¿«æ·é”®æ‰“å¼€/å…³é—­é¢æ¿')
      // console.log('')
      // console.log('ğŸ® æµ‹è¯•å‡½æ•°ï¼š')
      // console.log('  testCamera(x, y, z, lookY)')
      // console.log('    x: Xåæ ‡ï¼ˆè´Ÿå€¼=å·¦ä¾§ï¼‰')
      // console.log('    y: Yåæ ‡ï¼ˆé«˜åº¦ï¼‰')
      // console.log('    z: Zåæ ‡ï¼ˆæ­£å€¼=åæ–¹ï¼‰')
      // console.log('    lookY: ç„¦ç‚¹é«˜åº¦ï¼ˆå¯é€‰ï¼Œé»˜è®¤0.4ï¼‰')
      // console.log('')
      // console.log('  ç¤ºä¾‹: testCamera(-3, 3, 3, 0.5)')
      // console.log('â”'.repeat(50))
      
      // é”®ç›˜å¿«æ·é”® Ctrl+Shift+C æ‰“å¼€è°ƒè¯•é¢æ¿
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'C') {
          const panel = document.getElementById('cameraDebugPanel')
          if (panel.style.display === 'none') {
            showCameraDebug()
          } else {
            hideCameraDebug()
          }
        }
      })
    </script>

  </body>
</html>
