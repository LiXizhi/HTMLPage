<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å½±å­éª‘å£«</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdnproxy.keepwork.com/jsdelivr/npm/three@0.128.0/build/three.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        min-height: 700px;
        height: 90vh;
      }
      #gameContainer {
        position: relative;
        width: 100%;
        height: 100%;
      }
      #ui {
        position: fixed;
        top: 60px;
        left: 15px;
        z-index: 100;
        width: 200px;
        height: 480px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none; /* è®©UIåŒºåŸŸé»˜è®¤ä¸é˜»æŒ¡é¼ æ ‡äº‹ä»¶ */
      }
      #gameCanvas {
        width: 100%;
        height: 100vh;
      }
      #successEffect {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2rem;
        font-weight: bold;
        color: #4ade80;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 200;
        pointer-events: none;
        opacity: 0;
        transition: all 0.5s ease;
        text-align: center;
        max-width: 80%;
        line-height: 1.3;
      }
      .success-show {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.2) !important;
      }

      /* æ¸¸æˆè§„åˆ™å¼¹çª—æ ·å¼ */
      .modal-overlay {
        backdrop-filter: blur(4px);
        animation: fadeIn 0.3s ease;
      }

      .modal-content {
        animation: slideIn 0.3s ease;
        max-width: 85vw;
        max-height: 80vh;
        width: 100%;
        height: auto;
      }

      .modal-body {
        max-height: calc(80vh - 140px);
        overflow-y: auto;
      }

      /* æ–°çš„è§„åˆ™å¼¹çª—æ ·å¼ */
      .rules-content {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        max-width: 768px;
        border-radius: 16px;
        padding: 36px;
      }

      .rules-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 36px;
        font-size: 36px;
      }

      .rules-list {
        list-style-type: decimal;
        margin-left: 36px;
        font-weight: 500;
        font-size: 27px;
      }

      .rules-list li {
        margin-bottom: 18px;
      }

      .rules-footer {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
        padding: 12px 36px;
        border-radius: 16px;
        font-weight: bold;
        font-size: 24px;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* å¸®åŠ©æŒ‰é’® */
      .help-btn {
        position: fixed;
        bottom: 16px;
        right: 16px;
        z-index: 40;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      .help-btn:hover {
        transform: scale(1.1);
      }

      /* å·¦ä¾§æ‚¬æµ®é¢æ¿æ ·å¼ */
      .ui-section {
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        border-radius: 8px;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        pointer-events: auto; /* æ¢å¤UIå…ƒç´ çš„é¼ æ ‡äº‹ä»¶ */
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      #cubeCount > div {
        min-width: 150px;
        font-size: 1.4rem;
      }

      .stat-number {
        color: #2aeb71;
        font-size: 3rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 1px 2px rgba(0, 0, 0, 0.3); /* æ·»åŠ é˜´å½±æ•ˆæœ */
        font-weight: bold;
      }

      /* å³ä¾§æ‚¬æµ®é¢æ¿æ ·å¼ */
      .ui-section-right {
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        border-radius: 8px;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        pointer-events: auto;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      #ui-right {
        position: fixed;
        top: 60px;
        right: 15px;
        z-index: 100;
        width: 240px;
        height: 480px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none;
      }

      .ui-button {
        width: 100%;
        padding: 10px 16px;
        font-size: 16px;
        font-weight: 600;
        border-radius: 8px;
        transition: all 0.3s ease;
        border: none;
        cursor: pointer;
        text-align: center;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .ui-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .ui-button:active {
        transform: translateY(0);
      }

      .ui-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        pointer-events: none;
      }

      .ui-select {
        width: 100%;
        padding: 12px;
        font-size: 1rem;
        border-radius: 8px;
        background: #374151;
        color: white;
        border: 1px solid #4b5563;
        min-height: 44px;
        text-align: center;
      }

      .ui-label {
        font-size: 16px;
        font-weight: 600;
        color: white;
        margin-bottom: 8px;
        display: block;
      }

      .info-display {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 12px;
        color: white;
        font-size: 14px;
        line-height: 1.4;
      }

      /* ä¸“é—¨ä¸ºç§»åŠ¨è®¾å¤‡ä¼˜åŒ–çš„æ ·å¼ */
      @media (max-width: 768px) {
        #ui {
          position: fixed;
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: auto;
          width: auto;
          flex-direction: row;
          flex-wrap: wrap;
          gap: 8px;
          max-height: 180px;
          overflow-y: auto;
        }

        #ui-right {
          position: fixed;
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: auto;
          width: auto;
          flex-direction: row;
          flex-wrap: wrap;
          gap: 8px;
          max-height: 150px;
          overflow-y: auto;
        }

        #gameCanvas {
          width: 100%;
          height: 100vh;
        }

        .ui-section,
        .ui-section-right {
          flex: 1;
          min-width: calc(50% - 8px);
          padding: 10px;
        }

        .ui-button {
          padding: 10px 12px;
          font-size: 12px;
          min-height: 40px;
        }

        .ui-select {
          padding: 10px;
          font-size: 12px;
          min-height: 40px;
        }

        .ui-label {
          font-size: 14px;
          margin-bottom: 6px;
        }

        .info-display {
          font-size: 12px;
          padding: 10px;
        }

        .help-btn {
          width: 50px;
          height: 50px;
          bottom: 15px;
          right: 15px;
        }
      }

      @media (max-width: 480px) {
        .ui-section,
        .ui-section-right {
          min-width: 100%;
          margin-bottom: 6px;
        }

        .ui-button {
          padding: 8px 12px;
          font-size: 11px;
          min-height: 36px;
        }

        .ui-select {
          padding: 8px;
          font-size: 11px;
          min-height: 36px;
        }
      }

      /* å¼¹çª—å“åº”å¼æ ·å¼ */
      @media (max-width: 768px) {
        .modal-content {
          max-width: 95vw;
          margin: 1rem;
        }

        .modal-content .p-8 {
          padding: 1.5rem !important;
        }

        .modal-body .text-lg {
          font-size: 1rem !important;
        }

        .modal-content h2 {
          font-size: 1.5rem !important;
        }
      }

      @media (max-width: 480px) {
        .modal-content .p-8 {
          padding: 1.25rem !important;
        }

        .modal-body .text-lg {
          font-size: 0.95rem !important;
        }

        .modal-content h2 {
          font-size: 1.375rem !important;
        }
      }
    </style>

  </head>
  <body>
    <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
    <div
      id="rulesModal"
      class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden flex items-center justify-center z-50 p-4"
      style="z-index: 9999"
    >
      <div class="rules-content bg-white shadow-2xl">        <div class="rules-header">
          <h2 class="text-gray-800 font-bold" data-i18n="gameRules.title">ğŸ§© å½±å­éª‘å£«</h2>
          <button id="closeRules" class="text-gray-500 hover:text-gray-700 leading-none">Ã—</button>
        </div>

        <ol class="rules-list text-gray-700">
          <li data-i18n="gameRules.rule1">åœ¨ä½ è®¤ä¸ºæ­£ç¡®çš„ä½ç½®è‡ªä¸‹å‘ä¸Šæ­å»ºæ–¹å—ï¼Œä½¿å…¶æŠ•å½±ä¸ä¸¤ä¾§å¢™å£ä¸Šçš„æŠ•å½±ä½ç½®ä¸€è‡´</li>
          <li data-i18n="gameRules.rule2">å¯åˆ©ç”¨å·¦å³æ—‹è½¬æŒ‰é”®è§‚å¯Ÿï¼Œæ­å»ºé”™è¯¯å¯æ’¤é”€ï¼Œè®¤ä¸ºæ­å»ºå®Œæˆæ—¶æäº¤ç­”æ¡ˆ</li>
          <li data-i18n="gameRules.rule3">äº‰å–åœ¨ç†æƒ³æ–¹å—æ•°å†…å®Œæˆï¼Œè¶…å‡ºæ—¶å®Œæˆä»å¯å¾—åˆ†</li>
        </ol>

        <button
          id="startGameFromRules"
          class="rules-footer bg-blue-500 hover:bg-blue-600 text-white transition-all transform hover:scale-105"
          data-i18n="gameRules.startButton"
        >
          å¼€å§‹è®­ç»ƒ
        </button>
      </div>
    </div>

    <div id="gameContainer">
      <!-- å·¦ä¾§UIé¢æ¿ -->
      <div id="ui" class="text-white">
        <!-- æ¸¸æˆä¿¡æ¯åŒºåŸŸ -->
        <div class="ui-section">
          <div id="cubeCount" class="info-display text-center grid grid-cols-1 gap-8">
            <!-- æ¸¸æˆä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
          </div>
        </div>

        <!-- æ“ä½œè¯´æ˜åŒºåŸŸ -->
        <div class="ui-section-right">          <div class="info-display text-lg">
            <!-- <div class="mb-2"><strong>æ“ä½œè¯´æ˜ï¼š</strong></div> -->
            <div class="desktop-only flex justify-between">
              <div data-i18n="ui.controls.leftClick">å·¦é”®ï¼š</div>
              <div data-i18n="ui.controls.place">æ”¾ç½®</div>
            </div>
            <div class="desktop-only flex justify-between">
              <div data-i18n="ui.controls.rightClick">å³é”®/é•¿æŒ‰ï¼š</div>
              <div data-i18n="ui.controls.delete">åˆ é™¤</div>
            </div>
            <!-- <div class="mt-2"><strong>æŠ•å½±è¯´æ˜ï¼š</strong></div> -->
            <div class="flex justify-between">
              <div data-i18n="ui.controls.blackProjection">é»‘è‰²ï¼š</div>
              <div data-i18n="ui.controls.correctProjection">æ­£ç¡®æŠ•å½±</div>
            </div>
            <div class="flex justify-between">
              <div data-i18n="ui.controls.grayProjection">ç°è‰²ï¼š</div>
              <div data-i18n="ui.controls.targetProjection">ç›®æ ‡æŠ•å½±</div>
            </div>
            <div class="flex justify-between">
              <div data-i18n="ui.controls.redProjection">çº¢è‰²Xï¼š</div>
              <div data-i18n="ui.controls.wrongProjection">é”™è¯¯æŠ•å½±</div>
            </div>
          </div>
        </div>
      </div>

      <!-- æ¸¸æˆç”»å¸ƒåŒºåŸŸ -->
      <div id="gameCanvas"></div>

      <div id="successEffect" data-i18n="ui.successMessage">ğŸ‰ å®Œç¾ï¼ä¸‹ä¸€å…³...</div>

      <!-- å³ä¾§UIé¢æ¿ -->
      <div id="ui-right" class="text-white">
        <!-- éš¾åº¦é€‰æ‹©åŒºåŸŸ -->        <div class="ui-section-right ui-select_container flex items-center">
          <label style="flex-shrink: 0" data-i18n="ui.difficulty">éš¾åº¦ï¼š</label>
          <select id="difficultySelect" class="ui-select">
            <option value="2" data-i18n="ui.difficultyLevels.beginner">å…¥é—¨ (2Ã—2)</option>
            <option value="3" data-i18n="ui.difficultyLevels.easy">ç®€å• (3Ã—3)</option>
            <option value="4" data-i18n="ui.difficultyLevels.medium">ä¸­ç­‰ (4Ã—4)</option>
            <option value="5" data-i18n="ui.difficultyLevels.hard">å›°éš¾ (5Ã—5)</option>
          </select>
        </div>

        <!-- æ¸¸æˆæ§åˆ¶åŒºåŸŸ -->        <div class="ui-section-right">
          <button id="newGame" class="ui-button text-xl bg-blue-600 hover:bg-blue-700 text-white mb-3" data-i18n="ui.buttons.newGame">
            ğŸ® é‡æ–°å¼€å§‹
          </button>
          <button id="undo" class="ui-button text-xl bg-orange-600 hover:bg-orange-700 text-white" data-i18n="ui.buttons.undo">â†©ï¸ æ’¤é”€æ“ä½œ</button>
        </div>

        <!-- è§†è§’æ§åˆ¶åŒºåŸŸ -->        <div class="ui-section-right">
          <button id="rotateLeft" class="ui-button text-xl bg-purple-600 hover:bg-purple-700 text-white mb-3" data-i18n="ui.buttons.rotateLeft">
            âŸ² å‘å·¦æ—‹è½¬
          </button>
          <button id="rotateRight" class="ui-button text-xl bg-purple-600 hover:bg-purple-700 text-white mb-3" data-i18n="ui.buttons.rotateRight">
            âŸ³ å‘å³æ—‹è½¬
          </button>
          <button id="submitAnswer" class="ui-button text-xl bg-green-600 hover:bg-green-700 text-white" data-i18n="ui.buttons.submit">
            âœ“ æäº¤ç­”æ¡ˆ
          </button>
        </div>
      </div>
    </div>

    <!-- å¸®åŠ©æŒ‰é’® -->
    <button id="helpBtn" class="help-btn bg-blue-500 hover:bg-blue-600 text-white" data-i18n-title="ui.helpTitle" title="æŸ¥çœ‹è§„åˆ™">
      <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
        />
      </svg>
    </button>    <script>
      // è¯­è¨€æ”¯æŒç³»ç»Ÿ
      let currentLanguage = 'zhCN' // é»˜è®¤ä¸­æ–‡

      // å¤šè¯­è¨€æ–‡æœ¬å®šä¹‰
      const translations = {
        zhCN: {
          title: 'å½±å­éª‘å£«',
          gameRules: {
            title: 'ğŸ§© å½±å­éª‘å£«',
            rule1: 'åœ¨ä½ è®¤ä¸ºæ­£ç¡®çš„ä½ç½®è‡ªä¸‹å‘ä¸Šæ­å»ºæ–¹å—ï¼Œä½¿å…¶æŠ•å½±ä¸ä¸¤ä¾§å¢™å£ä¸Šçš„æŠ•å½±ä½ç½®ä¸€è‡´',
            rule2: 'å¯åˆ©ç”¨å·¦å³æ—‹è½¬æŒ‰é”®è§‚å¯Ÿï¼Œæ­å»ºé”™è¯¯å¯æ’¤é”€ï¼Œè®¤ä¸ºæ­å»ºå®Œæˆæ—¶æäº¤ç­”æ¡ˆ',
            rule3: 'äº‰å–åœ¨ç†æƒ³æ–¹å—æ•°å†…å®Œæˆï¼Œè¶…å‡ºæ—¶å®Œæˆä»å¯å¾—åˆ†',
            startButton: 'å¼€å§‹è®­ç»ƒ'
          },
          ui: {
            difficulty: 'éš¾åº¦ï¼š',
            difficultyLevels: {
              beginner: 'å…¥é—¨ (2Ã—2)',
              easy: 'ç®€å• (3Ã—3)',
              medium: 'ä¸­ç­‰ (4Ã—4)',
              hard: 'å›°éš¾ (5Ã—5)'
            },
            buttons: {
              newGame: 'ğŸ® é‡æ–°å¼€å§‹',
              undo: 'â†©ï¸ æ’¤é”€æ“ä½œ',
              rotateLeft: 'âŸ² å‘å·¦æ—‹è½¬',
              rotateRight: 'âŸ³ å‘å³æ—‹è½¬',
              submit: 'âœ“ æäº¤ç­”æ¡ˆ'
            },
            controls: {
              leftClick: 'å·¦é”®ï¼š',
              rightClick: 'å³é”®/é•¿æŒ‰ï¼š',
              place: 'æ”¾ç½®',
              delete: 'åˆ é™¤',
              blackProjection: 'é»‘è‰²ï¼š',
              grayProjection: 'ç°è‰²ï¼š',
              redProjection: 'çº¢è‰²Xï¼š',
              correctProjection: 'æ­£ç¡®æŠ•å½±',
              targetProjection: 'ç›®æ ‡æŠ•å½±',
              wrongProjection: 'é”™è¯¯æŠ•å½±'
            },
            successMessage: 'ğŸ‰ å®Œç¾ï¼ä¸‹ä¸€å…³...',
            helpTitle: 'æŸ¥çœ‹è§„åˆ™'
          },          gameInfo: {
            level: 'å…³å¡',
            score: 'å¾—åˆ†',
            cubesUsed: 'å·²ç”¨æ–¹å—',
            minCubes: 'æœ€å°‘éœ€è¦',
            gameComplete: 'æ¸¸æˆå®Œæˆï¼',
            finalScore: 'æœ€ç»ˆå¾—åˆ†',
            congratulations: 'æ­å–œå®Œæˆæ‰€æœ‰å…³å¡ï¼',            success: 'æˆåŠŸ',
            perfect: 'å®Œç¾',
            levelScore: 'æœ¬å…³å¾—åˆ†',
            maxScore: 'æ»¡åˆ†',
            canGetMaxWith: 'å¯ç”¨{0}ä¸ªæ–¹å—è·å¾—æ»¡åˆ†',
            nextLevel: 'æ­£åœ¨è¿›å…¥ä¸‹ä¸€å…³...',
            highestRecord: 'æœ€é«˜çºªå½•',
            points: 'åˆ†'
          }
        },
        enUS: {
          title: 'Shadow Knight',
          gameRules: {
            title: 'ğŸ§© Shadow Knight',
            rule1: 'Build blocks from bottom to top at positions you think are correct, so their projections match the projections on both side walls',
            rule2: 'Use left/right rotation buttons to observe. You can undo wrong placements and submit when you think it\'s complete',
            rule3: 'Try to complete within the ideal number of blocks. You can still score even if you exceed the limit',
            startButton: 'Start Training'
          },
          ui: {
            difficulty: 'Difficulty:',
            difficultyLevels: {
              beginner: 'Beginner (2Ã—2)',
              easy: 'Easy (3Ã—3)',
              medium: 'Medium (4Ã—4)',
              hard: 'Hard (5Ã—5)'
            },
            buttons: {
              newGame: 'ğŸ® New Game',
              undo: 'â†©ï¸ Undo',
              rotateLeft: 'âŸ² Rotate Left',
              rotateRight: 'âŸ³ Rotate Right',
              submit: 'âœ“ Submit'
            },
            controls: {
              leftClick: 'Left Click:',
              rightClick: 'Right Click/Hold:',
              place: 'Place',
              delete: 'Delete',
              blackProjection: 'Black:',
              grayProjection: 'Gray:',
              redProjection: 'Red X:',
              correctProjection: 'Correct',
              targetProjection: 'Target',
              wrongProjection: 'Wrong'
            },
            successMessage: 'ğŸ‰ Perfect! Next level...',
            helpTitle: 'View Rules'
          },          gameInfo: {
            level: 'Level',
            score: 'Score',
            cubesUsed: 'Cubes Used',
            minCubes: 'Min Required',
            gameComplete: 'Game Complete!',
            finalScore: 'Final Score',
            congratulations: 'Congratulations on completing all levels!',            success: 'Success',
            perfect: 'Perfect',
            levelScore: 'Level Score',
            maxScore: 'Perfect Score',
            canGetMaxWith: 'Can get max score with {0} blocks',
            nextLevel: 'Proceeding to next level...',
            highestRecord: 'Highest Record',
            points: 'pts'
          }
        }
      }

      // è·å–è¯­è¨€è®¾ç½®
      function getLanguage() {
        // 1. é¦–å…ˆæ£€æŸ¥URLå‚æ•°
        const urlParams = new URLSearchParams(window.location.search)
        const langParam = urlParams.get('lang')
        
        if (langParam === 'zhCN' || langParam === 'enUS') {
          return langParam
        }
        
        // 2. å¦‚æœURLä¸­æ²¡æœ‰langå‚æ•°ï¼Œä½¿ç”¨æµè§ˆå™¨è¯­è¨€
        const browserLang = navigator.language || navigator.userLanguage
        
        // åˆ¤æ–­æµè§ˆå™¨è¯­è¨€ï¼Œä¼˜å…ˆåŒ¹é…ä¸­æ–‡
        if (browserLang.startsWith('zh')) {
          return 'zhCN'
        } else {
          return 'enUS'
        }
      }
      function updatePageText() {
        const t = translations[currentLanguage]
        
        // æ›´æ–°é¡µé¢æ ‡é¢˜
        document.title = t.title
        
        function updateElementText(element, key) {
          const keys = key.split('.')
          let value = t
          for (const k of keys) {
            value = value[k]
            if (!value) return false
          }
          element.textContent = value
          return true
        }
        
        function updateElementTitle(element, key) {
          const keys = key.split('.')
          let value = t
          for (const k of keys) {
            value = value[k]
            if (!value) return false
          }
          element.title = value
          return true
        }
        
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n')
          updateElementText(element, key)
        })
        
        document.querySelectorAll('[data-i18n-title]').forEach(element => {
          const key = element.getAttribute('data-i18n-title')
          updateElementTitle(element, key)
        })
        
        if (window.game && game.updateCubeCount) {
          game.updateCubeCount()
        }
      }

      // è·å–ç¿»è¯‘æ–‡æœ¬çš„è¾…åŠ©å‡½æ•°
      function getText(key) {
        const keys = key.split('.')
        let result = translations[currentLanguage]
        for (const k of keys) {
          result = result[k]
          if (!result) return key
        }
        return result
      }

      // æ¸¸æˆç»Ÿè®¡å’Œæ¶ˆæ¯é€šä¿¡
      let game_config = ''
      let bestScore = 0
      let currentGameScore = 0
      let gameStarted = false

      // è®¡ç®—åˆ†æ•°ï¼šåŸºäºå…³å¡æ•°å¹³å‡åˆ†é…ï¼Œæ¯ä¸ªéš¾åº¦å®Œç¾å®Œæˆåæ€»åˆ†éƒ½æ˜¯100åˆ†
      function calculateGameScore(gridSize, actualCubes, minCubes, maxLevels = 10) {
        // æ¯å…³çš„åŸºç¡€åˆ†æ•° = 100åˆ† / æ€»å…³å¡æ•°
        const baseScore = 100 / maxLevels

        // æ•ˆç‡åŠ æˆï¼šä½¿ç”¨æœ€å°‘æ–¹å—æ•°å¾—æ»¡åˆ†ï¼Œä½¿ç”¨æ›´å¤šæ–¹å—æŒ‰æ¯”ä¾‹å‡åˆ†
        const efficiency = Math.min(1, minCubes / actualCubes)

        return Math.round(baseScore * efficiency)
      }

      // è·å–éš¾åº¦ç­‰çº§
      function getDifficultyLevel(gridSize) {
        if (gridSize === 2) return 0 // å…¥é—¨
        if (gridSize === 3) return 1 // ç®€å•
        if (gridSize === 4) return 2 // ä¸­ç­‰
        return 3 // å›°éš¾
      }

      // æ¶ˆæ¯ç›‘å¬å™¨
      window.addEventListener('message', function (e) {
        switch (e.data.type) {
          case 'setGameConfig':
            game_config = e.data.data // this is markdown or text string
            // æ›´æ–°æ¸¸æˆé…ç½®é€»è¾‘
            console.log('Game config updated:', game_config)
            // if (game) {
            //     game.applyExternalConfig(game_config);
            // }
            break
          case 'gameContinue':
            if (game && game.isGameFinished) {
              // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œé‡æ–°å¼€å§‹æ¸¸æˆ
              game.newGame()
            }
            break
          case 'getGameStats':
            window.parent.postMessage(
              {
                type: 'gameStats',
                data: {
                  score: bestScore, // æ°¸è¿œè¿”å›æœ€é«˜åˆ†
                  difficulty: getDifficultyLevel(game.gridSize),
                },
              },
              '*'
            )
            break
        }
      })      // è§„åˆ™å¼¹çª—æ§åˆ¶
      function initRulesModal() {
        const rulesModal = document.getElementById('rulesModal')
        const closeRules = document.getElementById('closeRules')
        const startGameFromRules = document.getElementById('startGameFromRules')
        const helpBtn = document.getElementById('helpBtn')

        // å…³é—­è§„åˆ™å¼¹çª—
        function closeRulesModal() {
          rulesModal.classList.add('hidden')
        }

        // æ‰“å¼€è§„åˆ™å¼¹çª—
        function openRulesModal() {
          rulesModal.classList.remove('hidden')
        }

        openRulesModal()

        closeRules.addEventListener('click', closeRulesModal)
        helpBtn.addEventListener('click', openRulesModal)

        // ä»è§„åˆ™å¼¹çª—å¼€å§‹æ¸¸æˆ
        startGameFromRules.addEventListener('click', () => {
          closeRulesModal()
          if (game) {
            game.newGame()
          }
        })

        // ç‚¹å‡»é®ç½©å…³é—­
        rulesModal.addEventListener('click', (e) => {
          if (e.target === rulesModal) {
            closeRulesModal()
          }
        })
      }

      // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
      function initLanguage() {
        currentLanguage = getLanguage()
        updatePageText()
      }

      class SpatialGame {
        constructor() {
          this.scene = new THREE.Scene()
          this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
          this.renderer = new THREE.WebGLRenderer({ antialias: true })
          this.gridSize = 3 // é»˜è®¤3x3
          this.cubes = new Map() // å­˜å‚¨ç”¨æˆ·æ”¾ç½®çš„ç«‹æ–¹ä½“
          this.targetCubes = new Map() // å­˜å‚¨ç›®æ ‡ç«‹æ–¹ä½“
          this.projectionCubes = [] // å­˜å‚¨æŠ•å½±ç«‹æ–¹ä½“
          this.cubeHistory = [] // å­˜å‚¨æ–¹å—æ”¾ç½®å†å²ï¼Œç”¨äºæ’¤é”€
          this.rotationSteps = 0 // ä½¿ç”¨æ­¥æ•°è€Œä¸æ˜¯è§’åº¦ï¼Œé¿å…æµ®ç‚¹æ•°ç´¯ç§¯è¯¯å·®
          this.isRotating = false // æ˜¯å¦æ­£åœ¨æ—‹è½¬
          this.minCubesNeeded = 0 // æœ€å°‘éœ€è¦çš„æ–¹å—æ•°

          // é•¿æŒ‰ç›¸å…³
          this.longPressTimer = null
          this.longPressThreshold = 600 // 600ms é•¿æŒ‰é˜ˆå€¼
          this.isLongPressing = false
          this.touchStartPos = null

          this.startTime = 0
          this.gameLoaded = false

          // æ–°å¢ï¼šæ¸¸æˆå…³å¡å’Œæ€»ä½“è®¡åˆ†ç³»ç»Ÿ
          this.currentLevel = 1
          this.maxLevels = 10
          this.levelScores = [] // è®°å½•å„å…³åˆ†æ•°
          this.gameStartTime = 0 // æ•´ä¸ªæ¸¸æˆå¼€å§‹æ—¶é—´          this.isGameFinished = false // æ¸¸æˆæ˜¯å¦å·²ç»“æŸ

          this.init()
          this.setupEventListeners()
          
          // å»¶è¿Ÿè°ƒç”¨newGameï¼Œç¡®ä¿initå®Œå…¨å®Œæˆ
          setTimeout(() => {
            this.newGame()
          }, 100)

          // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
          initLanguage()
          
          // åˆå§‹åŒ–è§„åˆ™å¼¹çª—
          initRulesModal()
        }

        init() {
          // ä¿®æ”¹æ¸²æŸ“å™¨é™„åŠ åˆ°æ¸¸æˆç”»å¸ƒåŒºåŸŸï¼Œä½¿ç”¨å…¨å±ç©ºé—´
          this.renderer.setSize(window.innerWidth, window.innerHeight)
          this.renderer.setClearColor(0x87ceeb)
          document.getElementById('gameCanvas').appendChild(this.renderer.domElement)

          // è°ƒæ•´åˆå§‹ç›¸æœºä½ç½®ï¼Œå‘ä¸‹ç§»åŠ¨åœºæ™¯å¹¶æ”¾å¤§
          this.camera.position.set(-4, 4, 4)
          this.camera.lookAt(-this.gridSize / 6, 0.5, this.gridSize / 6)

          // æ·»åŠ ç¯å¢ƒå…‰å’Œæ–¹å‘å…‰ï¼ˆä¸äº§ç”Ÿé˜´å½±ï¼‰
          const ambientLight = new THREE.AmbientLight(0x404040, 0.8)
          this.scene.add(ambientLight)

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6)
          directionalLight.position.set(10, 10, 5)
          this.scene.add(directionalLight)

          // Define original position and scale variables
          const originalPlatformX = 0.5 // slight to the left for UI.
          const originalPlatformZ = -1 // slight to the left for UI.
          const originalPlatformY = -1.6

          const platformScale = 1.5

          // ...existing code...
          this.platformGroup = new THREE.Group()
          this.platformGroup.position.set(originalPlatformX, originalPlatformY, originalPlatformZ) // å‘ä¸Šç§»åŠ¨ï¼Œå‡å°‘ä¸‹æ–¹ç©ºç™½
          this.platformGroup.scale.setScalar(platformScale)
          this.scene.add(this.platformGroup)

          // åˆ›å»ºå›ºå®šçš„æŠ•å½±å¢™ç»„
          this.wallGroup = new THREE.Group()
          this.wallGroup.position.set(originalPlatformX, originalPlatformY, originalPlatformZ) // ä¸å¹³å°ç»„ä¿æŒä¸€è‡´
          this.wallGroup.scale.setScalar(platformScale)
          this.scene.add(this.wallGroup)

          this.createPlatform()
          this.createWalls()

          // Set optimal camera position after scene is created
          setTimeout(() => this.autoZoomCamera(), 100)

          this.animate()

          // å‘é€æ¸¸æˆåŠ è½½å®Œæˆäº‹ä»¶
          if (!this.gameLoaded) {
            window.parent.postMessage({ type: 'gameLoaded' }, '*')
            this.gameLoaded = true
          }
        }

        // è·å–ç²¾ç¡®çš„æ—‹è½¬å˜æ¢å‚æ•°ï¼Œé¿å…æµ®ç‚¹æ•°è¯¯å·®
        getRotationParams() {
          // å°†æ—‹è½¬æ­¥æ•°æ ‡å‡†åŒ–åˆ°0-3èŒƒå›´å†…
          const normalizedSteps = ((this.rotationSteps % 4) + 4) % 4

          switch (normalizedSteps) {
            case 0:
              return { cos: 1, sin: 0 } // 0åº¦
            case 1:
              return { cos: 0, sin: -1 } // 90åº¦
            case 2:
              return { cos: -1, sin: 0 } // 180åº¦
            case 3:
              return { cos: 0, sin: 1 } // 270åº¦
            default:
              return { cos: 1, sin: 0 }
          }
        }

        // åº”ç”¨å¤–éƒ¨é…ç½®
        applyExternalConfig(configData) {
          if (!configData) return

          try {
            // å°è¯•è§£æJSONé…ç½®
            let config
            if (typeof configData === 'string') {
              config = JSON.parse(configData)
            } else {
              config = configData
            }
            if (!config) {
              console.error('applyExternalConfig: é…ç½®å¯¹è±¡æ— æ•ˆï¼Œä¿æŒå½“å‰é…ç½®')
              return
            }

            // éšè—éš¾åº¦é€‰æ‹©å™¨
            const difficultyContainer = document.querySelector('.ui-select_container')
            if (difficultyContainer) {
              // difficultyContainer.style.display = 'none';
            }

            // å…³é—­ä»»ä½•æ˜¾ç¤ºçš„æ•ˆæœçª—å£
            const effect = document.getElementById('successEffect')
            effect.classList.remove('success-show')

            // é‡ç½®æ¸¸æˆçŠ¶æ€åˆ°ç¬¬ä¸€å…³
            this.maxLevels = config.maxLevels
            this.gridSize = config.gridSize
            this.currentLevel = 1
            this.levelScores = []
            this.isGameFinished = false
            this.gameStartTime = 0 // é‡ç½®æ¸¸æˆå¼€å§‹æ—¶é—´ï¼Œä¸‹æ¬¡newGameæ—¶ä¼šé‡æ–°è®¾ç½®
            document.getElementById('difficultySelect').value = this.gridSize
            // é‡æ–°å¼€å§‹æ¸¸æˆ
            this.newGame()
            console.log('å¤–éƒ¨é…ç½®å·²åº”ç”¨:', config)
          } catch (error) {
            console.error('è§£æå¤–éƒ¨é…ç½®æ—¶å‡ºé”™:', error)
          }
        }

        createCheckerboardTexture() {
          const size = 256
          const canvas = document.createElement('canvas')
          canvas.width = size
          canvas.height = size
          const context = canvas.getContext('2d')

          const tileSize = size / this.gridSize

          for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
              const isLight = (i + j) % 2 === 0
              context.fillStyle = isLight ? '#8B6F47' : '#6B5937' // æµ…æ£•è‰²å’Œæ·±æ£•è‰²
              context.fillRect(i * tileSize, j * tileSize, tileSize, tileSize)
            }
          }

          const texture = new THREE.CanvasTexture(canvas)
          texture.wrapS = THREE.ClampToEdgeWrapping
          texture.wrapT = THREE.ClampToEdgeWrapping
          return texture
        }        createPlatform() {
          // ç¡®ä¿platformGroupå­˜åœ¨
          if (!this.platformGroup) {
            console.error('platformGroup not initialized')
            return
          }
          
          // æ¸…é™¤ç°æœ‰å¹³å°
          while (this.platformGroup.children.length > 0) {
            this.platformGroup.remove(this.platformGroup.children[0])
          }

          // åˆ›å»ºæ£‹ç›˜æ ¼çº¹ç†
          const checkerTexture = this.createCheckerboardTexture()

          // åˆ›å»ºåº•éƒ¨å¹³å°
          const platformGeometry = new THREE.BoxGeometry(this.gridSize, 0.2, this.gridSize)
          const platformMaterial = new THREE.MeshLambertMaterial({
            map: checkerTexture,
          })
          const platform = new THREE.Mesh(platformGeometry, platformMaterial)
          platform.position.y = -0.1
          platform.userData = { type: 'platform' }
          this.platformGroup.add(platform)

          // åˆ›å»ºç½‘æ ¼çº¿
          this.createGridLines()
        }

        createGridLines() {
          const material = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.4, transparent: true })

          // æ°´å¹³çº¿
          for (let i = 0; i <= this.gridSize; i++) {
            const geometry = new THREE.BufferGeometry()
            const points = [
              new THREE.Vector3(-this.gridSize / 2, 0.01, -this.gridSize / 2 + i),
              new THREE.Vector3(this.gridSize / 2, 0.01, -this.gridSize / 2 + i),
            ]
            geometry.setFromPoints(points)
            this.platformGroup.add(new THREE.Line(geometry, material))
          }

          // å‚ç›´çº¿
          for (let i = 0; i <= this.gridSize; i++) {
            const geometry = new THREE.BufferGeometry()
            const points = [
              new THREE.Vector3(-this.gridSize / 2 + i, 0.01, -this.gridSize / 2),
              new THREE.Vector3(-this.gridSize / 2 + i, 0.01, this.gridSize / 2),
            ]
            geometry.setFromPoints(points)
            this.platformGroup.add(new THREE.Line(geometry, material))
          }
        }        createWalls() {
          // ç¡®ä¿wallGroupå­˜åœ¨
          if (!this.wallGroup) {
            console.error('wallGroup not initialized')
            return
          }
          
          // æ¸…é™¤ç°æœ‰å¢™
          while (this.wallGroup.children.length > 0) {
            this.wallGroup.remove(this.wallGroup.children[0])
          }

          // å¢åŠ å¢™å£é«˜åº¦ä»¥é€‚åº”æ›´é«˜å±‚çš„æŠ•å½±æ˜¾ç¤ºï¼Œå¹¶è¿›ä¸€æ­¥æ”¾å¤§
          const wallHeight = this.gridSize // ä»1.2å¢åŠ åˆ°1.5

          // æ­£é¢å¢™
          const frontWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight)
          const frontWallMaterial = new THREE.MeshLambertMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
          })
          const frontWall = new THREE.Mesh(frontWallGeometry, frontWallMaterial)
          frontWall.position.set(0, wallHeight / 2, -this.gridSize / 2 - 0.4) // å‡å°‘è·ç¦»è®©å¢™æ›´è¿‘
          frontWall.userData = { type: 'wall' }
          this.wallGroup.add(frontWall)

          // å³ä¾§å¢™
          const rightWallGeometry = new THREE.PlaneGeometry(this.gridSize, wallHeight)
          const rightWallMaterial = new THREE.MeshLambertMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
          })
          const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial)
          rightWall.position.set(this.gridSize / 2 + 0.4, wallHeight / 2, 0) // å‡å°‘è·ç¦»è®©å¢™æ›´è¿‘
          rightWall.rotation.y = Math.PI / 2
          rightWall.userData = { type: 'wall' }
          this.wallGroup.add(rightWall)
        }

        generateTarget() {
          this.targetCubes.clear()
          const numCubes = Math.floor(Math.random() * (this.gridSize * 2)) + 2

          // ç¡®ä¿ç¬¬ä¸€ä¸ªæ–¹å—åœ¨åœ°é¢ä¸Šï¼ˆä½œä¸ºè¿æ¥èµ·ç‚¹ï¼‰
          let firstX = Math.floor(Math.random() * this.gridSize)
          let firstZ = Math.floor(Math.random() * this.gridSize)
          let key = `${firstX},0,${firstZ}`
          this.targetCubes.set(key, { x: firstX, y: 0, z: firstZ, color: this.getRandomColor() })

          // ç”Ÿæˆå…¶ä»–è”é€šçš„æ–¹å—
          for (let i = 1; i < numCubes; i++) {
            let placed = false
            let attempts = 0

            while (!placed && attempts < 50) {
              // éšæœºé€‰æ‹©ä¸€ä¸ªå·²å­˜åœ¨çš„æ–¹å—
              const existingCubes = Array.from(this.targetCubes.values())
              const baseCube = existingCubes[Math.floor(Math.random() * existingCubes.length)]

              // åœ¨å…¶ç›¸é‚»ä½ç½®å°è¯•æ”¾ç½®æ–°æ–¹å—
              const directions = [
                { x: 1, y: 0, z: 0 },
                { x: -1, y: 0, z: 0 },
                { x: 0, y: 1, z: 0 },
                { x: 0, y: -1, z: 0 },
                { x: 0, y: 0, z: 1 },
                { x: 0, y: 0, z: -1 },
              ]

              const direction = directions[Math.floor(Math.random() * directions.length)]
              const newX = baseCube.x + direction.x
              const newY = baseCube.y + direction.y
              const newZ = baseCube.z + direction.z

              // æ£€æŸ¥è¾¹ç•Œå’Œæ˜¯å¦å·²å­˜åœ¨
              if (
                newX >= 0 &&
                newX < this.gridSize &&
                newZ >= 0 &&
                newZ < this.gridSize &&
                newY >= 0 &&
                newY < this.gridSize
              ) {
                const newKey = `${newX},${newY},${newZ}`
                if (!this.targetCubes.has(newKey)) {
                  this.targetCubes.set(newKey, {
                    x: newX,
                    y: newY,
                    z: newZ,
                    color: this.getRandomColor(),
                  })
                  placed = true
                }
              }
              attempts++
            }
          }

          this.calculateMinCubes()
          this.updateProjections()
          this.updateCubeCount()
          this.updateSubmitButton()
        }

        calculateMinCubes() {
          this.minCubesNeeded = this.targetCubes.size
        }

        getRandomColor() {
          const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff]
          return colors[Math.floor(Math.random() * colors.length)]
        }

        updateProjections() {
          // æ¸…é™¤ç°æœ‰æŠ•å½±
          this.projectionCubes.forEach((cube) => {
            this.wallGroup.remove(cube)
          })
          this.projectionCubes = []

          // è®¡ç®—æŠ•å½±
          this.createProjectionDisplay()
        }

        createProjectionDisplay() {
          // è·å–ç›®æ ‡æŠ•å½±
          const targetFrontProjection = new Set()
          const targetRightProjection = new Set()

          for (const [key, target] of this.targetCubes) {
            const originalX = target.x - this.gridSize / 2 + 0.5
            const originalZ = target.z - this.gridSize / 2 + 0.5
            const originalY = target.y

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            targetFrontProjection.add(frontProjKey)
            targetRightProjection.add(rightProjKey)
          }

          // è·å–å½“å‰ç”¨æˆ·æ–¹å—çš„æŠ•å½±
          const currentFrontProjection = new Set()
          const currentRightProjection = new Set()

          for (const [key, cube] of this.cubes) {
            const originalX = cube.userData.gridX - this.gridSize / 2 + 0.5
            const originalZ = cube.userData.gridZ - this.gridSize / 2 + 0.5
            const originalY = cube.userData.gridY

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            currentFrontProjection.add(frontProjKey)
            currentRightProjection.add(rightProjKey)
          }

          // åˆ›å»ºæ­£é¢æŠ•å½±æ˜¾ç¤º
          this.createWallProjectionDisplay(targetFrontProjection, currentFrontProjection, 'front')

          // åˆ›å»ºå³ä¾§æŠ•å½±æ˜¾ç¤º
          this.createWallProjectionDisplay(targetRightProjection, currentRightProjection, 'right')
        }

        createWallProjectionDisplay(targetProjection, currentProjection, wall) {
          // åˆå¹¶æ‰€æœ‰æŠ•å½±ä½ç½®
          const allPositions = new Set([...targetProjection, ...currentProjection])

          for (const posKey of allPositions) {
            const [coordStr, yStr] = posKey.split(',')
            const coord = parseFloat(coordStr) / 2
            const y = parseFloat(yStr) / 2

            const isTarget = targetProjection.has(posKey)
            const isCurrent = currentProjection.has(posKey)

            let projCube

            if (isTarget && isCurrent) {
              // æ­£ç¡®æŠ•å½± - æ·±é»‘è‰²ï¼Œå¢å¤§å°ºå¯¸
              const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1) // ä»0.8å¢åŠ åˆ°0.9
              const projMaterial = new THREE.MeshLambertMaterial({
                color: 0x222222,
              })
              projCube = new THREE.Mesh(projGeometry, projMaterial)
            } else if (isTarget && !isCurrent) {
              // ç›®æ ‡æŠ•å½±ä½†ç”¨æˆ·æœªå®ç° - ç°è‰²ï¼Œå¢å¤§å°ºå¯¸
              const projGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.1) // ä»0.8å¢åŠ åˆ°0.9
              const projMaterial = new THREE.MeshLambertMaterial({
                color: 0xeeeeee,
                emissive: 0x888888,
                emissiveIntensity: 0.3,
              })
              projCube = new THREE.Mesh(projGeometry, projMaterial)
            } else if (!isTarget && isCurrent) {
              // é”™è¯¯æŠ•å½± - æ˜¾ç¤ºXï¼Œå¢å¤§å°ºå¯¸
              projCube = this.createXMark(0.9) // ä»0.8å¢åŠ åˆ°0.9
            }

            if (projCube) {
              // æ”¾å®½æ˜¾ç¤ºèŒƒå›´é™åˆ¶ï¼Œå…è®¸æ›´é«˜å±‚çš„æŠ•å½±æ˜¾ç¤º
              const maxWallHeight = this.gridSize * 1.5 // ä»1.2å¢åŠ åˆ°1.5

              if (wall === 'front') {
                // æ­£é¢å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                if (Math.abs(coord) <= this.gridSize / 2 && y <= maxWallHeight && y > 0) {
                  projCube.position.set(coord, y, -this.gridSize / 2 - 0.5) // è°ƒæ•´ä½ç½®
                  this.wallGroup.add(projCube)
                  this.projectionCubes.push(projCube)
                }
              } else if (wall === 'right') {
                // å³ä¾§å¢™æŠ•å½±æ˜¾ç¤ºæ¡ä»¶
                if (Math.abs(coord) <= this.gridSize / 2 && y <= maxWallHeight && y > 0) {
                  projCube.position.set(this.gridSize / 2 + 0.5, y, coord) // è°ƒæ•´ä½ç½®
                  if (projCube.rotation) {
                    projCube.rotation.y = Math.PI / 2
                  }
                  this.wallGroup.add(projCube)
                  this.projectionCubes.push(projCube)
                }
              }
            }
          }
        }

        createXMark(size) {
          const group = new THREE.Group()
          const material = new THREE.MeshLambertMaterial({
            color: 0xcc3333,
            emissive: 0x888888,
            emissiveIntensity: 0.3,
          })

          // åˆ›å»ºXçš„ä¸¤æ¡çº¿
          const lineGeometry1 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05)
          const lineGeometry2 = new THREE.BoxGeometry(size * 0.8, size * 0.1, 0.05)

          const line1 = new THREE.Mesh(lineGeometry1, material)
          const line2 = new THREE.Mesh(lineGeometry2, material)

          line1.rotation.z = Math.PI / 4
          line2.rotation.z = -Math.PI / 4

          group.add(line1)
          group.add(line2)

          return group
        }

        isConnected(x, y, z) {
          // åœ°é¢ä¸Š(y=0)æ°¸è¿œå¯ä»¥æ”¾ç½®æ–¹å—
          if (y === 0) {
            return true
          }

          // å…¶ä»–ä½ç½®éœ€è¦æ£€æŸ¥è¿é€šæ€§
          if (this.cubes.size === 0) {
            return true
          }

          const neighbors = [
            { x: x + 1, y: y, z: z },
            { x: x - 1, y: y, z: z },
            { x: x, y: y + 1, z: z },
            { x: x, y: y - 1, z: z },
            { x: x, y: y, z: z + 1 },
            { x: x, y: y, z: z - 1 },
          ]

          for (const neighbor of neighbors) {
            const neighborKey = `${neighbor.x},${neighbor.y},${neighbor.z}`
            if (this.cubes.has(neighborKey)) {
              return true
            }
          }

          return false
        }

        startLongPress(event) {
          this.isLongPressing = false
          this.touchStartPos = {
            x: event.touches ? event.touches[0].clientX : event.clientX,
            y: event.touches ? event.touches[0].clientY : event.clientY,
          }

          this.longPressTimer = setTimeout(() => {
            this.isLongPressing = true
            this.handleLongPress(event)
          }, this.longPressThreshold)
        }

        endLongPress(event) {
          if (this.longPressTimer) {
            clearTimeout(this.longPressTimer)
            this.longPressTimer = null
          }

          if (!this.isLongPressing) {
            // çŸ­æŒ‰ï¼Œæ­£å¸¸ç‚¹å‡»
            this.handleClick(event)
          }

          this.isLongPressing = false
        }

        handleLongPress(event) {
          // é•¿æŒ‰åˆ é™¤æ–¹å—
          const mouse = new THREE.Vector2()
          const clientX = event.touches ? event.touches[0].clientX : event.clientX
          const clientY = event.touches ? event.touches[0].clientY : event.clientY

          mouse.x = (clientX / window.innerWidth) * 2 - 1
          mouse.y = -(clientY / window.innerHeight) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh && child.userData.type === 'cube') {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const object = intersects[0].object
            if (object.userData.type === 'cube') {
              this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ)
            }
          }
        }

        handleRightClick(event) {
          // å³é”®åˆ é™¤æ–¹å—
          event.preventDefault()

          const mouse = new THREE.Vector2()
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh && child.userData.type === 'cube') {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const object = intersects[0].object
            if (object.userData.type === 'cube') {
              this.removeCube(object.userData.gridX, object.userData.gridY, object.userData.gridZ)
            }
          }
        }

        handleClick(event) {
          if (this.isRotating) return

          // æ£€æŸ¥æ˜¯å¦æ˜¯å³é”®ç‚¹å‡»
          if (event.button === 2) {
            this.handleRightClick(event)
            return
          }

          const mouse = new THREE.Vector2()
          const clientX = event.touches ? event.changedTouches[0].clientX : event.clientX
          const clientY = event.touches ? event.changedTouches[0].clientY : event.clientY

          mouse.x = (clientX / window.innerWidth) * 2 - 1
          mouse.y = -(clientY / window.innerHeight) * 2 + 1

          const raycaster = new THREE.Raycaster()
          raycaster.setFromCamera(mouse, this.camera)

          const allObjects = []
          this.platformGroup.traverse((child) => {
            if (child.isMesh) {
              allObjects.push(child)
            }
          })

          const intersects = raycaster.intersectObjects(allObjects)

          if (intersects.length > 0) {
            const intersect = intersects[0]
            const object = intersect.object

            if (object.userData.type === 'platform') {
              this.handlePlatformClick(intersect)
            } else if (object.userData.type === 'cube') {
              this.handleCubeClick(intersect, object)
            }
          }
        }

        handlePlatformClick(intersect) {
          const point = intersect.point
          const localPoint = this.platformGroup.worldToLocal(point.clone())
          const gridX = Math.floor(localPoint.x + this.gridSize / 2)
          const gridZ = Math.floor(localPoint.z + this.gridSize / 2)

          if (gridX >= 0 && gridX < this.gridSize && gridZ >= 0 && gridZ < this.gridSize) {
            // åœ¨åœ°é¢ä¸Šæ”¾ç½®ï¼ˆy=0ï¼‰ï¼Œæ°¸è¿œå…è®¸
            this.placeCubeAt(gridX, 0, gridZ)
          }
        }

        handleCubeClick(intersect, cube) {
          const normal = intersect.face.normal.clone()
          normal.transformDirection(cube.matrixWorld)
          const platformMatrix = new THREE.Matrix4().copy(this.platformGroup.matrixWorld).invert()
          normal.transformDirection(platformMatrix)

          let targetX = cube.userData.gridX
          let targetY = cube.userData.gridY
          let targetZ = cube.userData.gridZ

          if (Math.abs(normal.x) > 0.7) {
            targetX += Math.sign(normal.x)
          } else if (Math.abs(normal.y) > 0.7) {
            targetY += Math.sign(normal.y)
          } else if (Math.abs(normal.z) > 0.7) {
            targetZ += Math.sign(normal.z)
          }

          if (
            targetX >= 0 &&
            targetX < this.gridSize &&
            targetZ >= 0 &&
            targetZ < this.gridSize &&
            targetY >= 0 &&
            targetY < this.gridSize
          ) {
            const key = `${targetX},${targetY},${targetZ}`
            if (!this.cubes.has(key) && this.isConnected(targetX, targetY, targetZ)) {
              this.placeCubeAt(targetX, targetY, targetZ)
            }
          }
        }

        placeCubeAt(x, y, z) {
          const key = `${x},${y},${z}`
          if (this.cubes.has(key)) return

          const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9)
          const material = new THREE.MeshLambertMaterial({ color: this.getRandomColor() })
          const cube = new THREE.Mesh(geometry, material)

          cube.position.set(x - this.gridSize / 2 + 0.5, y + 0.5, z - this.gridSize / 2 + 0.5)
          cube.userData = { gridX: x, gridY: y, gridZ: z, type: 'cube' }

          this.cubes.set(key, cube)
          this.platformGroup.add(cube)

          // æ·»åŠ åˆ°å†å²è®°å½•
          this.cubeHistory.push({ x, y, z })

          this.updateCubeCount()
          this.updateProjections() // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
          this.updateSubmitButton()
          this.updateUndoButton()
        }

        removeCube(x, y, z) {
          const key = `${x},${y},${z}`
          const cube = this.cubes.get(key)
          if (cube) {
            // è®°å½•ç§»é™¤å‰çš„æ–¹å—æ•°é‡
            const previousCubeCount = this.cubes.size

            this.platformGroup.remove(cube)
            this.cubes.delete(key)

            // ä»å†å²è®°å½•ä¸­ç§»é™¤
            const index = this.cubeHistory.findIndex((item) => item.x === x && item.y === y && item.z === z)
            if (index !== -1) {
              this.cubeHistory.splice(index, 1)
            }

            this.updateCubeCount()
            this.updateProjections() // å®æ—¶æ›´æ–°æŠ•å½±æ˜¾ç¤º
            this.updateSubmitButton()
            this.updateUndoButton()
          }
        }

        undo() {
          if (this.cubeHistory.length === 0) return

          // ç§»é™¤æœ€åæ”¾ç½®çš„æ–¹å—
          const lastCube = this.cubeHistory.pop()
          this.removeCube(lastCube.x, lastCube.y, lastCube.z)

          // é‡æ–°æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆå› ä¸ºremoveCubeä¼šåˆ é™¤å®ƒï¼‰
          // ä½†æˆ‘ä»¬ä¸éœ€è¦é‡æ–°æ·»åŠ ï¼Œå› ä¸ºè¿™å°±æ˜¯æ’¤é”€çš„ç›®çš„
        }

        updateUndoButton() {
          const undoButton = document.getElementById('undo')
          undoButton.disabled = this.cubeHistory.length === 0
          if (undoButton.disabled) {
            undoButton.classList.add('opacity-50', 'cursor-not-allowed')
            undoButton.classList.remove('hover:bg-orange-700')
          } else {
            undoButton.classList.remove('opacity-50', 'cursor-not-allowed')
            undoButton.classList.add('hover:bg-orange-700')
          }
        }

        updateSubmitButton() {
          const submitButton = document.getElementById('submitAnswer')
          const isProjectionCorrect = this.checkProjectionMatch()

          if (isProjectionCorrect && this.cubes.size > 0) {
            submitButton.disabled = false
            submitButton.classList.remove('opacity-50', 'cursor-not-allowed')
            submitButton.classList.add('hover:bg-green-700')
          } else {
            submitButton.disabled = true
            submitButton.classList.add('opacity-50', 'cursor-not-allowed')
            submitButton.classList.remove('hover:bg-green-700')
          }
        }        updateCubeCount() {
          const currentCount = this.cubes.size

          document.getElementById('cubeCount').innerHTML =
            `<div><div>${getText('gameInfo.level')}</div><div class="stat-number">${this.currentLevel}/${this.maxLevels}</div></div>` +
            `<div><div>${getText('gameInfo.cubesUsed')}/${getText('gameInfo.minCubes')}</div><div class="stat-number">${currentCount}/${this.minCubesNeeded}</div></div>`

          if (currentCount > this.minCubesNeeded) {
            document.getElementById('cubeCount').style.color = '#f87171'
          } else if (currentCount === this.minCubesNeeded) {
            document.getElementById('cubeCount').style.color = '#4ade80'
          } else {
            document.getElementById('cubeCount').style.color = '#fbbf24'
          }
        }

        // æ£€æŸ¥å½“å‰æ–¹å—æ˜¯å¦äº§ç”Ÿæ­£ç¡®çš„æŠ•å½±
        checkProjectionMatch() {
          const currentFrontProjection = new Set()
          const currentRightProjection = new Set()

          // è®¡ç®—å½“å‰æ–¹å—çš„æŠ•å½±
          for (const [key, cube] of this.cubes) {
            const originalX = cube.userData.gridX - this.gridSize / 2 + 0.5
            const originalZ = cube.userData.gridZ - this.gridSize / 2 + 0.5
            const originalY = cube.userData.gridY

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            currentFrontProjection.add(frontProjKey)
            currentRightProjection.add(rightProjKey)
          }

          // è®¡ç®—ç›®æ ‡æŠ•å½±
          const targetFrontProjection = new Set()
          const targetRightProjection = new Set()

          for (const [key, target] of this.targetCubes) {
            const originalX = target.x - this.gridSize / 2 + 0.5
            const originalZ = target.z - this.gridSize / 2 + 0.5
            const originalY = target.y

            // ä½¿ç”¨ç²¾ç¡®çš„æ—‹è½¬å‚æ•°
            const { cos, sin } = this.getRotationParams()
            const rotatedX = originalX * cos - originalZ * sin
            const rotatedZ = originalX * sin + originalZ * cos

            const frontProjKey = `${Math.round(rotatedX * 2)},${Math.round((originalY + 0.5) * 2)}`
            const rightProjKey = `${Math.round(rotatedZ * 2)},${Math.round((originalY + 0.5) * 2)}`

            targetFrontProjection.add(frontProjKey)
            targetRightProjection.add(rightProjKey)
          }

          // æ¯”è¾ƒæŠ•å½±æ˜¯å¦åŒ¹é…
          const frontMatch = this.setsEqual(currentFrontProjection, targetFrontProjection)
          const rightMatch = this.setsEqual(currentRightProjection, targetRightProjection)

          return frontMatch && rightMatch
        }

        setsEqual(set1, set2) {
          if (set1.size !== set2.size) return false
          for (const item of set1) {
            if (!set2.has(item)) return false
          }
          return true
        }        showSuccessEffect(message = null) {
          if (this.isGameFinished) return // é˜²æ­¢é‡å¤è§¦å‘

          // å¦‚æœæ²¡æœ‰æä¾›æ¶ˆæ¯ï¼Œä½¿ç”¨é»˜è®¤æˆåŠŸæ¶ˆæ¯
          if (!message) {
            message = getText('ui.successMessage')
          }

          const effect = document.getElementById('successEffect')
          effect.innerHTML = message.replace(/\n/g, '<br>')
          effect.classList.add('success-show')

          setTimeout(() => {
            effect.classList.remove('success-show')
          }, 3000)
        }

        endGame() {
          if (this.isGameFinished) return // é˜²æ­¢é‡å¤è§¦å‘
          this.isGameFinished = true

          const effect = document.getElementById('successEffect')

          // è®¡ç®—æœ€ç»ˆåˆ†æ•°ï¼ˆæ‰€æœ‰å…³å¡åˆ†æ•°æ€»å’Œï¼‰
          let finalScore = this.levelScores.reduce((sum, score) => sum + score, 0)
          finalScore = Math.min(finalScore, 100)

          // æ›´æ–°æœ€é«˜åˆ†
          if (finalScore > bestScore) {
            bestScore = finalScore
            localStorage.setItem('spatialGameBestScore', bestScore.toString())
          }          // æ˜¾ç¤ºæ¸¸æˆå®Œæˆæ•ˆæœ
          effect.classList.add('success-show')
          effect.innerHTML = `ğŸŠ ${getText('gameInfo.gameComplete')}<br><span style="font-size: 1.5rem;">${getText('gameInfo.finalScore')}: ${finalScore}${getText('gameInfo.points')}</span><br><span style="font-size: 1rem;">${getText('gameInfo.highestRecord')}: ${bestScore}${getText('gameInfo.points')}</span>`

          // å‘é€æ¸¸æˆå®Œæˆäº‹ä»¶
          window.parent.postMessage(
            {
              type: 'gameFinished',
              data: {
                score: finalScore,
                bestScore: bestScore,
                difficulty: getDifficultyLevel(this.gridSize),
                gridSize: this.gridSize,
                levelsCompleted: this.currentLevel,
                maxLevels: this.maxLevels,
                levelScores: this.levelScores,
              },
            },
            '*'
          )

          // 5ç§’åå¯ä»¥é‡æ–°å¼€å§‹æ¸¸æˆ
          setTimeout(() => {
            effect.innerHTML += '<br><span style="font-size: 1rem;">ç‚¹å‡»"é‡æ–°å¼€å§‹"</span>'
          }, 5000)
        }

        rotatePlatform(direction) {
          if (this.isRotating) return

          this.isRotating = true
          const startRotationSteps = this.rotationSteps
          const targetRotationSteps = this.rotationSteps + direction

          // è®¡ç®—å®é™…çš„è§’åº¦ç”¨äºåŠ¨ç”»
          const startAngle = startRotationSteps * 90
          const targetAngle = targetRotationSteps * 90

          const duration = 500
          const startTime = Date.now()

          const animate = () => {
            const elapsed = Date.now() - startTime
            const progress = Math.min(elapsed / duration, 1)

            const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress

            const currentAngle = startAngle + (targetAngle - startAngle) * easeProgress
            this.platformGroup.rotation.y = THREE.MathUtils.degToRad(currentAngle)

            if (progress < 1) {
              requestAnimationFrame(animate)
            } else {
              // æ›´æ–°æ—‹è½¬æ­¥æ•°è€Œä¸æ˜¯è§’åº¦
              this.rotationSteps = targetRotationSteps
              this.isRotating = false
              this.calculateMinCubes()
              this.updateProjections()
              this.updateCubeCount()
              this.autoCheckAnswer()
            }
          }

          animate()
        }

        submitAnswer() {
          if (!this.checkProjectionMatch()) {
            return // æŠ•å½±ä¸æ­£ç¡®ï¼Œä¸èƒ½æäº¤
          }

          // è®¡ç®—å½“å‰å…³å¡å¾—åˆ†
          const actualCubes = this.cubes.size
          const minCubes = this.minCubesNeeded
          const levelScore = calculateGameScore(this.gridSize, actualCubes, minCubes, this.maxLevels)

          // è®°å½•å…³å¡å¾—åˆ†
          this.levelScores.push(levelScore)          // æ˜¾ç¤ºæˆåŠŸæ•ˆæœå’Œå¾—åˆ†ä¿¡æ¯
          let message = ''
          if (actualCubes > minCubes) {
            const canGetMaxText = getText('gameInfo.canGetMaxWith').replace('{0}', minCubes)
            message += `ğŸ‰ ${getText('gameInfo.success')}!\n${getText('gameInfo.levelScore')}: ${levelScore}${getText('gameInfo.points')} (${canGetMaxText})`
          } else {
            message += `ğŸ‰ ${getText('gameInfo.perfect')}!\n${getText('gameInfo.levelScore')}: ${levelScore}${getText('gameInfo.points')} (${getText('gameInfo.maxScore')}!)`
          }

          if (this.currentLevel < this.maxLevels) {
            message += `\n${getText('gameInfo.nextLevel')}`
          } else {
            message += `\n${getText('gameInfo.gameComplete')}`
          }

          this.showSuccessEffect(message)

          // å»¶è¿Ÿè¿›å…¥ä¸‹ä¸€å…³æˆ–ç»“æŸæ¸¸æˆ
          setTimeout(() => {
            if (this.currentLevel < this.maxLevels) {
              this.currentLevel++
              this.newGame()
            } else {
              this.endGame()
            }
          }, 2000)
        }

        newGame() {
          // å…³é—­æ¸¸æˆå®Œæˆæ•ˆæœçª—å£
          const effect = document.getElementById('successEffect')
          effect.classList.remove('success-show')

          // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œé‡ç½®æ‰€æœ‰çŠ¶æ€
          if (this.isGameFinished) {
            this.currentLevel = 1
            this.levelScores = []
            this.isGameFinished = false
            this.gameStartTime = Date.now()
          }

          this.gridSize = parseInt(document.getElementById('difficultySelect').value)

          // é‡ç½®å½“å‰å…³å¡ç»Ÿè®¡
          this.startTime = Date.now()

          // å¦‚æœæ˜¯ç¬¬ä¸€å…³ï¼Œè®°å½•æ¸¸æˆå¼€å§‹æ—¶é—´
          if (this.currentLevel === 1 && this.gameStartTime === 0) {
            this.gameStartTime = Date.now()
          }

          // é‡ç½®æ‰€æœ‰çŠ¶æ€
          this.rotationSteps = 0
          this.isRotating = false
          this.cubeHistory = [] // æ¸…ç©ºå†å²è®°å½•

          // å®Œå…¨æ¸…ç©ºæ‰€æœ‰æ–¹å—
          for (const [key, cube] of this.cubes) {
            this.platformGroup.remove(cube)
          }
          this.cubes.clear()

          // é‡å»ºæ¸¸æˆåœºæ™¯
          this.createPlatform()
          this.createWalls()
          this.platformGroup.rotation.y = 0

          // Auto-adjust camera for new grid size
          this.autoZoomCamera()

          // ç”Ÿæˆæ–°çš„ç›®æ ‡
          this.generateTarget()
          this.updateUndoButton()
          this.updateSubmitButton()

          // å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶
          if (!gameStarted) {
            window.parent.postMessage({ type: 'gameStarted' }, '*')
            gameStarted = true
          }
        }

        setupEventListeners() {
          document.getElementById('newGame').addEventListener('click', () => this.newGame())
          document.getElementById('undo').addEventListener('click', () => this.undo())
          document.getElementById('rotateLeft').addEventListener('click', () => this.rotatePlatform(1))
          document.getElementById('rotateRight').addEventListener('click', () => this.rotatePlatform(-1))
          document.getElementById('submitAnswer').addEventListener('click', () => this.submitAnswer())

          // éš¾åº¦é€‰æ‹©äº‹ä»¶ç›‘å¬å™¨
          document.getElementById('difficultySelect').addEventListener('change', () => {
            // å…³é—­ä»»ä½•æ˜¾ç¤ºçš„æ•ˆæœçª—å£
            const effect = document.getElementById('successEffect')
            effect.classList.remove('success-show')

            // é‡ç½®æ¸¸æˆçŠ¶æ€åˆ°ç¬¬ä¸€å…³
            this.currentLevel = 1
            this.levelScores = []
            this.isGameFinished = false
            this.gameStartTime = 0 // é‡ç½®æ¸¸æˆå¼€å§‹æ—¶é—´ï¼Œä¸‹æ¬¡newGameæ—¶ä¼šé‡æ–°è®¾ç½®

            // é‡æ–°å¼€å§‹æ¸¸æˆ
            this.newGame()
          })

          // é¼ æ ‡äº‹ä»¶
          this.renderer.domElement.addEventListener('mousedown', (event) => {
            event.preventDefault()
            if (event.button === 2) {
              // å³é”®ç‚¹å‡»ï¼Œç›´æ¥å¤„ç†åˆ é™¤
              this.handleRightClick(event)
            } else {
              // å·¦é”®ç‚¹å‡»ï¼Œå¼€å§‹é•¿æŒ‰æ£€æµ‹
              this.startLongPress(event)
            }
          })

          this.renderer.domElement.addEventListener('mouseup', (event) => {
            event.preventDefault()
            if (event.button !== 2) {
              // åªå¤„ç†å·¦é”®æ¾å¼€
              this.endLongPress(event)
            }
          })

          // è§¦æ‘¸äº‹ä»¶
          this.renderer.domElement.addEventListener('touchstart', (event) => {
            event.preventDefault()
            this.startLongPress(event)
          })

          this.renderer.domElement.addEventListener('touchend', (event) => {
            event.preventDefault()
            this.endLongPress(event)
          })

          // é˜»æ­¢å³é”®èœå•
          this.renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault()
          })

          window.addEventListener('resize', () => {
            this.handleResize()
          })
        }

        handleResize() {
          // ç­‰å¾…DOMæ›´æ–°åå†è·å–å°ºå¯¸
          setTimeout(() => {
            // è·å–å®¹å™¨çš„å®é™…å°ºå¯¸
            const container = document.getElementById('gameCanvas')
            const containerRect = container.getBoundingClientRect()

            // ä½¿ç”¨å®¹å™¨çš„å®é™…å°ºå¯¸ï¼Œè€Œä¸æ˜¯windowçš„å°ºå¯¸
            const canvasWidth = containerRect.width || window.innerWidth
            const canvasHeight = containerRect.height || window.innerHeight

            // ç¡®ä¿å°ºå¯¸å¤§äº0
            if (canvasWidth > 0 && canvasHeight > 0) {
              // Update camera aspect ratio
              this.camera.aspect = canvasWidth / canvasHeight
              this.camera.updateProjectionMatrix()

              // Update renderer size
              this.renderer.setSize(canvasWidth, canvasHeight)

              // Auto-adjust camera position for optimal viewing
              this.autoZoomCamera()
            }
          }, 100)
        }

        autoZoomCamera() {
          const aspect = window.innerWidth / window.innerHeight
          const sceneSize = this.gridSize + 2 // å¢åŠ åœºæ™¯å¤§å°è®¡ç®—

          // Calculate optimal distance based on grid size and aspect ratio
          const fov = this.camera.fov * (Math.PI / 180) // Convert to radians
          const targetDistance = sceneSize / (2 * Math.tan(fov / 2))

          // Adjust distance based on aspect ratio - ä½¿åœºæ™¯æ›´å¤§æ›´æ˜“æ“ä½œ
          let optimalDistance
          if (aspect > 1) {
            // Landscape: use height as limiting factor
            optimalDistance = targetDistance * 0.6 // è¿›ä¸€æ­¥å‡å°è®©åœºæ™¯æ›´å¤§
          } else {
            // Portrait: use width as limiting factor and move camera further
            optimalDistance = (targetDistance * 0.8) / aspect // è¿›ä¸€æ­¥å‡å°
          }

          // Ensure minimum and maximum distances - è°ƒæ•´èŒƒå›´è®©åœºæ™¯æ›´å¤§
          optimalDistance = Math.max(optimalDistance, this.gridSize * 1.2) // å‡å°æœ€å°è·ç¦»
          optimalDistance = Math.min(optimalDistance, this.gridSize * 5) // å‡å°æœ€å¤§è·ç¦»

          // Smoothly animate camera to new position - å‘ä¸‹ç§»åŠ¨åœºæ™¯
          this.animateCameraToPosition(
            -optimalDistance * 0.8,
            optimalDistance * 1.2, // è¿›ä¸€æ­¥é™ä½Yè½´ä½ç½®
            optimalDistance * 0.8
          )
        }

        animateCameraToPosition(targetX, targetY, targetZ) {
          const startPosition = this.camera.position.clone()
          const targetPosition = new THREE.Vector3(targetX, targetY, targetZ)

          const duration = 800 // Animation duration in ms
          const startTime = Date.now()

          const animate = () => {
            const elapsed = Date.now() - startTime
            const progress = Math.min(elapsed / duration, 1)

            // Smooth easing function
            const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress

            // Interpolate camera position
            this.camera.position.lerpVectors(startPosition, targetPosition, easeProgress)

            // Update camera to look at the scene center - è°ƒæ•´è§‚å¯Ÿç‚¹
            this.camera.lookAt(0, 1, 0) // ç®€åŒ–è§‚å¯Ÿç‚¹ï¼Œè®©è§†è§’æ›´å±…ä¸­

            if (progress < 1) {
              requestAnimationFrame(animate)
            }
          }

          animate()
        }

        animate() {
          requestAnimationFrame(() => this.animate())
          this.renderer.render(this.scene, this.camera)
        }
      }      // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æœ€é«˜åˆ†
      bestScore = parseInt(localStorage.getItem('spatialGameBestScore') || '0')      // å¯åŠ¨æ¸¸æˆ
      let game = null // å…¨å±€æ¸¸æˆå¯¹è±¡
      
      // åˆå§‹åŒ–æ¸¸æˆçš„å‡½æ•°
      function initGame() {
        // ç¡®ä¿gameCanvaså…ƒç´ å­˜åœ¨
        const gameCanvas = document.getElementById('gameCanvas')
        if (!gameCanvas) {
          console.error('gameCanvas element not found')
          return
        }
        
        if (!game) {
          game = new SpatialGame()
          window.game = game // ä½¿æ¸¸æˆå¯¹è±¡å…¨å±€å¯è®¿é—®
        }
      }
      
      initGame()
      
    </script>
  </body>
</html>

