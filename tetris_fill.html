<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¿„ç½—æ–¯æ–¹å—æ‹¼å›¾æ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        .game-cell {
            width: 30px;
            height: 30px;
            border: 1px solid #ddd;
        }

        .tetris-piece {
            cursor: grab;
            transition: transform 0.2s;
        }

        .tetris-piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        .piece-cell {
            width: 20px;
            height: 20px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .dragging {
            opacity: 0.8;
            z-index: 1000;
            pointer-events: none;
        }

        .valid-drop {
            background-color: rgba(34, 197, 94, 0.3) !important;
        }

        .invalid-drop {
            background-color: rgba(239, 68, 68, 0.3) !important;
        }

        /* ç¡®ä¿æ¸¸æˆæ£‹ç›˜åœ¨ä¸åŒå±å¹•ä¸‹çš„é€‚é… */
        #gameBoard {
            min-width: fit-content;
        }
    </style>
</head>

<body class="bg-gray-100 p-4">
    <div class="max-w-6xl mx-auto"> <!-- é¡¶éƒ¨æ§åˆ¶æ  - æ¨ªå±å¸ƒå±€ -->
        <div class="bg-white rounded-lg shadow-lg p-4 mb-4">
            <div class="control-bar flex items-center justify-between flex-wrap gap-4">
                <!-- å·¦ä¾§ï¼šéš¾åº¦é€‰æ‹© -->
                <div class="flex items-center gap-3">
                    <label class="text-lg font-semibold">éš¾åº¦:</label>
                    <select id="difficultySelect" class="bg-white border border-gray-300 px-3 py-2 rounded">
                        <option value="easy">ç®€å• (4-6ä¸ªæ–¹å—)</option>
                        <option value="medium">ä¸­ç­‰ (8-12ä¸ªæ–¹å—)</option>
                        <option value="hard">å›°éš¾ (14-18ä¸ªæ–¹å—)</option>
                        <option value="expert">ä¸“å®¶ (16-20ä¸ªæ–¹å—)</option>
                    </select>
                </div>

                <!-- ä¸­é—´ï¼šå…³å¡ä¿¡æ¯ -->
                <div class="text-xl font-bold text-blue-600">
                    å…³å¡: <span id="level">1</span>/5
                </div>

                <!-- å³ä¾§ï¼šæ¸¸æˆæ§åˆ¶æŒ‰é’® -->
                <div class="flex items-center gap-3">
                    <button id="newGame"
                        class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-semibold">
                        ğŸ® æ–°æ¸¸æˆ
                    </button>
                    <button id="clearBoard"
                        class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded font-semibold">
                        ğŸ—‘ï¸ æ¸…ç©ºæ£‹ç›˜
                    </button>
                </div>
            </div>
        </div> <!-- æ¸¸æˆä¸»åŒºåŸŸ - æ¨ªå±å¸ƒå±€ -->
        <div class="flex gap-4 flex-horizontal">
            <!-- å·¦ä¾§ï¼šæ¸¸æˆæ£‹ç›˜ -->
            <div class="bg-white rounded-lg shadow-lg p-6 flex-shrink-0">
                <div class="flex justify-center">
                    <div id="gameBoard" class="inline-grid gap-0 border-2 border-gray-400 bg-gray-50"></div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šæ–¹å—åŒºåŸŸå’Œè¯´æ˜ -->
            <div class="flex-1 space-y-4">
                <!-- æ–¹å—åŒºåŸŸ -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h3 class="text-lg font-semibold mb-4 text-center">ğŸ§© æ‹–æ‹½åˆ°ç›®æ ‡åŒºåŸŸ | å•å‡»æ–¹å—å¯æ—‹è½¬</h3>
                    <div id="piecesContainer" class="flex flex-wrap justify-center gap-4"></div>
                </div>
            </div>
        </div>

        <!-- èƒœåˆ©å¼¹çª— -->
        <div id="winModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-8 text-center">
                <h2 class="text-2xl font-bold text-green-600 mb-4">ğŸ‰ æ­å–œé€šå…³ï¼</h2>
                <p class="text-gray-700 mb-6">ä½ æˆåŠŸå®Œæˆäº†å…³å¡ <span id="completedLevel"></span>ï¼</p>
                <button id="nextLevel"
                    class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded mr-2">ä¸‹ä¸€å…³</button>
                <button id="closeModal" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded">å…³é—­</button>
            </div>
        </div>
    </div>

    <script>        class TetrisPuzzle {
            constructor() {
                this.boardSize = 8;
                this.board = [];
                this.targetBoard = []; // ç›®æ ‡åœ°å›¾
                this.pieces = [];
                this.currentLevel = 1;
                this.currentDifficulty = 'easy';
                this.maxLevel = 5;
                this.draggedPiece = null;
                this.dragOffset = { x: 0, y: 0 };
                this.placedPieces = []; // è®°å½•å·²æ”¾ç½®çš„æ–¹å—
                this.currentDragElement = null; // ä¿å­˜å½“å‰æ‹–æ‹½å…ƒç´ çš„å¼•ç”¨

                // éš¾åº¦é…ç½®
                this.difficultyConfig = {
                    easy: { minPieces: 4, maxPieces: 6, name: 'ç®€å•' },
                    medium: { minPieces: 8, maxPieces: 12, name: 'ä¸­ç­‰' },
                    hard: { minPieces: 14, maxPieces: 18, name: 'å›°éš¾' },
                    expert: { minPieces: 16, maxPieces: 20, name: 'ä¸“å®¶' }
                };

                // ä¿„ç½—æ–¯æ–¹å—å½¢çŠ¶å®šä¹‰
                this.shapes = {
                    I: [[1, 1, 1, 1]],
                    O: [[1, 1], [1, 1]],
                    T: [[0, 1, 0], [1, 1, 1]],
                    L: [[1, 0], [1, 0], [1, 1]],
                    J: [[0, 1], [0, 1], [1, 1]],
                    S: [[0, 1, 1], [1, 1, 0]],
                    Z: [[1, 1, 0], [0, 1, 1]]
                };

                this.colors = [
                    '#3B82F6', // è“è‰²
                    '#EF4444', // çº¢è‰²
                    '#10B981', // ç»¿è‰²
                    '#F59E0B', // é»„è‰²
                    '#8B5CF6', // ç´«è‰²
                    '#EC4899', // ç²‰è‰²
                    '#06B6D4'  // é’è‰²
                ];

                this.initializeBoard();
                this.generateLevel();
                this.setupEventListeners();
            } initializeBoard() {
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.targetBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.placedPieces = [];
                this.renderBoard();
            } renderBoard() {
                const gameBoard = document.getElementById('gameBoard');
                gameBoard.style.gridTemplateColumns = `repeat(${this.boardSize}, 30px)`;
                gameBoard.innerHTML = '';

                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'game-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        // æŸ¥æ‰¾è¯¥ä½ç½®æ˜¯å¦æœ‰å·²æ”¾ç½®çš„æ–¹å—
                        const placedPiece = this.findPlacedPieceAt(row, col);

                        if (placedPiece) {
                            cell.style.backgroundColor = placedPiece.color;
                            cell.style.cursor = 'grab';
                            cell.dataset.pieceId = placedPiece.id;
                            cell.addEventListener('mousedown', (e) => this.startDragFromBoard(e, placedPiece));
                            cell.addEventListener('touchstart', (e) => this.startDragFromBoard(e, placedPiece));
                        } else if (this.targetBoard[row][col] === 1) {
                            cell.style.backgroundColor = '#cccccc'; // ç›®æ ‡åŒºåŸŸ - æµ…ç°è‰²
                            cell.style.border = '2px dashed #9CA3AF';
                        } else {
                            cell.style.backgroundColor = '#FFFFFF'; // ç©ºç™½
                            cell.style.border = '1px solid #E5E7EB';
                        }

                        gameBoard.appendChild(cell);
                    }
                }
            }

            findPlacedPieceAt(row, col) {
                return this.placedPieces.find(placedPiece => {
                    const { startRow, startCol, piece } = placedPiece;
                    for (let r = 0; r < piece.shape.length; r++) {
                        for (let c = 0; c < piece.shape[r].length; c++) {
                            if (piece.shape[r][c] && startRow + r === row && startCol + c === col) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            } generateLevel() {
                this.initializeBoard();

                // è·å–å½“å‰éš¾åº¦é…ç½®
                const config = this.difficultyConfig[this.currentDifficulty];
                const baseCount = config.minPieces;
                const extraCount = Math.floor((config.maxPieces - config.minPieces) * (this.currentLevel - 1) / (this.maxLevel - 1));
                const totalPieces = baseCount + extraCount;

                this.generateTargetMapAndPieces(totalPieces);
                this.renderBoard();
                this.renderPieces();

                // æ›´æ–°UI
                document.getElementById('level').textContent = this.currentLevel;
            }

            generateTargetMapAndPieces(pieceCount) {
                this.pieces = [];
                this.targetBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));

                const shapeNames = Object.keys(this.shapes);
                let pieceId = 0;

                // ä¾æ¬¡ç”Ÿæˆæ–¹å—å¹¶æ”¾ç½®åœ¨ç›®æ ‡åœ°å›¾ä¸Š
                for (let i = 0; i < pieceCount; i++) {
                    // éšæœºé€‰æ‹©å½¢çŠ¶å’Œæ—‹è½¬
                    const shapeName = shapeNames[Math.floor(Math.random() * shapeNames.length)];
                    const shape = this.shapes[shapeName];
                    const rotation = Math.floor(Math.random() * 4);
                    const rotatedShape = this.rotateShape(shape, rotation);

                    // å°è¯•åœ¨ç›®æ ‡åœ°å›¾ä¸Šæ‰¾ä½ç½®
                    const position = this.findBestPositionForShape(rotatedShape);

                    if (position) {
                        // åœ¨ç›®æ ‡åœ°å›¾ä¸Šæ ‡è®°
                        this.markShapeOnTarget(position.row, position.col, rotatedShape);

                        // åˆ›å»ºæ–¹å—å¯¹è±¡
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        this.pieces.push({
                            id: pieceId++,
                            shape: rotatedShape,
                            color: color,
                            placed: false
                        });
                    }
                }

                // å¦‚æœç”Ÿæˆçš„æ–¹å—ä¸å¤Ÿï¼Œè¡¥å……å•ä¸ªæ–¹å—
                while (this.pieces.length < pieceCount) {
                    const emptyPositions = this.getEmptyTargetPositions();
                    if (emptyPositions.length === 0) break;

                    const randomPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                    this.targetBoard[randomPos.row][randomPos.col] = 1;

                    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                    this.pieces.push({
                        id: pieceId++,
                        shape: [[1]],
                        color: color,
                        placed: false
                    });
                }
            }

            findBestPositionForShape(shape) {
                const positions = [];

                // æ”¶é›†æ‰€æœ‰å¯èƒ½çš„ä½ç½®
                for (let row = 0; row <= this.boardSize - shape.length; row++) {
                    for (let col = 0; col <= this.boardSize - shape[0].length; col++) {
                        if (this.canPlaceShapeOnTarget(row, col, shape)) {
                            // è®¡ç®—ä¸å·²æœ‰æ–¹å—çš„é‚»æ¥åº¦
                            const adjacency = this.calculateAdjacency(row, col, shape);
                            positions.push({ row, col, adjacency });
                        }
                    }
                }

                if (positions.length === 0) return null;

                // ä¼˜å…ˆé€‰æ‹©é‚»æ¥åº¦é«˜çš„ä½ç½®ï¼ˆæ›´å®¹æ˜“æ— ç¼æ‹¼æ¥ï¼‰
                positions.sort((a, b) => b.adjacency - a.adjacency);

                // åœ¨å‰å‡ ä¸ªæœ€ä½³ä½ç½®ä¸­éšæœºé€‰æ‹©
                const topPositions = positions.slice(0, Math.min(3, positions.length));
                return topPositions[Math.floor(Math.random() * topPositions.length)];
            }

            canPlaceShapeOnTarget(startRow, startCol, shape) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const targetRow = startRow + r;
                            const targetCol = startCol + c;

                            if (targetRow < 0 || targetRow >= this.boardSize ||
                                targetCol < 0 || targetCol >= this.boardSize ||
                                this.targetBoard[targetRow][targetCol] === 1) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            calculateAdjacency(startRow, startCol, shape) {
                let adjacency = 0;
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const targetRow = startRow + r;
                            const targetCol = startCol + c;

                            // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„é‚»æ¥
                            for (const [dr, dc] of directions) {
                                const adjRow = targetRow + dr;
                                const adjCol = targetCol + dc;

                                if (adjRow >= 0 && adjRow < this.boardSize &&
                                    adjCol >= 0 && adjCol < this.boardSize &&
                                    this.targetBoard[adjRow][adjCol] === 1) {
                                    adjacency++;
                                }
                            }
                        }
                    }
                }

                return adjacency;
            }

            markShapeOnTarget(startRow, startCol, shape) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            this.targetBoard[startRow + r][startCol + c] = 1;
                        }
                    }
                }
            } getEmptyTargetPositions() {
                const positions = [];
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.targetBoard[row][col] === 0) {
                            positions.push({ row, col });
                        }
                    }
                }
                return positions;
            } startDragFromBoard(e, placedPiece) {
                e.preventDefault();
                e.stopPropagation();

                // ç§»é™¤å·²æ”¾ç½®çš„æ–¹å—
                this.removePlacedPiece(placedPiece.id);

                // è®¾ç½®ä¸ºå½“å‰æ‹–æ‹½çš„æ–¹å—
                this.draggedPiece = placedPiece.piece;

                // åˆ›å»ºä¸´æ—¶æ‹–æ‹½å…ƒç´ 
                const tempElement = this.createDragElement(placedPiece.piece);
                document.body.appendChild(tempElement);
                this.currentDragElement = tempElement; // ä¿å­˜å¼•ç”¨ä»¥ä¾¿æ¸…ç†

                let clientX, clientY;
                if (e.type === 'mousedown') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                }

                this.dragOffset = {
                    x: tempElement.offsetWidth / 2,
                    y: tempElement.offsetHeight / 2
                };

                tempElement.style.left = (clientX - this.dragOffset.x) + 'px';
                tempElement.style.top = (clientY - this.dragOffset.y) + 'px';

                document.addEventListener('mousemove', this.handleDragMoveFromBoard);
                document.addEventListener('mouseup', this.handleDragEndFromBoard);
                document.addEventListener('touchmove', this.handleDragMoveFromBoard);
                document.addEventListener('touchend', this.handleDragEndFromBoard);
            } createDragElement(piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'tetris-piece dragging';
                pieceDiv.style.position = 'fixed';
                pieceDiv.style.zIndex = '1000';
                pieceDiv.style.pointerEvents = 'none';
                pieceDiv.dataset.pieceId = piece.id;

                const grid = document.createElement('div');
                grid.className = 'inline-grid gap-0 p-2 bg-white rounded shadow';
                grid.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 20px)`;

                piece.shape.forEach(row => {
                    row.forEach(cell => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'piece-cell';
                        cellDiv.style.backgroundColor = cell ? piece.color : 'transparent';
                        grid.appendChild(cellDiv);
                    });
                });
                pieceDiv.appendChild(grid);
                return pieceDiv;
            }

            // ä»æ¸¸æˆæ¿æ‹–æ‹½çš„äº‹ä»¶å¤„ç†
            handleDragMoveFromBoard = (e) => {
                if (!this.draggedPiece || !this.currentDragElement) return;

                let clientX, clientY;
                if (e.type === 'mousemove') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else {
                    const touch = e.touches[0];
                    clientX = touch.clientX;
                    clientY = touch.clientY;
                }

                this.currentDragElement.style.left = (clientX - this.dragOffset.x) + 'px';
                this.currentDragElement.style.top = (clientY - this.dragOffset.y) + 'px';

                this.highlightDropZoneByPiecePosition(clientX, clientY);
            };

            handleDragEndFromBoard = (e) => {
                if (!this.draggedPiece || !this.currentDragElement) return;

                let clientX, clientY;
                if (e.type === 'mouseup') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else {
                    const touch = e.changedTouches[0];
                    clientX = touch.clientX;
                    clientY = touch.clientY;
                }

                // æ¸…ç†ä¸´æ—¶æ‹–æ‹½å…ƒç´ 
                if (this.currentDragElement) {
                    document.body.removeChild(this.currentDragElement);
                    this.currentDragElement = null;
                }

                this.tryPlacePieceByPosition(clientX, clientY);
                this.clearHighlights();
                this.draggedPiece = null;

                document.removeEventListener('mousemove', this.handleDragMoveFromBoard);
                document.removeEventListener('mouseup', this.handleDragEndFromBoard);
                document.removeEventListener('touchmove', this.handleDragMoveFromBoard);
                document.removeEventListener('touchend', this.handleDragEndFromBoard);
            };

            // åŸºäºæ–¹å—ä½ç½®çš„é«˜äº®æ˜¾ç¤º
            highlightDropZoneByPiecePosition(clientX, clientY) {
                this.clearHighlights();
                const boardElement = document.getElementById('gameBoard');
                const boardRect = boardElement.getBoundingClientRect();

                if (clientX >= boardRect.left && clientX <= boardRect.right &&
                    clientY >= boardRect.top && clientY <= boardRect.bottom) {

                    const cellSize = 30;
                    // è®¡ç®—æ–¹å—å·¦ä¸Šè§’å¯¹åº”çš„ç½‘æ ¼ä½ç½®
                    const pieceLeftX = clientX - this.dragOffset.x;
                    const pieceTopY = clientY - this.dragOffset.y;

                    const row = Math.floor((pieceTopY - boardRect.top) / cellSize);
                    const col = Math.floor((pieceLeftX - boardRect.left) / cellSize);

                    if (this.canPlacePiece(row, col, this.draggedPiece.shape)) {
                        this.highlightCells(row, col, this.draggedPiece.shape, 'valid-drop');
                    } else {
                        this.highlightCells(row, col, this.draggedPiece.shape, 'invalid-drop');
                    }
                }
            }

            // åŸºäºæ–¹å—ä½ç½®çš„æ”¾ç½®å°è¯•
            tryPlacePieceByPosition(clientX, clientY) {
                const boardElement = document.getElementById('gameBoard');
                const boardRect = boardElement.getBoundingClientRect();

                if (clientX >= boardRect.left && clientX <= boardRect.right &&
                    clientY >= boardRect.top && clientY <= boardRect.bottom) {

                    const cellSize = 30;
                    // è®¡ç®—æ–¹å—å·¦ä¸Šè§’å¯¹åº”çš„ç½‘æ ¼ä½ç½®
                    const pieceLeftX = clientX - this.dragOffset.x;
                    const pieceTopY = clientY - this.dragOffset.y;

                    const row = Math.floor((pieceTopY - boardRect.top) / cellSize);
                    const col = Math.floor((pieceLeftX - boardRect.left) / cellSize);

                    if (this.canPlacePiece(row, col, this.draggedPiece.shape)) {
                        this.placePiece(row, col, this.draggedPiece);
                    }
                }
            }

            removePlacedPiece(pieceId) {
                // æ‰¾åˆ°è¦ç§»é™¤çš„æ–¹å—
                const placedPiece = this.placedPieces.find(p => p.id === pieceId);
                if (placedPiece) {
                    // æ¸…é™¤æ£‹ç›˜ä¸Šçš„ä½ç½®
                    const { startRow, startCol, piece } = placedPiece;
                    piece.shape.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            if (cell) {
                                this.board[startRow + r][startCol + c] = 0;
                            }
                        });
                    });
                }

                // ä»å·²æ”¾ç½®åˆ—è¡¨ä¸­ç§»é™¤
                this.placedPieces = this.placedPieces.filter(p => p.id !== pieceId);
                this.pieces.find(p => p.id === pieceId).placed = false;
                this.renderBoard();
                this.renderPieces();
            }

            canPlacePieceInEmptyBoard(startRow, startCol, shape, emptySpaces) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const targetRow = startRow + r;
                            const targetCol = startCol + c;

                            // æ£€æŸ¥è¾¹ç•Œ
                            if (targetRow < 0 || targetRow >= this.boardSize ||
                                targetCol < 0 || targetCol >= this.boardSize) {
                                return false;
                            }

                            // æ£€æŸ¥æ˜¯å¦åœ¨ç©ºä½åˆ—è¡¨ä¸­
                            const isEmpty = emptySpaces.some(space =>
                                space.row === targetRow && space.col === targetCol);
                            if (!isEmpty) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            rotateShape(shape, times) {
                let rotated = shape;
                for (let i = 0; i < times; i++) {
                    const rows = rotated.length;
                    const cols = rotated[0].length;
                    const newShape = Array(cols).fill().map(() => Array(rows).fill(0));

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            newShape[c][rows - 1 - r] = rotated[r][c];
                        }
                    }
                    rotated = newShape;
                }
                return rotated;
            }

            renderPieces() {
                const container = document.getElementById('piecesContainer');
                container.innerHTML = '';

                this.pieces.forEach(piece => {
                    if (!piece.placed) {
                        const pieceElement = this.createPieceElement(piece);
                        container.appendChild(pieceElement);
                    }
                });
            }

            createPieceElement(piece) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'tetris-piece m-2 p-2 bg-white rounded shadow';
                pieceDiv.dataset.pieceId = piece.id;

                const grid = document.createElement('div');
                grid.className = 'inline-grid gap-0';
                grid.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 20px)`;

                piece.shape.forEach(row => {
                    row.forEach(cell => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'piece-cell';
                        cellDiv.style.backgroundColor = cell ? piece.color : 'transparent';
                        grid.appendChild(cellDiv);
                    });
                });

                pieceDiv.appendChild(grid);

                // æ·»åŠ æ‹–æ‹½äº‹ä»¶
                this.addDragEvents(pieceDiv, piece);
                return pieceDiv;
            }

            addDragEvents(element, piece) {
                let startX, startY;
                let dragStarted = false;
                let startTime = 0;

                // é¼ æ ‡äº‹ä»¶
                element.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    dragStarted = false;
                    startTime = Date.now();
                    startX = e.clientX;
                    startY = e.clientY;

                    // å»¶è¿Ÿå¯åŠ¨æ‹–æ‹½ï¼Œç»™å•å‡»ç•™å‡ºæ—¶é—´
                    setTimeout(() => {
                        if (!dragStarted) {
                            this.startDrag(e, element, piece, e.clientX, e.clientY);
                            dragStarted = true;
                        }
                    }, 150);
                });

                element.addEventListener('mouseup', (e) => {
                    const endTime = Date.now();
                    const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));

                    // å¦‚æœæ˜¯çŸ­æ—¶é—´ç‚¹å‡»ä¸”æ²¡æœ‰ç§»åŠ¨ï¼Œåˆ™æ—‹è½¬
                    if (!dragStarted && endTime - startTime < 200 && distance < 5) {
                        piece.shape = this.rotateShape(piece.shape, 1);
                        this.renderPieces();
                    }
                });

                // è§¦æ‘¸äº‹ä»¶
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    dragStarted = false;
                    startTime = Date.now();
                    startX = touch.clientX;
                    startY = touch.clientY;

                    // å»¶è¿Ÿå¯åŠ¨æ‹–æ‹½
                    setTimeout(() => {
                        if (!dragStarted && e.touches.length > 0) {
                            this.startDrag(e, element, piece, touch.clientX, touch.clientY);
                            dragStarted = true;
                        }
                    }, 150);
                });

                element.addEventListener('touchend', (e) => {
                    const endTime = Date.now();
                    const touch = e.changedTouches[0];
                    const distance = Math.sqrt(Math.pow(touch.clientX - startX, 2) + Math.pow(touch.clientY - startY, 2));

                    // å¦‚æœæ˜¯çŸ­æ—¶é—´ç‚¹å‡»ä¸”æ²¡æœ‰ç§»åŠ¨ï¼Œåˆ™æ—‹è½¬
                    if (!dragStarted && endTime - startTime < 200 && distance < 5) {
                        piece.shape = this.rotateShape(piece.shape, 1);
                        this.renderPieces();
                    }
                });
            }

            startDrag(e, element, piece, clientX, clientY) {
                this.draggedPiece = piece;
                const rect = element.getBoundingClientRect();
                this.dragOffset = {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };

                element.classList.add('dragging');
                element.style.position = 'fixed';
                element.style.left = (clientX - this.dragOffset.x) + 'px';
                element.style.top = (clientY - this.dragOffset.y) + 'px';
                element.style.zIndex = '1000';

                document.addEventListener('mousemove', this.handleDragMove);
                document.addEventListener('mouseup', this.handleDragEnd);
                document.addEventListener('touchmove', this.handleDragMove);
                document.addEventListener('touchend', this.handleDragEnd);
            }

            handleDragMove = (e) => {
                if (!this.draggedPiece) return;

                let clientX, clientY;
                if (e.type === 'mousemove') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else {
                    const touch = e.touches[0];
                    clientX = touch.clientX;
                    clientY = touch.clientY;
                }

                const element = document.querySelector(`[data-piece-id="${this.draggedPiece.id}"]`);
                element.style.left = (clientX - this.dragOffset.x) + 'px';
                element.style.top = (clientY - this.dragOffset.y) + 'px';

                this.highlightDropZone(clientX, clientY);
            };

            handleDragEnd = (e) => {
                if (!this.draggedPiece) return;

                let clientX, clientY;
                if (e.type === 'mouseup') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else {
                    const touch = e.changedTouches[0];
                    clientX = touch.clientX;
                    clientY = touch.clientY;
                }

                const element = document.querySelector(`[data-piece-id="${this.draggedPiece.id}"]`);
                element.classList.remove('dragging');
                element.style.position = '';
                element.style.left = '';
                element.style.top = '';
                element.style.zIndex = '';

                this.tryPlacePiece(clientX, clientY);
                this.clearHighlights();
                this.draggedPiece = null;

                document.removeEventListener('mousemove', this.handleDragMove);
                document.removeEventListener('mouseup', this.handleDragEnd);
                document.removeEventListener('touchmove', this.handleDragMove);
                document.removeEventListener('touchend', this.handleDragEnd);
            }; highlightDropZone(clientX, clientY) {
                this.clearHighlights();
                const boardElement = document.getElementById('gameBoard');
                const boardRect = boardElement.getBoundingClientRect();

                if (clientX >= boardRect.left && clientX <= boardRect.right &&
                    clientY >= boardRect.top && clientY <= boardRect.bottom) {

                    const cellSize = 30;
                    // è®¡ç®—æ–¹å—å·¦ä¸Šè§’å¯¹åº”çš„ç½‘æ ¼ä½ç½®
                    const pieceLeftX = clientX - this.dragOffset.x;
                    const pieceTopY = clientY - this.dragOffset.y;

                    const row = Math.floor((pieceTopY - boardRect.top) / cellSize);
                    const col = Math.floor((pieceLeftX - boardRect.left) / cellSize);

                    if (this.canPlacePiece(row, col, this.draggedPiece.shape)) {
                        this.highlightCells(row, col, this.draggedPiece.shape, 'valid-drop');
                    } else {
                        this.highlightCells(row, col, this.draggedPiece.shape, 'invalid-drop');
                    }
                }
            }

            highlightCells(startRow, startCol, shape, className) {
                shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const targetRow = startRow + r;
                            const targetCol = startCol + c;
                            const cellElement = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                            if (cellElement) {
                                cellElement.classList.add(className);
                            }
                        }
                    });
                });
            }

            clearHighlights() {
                document.querySelectorAll('.valid-drop, .invalid-drop').forEach(cell => {
                    cell.classList.remove('valid-drop', 'invalid-drop');
                });
            } tryPlacePiece(clientX, clientY) {
                const boardElement = document.getElementById('gameBoard');
                const boardRect = boardElement.getBoundingClientRect();

                if (clientX >= boardRect.left && clientX <= boardRect.right &&
                    clientY >= boardRect.top && clientY <= boardRect.bottom) {

                    const cellSize = 30;
                    // è®¡ç®—æ–¹å—å·¦ä¸Šè§’å¯¹åº”çš„ç½‘æ ¼ä½ç½®
                    const pieceLeftX = clientX - this.dragOffset.x;
                    const pieceTopY = clientY - this.dragOffset.y;

                    const row = Math.floor((pieceTopY - boardRect.top) / cellSize);
                    const col = Math.floor((pieceLeftX - boardRect.left) / cellSize);

                    if (this.canPlacePiece(row, col, this.draggedPiece.shape)) {
                        this.placePiece(row, col, this.draggedPiece);
                    }
                }
            }

            canPlacePiece(startRow, startCol, shape) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const targetRow = startRow + r;
                            const targetCol = startCol + c;

                            if (targetRow < 0 || targetRow >= this.boardSize ||
                                targetCol < 0 || targetCol >= this.boardSize ||
                                this.board[targetRow][targetCol] !== 0) {
                                return false;
                            }
                        }
                    }
                } return true;
            }

            placePiece(startRow, startCol, piece) {
                // æ›´æ–°æ¸¸æˆæ¿çŠ¶æ€
                piece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            this.board[startRow + r][startCol + c] = 1;
                        }
                    });
                });

                // è®°å½•å·²æ”¾ç½®çš„æ–¹å—ï¼Œä»¥ä¾¿èƒ½å¤Ÿæ‹–æ‹½å›æ¥
                this.placedPieces.push({
                    id: piece.id,
                    piece: piece,
                    startRow: startRow,
                    startCol: startCol,
                    color: piece.color
                });

                piece.placed = true;
                this.renderBoard();
                this.renderPieces();

                if (this.checkWin()) {
                    setTimeout(() => this.showWinModal(), 500);
                }
            }

            checkWin() {
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç›®æ ‡ä½ç½®éƒ½è¢«å¡«æ»¡
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.targetBoard[row][col] === 1 && this.board[row][col] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            showWinModal() {
                document.getElementById('completedLevel').textContent = this.currentLevel;
                document.getElementById('winModal').classList.remove('hidden');
            } nextLevel() {
                this.currentLevel++;
                this.generateLevel();
                document.getElementById('winModal').classList.add('hidden');
            }

            clearPlacedPieces() {
                // åªæ¸…ç©ºæ¸¸æˆæ¿ä¸Šå·²æ”¾ç½®çš„æ–¹å—ï¼Œä¿ç•™ç›®æ ‡åœ°å›¾
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.placedPieces = [];

                // å°†æ‰€æœ‰æ–¹å—æ ‡è®°ä¸ºæœªæ”¾ç½®
                this.pieces.forEach(piece => piece.placed = false);

                // é‡æ–°æ¸²æŸ“
                this.renderBoard();
                this.renderPieces();
            }

            setupEventListeners() {
                document.getElementById('difficultySelect').addEventListener('change', (e) => {
                    this.currentDifficulty = e.target.value;
                    this.currentLevel = 1;
                    this.generateLevel();
                });

                document.getElementById('newGame').addEventListener('click', () => {
                    this.currentLevel = 1;
                    this.generateLevel();
                }); document.getElementById('clearBoard').addEventListener('click', () => {
                    this.clearPlacedPieces();
                });

                document.getElementById('nextLevel').addEventListener('click', () => {
                    this.nextLevel();
                });

                document.getElementById('closeModal').addEventListener('click', () => {
                    document.getElementById('winModal').classList.add('hidden');
                });
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        new TetrisPuzzle();
    </script>
</body>

</html>