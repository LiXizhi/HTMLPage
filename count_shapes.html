<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å‡ ä½•å›¾å½¢è®¡æ•°æ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        /* å…¨å±åŸºç¡€æ ·å¼ */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            position: fixed;
            width: 100%;
            font-size: 16px;
        }

        .game-container {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-y: auto;
            background: linear-gradient(135deg, #dbeafe 0%, #e9d5ff 100%);
            padding-top: 1rem;
        }

        /* SVGå½¢çŠ¶æ ·å¼ */
        .svg-shape {
            position: absolute;
            transition: all 0.3s ease;
            user-select: none;
            cursor: pointer;
            opacity: 0.9;
            visibility: visible;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* æ·»åŠ è¿™ä¸ªæ–°çš„CSSè§„åˆ™æ¥ç»Ÿä¸€è¾¹æ¡†ç²—ç»† */
        .svg-shape svg * {
            vector-effect: non-scaling-stroke !important;
            stroke-width: 3 !important;
        }

        .svg-shape:hover {
            opacity: 1;
            transform: scale(1.1) !important;
            z-index: 1000 !important;
        }

        .svg-shape:active {
            transform: scale(1.2) !important;
        }

        .shape-icon {
            width: 35px;
            height: 35px;
            margin-right: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }

        .shape-icon-svg {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shape-icon-svg svg {
            width: 100%;
            height: 100%;
        }

        .canvas-container {
            position: relative;
            border: 3px solid #374151;
            background: white;
            border-radius: 0.75rem;
            overflow: hidden;
        }

        /* ä¿®æ”¹è®¡æ•°ç½‘æ ¼çš„æ»šåŠ¨æ¡æ ·å¼ï¼Œç¡®ä¿containerå¤§å°ä¸å˜ */
        #countingGrid {
            max-height: 522px;
            overflow-y: auto;
            /* ä¸ºæ»šåŠ¨æ¡é¢„ç•™ç©ºé—´ï¼Œé¿å…å¸ƒå±€å˜åŒ– */
            scrollbar-gutter: stable;
            /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: #d1d5db #f3f4f6;
        }

        /* Webkitæµè§ˆå™¨æ»šåŠ¨æ¡æ ·å¼ */
        #countingGrid::-webkit-scrollbar {
            width: 8px;
        }

        #countingGrid::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 4px;
        }

        #countingGrid::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        #countingGrid::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* ä¿®æ”¹è®¡æ•°ç½‘æ ¼çš„æ»šåŠ¨æ¡æ ·å¼ï¼Œç¡®ä¿containerå¤§å°ä¸å˜ */
        #countingGrid {
            max-height: 522px;
            overflow-y: auto;
            /* ç§»é™¤ scrollbar-gutterï¼Œæ”¹ç”¨å›ºå®šå®½åº¦æ–¹æ¡ˆ */
            padding-right: 8px; /* ä¸ºæ»šåŠ¨æ¡é¢„ç•™å›ºå®šç©ºé—´ */
            margin-right: -8px; /* æŠµæ¶ˆpaddingé€ æˆçš„å†…å®¹åç§» */
            box-sizing: content-box; /* ç¡®ä¿paddingä¸å½±å“å®¹å™¨å¤§å° */
            scrollbar-width: thin;
            scrollbar-color: #d1d5db #f3f4f6;
        }

        /* Webkitæµè§ˆå™¨æ»šåŠ¨æ¡æ ·å¼ */
        #countingGrid::-webkit-scrollbar {
            width: 8px;
        }

        #countingGrid::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 4px;
        }

        #countingGrid::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        #countingGrid::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* åˆ é™¤é‡å¤çš„ .counting-grid è§„åˆ™ï¼Œåªä¿ç•™ä¸€ä¸ª */
        .counting-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.75rem;
            padding: 0.75rem 0.75rem 0.75rem 0.75rem; /* æ¢å¤æ­£å¸¸padding */
            justify-items: center;
            align-items: start;
            min-height: 480px; /* è®¾ç½®ä¸€ä¸ªæœ€å°é«˜åº¦ï¼Œé¿å…å†…å®¹å¤ªå°‘æ—¶ä¸éœ€è¦æ»šåŠ¨ */
        }

        /* ç¡®ä¿æ¸¸æˆå®¹å™¨ä¸ä¼šå› ä¸ºæ»šåŠ¨æ¡è€Œæ”¹å˜å¤§å° */
        .game-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            width: 100%; /* ç¡®ä¿å®½åº¦å›ºå®š */
        }

        /* å³ä¾§è®¡æ•°åŒºåŸŸçš„flexå®¹å™¨è°ƒæ•´ */
        .game-section.p-3.flex.flex-col {
            min-width: 0;
            overflow: hidden;
            width: 100%; /* ç¡®ä¿å®½åº¦å›ºå®š */
        }
        
        /* æ•°é‡è¾“å…¥æ§åˆ¶åŒºåŸŸ - æ”¹ä¸ºå›ºå®šå°ºå¯¸å¡ç‰‡å¸ƒå±€ */
        .count-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            padding: 1rem;
            border: 3px solid #e5e7eb;
            border-radius: 1rem;
            background: white;
            transition: all 0.2s ease;
            touch-action: manipulation;
            width: 160px;
            height: 150px;
            margin: 0;
            flex-shrink: 0;
        }

        .count-controls:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .count-card-icon {
            width: 65px;
            height: 65px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .count-card-icon svg {
            width: 60px;
            height: 60px;
        }

        .count-input-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            justify-content: center;
        }

        .count-btn {
            width: 2.5rem;
            height: 2.5rem;
            border: 2px solid #d1d5db;
            background: white;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            font-size: 1.125rem;
            color: #374151;
            transition: all 0.2s ease;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .count-btn:first-child {
            margin-right: 0.25rem;
        }

        .count-btn:last-child {
            margin-left: 0.25rem;
        }

        .count-btn.plus {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .count-btn.plus:hover {
            background: #2563eb;
            border-color: #1d4ed8;
        }

        .count-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .count-btn:active {
            transform: scale(0.95);
        }

        .count-display {
            min-width: 2rem;
            width: 2rem;
            text-align: center;
            font-weight: bold;
            font-size: 1.25rem;
            color: #374151;
            background: transparent;
            border: none;
            outline: none;
            flex-shrink: 0;
        }

        /* ç§»é™¤æ‰€æœ‰å“åº”å¼åª’ä½“æŸ¥è¯¢ */
        
        /* è®¡æ—¶å™¨æ ·å¼ */
        .timer-display {
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 1.375rem;
            font-weight: bold;
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            text-align: center;
            margin-left: 10px;
            min-width: 6rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 3px solid;
        }

        .timer-normal {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            border-color: #374151;
        }

        .timer-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border-color: #b45309;
            animation: pulse-warning 2s infinite;
        }

        .timer-urgent {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border-color: #b91c1c;
            animation: pulse-urgent 1s infinite;
        }

        /* æ¸¸æˆæŒ‰é’® */
        .game-btn {
            margin: 0 auto;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 1.125rem;
            transition: all 0.2s;
            touch-action: manipulation;
            user-select: none;
            min-height: 52px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            border: none;
            cursor: pointer;
        }

        .game-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .game-btn:active {
            transform: translateY(0);
        }

        /* ç»“æœå¼¹çª—æ ·å¼ */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }

        .result-modal.hidden {
            display: none;
        }

        .result-content {
            background: white;
            border-radius: 1rem;
            padding: 2.5rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            font-size: 1.25rem;
        }

        .result-content h3 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }

        .result-content .text-sm {
            font-size: 1.125rem;
        }

        .result-content .text-xs {
            font-size: 1rem;
        }

        /* å¸®åŠ©æŒ‰é’® */
        .help-btn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .help-btn:hover, .help-btn:active {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
        }

        /* è§„åˆ™å¼¹çª— */
        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 0.5rem;
        }

        .rules-content {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 95vh;
            overflow-y: auto;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.2s;
            touch-action: manipulation;
        }

        .close-btn:hover, .close-btn:active {
            background: #e5e7eb;
        }

        .rules-title {
            text-align: center;
            margin-bottom: 1.5rem;
            padding-right: 2.5rem;
        }

        .rules-title h2 {
            font-size: 2rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 0.5rem;
        }

        .rules-title p {
            color: #6b7280;
            font-size: 1.125rem;
        }

        .rules-section {
            margin-bottom: 1.5rem;
        }

        .rules-section h3 {
            font-size: 1.25rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 0.75rem;
        }

        .rules-section p {
            color: #4b5563;
            font-size: 1.125rem;
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }

        .rules-section ul {
            color: #4b5563;
            font-size: 1.125rem;
            margin: 0;
            padding-left: 1.5rem;
            line-height: 1.6;
        }

        .rules-section li {
            margin-bottom: 0.5rem;
        }

        .rules-start-btn {
            text-align: center;
            margin-top: 1.5rem;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        

        /* æ ‡é¢˜åŒºåŸŸ */
        .game-title {
            text-align: center;
            padding: 1rem 0.5rem 0.5rem;
        }

        .game-title h1 {
            font-size: 2.25rem;
            font-weight: bold;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
        }

        .result-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: center;
        }

        .result-actions .game-btn {
            flex: 1;
            max-width: 200px;
        }
        .difficulty-select {
            background: transparent;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            font-size: 1rem;
            color: #6b7280;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
        }

        .difficulty-select:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }

        .difficulty-select:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 1px #3b82f6;
        }
        
        @media (max-width: 768px) {
            .game-title h1 {
                font-size: 2rem;
            }
            
            .counting-item {
                padding: 0.5rem;
                min-height: 45px;
            }
            
            .shape-icon {
                width: 30px;
                height: 30px;
                margin-right: 0.5rem;
            }
            
            .shape-label {
                font-size: 0.875rem;
            }
        }

        @media (max-width: 480px) {
            .game-title h1 {
                font-size: 1.75rem;
            }
            
            .rules-content {
                padding: 1.5rem;
            }
            
            .result-content {
                padding: 2rem;
                font-size: 1.125rem;
            }
            
            .game-btn {
                font-size: 1rem;
                padding: 0.875rem 1.25rem;
            }
        }

        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes pulse-urgent {
            0%, 100% { transform: scale(1); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); }
            50% { transform: scale(1.1); box-shadow: 0 4px 16px rgba(220, 38, 38, 0.3); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- æ¸¸æˆä¸»ä½“ -->
        <div class="flex-1 px-2 pb-2">
            <div class="game-grid grid grid-cols-1 lg:grid-cols-2 gap-4 h-full">
                <!-- æ¸¸æˆç”»å¸ƒ -->
                <div class="game-section p-3">
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-xl font-semibold text-gray-800">æ•°ä¸€æ•°æ¯ç§å›¾å½¢çš„æ•°é‡</h2>
                        <div id="gameTimer" class="timer-display timer-normal">05:00</div>
                        <button id="newGame" class="game-btn bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white shadow-md">
                            ğŸ² æ–°æ¸¸æˆ
                        </button>
                    </div>
                    <div id="canvas" class="canvas-container w-full bg-white" style="height: calc(100% - 120px); min-height: 200px;"></div>
                    <!-- éš¾åº¦é€‰æ‹©åŒºåŸŸ -->
                    <div class="mt-2 flex justify-start">
                        <div class="flex items-center gap-2 text-sm text-gray-500">
                            <span class="text-base">éš¾åº¦:</span>
                            <select id="difficultySelect" class="difficulty-select">
                                <option value="1">ç®€å•</option>
                                <option value="2">ä¸­ç­‰</option>
                                <option value="3">å›°éš¾</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- è®¡æ•°åŒºåŸŸ -->
                <div class="game-section p-3 flex flex-col">
                    <h2 class="text-xl font-semibold mb-3 text-gray-800">è¾“å…¥æ¯ä¸ªå›¾å½¢çš„æ•°é‡</h2>
                    <div id="countingGrid" class="counting-grid grid gap-2 flex-1 overflow-y-auto pr-1"></div>
                    <div class="mt-3 flex gap-2 flex-wrap">
                        <button id="checkAnswers" class="game-btn bg-green-500 hover:bg-green-600 text-white shadow-md flex-1 min-w-0">
                            âœ… æ£€æŸ¥ç­”æ¡ˆ
                        </button>
                        <button id="clearInputs" class="game-btn bg-gray-500 hover:bg-gray-600 text-white shadow-md flex-1 min-w-0">
                            ğŸ—‘ï¸ æ¸…ç©º
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- å¸®åŠ©æŒ‰é’® -->
    <div class="help-btn" onclick="showRules()">
        â“
    </div>

    <!-- è§„åˆ™å¼¹çª— -->
    <div id="rulesModal" class="rules-modal">
        <div class="rules-content">
            <div class="close-btn" onclick="hideRules()">âœ•</div>
            <div class="rules-title">
                <h2>ğŸ”º å¯»å®å¤§å¸ˆ</h2>
            </div>
            
            <div class="rules-sections">
                <div class="rules-section">
                    <h3>ğŸ® æ¸¸æˆç©æ³•</h3>
                    <p>è§‚å¯Ÿç”»å¸ƒä¸­çš„å„ç§å‡ ä½•å›¾å½¢ï¼Œæ•°ä¸€æ•°æ¯ç§å½¢çŠ¶å’Œé¢œè‰²ç»„åˆçš„æ•°é‡ã€‚</p>
                </div>
                
                <div class="rules-section">
                    <h3>ğŸ“ æ“ä½œæ–¹æ³•</h3>
                    <p>åœ¨å³ä¾§é¢æ¿è¾“å…¥æ¯ç§å›¾å½¢çš„æ•°é‡ã€‚æ³¨æ„ï¼šç›¸åŒå½¢çŠ¶ä½†ä¸åŒé¢œè‰²çš„å›¾å½¢éœ€è¦åˆ†åˆ«ç»Ÿè®¡ã€‚</p>
                </div>
            </div>
            <div class="rules-start-btn">
                <button onclick="hideRules(); startNewGame();" class="game-btn bg-blue-500 text-white hover:bg-blue-600 transition-colors px-8 py-3 text-lg font-bold">
                    å¼€å§‹æ¸¸æˆ
                </button>
            </div>
        </div>
    </div>

    <!-- ç»“æœå¼¹çª— -->
    <div id="resultModal" class="result-modal hidden">
        <div class="result-content">
            <div id="resultContent"></div>
            <div class="result-actions">
                <button id="playAgain" class="game-btn bg-blue-500 hover:bg-blue-600 text-white">
                    ğŸ² å†æ¬¡æ¸¸æˆ
                </button>
                <button id="finishGame" class="game-btn bg-green-500 hover:bg-green-600 text-white">
                    âœ… ç»“ç®—
                </button>
            </div>
        </div>
    </div>

    <script>
        // SVGå½¢çŠ¶æ•°æ®æ•°ç»„
        const shapes_SVG = [
            {
                type: 'rectangle',
                name: 'çŸ©å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 70" xmlns="http://www.w3.org/2000/svg">
                        <rect x="5" y="5" width="90" height="60" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.43 // width/height
            },
            {
                type: 'square',
                name: 'æ­£æ–¹å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <rect x="5" y="5" width="90" height="90" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.0
            },
            {
                type: 'circle',
                name: 'åœ†å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.0
            },
            {
                type: 'equilateral-triangle',
                name: 'ç­‰è¾¹ä¸‰è§’å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 87" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="50,5 95,82 5,82" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.15
            },
            {
                type: 'right-triangle',
                name: 'ç›´è§’ä¸‰è§’å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="5,95 5,5 95,95" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.0
            },
            {
                type: 'triangle-30-60-90',
                name: '30-60-90åº¦ä¸‰è§’å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 87" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="5,82 35,5 95,82" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.15
            },
            {
                type: 'hexagon',
                name: 'å…­è¾¹å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 87" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="25,5 75,5 95,43.5 75,82 25,82 5,43.5" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.15
            },
            {
                type: 'pentagon',
                name: 'äº”è¾¹å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 95" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="50,5 95,35 80,90 20,90 5,35" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.05
            },
            {
                type: 'diamond',
                name: 'è±å½¢',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="50,5 95,50 50,95 5,50" fill="none" stroke="currentColor" stroke-width="3"/>
                      </svg>`,
                aspectRatio: 1.0
            },
            {
                type: 'star',
                name: 'äº”è§’æ˜Ÿ',
                svg: `<svg width="100%" height="100%" viewBox="0 0 100 95" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="50,5 61,35 95,35 68,57 79,90 50,70 21,90 32,57 5,35 39,35" fill="none" stroke="currentColor" stroke-width="2"/>
                      </svg>`,
                aspectRatio: 1.05
            }
        ];

        // æ·»åŠ å…¨å±€å˜é‡
        let game_config = '';
        let highestScore = 0;
        let difficulty = 1;
        let gameInstance = null;
        let gameTimeLimit = 300;
        let timeLeft = 0;
        let gameTimer = null;

        // æ˜¾ç¤ºè§„åˆ™
        function showRules() {
            document.getElementById('rulesModal').style.display = 'flex';
        }

        // éšè—è§„åˆ™
        function hideRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        // ä»å¼¹çª—å¼€å§‹æ¸¸æˆ
        function startNewGame() {
            if (gameInstance) {
                gameInstance.initializeGame();
            }
        }

        // æ·»åŠ æ¶ˆæ¯ç›‘å¬å™¨
        window.addEventListener('message', function (e) {
            switch (e.data.type) {
                case 'setGameConfig':
                    game_config = e.data.data
                    updateGameConfig(game_config);
                    break;
                case 'getGameStats':
                    window.parent.postMessage({ 
                        type: 'gameStats', 
                        data: {
                            score: highestScore,
                            difficulty: difficulty
                        }
                    }, '*');
                    break;
            }
        });

        class ShapeCountingGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.shapes = shapes_SVG; // ä½¿ç”¨SVGæ•°ç»„
                this.colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#f97316', '#06b6d4', '#84cc16', '#ec4899', '#6366f1'];
                this.gameShapes = [];
                this.correctCounts = {};
                this.shapeColorCombinations = new Map();
                this.currentScore = 0;
                this.gameStartTime = null;
                this.gameInProgress = false;
                
                // é‡å æ§åˆ¶å‚æ•°
                this.overlapPercentage = 0.5;
                this.overlapIntensity = 0.3;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('newGame').addEventListener('click', () => this.initializeGame());
                document.getElementById('checkAnswers').addEventListener('click', () => this.checkAnswers());
                document.getElementById('clearInputs').addEventListener('click', () => this.clearInputs());
                
                // æ·»åŠ éš¾åº¦é€‰æ‹©å™¨äº‹ä»¶ç›‘å¬
                document.getElementById('difficultySelect').addEventListener('change', (e) => {
                    difficulty = parseInt(e.target.value);
                    console.log(`éš¾åº¦å·²åˆ‡æ¢åˆ°: ${difficulty}`);
                    this.initializeGame(); // ç«‹å³é‡æ–°å¼€å§‹æ¸¸æˆ
                });
                
                document.getElementById('playAgain').addEventListener('click', () => this.playAgain());
                document.getElementById('finishGame').addEventListener('click', () => this.finishGame());
            }

            initializeGame() {
                // åŒæ­¥éš¾åº¦é€‰æ‹©å™¨çš„å€¼
                document.getElementById('difficultySelect').value = difficulty;
                
                this.canvas.innerHTML = '';
                this.gameShapes = [];
                this.correctCounts = {};
                this.shapeColorCombinations.clear();
                this.gameInProgress = true;
                this.gameStartTime = Date.now();

                // æ ¹æ®éš¾åº¦è°ƒæ•´æ¸¸æˆå‚æ•°
                let shapeTypeCount, colorCount, minCount, maxCount;
                switch (difficulty) {
                    case 3: // å›°éš¾
                        shapeTypeCount = 6;
                        colorCount = 6; 
                        minCount = 3;
                        maxCount = 8;
                        gameTimeLimit = 180;
                        this.overlapPercentage = 0.7;
                        this.overlapIntensity = 0.5;
                        break;
                    case 2: // ä¸­ç­‰
                        shapeTypeCount = 5;
                        colorCount = 4;
                        minCount = 2;
                        maxCount = 6;
                        gameTimeLimit = 240;
                        this.overlapPercentage = 0.5;
                        this.overlapIntensity = 0.3;
                        break;
                    default: // ç®€å•
                        shapeTypeCount = 4;
                        colorCount = 3;
                        minCount = 1;
                        maxCount = 4;
                        gameTimeLimit = 300;
                        this.overlapPercentage = 0.3;
                        this.overlapIntensity = 0.2;
                        break;
                }

                this.startTimer();

                // é€‰æ‹©è¦ä½¿ç”¨çš„å›¾å½¢ç±»å‹å’Œé¢œè‰²
                const selectedShapes = this.shapes.slice(0, shapeTypeCount);
                const selectedColors = this.colors.slice(0, colorCount);
                
                // ä¸ºæ¯ç§å½¢çŠ¶-é¢œè‰²ç»„åˆé¢„å®šä¹‰å›ºå®šå°ºå¯¸
                this.generateShapeColorCombinations(selectedShapes, selectedColors);
                
                // ç”Ÿæˆæ¯ç§ç»„åˆçš„æ•°é‡
                this.generateCombinationCounts(minCount, maxCount);
                
                // åˆ›å»ºæ‰€æœ‰å›¾å½¢
                this.createAllShapes();
                this.applyOverlapAlgorithm();
                this.createCountingGrid();

                window.parent.postMessage({ type: 'gameStarted' }, '*');
            }

            generateShapeColorCombinations(shapes, colors) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const canvasWidth = canvasRect.width;
                
                // è®¡ç®—åŸºç¡€å°ºå¯¸ï¼šcanvaså®½åº¦çš„5%-20%
                const minSize = canvasWidth * 0.05;
                const maxSize = canvasWidth * 0.3;
                
                shapes.forEach(shape => {
                    colors.forEach(color => {
                        const key = `${shape.type}-${color}`;
                        // ä¸ºæ¯ç§å½¢çŠ¶-é¢œè‰²ç»„åˆç”Ÿæˆå›ºå®šå°ºå¯¸
                        const size = Math.random() * (maxSize - minSize) + minSize;
                        this.shapeColorCombinations.set(key, {
                            shape: shape,
                            color: color,
                            size: size
                        });
                    });
                });
            }

            generateCombinationCounts(minCount, maxCount) {
                // éšæœºé€‰æ‹©ä¸€éƒ¨åˆ†ç»„åˆæ¥ç”Ÿæˆ
                const allCombinations = Array.from(this.shapeColorCombinations.keys());
                const numCombinations = Math.floor(allCombinations.length * (0.4 + Math.random() * 0.4)); // 40%-80%çš„ç»„åˆ
                
                const selectedCombinations = [];
                while (selectedCombinations.length < numCombinations) {
                    const randomKey = allCombinations[Math.floor(Math.random() * allCombinations.length)];
                    if (!selectedCombinations.includes(randomKey)) {
                        selectedCombinations.push(randomKey);
                    }
                }
                
                selectedCombinations.forEach(key => {
                    const count = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
                    this.correctCounts[key] = count;
                });
            }

            createAllShapes() {
                Object.keys(this.correctCounts).forEach(key => {
                    const count = this.correctCounts[key];
                    const combination = this.shapeColorCombinations.get(key);
                    
                    for (let i = 0; i < count; i++) {
                        this.createShapeElement(combination.shape.type, combination.color, combination.size);
                    }
                });

                this.arrangeShapesRandomly();
            }

            createShapeElement(shapeType, color, size) {
                const shapeData = this.shapes.find(s => s.type === shapeType);
                if (!shapeData) {
                    console.error(`Shape type ${shapeType} not found`);
                    return;
                }

                const shapeElement = document.createElement('div');
                shapeElement.className = 'shape svg-shape';
                
                // è®¡ç®—å®é™…å°ºå¯¸ï¼ˆè€ƒè™‘å®½é«˜æ¯”ï¼‰
                const width = size;
                const height = size / shapeData.aspectRatio;
                
                shapeElement.style.width = width + 'px';
                shapeElement.style.height = height + 'px';
                shapeElement.style.color = color;
                shapeElement.style.position = 'absolute';
                shapeElement.style.cursor = 'pointer';
                shapeElement.style.userSelect = 'none';
                shapeElement.style.transition = 'all 0.3s ease';
                shapeElement.style.opacity = '0.9';
                
                // æ’å…¥SVG
                shapeElement.innerHTML = shapeData.svg;

                const rotation = Math.random() * 360;
                shapeElement.style.transform = `rotate(${rotation}deg)`;
                shapeElement.style.zIndex = Math.floor(Math.random() * 100);
                
                // æ·»åŠ äº¤äº’äº‹ä»¶
                shapeElement.addEventListener('mouseenter', () => {
                    shapeElement.style.transform = `rotate(${rotation}deg) scale(1.1)`;
                    shapeElement.style.zIndex = '1000';
                    shapeElement.style.opacity = '1';
                });
                
                shapeElement.addEventListener('mouseleave', () => {
                    shapeElement.style.transform = `rotate(${rotation}deg) scale(1)`;
                    shapeElement.style.zIndex = Math.floor(Math.random() * 100);
                    shapeElement.style.opacity = '0.9';
                });

                shapeElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    shapeElement.style.transform = `rotate(${rotation}deg) scale(1.2)`;
                    shapeElement.style.zIndex = '1000';
                    shapeElement.style.opacity = '1';
                });

                shapeElement.addEventListener('touchend', () => {
                    shapeElement.style.transform = `rotate(${rotation}deg) scale(1)`;
                    shapeElement.style.zIndex = Math.floor(Math.random() * 100);
                    shapeElement.style.opacity = '0.9';
                });
                
                this.canvas.appendChild(shapeElement);
                this.gameShapes.push({ 
                    type: shapeType, 
                    element: shapeElement, 
                    color: color,
                    size: size,
                    width: width,
                    height: height,
                    rotation: rotation,
                    x: 0, 
                    y: 0,
                    shouldOverlap: false
                });
            }

            arrangeShapesRandomly() {
                const canvasRect = this.canvas.getBoundingClientRect();
                const canvasWidth = canvasRect.width;
                const canvasHeight = canvasRect.height;
                
                this.gameShapes.forEach(item => {
                    const margin = 20;
                    const maxX = Math.max(margin, canvasWidth - item.width - margin);
                    const maxY = Math.max(margin, canvasHeight - item.height - margin);
                    
                    item.x = Math.random() * (maxX - margin) + margin;
                    item.y = Math.random() * (maxY - margin) + margin;
                    
                    item.element.style.left = item.x + 'px';
                    item.element.style.top = item.y + 'px';
                });
            }

            applyOverlapAlgorithm() {
                const canvasRect = this.canvas.getBoundingClientRect();
                const canvasWidth = canvasRect.width;
                const canvasHeight = canvasRect.height;
                
                const shapesToOverlap = this.selectShapesForOverlap();
                
                shapesToOverlap.forEach(targetShape => {
                    this.createOverlapForShape(targetShape, canvasWidth, canvasHeight);
                });
                
                this.updateZIndexes();
            }

            selectShapesForOverlap() {
                const shuffled = [...this.gameShapes].sort(() => Math.random() - 0.5);
                const overlapCount = Math.floor(this.gameShapes.length * this.overlapPercentage);
                const selected = shuffled.slice(0, overlapCount);
                
                selected.forEach(shape => {
                    shape.shouldOverlap = true;
                });
                
                return selected;
            }

            createOverlapForShape(targetShape, canvasWidth, canvasHeight) {
                const candidateShapes = this.gameShapes.filter(shape => 
                    shape !== targetShape && this.calculateDistance(targetShape, shape) < 150
                );
                
                if (candidateShapes.length === 0) {
                    const randomShape = this.gameShapes[Math.floor(Math.random() * this.gameShapes.length)];
                    if (randomShape !== targetShape) {
                        candidateShapes.push(randomShape);
                    }
                }
                
                if (candidateShapes.length > 0) {
                    const partnerShape = candidateShapes[Math.floor(Math.random() * candidateShapes.length)];
                    this.moveShapeToOverlap(targetShape, partnerShape, canvasWidth, canvasHeight);
                }
            }

            moveShapeToOverlap(shapeA, shapeB, canvasWidth, canvasHeight) {
                const overlapDistance = (Math.max(shapeA.width, shapeA.height) + Math.max(shapeB.width, shapeB.height)) * this.overlapIntensity * 0.5;
                
                const dx = shapeA.x - shapeB.x;
                const dy = shapeA.y - shapeB.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                
                const normalizedDx = dx / distance;
                const normalizedDy = dy / distance;
                
                const newX = shapeB.x + normalizedDx * overlapDistance;
                const newY = shapeB.y + normalizedDy * overlapDistance;
                
                const margin = 20;
                shapeA.x = Math.max(margin, Math.min(newX, canvasWidth - shapeA.width - margin));
                shapeA.y = Math.max(margin, Math.min(newY, canvasHeight - shapeA.height - margin));
                
                shapeA.element.style.left = shapeA.x + 'px';
                shapeA.element.style.top = shapeA.y + 'px';
            }

            calculateDistance(shapeA, shapeB) {
                const dx = shapeA.x - shapeB.x;
                const dy = shapeA.y - shapeB.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            updateZIndexes() {
                this.gameShapes.forEach(shape => {
                    if (shape.shouldOverlap) {
                        shape.element.style.zIndex = Math.floor(Math.random() * 50) + 50;
                    } else {
                        shape.element.style.zIndex = Math.floor(Math.random() * 50);
                    }
                });
            }

            createCountingGrid() {
                const countingGrid = document.getElementById('countingGrid');
                countingGrid.innerHTML = '';
                
                const usedCombinations = Object.keys(this.correctCounts);
                
                usedCombinations.forEach(key => {
                    const combination = this.shapeColorCombinations.get(key);
                    const shapeData = this.shapes.find(s => s.type === combination.shape.type);
                    
                    const card = document.createElement('div');
                    card.className = 'count-controls';
                    
                    card.innerHTML = `
                        <div class="count-card-icon" style="color: ${combination.color}">
                            ${shapeData.svg}
                        </div>
                        <div class="count-input-row">
                            <button class="count-btn" onclick="adjustCount('${key}', -1)">-</button>
                            <div class="count-display" data-shape="${key}">0</div>
                            <button class="count-btn plus" onclick="adjustCount('${key}', 1)">+</button>
                        </div>
                    `;
                    
                    countingGrid.appendChild(card);
                });
            }

            startTimer() {
                if (gameTimer) {
                    clearInterval(gameTimer);
                }

                timeLeft = gameTimeLimit;
                this.updateTimerDisplay();

                gameTimer = setInterval(() => {
                    timeLeft--;
                    this.updateTimerDisplay();

                    if (timeLeft <= 0) {
                        this.timeUp();
                    }
                }, 1000);
            }

            updateTimerDisplay() {
                const timerElement = document.getElementById('gameTimer');
                if (!timerElement) return;

                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                timerElement.textContent = timeString;
                
                if (timeLeft <= 30) {
                    timerElement.className = 'timer-display timer-urgent';
                } else if (timeLeft <= 60) {
                    timerElement.className = 'timer-display timer-warning';
                } else {
                    timerElement.className = 'timer-display timer-normal';
                }
            }

            timeUp() {
                if (!this.gameInProgress) return;
                this.checkAnswers(true);
            }

            updateGameConfig(config) {
                try {
                    let configObj;
                    if (typeof config === 'string') {
                        configObj = JSON.parse(config);
                    } else {
                        configObj = config;
                    }
                    
                    if (configObj.difficulty) {
                        difficulty = parseInt(configObj.difficulty) || 1;
                    }
                    
                    if (configObj.overlapPercentage !== undefined) {
                        this.overlapPercentage = Math.max(0, Math.min(1, parseFloat(configObj.overlapPercentage)));
                    }
                    
                    if (configObj.overlapIntensity !== undefined) {
                        this.overlapIntensity = Math.max(0, Math.min(1, parseFloat(configObj.overlapIntensity)));
                    }
                    
                    console.log(`æ¸¸æˆé…ç½®å·²æ›´æ–°ï¼Œéš¾åº¦: ${difficulty}, é‡å æ¯”ä¾‹: ${this.overlapPercentage}, é‡å å¼ºåº¦: ${this.overlapIntensity}`);
                    
                } catch (error) {
                    console.warn('è§£ææ¸¸æˆé…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', error);
                    difficulty = 1;
                    this.overlapPercentage = 0.3;
                    this.overlapIntensity = 0.2;
                }
            }

            checkAnswers(isAutoSubmit = false) {
                if (!this.gameInProgress) return;
                
                this.gameInProgress = false;
                clearInterval(gameTimer);

                const timeTaken = Math.floor((Date.now() - this.gameStartTime) / 1000);
                const displays = document.querySelectorAll('.count-display');
                let correct = 0;
                let total = 0;
                let results = [];

                displays.forEach(display => {
                    const shapeKey = display.dataset.shape;
                    const userAnswer = parseInt(display.textContent) || 0;
                    const correctAnswer = this.correctCounts[shapeKey];
                    const combination = this.shapeColorCombinations.get(shapeKey);
                    const shapeName = combination.shape.name;
                    
                    total++;
                    if (userAnswer === correctAnswer) {
                        correct++;
                        display.style.backgroundColor = '#dcfce7';
                        display.style.borderRadius = '0.5rem';
                        display.style.padding = '0.25rem';
                    } else {
                        display.style.backgroundColor = '#fef2f2';
                        display.style.borderRadius = '0.5rem';
                        display.style.padding = '0.25rem';
                        results.push(`${shapeName}: æ­£ç¡®ç­”æ¡ˆæ˜¯ ${correctAnswer}ï¼Œæ‚¨çš„ç­”æ¡ˆæ˜¯ ${userAnswer}`);
                    }
                });

                this.currentScore = Math.round((correct / total) * 100);
                
                if (this.currentScore > highestScore) {
                    highestScore = this.currentScore;
                }

                this.showResult(correct, total, results, isAutoSubmit, timeTaken);
            }

            clearInputs() {
                const displays = document.querySelectorAll('.count-display');
                
                displays.forEach(display => {
                    display.textContent = '0';
                    display.style.backgroundColor = '';
                    display.style.borderRadius = '';
                    display.style.padding = '';
                });
            }

            showResult(correct, total, errors, isAutoSubmit = false, timeTaken = 0) {
                const percentage = Math.round((correct / total) * 100);
                
                let resultHTML = `
                    <div class="text-center mb-4">
                        <h3 class="text-xl font-bold text-gray-800 mb-2">ğŸ¯ æ¸¸æˆç»“æœ</h3>
                `;

                const minutes = Math.floor(timeTaken / 60);
                const seconds = timeTaken % 60;
                resultHTML += `<div class="text-sm text-gray-600 mb-2">â±ï¸ ç”¨æ—¶ï¼š${minutes}åˆ†${seconds}ç§’</div>`;

                if (isAutoSubmit) {
                    resultHTML += `<div class="text-red-600 font-bold mb-2">â° æ—¶é—´åˆ°ï¼è‡ªåŠ¨æäº¤ç­”æ¡ˆ</div>`;
                }

                if (highestScore > this.currentScore) {
                    resultHTML += `<div class="text-sm text-gray-600 mb-2">å†å²æœ€é«˜åˆ†: ${highestScore}</div>`;
                } else if (this.currentScore > 0) {
                    resultHTML += `<div class="text-sm text-green-600 mb-2">ğŸ‰ æ–°çºªå½•ï¼æœ€é«˜åˆ†: ${highestScore}</div>`;
                }

                if (percentage === 100) {
                    resultHTML += `<div class="text-green-700 font-semibold">ğŸ‰ å®Œç¾ï¼å…¨éƒ¨ç­”å¯¹äº†ï¼</div>`;
                } else if (percentage >= 80) {
                    resultHTML += `<div class="text-blue-700 font-semibold">ğŸ‘ åšå¾—å¾ˆå¥½ï¼</div>`;
                } else if (percentage >= 60) {
                    resultHTML += `<div class="text-yellow-700 font-semibold">ğŸ’ª ç»§ç»­åŠªåŠ›ï¼</div>`;
                }

                resultHTML += `</div>`;

                if (errors.length > 0) {
                    resultHTML += `
                        <div class="text-sm">
                            <p class="font-semibold mb-2 text-red-600">âŒ éœ€è¦æ”¹æ­£çš„ç­”æ¡ˆï¼š</p>
                            <div class="max-h-40 overflow-y-auto bg-gray-50 p-3 rounded-lg">
                                <ul class="space-y-1">
                                    ${errors.map(error => `<li class="text-xs text-gray-700">â€¢ ${error}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                }

                document.getElementById('resultContent').innerHTML = resultHTML;
                document.getElementById('resultModal').classList.remove('hidden');
            }

            playAgain() {
                document.getElementById('resultModal').classList.add('hidden');
                this.initializeGame();
            }

            finishGame() {
                document.getElementById('resultModal').classList.add('hidden');
                
                window.parent.postMessage({ 
                    type: 'gameFinished', 
                    data: {
                        score: this.currentScore,
                        highestScore: highestScore,
                        difficulty: difficulty
                    }
                }, '*');
            }
        }

        // å…¨å±€å‡½æ•°
        function adjustCount(shapeKey, delta) {
            const display = document.querySelector(`[data-shape="${shapeKey}"]`);
            if (display) {
                const currentCount = parseInt(display.textContent) || 0;
                const newCount = Math.max(0, currentCount + delta);
                display.textContent = newCount;
                
                // æ¸…é™¤ä¹‹å‰çš„èƒŒæ™¯è‰²
                display.style.backgroundColor = '';
                display.style.borderRadius = '';
                display.style.padding = '';
            }
        }

        function updateGameConfig(config) {
            if (gameInstance) {
                gameInstance.updateGameConfig(config);
            }
        }

        // æ˜¾ç¤ºè§„åˆ™å¼¹çª—
        showRules();
        
        // åˆ›å»ºæ¸¸æˆå®ä¾‹
        gameInstance = new ShapeCountingGame();
    </script>
</body>
</html>
