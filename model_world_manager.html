<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>model world</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.10"></script>
    <style>
      .drawer {
        transform: translateY(100%);
        transition: transform 0.3s ease-in-out;
      }
      .drawer.open {
        transform: translateY(0);
      }
      .model-card {
        transition: all 0.3s ease;
      }
      .model-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .btn-primary:hover {
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
      }
      /* è‡ªå®šä¹‰ç¡®è®¤å¼¹æ¡†æ ·å¼ */
      #customConfirmModal {
        backdrop-filter: blur(4px);
      }
      #customConfirmModal.show {
        display: flex !important;
      }
      #customConfirmModal.show .bg-white {
        transform: scale(1);
      }
      #customConfirmModal .bg-white {
        animation: modalSlideIn 0.3s ease-out;
      }
      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
      .btn-secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }
      .btn-secondary:hover {
        background: linear-gradient(135deg, #e081e9 0%, #e3455a 100%);
      }
      /* Tabæ ·å¼ */
      .tab-btn {
        color: #6b7280;
        background: transparent;
      }
      .tab-btn:hover {
        color: #374151;
        background: rgba(255, 255, 255, 0.5);
      }
      .tab-btn.active {
        color: #1f2937;
        background: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .loading {
        display: inline-block;
        width: 40px;
        height: 40px;
        border: 4px solid #f3f4f6;
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
      }
      .loading-small {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      .loading-dots {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 20px;
      }

      .loading-dots div {
        position: absolute;
        top: 50%;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #3b82f6;
        animation: loading-dots 1.2s linear infinite;
        transform: translateY(-50%);
      }

      .loading-dots div:nth-child(1) {
        left: 8px;
        animation-delay: 0s;
      }
      .loading-dots div:nth-child(2) {
        left: 32px;
        animation-delay: -0.4s;
      }
      .loading-dots div:nth-child(3) {
        left: 56px;
        animation-delay: -0.8s;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes loading-dots {
        0%,
        80%,
        100% {
          transform: translateY(-50%) scale(0);
          opacity: 0.5;
        }
        40% {
          transform: translateY(-50%) scale(1);
          opacity: 1;
        }
      }
      /* Loading overlay for better UX */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
      }

      /* Enhanced loading animations */
      @keyframes shimmer {
        0% {
          background-position: -200px 0;
        }
        100% {
          background-position: calc(200px + 100%) 0;
        }
      }

      @keyframes pulse-glow {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.02);
        }
      }

      .skeleton-card {
        background: #f3f4f6;
        border-radius: 8px;
        padding: 16px;
        position: relative;
        overflow: hidden;
        animation: pulse-glow 2s ease-in-out infinite;
        border: 1px solid #e5e7eb;
      }

      .skeleton-card::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-image: linear-gradient(90deg, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0.6) 20%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0.6) 80%, rgba(255, 255, 255, 0) 100%);
        animation: shimmer 2.5s infinite;
      }

      .skeleton-line {
        height: 16px;
        background: #e5e7eb;
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .skeleton-line.short {
        width: 60%;
      }

      .skeleton-line.medium {
        width: 80%;
      }

      .skeleton-line.long {
        width: 100%;
      }

      .skeleton-button {
        height: 32px;
        background: #e5e7eb;
        border-radius: 6px;
        margin: 4px;
        flex: 1;
      }

      /* Loading text animations */
      .loading-text-animated {
        animation: loading-text-fade 3s ease-in-out infinite;
      }

      @keyframes loading-text-fade {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      /* Progress bar for loading */
      .loading-progress {
        width: 100%;
        max-width: 300px;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
        margin: 16px auto;
      }

      .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3b82f6, #6366f1);
        border-radius: 2px;
        animation: loading-progress 2s ease-in-out infinite;
      }

      @keyframes loading-progress {
        0% {
          transform: translateX(-100%);
        }
        50% {
          transform: translateX(0%);
        }
        100% {
          transform: translateX(100%);
        }
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen">
    <!-- ä¸»é¡µé¢ -->
    <div class="w-full">
      <!-- å¤´éƒ¨åŒºåŸŸ -->
      <div class="bg-white shadow-[0_1px_3px_0_rgba(0,0,0,0.1)] px-6 py-4 mb-6 w-full">
        <!-- æœç´¢å’Œæ“ä½œåŒºåŸŸ -->
        <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
          <!-- æœç´¢æ¡† -->
          <div class="flex gap-2 items-center">
            <!-- Tabåˆ‡æ¢æŒ‰é’® -->
            <div class="flex bg-gray-100 rounded-lg p-1">
              <button id="allModelsBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn active">ğŸ“‹ å…¨éƒ¨</button>
              <button id="likeRecordBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn">â¤ï¸ æ”¶è—</button>
              <button id="downloadRecordBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn">ğŸ“¥ å†å²</button>
            </div>
            <input type="text" id="searchInput" placeholder="æœç´¢å­˜æ¡£ä¸–ç•Œ..." class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-48" />
            <button id="searchBtn" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">ğŸ”</button>
          </div>

          <!-- æ“ä½œæŒ‰é’® -->
          <div class="flex gap-2 flex-nowrap">
            <button
              id="uploadBtn"
              class="px-6 py-2 bg-gradient-to-r from-purple-500 to-blue-500 text-white rounded-lg hover:from-purple-600 hover:to-blue-600 transition-all shadow-lg font-semibold whitespace-nowrap"
            >
              â˜ï¸ æˆ‘çš„äº‘å­˜æ¡£
            </button>
          </div>
        </div>
      </div>
      <!-- å­˜æ¡£åˆ—è¡¨åŒºåŸŸ -->
      <div class="px-6">
        <!-- æ’åºé€‰æ‹©å™¨ -->
        <div class="flex justify-between items-center mb-4">
          <div class="flex items-center gap-2">
            <span class="text-sm text-gray-600">æ’åºï¼š</span>
            <button id="sortByTime" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">ä¿®æ”¹æ—¶é—´</button>
            <button id="sortByLikes" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">æ”¶è—æ•°</button>
            <button id="sortByDownloads" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">ä¸‹è½½æ•°</button>
          </div>
        </div>
        <!-- åŠ è½½çŠ¶æ€ -->
        <div id="loadingState" class="text-center py-12 hidden">
          <div class="loading mx-auto mb-4"></div>
          <div class="loading-dots mx-auto mb-4">
            <div></div>
            <div></div>
            <div></div>
          </div>
          <p id="loadingText" class="text-gray-600 text-lg font-medium">æ­£åœ¨åŠ è½½å­˜æ¡£...</p>
          <p class="text-gray-400 text-sm mt-2">è¯·ç¨å€™ï¼Œæ­£åœ¨è·å–æœ€æ–°æ•°æ®</p>

          <!-- Enhanced loading animation with skeleton cards -->
          <div id="loadingSkeletons" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
            <!-- Skeleton cards will be generated by JavaScript -->
          </div>
        </div>

        <!-- å­˜æ¡£åˆ—è¡¨å®¹å™¨ -->
        <div class="relative">
          <!-- åŠ è½½æ›´å¤šçš„è¦†ç›–å±‚ -->
          <div id="loadingMoreOverlay" class="loading-overlay hidden">
            <div class="bg-white rounded-lg p-6 shadow-lg text-center">
              <div class="loading mx-auto mb-3"></div>
              <p class="text-gray-600 font-medium">åŠ è½½æ›´å¤šå­˜æ¡£...</p>
            </div>
          </div>

          <!-- å­˜æ¡£åˆ—è¡¨ -->
          <div id="modelList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- å­˜æ¡£å¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>

        <!-- ç©ºçŠ¶æ€ -->
        <div id="emptyState" class="text-center py-12 hidden">
          <div class="text-gray-400 text-6xl mb-4">ğŸ“¦</div>
          <p class="text-gray-500 text-lg">æš‚æ— å­˜æ¡£æ•°æ®</p>
        </div>
      </div>
    </div>

    <!-- ä¸Šä¼ åˆ†äº«æŠ½å±‰ -->
    <div id="uploadDrawer" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden">
      <div class="drawer fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl h-[60vh] overflow-hidden">
        <div class="px-6 py-4 h-full flex flex-col">
          <!-- æŠ½å±‰å¤´éƒ¨ -->
          <div class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold text-gray-800">æˆ‘çš„äº‘å­˜æ¡£</h2>
            <button id="closeDrawer" class="text-gray-500 hover:text-gray-700 text-3xl">Ã—</button>
          </div>
          <!-- ä¸ªäººå­˜æ¡£åˆ—è¡¨å®¹å™¨ -->
          <div class="flex-1 overflow-y-auto">
            <div id="personalModelList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <!-- ä¸ªäººå­˜æ¡£å¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>

            <!-- ä¸ªäººå­˜æ¡£ç©ºçŠ¶æ€ -->
            <div id="personalEmptyState" class="text-center py-8 hidden">
              <div class="text-gray-400 text-4xl mb-2">ğŸ“</div>
              <p class="text-gray-500">è¿˜æ²¡æœ‰ä¸Šä¼ ä»»ä½•å­˜æ¡£</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- è‡ªå®šä¹‰ç¡®è®¤å¼¹æ¡† -->
    <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
      <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4 transform transition-all duration-300 scale-95">
        <div class="text-center">
          <!-- å›¾æ ‡ -->
          <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
            <svg class="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"
              />
            </svg>
          </div>
          <!-- æ ‡é¢˜ -->
          <h3 class="text-lg font-medium text-gray-900 mb-2" id="confirmTitle">ç¡®è®¤åˆ é™¤</h3>
          <!-- å†…å®¹ -->
          <p class="text-sm text-gray-500 mb-6" id="confirmMessage">ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­˜æ¡£å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚</p>
          <!-- æŒ‰é’® -->
          <div class="flex gap-3 justify-center">
            <button
              id="confirmCancelBtn"
              class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
            >
              å–æ¶ˆ
            </button>
            <button
              id="confirmOkBtn"
              class="px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
            >
              ç¡®å®šåˆ é™¤
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- å­˜æ¡£ç¼–è¾‘æ¨¡æ€æ¡† -->
    <div id="editModal" class="fixed inset-0 bg-black bg-opacity-50 z-[70] hidden">
      <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
          <h3 class="text-lg font-semibold mb-4">ç¼–è¾‘å­˜æ¡£ä¿¡æ¯</h3>
          <form id="editForm">
            <input type="hidden" id="editModelId" />
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">å­˜æ¡£åç§°</label>
              <input type="text" id="editModelName" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" required />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">å­˜æ¡£URL</label>
              <input type="text" id="editModelUrl" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" readonly />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">å­˜æ¡£å¤§å°</label>
              <input type="url" id="editModelSize" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" readonly />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">æ ‡ç­¾</label>
              <input type="text" id="editModelTag" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" value="maisiAI" readonly />
            </div>
            <div class="flex gap-2">
              <button type="submit" class="flex-1 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">ğŸ’¾ä¿å­˜</button>
              <button type="button" id="cancelEdit" class="flex-1 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition-colors">âŒå–æ¶ˆ</button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <!-- ä¿å­˜å­˜æ¡£ç¡®è®¤å¼¹æ¡† -->
    <div id="saveConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 z-[75] hidden">
      <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
          <div class="text-center">
            <!-- å›¾æ ‡ -->
            <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100 mb-4">
              <svg class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
              </svg>
            </div>
            <!-- æ ‡é¢˜ -->
            <h3 class="text-lg font-medium text-gray-900 mb-2">ä¿å­˜å­˜æ¡£</h3>
            <!-- å†…å®¹ -->
            <div class="text-sm text-gray-600 mb-6">
              <p class="mb-3">ç¡®è®¤è¦ä¿å­˜å½“å‰æ¸¸æˆçŠ¶æ€åˆ°å­˜æ¡£å—ï¼Ÿ</p>
              <div class="bg-gray-50 rounded-lg p-4 text-left">
                <div class="space-y-2">
                  <div class="flex justify-between">
                    <span class="text-gray-500">å­˜æ¡£åç§°ï¼š</span>
                    <input type="text" id="saveConfirmName" class="text-gray-900 bg-transparent border-b border-gray-300 focus:border-blue-500 focus:outline-none text-right" readonly />
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-500">å­˜æ¡£URLï¼š</span>
                    <span id="saveConfirmUrl" class="text-gray-900 text-xs truncate max-w-[200px]">è·å–ä¸­...</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-500">æ–‡ä»¶å¤§å°ï¼š</span>
                    <span id="saveConfirmSize" class="text-gray-900">è·å–ä¸­...</span>
                  </div>
                </div>
              </div>
              <div class="mt-3 text-xs text-gray-500">
                <p>ğŸ’¡ åªèƒ½ä¿®æ”¹å­˜æ¡£åç§°ï¼ŒURLå’Œå¤§å°å°†è‡ªåŠ¨ä»å½“å‰æ¸¸æˆçŠ¶æ€è·å–</p>
              </div>
            </div>
            <!-- æŒ‰é’® -->
            <div class="flex gap-3 justify-center">
              <button
                id="saveConfirmCancelBtn"
                class="px-6 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
              >
                å–æ¶ˆ
              </button>
              <button
                id="saveConfirmOkBtn"
                class="px-6 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
              >
                <span class="flex items-center">
                  <span id="saveConfirmBtnText">ç¡®è®¤ä¿å­˜</span>
                  <div id="saveConfirmLoading" class="loading-small ml-2 hidden"></div>
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- é€šç”¨æ¶ˆæ¯å¼¹æ¡† -->
    <div id="messageToast" class="fixed top-4 right-4 z-[80] transform translate-x-full opacity-0 transition-all duration-300 ease-in-out pointer-events-none">
      <div class="bg-white border border-gray-200 rounded-lg shadow-lg p-4 min-w-[300px] max-w-[400px]">
        <div class="flex items-start space-x-3">
          <div id="toastIcon" class="flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center">
            <!-- å›¾æ ‡å°†é€šè¿‡JavaScriptåŠ¨æ€è®¾ç½® -->
          </div>
          <div class="flex-1">
            <p id="toastMessage" class="text-sm text-gray-800 font-medium"></p>
          </div>
          <button id="closeToast" class="flex-shrink-0 text-gray-400 hover:text-gray-600 transition-colors">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script>
      // Initialize SDK
      const sdk = new KeepworkSDK({
        timeout: 30000,
      });
      const maxHistory = 100;
      // APIé…ç½®
      const API_BASE = "https://api.keepwork.com/core/v0";
      const DEFAULT_TAG = "maisiAI";
      const pageName = "modelWorld";      // é¡µé¢çŠ¶æ€
      let USER_ID = 1; // ç¤ºä¾‹ç”¨æˆ·IDï¼Œå®é™…åº”ç”¨ä¸­åº”ä»ç™»å½•çŠ¶æ€è·å–
      let currentView = "all"; // 'all', 'liked', 'downloaded'
      let currentModels = [];
      let personalModels = [];
      let likeModels = [];
      let downloadModels = [];
      let currentTag = DEFAULT_TAG; // ä»URLè·å–å½“å‰æ ‡ç­¾
      let keepworkToken = "";
      let keepworkUserInfo = {};
      
      // ç¼“å­˜çš„æ”¶è—æ•°æ®
      let cachedLikedModels = null;
      let likedModelsLoading = false;

      // åˆ†é¡µå’Œæ’åºçŠ¶æ€
      let currentPage = 1;
      let perPage = 20;
      let isLoading = false;
      let hasMoreData = true;
      let currentSort = { field: "", order: "desc" }; // DOMå…ƒç´ 
      const elements = {
        searchInput: document.getElementById("searchInput"),
        searchBtn: document.getElementById("searchBtn"),
        allModelsBtn: document.getElementById("allModelsBtn"),
        uploadBtn: document.getElementById("uploadBtn"),
        likeRecordBtn: document.getElementById("likeRecordBtn"),
        downloadRecordBtn: document.getElementById("downloadRecordBtn"),
        modelList: document.getElementById("modelList"),
        loadingState: document.getElementById("loadingState"),
        loadingMoreOverlay: document.getElementById("loadingMoreOverlay"),
        emptyState: document.getElementById("emptyState"),
        sortByTime: document.getElementById("sortByTime"),
        sortByLikes: document.getElementById("sortByLikes"),
        sortByDownloads: document.getElementById("sortByDownloads"),
        uploadDrawer: document.getElementById("uploadDrawer"),
        closeDrawer: document.getElementById("closeDrawer"),
        personalModelList: document.getElementById("personalModelList"),
        personalEmptyState: document.getElementById("personalEmptyState"),
        editModal: document.getElementById("editModal"),
        editForm: document.getElementById("editForm"),
        cancelEdit: document.getElementById("cancelEdit"),
        messageToast: document.getElementById("messageToast"),
        toastIcon: document.getElementById("toastIcon"),
        toastMessage: document.getElementById("toastMessage"),
        closeToast: document.getElementById("closeToast"),
      };

      // é€šç”¨æ¶ˆæ¯å¼¹æ¡†å‡½æ•°
      function showToast(message, type = "info", duration = 2000) {
        const toast = elements.messageToast;
        const icon = elements.toastIcon;
        const messageEl = elements.toastMessage;

        // è®¾ç½®æ¶ˆæ¯å†…å®¹
        messageEl.textContent = message;

        // æ ¹æ®ç±»å‹è®¾ç½®å›¾æ ‡å’Œé¢œè‰²
        switch (type) {
          case "success":
            icon.innerHTML = "âœ…";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-green-100 text-green-600";
            break;
          case "error":
            icon.innerHTML = "âŒ";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-red-100 text-red-600";
            break;
          case "warning":
            icon.innerHTML = "âš ï¸";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-yellow-100 text-yellow-600";
            break;
          default: // info
            icon.innerHTML = "â„¹ï¸";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-blue-100 text-blue-600";
        }

        // æ˜¾ç¤ºå¼¹æ¡†
        toast.classList.remove("translate-x-full", "opacity-0", "pointer-events-none");
        toast.classList.add("translate-x-0", "opacity-100", "pointer-events-auto");

        // è‡ªåŠ¨éšè—
        if (duration > 0) {
          setTimeout(() => {
            hideToast();
          }, duration);
        }
      }

      // éšè—å¼¹æ¡†
      function hideToast() {
        const toast = elements.messageToast;
        toast.classList.remove("translate-x-0", "opacity-100", "pointer-events-auto");
        toast.classList.add("translate-x-full", "opacity-0", "pointer-events-none");
      }

      // è®¾ç½®æ´»è·ƒçš„tab
      function setActiveTab(activeTabId) {
        // ç§»é™¤æ‰€æœ‰tabçš„activeç±»
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        // ä¸ºå½“å‰tabæ·»åŠ activeç±»
        document.getElementById(activeTabId).classList.add("active");
      }

      // APIè°ƒç”¨å‡½æ•°
      async function apiCall(endpoint, options = {}, needToken = true) {
        try {
          // å‡†å¤‡headers
          let headers = {
            ...options.headers, // å…ˆå±•å¼€ä¼ å…¥çš„headers
          };
          if (options.body && !headers["Content-Type"] && !headers["content-type"]) {
            headers["Content-Type"] = "application/json";
          }
          if (needToken) {
            if (needToken) {
              headers["Authorization"] = `Bearer ${keepworkToken}`;
            }
          }

          const response = await fetch(`${API_BASE}${endpoint}`, {
            headers: headers,
            ...options,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // å°è¯•è§£æJSONï¼Œå¦‚æœå¤±è´¥åˆ™è¿”å›åŸå§‹æ–‡æœ¬
          const responseText = await response.text();
          try {
            return JSON.parse(responseText);
          } catch (jsonError) {
            return responseText;
          }
        } catch (error) {
          console.error("APIè°ƒç”¨å¤±è´¥:", error);
          showToast("ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•", "error");
          throw error;
        }
      }

      async function startUploadModel() {
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error("è·å–å½“å‰å­˜æ¡£URLè¶…æ—¶"));
          }, 5000);

          const handleMessage = (e) => {
            if (e.data && e.data.type === "setGameConfig" && e.data.data && e.data.data.type === "modelUrlResponse") {
              clearTimeout(timeout);
              // æ£€æŸ¥æ¨¡å‹URLæ˜¯å¦ä¸ºç©º
              window.removeEventListener("message", handleMessage);
              if (!e.data.data.modelUrl || e.data.data.result === false) {
                reject(new Error("è·å–å½“å‰å­˜æ¡£URLå¤±è´¥ï¼Œè¯·å…ˆè¿”å›æ¸¸æˆä¿å­˜å½“å‰å­˜æ¡£"));
                return;
              }
              resolve({
                modelUrl: e.data.data.modelUrl,
                size: e.data.data.size,
              });
            }
          };

          window.addEventListener("message", handleMessage);
          window.parent.postMessage({ type: "requestModelUrl" }, "*");
        });
      }

      // è·å–å­˜æ¡£åˆ—è¡¨
      async function loadModels(tag = null, userId = null, page = 1, append = false) {
        if (isLoading) return;
        isLoading = true;

        if (!append) {
          showLoading(true);
          currentPage = 1;
          hasMoreData = true;
        }

        try {
          // å¦‚æœæ²¡æœ‰ä¼ å…¥tagå‚æ•°ï¼Œä½¿ç”¨å½“å‰æ ‡ç­¾
          const tagToUse = tag || currentTag;
          const params = new URLSearchParams({
            tag: tagToUse,
            "x-page": page,
            "x-per-page": perPage,
          });

          if (userId) params.append("userId", userId);

          // æ·»åŠ æ’åºå‚æ•°
          if (currentSort.field) {
            params.append("x-order", `${currentSort.field}-${currentSort.order}`);
          }

          const result = await apiCall(`/mall/getModelsByTag?${params}`);
          const newModels = result?.rows || [];

          if (append) {
            currentModels = [...currentModels, ...newModels];
          } else {
            currentModels = newModels;
          }

          // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
          hasMoreData = newModels.length === perPage;
          currentPage = page;

          await renderModelList(currentModels, append);
        } catch (error) {
          if (!append) {
            showEmptyState();
          }
        } finally {
          isLoading = false;
          if (!append) {
            showLoading(false);
          }
        }
      }      // æ¸²æŸ“å­˜æ¡£åˆ—è¡¨
      async function renderModelList(models, append = false) {
        if (!models || models.length === 0) {
          if (!append) {
            showEmptyState();
          }
          return;
        }

        // è·å–æ”¶è—çŠ¶æ€æ•°æ®ï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡æ¸²æŸ“æˆ–éè¿½åŠ æ¨¡å¼æ—¶è·å–ï¼‰
        let likedModels = cachedLikedModels;
        if (!append || !cachedLikedModels) {
          likedModels = await loadLikedModelsCache();
        }

        if (append) {
          // è¿½åŠ æ¨¡å¼ï¼šåªæ·»åŠ æ–°çš„å­˜æ¡£å¡ç‰‡
          const newCards = models.slice(currentModels.length - (models.length - currentModels.length));
          const newCardsHtml = newCards.map((model) => createModelCard(model, likedModels)).join("");
          elements.modelList.insertAdjacentHTML("beforeend", newCardsHtml);
        } else {
          // æ›¿æ¢æ¨¡å¼ï¼šé‡æ–°æ¸²æŸ“æ‰€æœ‰å­˜æ¡£
          const cardsHtml = models.map((model) => createModelCard(model, likedModels)).join("");
          elements.modelList.innerHTML = cardsHtml;
        }        elements.emptyState.classList.add("hidden");
      }

      // åŠ è½½æ”¶è—æ¨¡å‹ç¼“å­˜
      async function loadLikedModelsCache() {
        if (likedModelsLoading) {
          // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
          while (likedModelsLoading) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          return cachedLikedModels || [];
        }

        if (cachedLikedModels !== null) {
          return cachedLikedModels;
        }

        likedModelsLoading = true;
        try {
          cachedLikedModels = (await sdk.personalPageStore.loadPageData(pageName, "liked")) || [];
          return cachedLikedModels;
        } catch (error) {
          console.error("Failed to load liked models:", error);
          cachedLikedModels = [];
          return [];
        } finally {
          likedModelsLoading = false;
        }
      }

      // åˆ·æ–°æ”¶è—ç¼“å­˜
      function refreshLikedModelsCache() {
        cachedLikedModels = null;
      }

      // æ›´æ–°å•ä¸ªå¡ç‰‡çš„æ”¶è—çŠ¶æ€
      function updateCardLikedStatus(modelId, isLiked) {
        const card = document.querySelector(`button[onclick="likeModel(${modelId})"]`);
        if (card) {
          if (isLiked) {
            card.className = "flex-1 py-2 bg-gray-100 text-gray-400 cursor-not-allowed rounded transition-colors text-sm";
            card.disabled = true;
            card.innerHTML = "â¤ï¸å·²æ”¶è—";
          } else {
            card.className = "flex-1 py-2 bg-red-50 text-red-600 hover:bg-red-100 rounded transition-colors text-sm";
            card.disabled = false;
            card.innerHTML = "â¤ï¸æ”¶è—";
          }
        }
      }

      // åˆ›å»ºå­˜æ¡£å¡ç‰‡
      function createModelCard(model, likedModels = []) {
        // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
        const isLiked = likedModels.some((likedModel) => likedModel.id === model.id);

        return `
                <div class="model-card bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="font-semibold text-gray-800 truncate flex-1">${model.name || "æœªå‘½åå­˜æ¡£"}</h3>
                        <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">#${model.id || "0"}</span>
                    </div>
                    
                    <div class="flex items-center justify-between text-sm text-gray-600 mb-4">
                        <div class="flex items-center gap-4">
                            <span class="flex items-center gap-1">
                                â¤ï¸ ${model.likes || 0}
                            </span>
                            <span class="flex items-center gap-1">
                                ğŸ“¥ ${model.downloads || 0}
                            </span>
                        </div>
                        <span class="text-xs text-gray-400">å¤§å°ï¼š${formatFileSize(model.size)}</span>
                    </div>
                    
                    <div class="flex gap-2">
                        <button 
                            onclick="likeModel(${model.id})" 
                            class="flex-1 py-2 ${isLiked ? "bg-gray-100 text-gray-400 cursor-not-allowed" : "bg-red-50 text-red-600 hover:bg-red-100"} rounded transition-colors text-sm"
                            ${isLiked ? "disabled" : ""}
                        >
                            ${isLiked ? "â¤ï¸å·²æ”¶è—" : "â¤ï¸æ”¶è—"}
                        </button>
                        <button 
                            onclick="downloadModel(${model.id})" 
                            class="flex-1 py-2 bg-green-50 text-green-600 rounded hover:bg-green-100 transition-colors text-sm"
                        >
                            ğŸ“¥ä¸‹è½½
                        </button>
                    </div>
                </div>
            `;
      }

      // åˆ›å»ºä¸ªäººå­˜æ¡£å¡ç‰‡
      function createPersonalModelCard(model) {
        return `
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 relative">
                    <!-- åˆ é™¤æŒ‰é’® - å³ä¸Šè§’ -->
                    <button 
                        onclick="confirmDeleteModel(${model.id})" 
                        class="absolute top-2 right-2 w-6 h-6 flex items-center justify-center text-red-500 hover:bg-red-100 rounded-full transition-colors text-sm"
                        title="åˆ é™¤æ¨¡å‹"
                    >
                        ğŸ—‘ï¸
                    </button>
                    
                    <div class="flex items-center justify-between mb-2 pr-8">
                        <div class="flex items-center gap-2 flex-1">
                            <h4 id="modelName_${model.id}" class="font-medium text-gray-800 truncate">${model.name || "æœªå‘½åå­˜æ¡£"}</h4>
                            <button 
                                onclick="editModelName(${model.id})" 
                                class="text-gray-400 hover:text-blue-500 transition-colors"
                                title="ç¼–è¾‘åç§°"
                            >
                                âœï¸
                            </button>
                        </div>
                        <span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded">#${model.id || "0"}</span>
                    </div>
                    
                    <!-- åç§°ç¼–è¾‘æ¡† - é»˜è®¤éšè— -->
                    <div id="editNameBox_${model.id}" class="mb-2 pr-8 hidden">
                        <div class="flex gap-2">
                            <input 
                                type="text" 
                                id="editNameInput_${model.id}" 
                                value="${model.name || "æœªå‘½åå­˜æ¡£"}"
                                class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="è¾“å…¥æ¨¡å‹åç§°"
                            >
                            <button 
                                onclick="saveModelName(${model.id})" 
                                class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                            >
                                ç¡®å®š
                            </button>
                            <button 
                                onclick="cancelEditName(${model.id})" 
                                class="px-3 py-1 bg-gray-300 text-gray-700 rounded text-sm hover:bg-gray-400"
                            >
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between text-sm text-gray-600 mb-3">
                        <div class="flex items-center gap-3">
                            <span>â¤ï¸ ${model.likes || 0}</span>
                            <span>ğŸ“¥ ${model.downloads || 0}</span>
                        </div>
                        <span class="text-xs">å¤§å°ï¼š${formatFileSize(model.size)}</span>
                        <span class="text-xs">æ›´æ–°æ—¶é—´ï¼š${formatTimeAgo(model.updatedAt)}</span>
                    </div>
                    
                    <div class="flex gap-2">
                        <button 
                            onclick="loadPersonalModel(${model.id})" 
                            class="flex-1 py-1 bg-green-50 text-green-600 rounded hover:bg-green-100 transition-colors text-sm"
                        >
                            ğŸ“‚ åŠ è½½
                        </button>
                        <button 
                            onclick="savePersonalModel(${model.id})" 
                            class="flex-1 py-1 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition-colors text-sm"
                        >
                            ğŸ’¾ ä¿å­˜
                        </button>
                    </div>
                </div>
            `;
      }

      // åˆ›å»ºä¸Šä¼ æ–°å­˜æ¡£çš„å ä½UIå¡ç‰‡
      function createUploadPlaceholderCard() {
        return `
                <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-dashed border-blue-300 rounded-lg p-4 relative hover:from-blue-100 hover:to-indigo-100 transition-all cursor-pointer" onclick="handleUploadClick()">
                    <div class="flex flex-col items-center justify-center">
                        <div class="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center mb-2 hover:bg-blue-600 transition-colors">
                            <span class="text-white text-2xl font-light">+</span>
                        </div>
                        <h4 class="font-medium text-blue-700 text-sm mb-1">ä¸Šä¼ æ–°å­˜æ¡£</h4>
                        <p class="text-xs text-blue-500 text-center">ç‚¹å‡»è‡ªåŠ¨ä¸Šä¼ å½“å‰å­˜æ¡£</p>
                    </div>
                </div>
            `;
      } // æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
      function showLoading(show) {
        elements.loadingState.classList.toggle("hidden", !show);
        elements.modelList.classList.toggle("hidden", show);

        if (show) {
          // Generate skeleton cards and animate loading text
          generateSkeletonCards();
          animateLoadingText();
          // Add progress bar
          addLoadingProgress();
        } else {
          // Clear skeleton cards when hiding
          clearSkeletonCards();
          clearLoadingAnimations();
        }
      }

      // Generate skeleton loading cards
      function generateSkeletonCards() {
        const skeletonsContainer = document.getElementById("loadingSkeletons");
        if (!skeletonsContainer) return;

        // Clear existing skeletons
        skeletonsContainer.innerHTML = "";

        // Generate 6 skeleton cards
        for (let i = 0; i < 6; i++) {
          const skeletonCard = document.createElement("div");
          skeletonCard.className = "skeleton-card";
          skeletonCard.innerHTML = `
            <div class="flex items-center justify-between mb-3">
              <div class="skeleton-line medium"></div>
              <div class="skeleton-line short" style="width: 40px; height: 20px;"></div>
            </div>
            <div class="flex items-center justify-between text-sm text-gray-600 mb-4">
              <div class="flex items-center gap-4">
                <div class="skeleton-line short" style="width: 30px; height: 14px;"></div>
                <div class="skeleton-line short" style="width: 30px; height: 14px;"></div>
              </div>
              <div class="skeleton-line short" style="width: 60px; height: 14px;"></div>
            </div>
            <div class="flex gap-2">
              <div class="skeleton-button"></div>
              <div class="skeleton-button"></div>
            </div>
          `;

          // Add staggered animation delay
          skeletonCard.style.animationDelay = `${i * 0.2}s`;
          skeletonsContainer.appendChild(skeletonCard);
        }
      }

      // Clear skeleton cards
      function clearSkeletonCards() {
        const skeletonsContainer = document.getElementById("loadingSkeletons");
        if (skeletonsContainer) {
          skeletonsContainer.innerHTML = "";
        }
      }

      // Animate loading text
      function animateLoadingText() {
        const loadingText = document.getElementById("loadingText");
        if (!loadingText) return;

        const loadingMessages = ["æ­£åœ¨åŠ è½½å­˜æ¡£...", "æ­£åœ¨è·å–æ•°æ®...", "æ­£åœ¨è§£æå†…å®¹...", "å³å°†å®ŒæˆåŠ è½½..."];

        let messageIndex = 0;

        // Clear any existing interval
        if (window.loadingTextInterval) {
          clearInterval(window.loadingTextInterval);
        }

        // Set initial animation class
        loadingText.classList.add("loading-text-animated");

        // Change text every 2 seconds
        window.loadingTextInterval = setInterval(() => {
          messageIndex = (messageIndex + 1) % loadingMessages.length;
          loadingText.textContent = loadingMessages[messageIndex];
        }, 2000);
      }

      // Add loading progress bar
      function addLoadingProgress() {
        const loadingState = document.getElementById("loadingState");
        if (!loadingState) return;

        // Check if progress bar already exists
        let progressContainer = loadingState.querySelector(".loading-progress");
        if (progressContainer) return;

        // Create progress bar
        progressContainer = document.createElement("div");
        progressContainer.className = "loading-progress";

        const progressBar = document.createElement("div");
        progressBar.className = "loading-progress-bar";

        progressContainer.appendChild(progressBar);
        loadingState.appendChild(progressContainer);
      }

      // Clear loading animations
      function clearLoadingAnimations() {
        // Clear loading text interval
        if (window.loadingTextInterval) {
          clearInterval(window.loadingTextInterval);
          window.loadingTextInterval = null;
        }

        // Reset loading text
        const loadingText = document.getElementById("loadingText");
        if (loadingText) {
          loadingText.classList.remove("loading-text-animated");
          loadingText.textContent = "æ­£åœ¨åŠ è½½å­˜æ¡£...";
        }

        // Remove progress bar
        const loadingState = document.getElementById("loadingState");
        if (loadingState) {
          const progressContainer = loadingState.querySelector(".loading-progress");
          if (progressContainer) {
            progressContainer.remove();
          }
        }
      }

      // æ˜¾ç¤ºç©ºçŠ¶æ€
      function showEmptyState() {
        elements.emptyState.classList.remove("hidden");
        elements.modelList.classList.add("hidden");
      }

      // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
      function formatFileSize(bytes) {
        if (!bytes) return "æœªçŸ¥";
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + " " + sizes[i];
      }

      // æ ¼å¼åŒ–æ—¶é—´ä¸ºç›¸å¯¹æ—¶é—´æ˜¾ç¤º
      function formatTimeAgo(utcTimeString) {
        if (!utcTimeString || utcTimeString === "æœªçŸ¥") return "æœªçŸ¥";

        try {
          const now = new Date();
          const time = new Date(utcTimeString);
          const diffMs = now - time;

          // å¦‚æœæ—¶é—´å·®ä¸ºè´Ÿæ•°æˆ–æ— æ•ˆï¼Œè¿”å›æœªçŸ¥
          if (diffMs < 0 || isNaN(diffMs)) return "æœªçŸ¥";

          const diffSeconds = Math.floor(diffMs / 1000);
          const diffMinutes = Math.floor(diffSeconds / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          const diffDays = Math.floor(diffHours / 24);
          const diffMonths = Math.floor(diffDays / 30);
          const diffYears = Math.floor(diffDays / 365);

          if (diffYears > 0) {
            return `${diffYears}å¹´å‰`;
          } else if (diffMonths > 0) {
            return `${diffMonths}ä¸ªæœˆå‰`;
          } else if (diffDays > 0) {
            return `${diffDays}å¤©å‰`;
          } else if (diffHours > 0) {
            return `${diffHours}å°æ—¶å‰`;
          } else if (diffMinutes > 0) {
            return `${diffMinutes}åˆ†é’Ÿå‰`;
          } else if (diffSeconds > 30) {
            return `${diffSeconds}ç§’å‰`;
          } else {
            return "åˆšåˆš";
          }
        } catch (error) {
          console.error("æ—¶é—´æ ¼å¼åŒ–é”™è¯¯:", error);
          return "æœªçŸ¥";
        }
      }

      // è§£ææ–‡ä»¶å¤§å°å­—ç¬¦ä¸²ä¸ºå­—èŠ‚æ•°
      function parseFileSize(sizeStr) {
        if (!sizeStr || sizeStr === "æœªçŸ¥") return 0;

        const sizes = ["B", "KB", "MB", "GB"];
        const regex = /^([\d.]+)\s*(B|KB|MB|GB)$/i;
        const match = sizeStr.trim().match(regex);

        if (!match) return 0;

        const value = parseFloat(match[1]);
        const unit = match[2].toUpperCase();
        const unitIndex = sizes.indexOf(unit);

        if (unitIndex === -1) return 0;

        return Math.round(value * Math.pow(1024, unitIndex));
      } // ç‚¹èµå­˜æ¡£
      async function likeModel(modelId) {
        // Find the like button and show loading state
        const likeButton = document.querySelector(`button[onclick="likeModel(${modelId})"]`);
        const originalText = likeButton ? likeButton.innerHTML : "";

        if (likeButton) {
          likeButton.disabled = true;
          likeButton.innerHTML = '<div class="loading-small mr-1"></div>æ”¶è—ä¸­...';
        }        try {
          // æ£€æŸ¥æ˜¯å¦å·²ç»æ”¶è—è¿‡ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
          let likedModels = await loadLikedModelsCache();
          let likedModelsCopy = JSON.parse(JSON.stringify(likedModels));
          const alreadyLiked = likedModelsCopy.find((model) => model.id === modelId);

          if (alreadyLiked) {
            showToast("å·²ç»æ”¶è—è¿‡äº†ï¼", "warning");
            return;
          }

          await apiCall(`/mall/personalModels/${modelId}/likes`, { method: "POST" });

          // è·å–å®Œæ•´çš„æ¨¡å‹æ•°æ®å¹¶æ·»åŠ åˆ°æ”¶è—åˆ—è¡¨
          const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}`);
          const allModels = result?.rows || [];
          const modelToLike = allModels.find((model) => model.id === modelId);

          if (modelToLike) {
            // æ·»åŠ æ”¶è—æ—¶é—´æˆ³
            modelToLike.likedAt = new Date().toISOString();

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡maxHistoryæ¡é™åˆ¶
            if (likedModelsCopy.length >= maxHistory) {
              // æŒ‰æ”¶è—æ—¶é—´æ’åºï¼Œç§»é™¤æœ€æ—©çš„è®°å½•
              likedModelsCopy.sort((a, b) => {
                const timeA = new Date(a.likedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.likedAt || b.created_at || 0).getTime();
                return timeA - timeB;
              });
              // ç§»é™¤æœ€æ—©çš„è®°å½•
              likedModelsCopy.shift();
            }

            likedModelsCopy.push(modelToLike);
            await sdk.personalPageStore.savePageData(pageName, "liked", likedModelsCopy);
            
            // åˆ·æ–°ç¼“å­˜
            cachedLikedModels = likedModelsCopy;
            
            // ç«‹å³æ›´æ–°å½“å‰å¡ç‰‡çš„æ”¶è—çŠ¶æ€
            updateCardLikedStatus(modelId, true);
          }

          showToast("æ”¶è—æˆåŠŸï¼", "success");

          // é‡æ–°åŠ è½½å½“å‰è§†å›¾ï¼ˆåªæœ‰åœ¨æ”¶è—è§†å›¾æ—¶æ‰éœ€è¦å®Œå…¨é‡æ–°åŠ è½½ï¼‰
          if (currentView === "liked") {
            loadLikedModels();
          }
        } catch (error) {
          // é”™è¯¯å·²åœ¨apiCallä¸­å¤„ç†
        } finally {
          // Restore button state
          if (likeButton) {
            likeButton.disabled = false;
            likeButton.innerHTML = originalText;
          }
        }
      } // ä¸‹è½½å­˜æ¡£
      async function downloadModel(modelId) {
        // Find the download button and show loading state
        const downloadButton = document.querySelector(`button[onclick="downloadModel(${modelId})"]`);
        const originalText = downloadButton ? downloadButton.innerHTML : "";

        if (downloadButton) {
          downloadButton.disabled = true;
          downloadButton.innerHTML = '<div class="loading-small mr-1"></div>ä¸‹è½½ä¸­...';
        }

        try {
          await apiCall(`/mall/personalModels/${modelId}/downloads`, { method: "POST" });

          // è·å–å®Œæ•´çš„æ¨¡å‹æ•°æ®å¹¶æ·»åŠ åˆ°ä¸‹è½½åˆ—è¡¨
          let personalDatas = (await sdk.personalPageStore.loadPageData(pageName, "downloaded")) || [];
          let downloadedModels = JSON.parse(JSON.stringify(personalDatas));
          let existingModel = downloadedModels.find((model) => model.id === modelId);
          let currentModel;
          if (existingModel) {
            // å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°ä¸‹è½½æ¬¡æ•°å’Œæ—¶é—´
            existingModel.downloads = (existingModel.downloads || 0) + 1;
            existingModel.lastDownloadedAt = new Date().toISOString();
            currentModel = existingModel;
          } else {
            // å¦‚æœä¸å­˜åœ¨ï¼Œè·å–å®Œæ•´æ¨¡å‹æ•°æ®å¹¶æ·»åŠ 
            const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}`);
            const allModels = result?.rows || [];
            const modelToDownload = allModels.find((model) => model.id === modelId);

            if (modelToDownload) {
              modelToDownload.downloads = 1;
              modelToDownload.lastDownloadedAt = new Date().toISOString();

              // æ£€æŸ¥æ˜¯å¦è¶…è¿‡maxHistoryæ¡é™åˆ¶
              if (downloadedModels.length >= maxHistory) {
                // æŒ‰ä¸‹è½½æ—¶é—´æ’åºï¼Œç§»é™¤æœ€æ—©çš„è®°å½•
                downloadedModels.sort((a, b) => {
                  const timeA = new Date(a.lastDownloadedAt || a.created_at || 0).getTime();
                  const timeB = new Date(b.lastDownloadedAt || b.created_at || 0).getTime();
                  return timeA - timeB;
                });
                // ç§»é™¤æœ€æ—©çš„è®°å½•
                downloadedModels.shift();
              }
              currentModel = modelToDownload;
              downloadedModels.push(modelToDownload);
            }
          }

          showToast("ä¸‹è½½è®°å½•å·²ä¿å­˜ï¼", "success");
          await sdk.personalPageStore.savePageData(pageName, "downloaded", downloadedModels, true);
          await new Promise((resolve) => setTimeout(resolve, 500));

          // å‘é€loadModelæ¶ˆæ¯ç»™çˆ¶çª—å£
          console.log("Loading public model:", v);
          window.parent.postMessage(
            {
              type: "loadModel",
              modelId: currentModel.id,
              modelData: {
                id: currentModel.id,
                name: currentModel.name,
                modelUrl: currentModel.modelUrl,
                size: currentModel.size,
                tag: currentModel.tag,
                likes: currentModel.likes,
                downloads: currentModel.downloads,
                updatedAt: currentModel.updatedAt,
              },
            },
            "*"
          );
          if (currentView === "all") {
            loadModels();
          } else if (currentView === "downloaded") {
            loadDownloadedModels();
          }
        } catch (error) {
          // é”™è¯¯å·²åœ¨apiCallä¸­å¤„ç†
        } finally {
          // Restore button state
          if (downloadButton) {
            downloadButton.disabled = false;
            downloadButton.innerHTML = originalText;
          }
        }
      }

      // è‡ªå®šä¹‰ç¡®è®¤å¼¹æ¡†å‡½æ•°
      function showCustomConfirm(title, message, onConfirm, onCancel) {
        const modal = document.getElementById("customConfirmModal");
        const titleEl = document.getElementById("confirmTitle");
        const messageEl = document.getElementById("confirmMessage");
        const confirmBtn = document.getElementById("confirmOkBtn");
        const cancelBtn = document.getElementById("confirmCancelBtn");

        // è®¾ç½®å†…å®¹
        titleEl.textContent = title;
        messageEl.textContent = message;

        // æ˜¾ç¤ºå¼¹æ¡†
        modal.classList.remove("hidden");
        setTimeout(() => modal.classList.add("show"), 10);

        // ç»‘å®šäº‹ä»¶
        const handleConfirm = () => {
          hideCustomConfirm();
          if (onConfirm) onConfirm();
        };

        const handleCancel = () => {
          hideCustomConfirm();
          if (onCancel) onCancel();
        };

        // ç§»é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
        confirmBtn.replaceWith(confirmBtn.cloneNode(true));
        cancelBtn.replaceWith(cancelBtn.cloneNode(true));

        // é‡æ–°è·å–å…ƒç´ å¹¶æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        const newConfirmBtn = document.getElementById("confirmOkBtn");
        const newCancelBtn = document.getElementById("confirmCancelBtn");

        newConfirmBtn.addEventListener("click", handleConfirm);
        newCancelBtn.addEventListener("click", handleCancel);

        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            handleCancel();
          }
        });

        // ESCé”®å…³é—­
        const handleEsc = (e) => {
          if (e.key === "Escape") {
            handleCancel();
            document.removeEventListener("keydown", handleEsc);
          }
        };
        document.addEventListener("keydown", handleEsc);
      }

      function hideCustomConfirm() {
        const modal = document.getElementById("customConfirmModal");
        modal.classList.remove("show");
        setTimeout(() => modal.classList.add("hidden"), 300);
      }

      // ç¡®è®¤åˆ é™¤å­˜æ¡£
      function confirmDeleteModel(modelId) {
        showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­˜æ¡£å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚", () => deleteModel(modelId), null);
      }

      // åˆ é™¤å­˜æ¡£
      async function deleteModel(modelId) {
        try {
          await apiCall(`/mall/personalModels/${modelId}`, { method: "DELETE" });
          showToast("åˆ é™¤æˆåŠŸï¼", "success");
          loadPersonalModels();
        } catch (error) {
          // é”™è¯¯å·²åœ¨apiCallä¸­å¤„ç†
        }
      }

      // åŠ è½½ä¸ªäººæ¨¡å‹
      async function loadPersonalModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) {
          showToast("æ¨¡å‹ä¸å­˜åœ¨", "error");
          return;
        }

        try {
           console.log("Loading personal model:", model);
          // å‘é€loadModelæ¶ˆæ¯ç»™çˆ¶çª—å£
          window.parent.postMessage(
            {
              type: "loadModel",
              modelId: model.id,
              modelData: {
                id: model.id,
                name: model.name,
                modelUrl: model.modelUrl,
                size: model.size,
                tag: model.tag,
                likes: model.likes,
                downloads: model.downloads,
                updatedAt: model.updatedAt,
              },
            },
            "*"
          );

          showToast(`å·²åŠ è½½æ¨¡å‹ï¼š${model.name}`, "success");
        } catch (error) {
          showToast("åŠ è½½æ¨¡å‹å¤±è´¥", "error");
        }
      }

      // ä¿å­˜ä¸ªäººæ¨¡å‹
      async function savePersonalModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) {
          showToast("æ¨¡å‹ä¸å­˜åœ¨", "error");
          return;
        }

        // æ˜¾ç¤ºä¿å­˜ç¡®è®¤å¼¹æ¡†
        await showSaveConfirmModal(model);
      }

      // ç¼–è¾‘æ¨¡å‹åç§°
      function editModelName(modelId) {
        const nameElement = document.getElementById(`modelName_${modelId}`);
        const editBox = document.getElementById(`editNameBox_${modelId}`);
        const input = document.getElementById(`editNameInput_${modelId}`);

        if (nameElement && editBox && input) {
          nameElement.style.display = "none";
          editBox.classList.remove("hidden");
          input.focus();
          input.select();
        }
      }

      // ä¿å­˜æ¨¡å‹åç§°
      async function saveModelName(modelId) {
        const input = document.getElementById(`editNameInput_${modelId}`);
        const newName = input.value.trim();

        if (!newName) {
          showToast("åç§°ä¸èƒ½ä¸ºç©º", "error");
          return;
        }

        try {
          await apiCall(`/mall/personalModels/${modelId}`, {
            method: "PUT",
            body: JSON.stringify({ name: newName }),
          });

          showToast("åç§°ä¿®æ”¹æˆåŠŸï¼", "success");
          loadPersonalModels(); // é‡æ–°åŠ è½½åˆ—è¡¨
        } catch (error) {
          // é”™è¯¯å·²åœ¨apiCallä¸­å¤„ç†
        }
      }

      // å–æ¶ˆç¼–è¾‘åç§°
      function cancelEditName(modelId) {
        const nameElement = document.getElementById(`modelName_${modelId}`);
        const editBox = document.getElementById(`editNameBox_${modelId}`);
        const input = document.getElementById(`editNameInput_${modelId}`);

        if (nameElement && editBox && input) {
          // æ¢å¤åŸå§‹å€¼
          const model = personalModels.find((m) => m.id === modelId);
          if (model) {
            input.value = model.name || "æœªå‘½åå­˜æ¡£";
          }

          nameElement.style.display = "block";
          editBox.classList.add("hidden");
        }
      }

      // ç¼–è¾‘å­˜æ¡£
      function editModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) return;

        document.getElementById("editModelId").value = model.id;
        document.getElementById("editModelName").value = model.name || "";
        document.getElementById("editModelUrl").value = model.modelUrl || "";
        document.getElementById("editModelSize").value = formatFileSize(model.size || 0);
        document.getElementById("editModelTag").value = model.tag || currentTag; // ä½¿ç”¨å­˜æ¡£çš„æ ‡ç­¾æˆ–å½“å‰æ ‡ç­¾

        elements.editModal.classList.remove("hidden");
      }

      // åŠ è½½ä¸ªäººå­˜æ¡£
      async function loadPersonalModels() {
        try {
          const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}&userId=${USER_ID}`);
          personalModels = result?.rows || [];
          renderPersonalModels(personalModels);
        } catch (error) {
          elements.personalEmptyState.classList.remove("hidden");
          elements.personalModelList.innerHTML = "";
        }
      }

      // æ¸²æŸ“ä¸ªäººå­˜æ¡£åˆ—è¡¨
      function renderPersonalModels(models) {
        // åˆ›å»ºå ä½UIå¡ç‰‡ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ 
        const placeholderCard = createUploadPlaceholderCard();

        if (!models || models.length === 0) {
          elements.personalEmptyState.classList.add("hidden");
          elements.personalModelList.innerHTML = placeholderCard;
          return;
        }

        elements.personalEmptyState.classList.add("hidden");
        const modelCards = models.map((model) => createPersonalModelCard(model)).join("");
        elements.personalModelList.innerHTML = placeholderCard + modelCards;
      }

      // åŠ è½½æ‰€æœ‰å­˜æ¡£
      async function loadAllModels() {
        currentView = "all";
        resetPagination();
        loadModels(); // ä¸ä¼ å‚æ•°ï¼Œä½¿ç”¨å½“å‰æ ‡ç­¾
      }

      // åŠ è½½ç‚¹èµè®°å½•
      async function loadLikedModels() {
        currentView = "liked";
        resetPagination();
        showLoading(true);

        try {
          let likedModels = (await sdk.personalPageStore.loadPageData(pageName, "liked")) || [];

          // åº”ç”¨æ’åºé€»è¾‘
          likedModels = applySortToPersonalData(likedModels);

          currentModels = likedModels;

          if (likedModels.length === 0) {
            // æ¸…é™¤åŸæœ‰çš„åœ¨çº¿æ•°æ®åˆ—è¡¨UI
            elements.modelList.innerHTML = "";
            showEmptyState();
          } else {
            await renderModelList(likedModels);
          }
        } catch (error) {
          console.error("åŠ è½½æ”¶è—è®°å½•å¤±è´¥:", error);
          showToast("åŠ è½½æ”¶è—è®°å½•å¤±è´¥", "error");
          // æ¸…é™¤åŸæœ‰çš„åœ¨çº¿æ•°æ®åˆ—è¡¨UI
          elements.modelList.innerHTML = "";
          showEmptyState();
        } finally {
          showLoading(false);
        }
      }

      // åŠ è½½ä¸‹è½½è®°å½•
      async function loadDownloadedModels() {
        currentView = "downloaded";
        resetPagination();
        showLoading(true);

        try {
          let downloadedModels = (await sdk.personalPageStore.loadPageData(pageName, "downloaded")) || [];

          // åº”ç”¨æ’åºé€»è¾‘
          downloadedModels = applySortToPersonalData(downloadedModels);

          currentModels = downloadedModels;

          if (downloadedModels.length === 0) {
            // æ¸…é™¤åŸæœ‰çš„åœ¨çº¿æ•°æ®åˆ—è¡¨UI
            elements.modelList.innerHTML = "";
            showEmptyState();
          } else {
            await renderModelList(downloadedModels);
          }
        } catch (error) {
          console.error("åŠ è½½ä¸‹è½½è®°å½•å¤±è´¥:", error);
          showToast("åŠ è½½ä¸‹è½½è®°å½•å¤±è´¥", "error");
          // æ¸…é™¤åŸæœ‰çš„åœ¨çº¿æ•°æ®åˆ—è¡¨UI
          elements.modelList.innerHTML = "";
          showEmptyState();
        } finally {
          showLoading(false);
        }
      }

      // é‡ç½®åˆ†é¡µçŠ¶æ€
      function resetPagination() {
        currentPage = 1;
        hasMoreData = true;
        currentModels = [];
      }

      // åº”ç”¨æ’åº
      function applySort() {
        resetPagination();
        reloadCurrentView();
      }

      // é‡æ–°åŠ è½½å½“å‰è§†å›¾
      function reloadCurrentView() {
        if (currentView === "all") {
          loadModels();
        } else if (currentView === "liked") {
          loadLikedModels();
        } else if (currentView === "downloaded") {
          loadDownloadedModels();
        }
      }

      // ä¸ºä¸ªäººæ•°æ®åº”ç”¨æ’åºé€»è¾‘
      function applySortToPersonalData(models) {
        if (!models || models.length === 0) return models;

        const sortedModels = [...models];

        switch (currentSort.field) {
          case "name":
            sortedModels.sort((a, b) => {
              const nameA = (a.name || "").toLowerCase();
              const nameB = (b.name || "").toLowerCase();
              return currentSort.order === "asc" ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
            });
            break;
          case "likes":
            sortedModels.sort((a, b) => {
              const likesA = a.likes || 0;
              const likesB = b.likes || 0;
              return currentSort.order === "asc" ? likesA - likesB : likesB - likesA;
            });
            break;
          case "downloads":
            sortedModels.sort((a, b) => {
              const downloadsA = a.downloads || 0;
              const downloadsB = b.downloads || 0;
              return currentSort.order === "asc" ? downloadsA - downloadsB : downloadsB - downloadsA;
            });
            break;
          case "size":
            sortedModels.sort((a, b) => {
              const sizeA = a.size || 0;
              const sizeB = b.size || 0;
              return currentSort.order === "asc" ? sizeA - sizeB : sizeB - sizeA;
            });
            break;
          case "created_at":
            sortedModels.sort((a, b) => {
              const timeA = new Date(a.created_at || 0).getTime();
              const timeB = new Date(b.created_at || 0).getTime();
              return currentSort.order === "asc" ? timeA - timeB : timeB - timeA;
            });
            break;
          default:
            // é»˜è®¤æŒ‰æ·»åŠ æ—¶é—´å€’åºæ’åˆ—ï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
            if (currentView === "liked") {
              sortedModels.sort((a, b) => {
                const timeA = new Date(a.likedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.likedAt || b.created_at || 0).getTime();
                return timeB - timeA;
              });
            } else if (currentView === "downloaded") {
              sortedModels.sort((a, b) => {
                const timeA = new Date(a.lastDownloadedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.lastDownloadedAt || b.created_at || 0).getTime();
                return timeB - timeA;
              });
            }
            break;
        }

        return sortedModels;
      }

      // æœç´¢åŠŸèƒ½
      async function searchModels() {
        const query = elements.searchInput.value.trim().toLowerCase();
        if (!query) {
          await renderModelList(currentModels);
          return;
        }
        let modelId = parseInt(query);
        const filteredModels = currentModels.filter(
          (model) => (model.name || "").toLowerCase().includes(query) || (model.tag || "").toLowerCase().includes(query) || (model.id || "").includes(query) || (modelId && model.id === modelId)
        );
        await renderModelList(filteredModels);
      }

      // äº‹ä»¶ç›‘å¬å™¨
      elements.searchBtn.addEventListener("click", searchModels);
      elements.searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") searchModels();
      });

      elements.uploadBtn.addEventListener("click", () => {
        elements.uploadDrawer.classList.remove("hidden");
        setTimeout(() => {
          elements.uploadDrawer.querySelector(".drawer").classList.add("open");
        }, 10);
        loadPersonalModels();
      });

      elements.closeDrawer.addEventListener("click", () => {
        elements.uploadDrawer.querySelector(".drawer").classList.remove("open");
        setTimeout(() => {
          elements.uploadDrawer.classList.add("hidden");
        }, 300);
      });

      elements.likeRecordBtn.addEventListener("click", () => {
        setActiveTab("likeRecordBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
        loadLikedModels();
      });
      elements.downloadRecordBtn.addEventListener("click", () => {
        setActiveTab("downloadRecordBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
        loadDownloadedModels();
      });
      elements.allModelsBtn.addEventListener("click", () => {
        setActiveTab("allModelsBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
        loadAllModels();
      });

      // æ›´æ–°æŒ‰é’®æ–‡å­—æ˜¾ç¤º
      function updateSortButtonText() {
        const buttons = [
          { element: elements.sortByTime, field: "updatedAt", name: "ä¿®æ”¹æ—¶é—´" },
          { element: elements.sortByLikes, field: "likes", name: "æ”¶è—æ•°" },
          { element: elements.sortByDownloads, field: "downloads", name: "ä¸‹è½½æ•°" },
        ];

        buttons.forEach(({ element, field, name }) => {
          if (currentSort.field === field) {
            const arrow = currentSort.order === "desc" ? "â†“" : "â†‘";
            element.textContent = `${name} ${arrow}`;
            element.classList.add("bg-blue-100", "text-blue-700", "border-blue-300");
            element.classList.remove("hover:bg-gray-50");
          } else {
            element.textContent = name;
            element.classList.remove("bg-blue-100", "text-blue-700", "border-blue-300");
            element.classList.add("hover:bg-gray-50");
          }
        });
      }

      // æ’åºæŒ‰é’®äº‹ä»¶ç›‘å¬
      elements.sortByTime.addEventListener("click", () => {
        if (currentSort.field === "updatedAt") {
          // åˆ‡æ¢æ’åºé¡ºåº
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // è®¾ç½®æ–°çš„æ’åºå­—æ®µ
          currentSort.field = "updatedAt";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      elements.sortByLikes.addEventListener("click", () => {
        if (currentSort.field === "likes") {
          // åˆ‡æ¢æ’åºé¡ºåº
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // è®¾ç½®æ–°çš„æ’åºå­—æ®µ
          currentSort.field = "likes";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      elements.sortByDownloads.addEventListener("click", () => {
        if (currentSort.field === "downloads") {
          // åˆ‡æ¢æ’åºé¡ºåº
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // è®¾ç½®æ–°çš„æ’åºå­—æ®µ
          currentSort.field = "downloads";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      // å¤„ç†ä¸Šä¼ æ–°å­˜æ¡£çš„ç‚¹å‡»äº‹ä»¶
      async function handleUploadClick() {
        // æ¸…ç©ºè¡¨å•
        document.getElementById("editModelId").value = "";
        document.getElementById("editModelName").value = "";
        document.getElementById("editModelUrl").value = "";
        document.getElementById("editModelSize").value = "";
        document.getElementById("editModelTag").value = currentTag; // ä½¿ç”¨URLå‚æ•°ä¸­çš„æ ‡ç­¾
        elements.editModal.classList.remove("hidden");
        try {
          const modelUrlResponse = await startUploadModel();
          if (!modelUrlResponse.modelUrl) {
            showToast("è·å–å½“å‰å­˜æ¡£URLå¤±è´¥ï¼Œè¯·å…ˆè¿”å›æ¸¸æˆä¿å­˜å½“å‰å­˜æ¡£", "error");
            return;
          }
          document.getElementById("editModelUrl").value = modelUrlResponse.modelUrl;
          document.getElementById("editModelSize").value = formatFileSize(modelUrlResponse.size || 0);
        } catch (error) {
          showToast("ä¸Šä¼ æ¨¡å‹å¤±è´¥", "error");
        }
      }

      elements.cancelEdit.addEventListener("click", () => {
        elements.editModal.classList.add("hidden");
      });

      elements.editForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const modelName = document.getElementById("editModelName").value;
        if (!modelName) {
          showToast("è¯·è¾“å…¥å­˜æ¡£åç§°", "warning");
          return;
        }
        const modelUrl = document.getElementById("editModelUrl").value;
        if (!modelUrl || !modelUrl.startsWith("https://")) {
          showToast("è¯·è¿”å›æ¸¸æˆä¿å­˜å½“å‰å­˜æ¡£ï¼Œé‡æ–°è·å–å½“å‰å­˜æ¡£URL", "warning");
          return;
        }
        const modelId = document.getElementById("editModelId").value;
        const modelData = {
          name: modelName,
          tag: currentTag, // ä½¿ç”¨URLå‚æ•°ä¸­çš„æ ‡ç­¾
        };

        if (modelId) {
          // ç¼–è¾‘ç°æœ‰å­˜æ¡£ï¼Œåªæ›´æ–°åç§°
          modelData.id = parseInt(modelId);
        } else {
          // æ–°å»ºå­˜æ¡£ï¼Œéœ€è¦URLç­‰å®Œæ•´ä¿¡æ¯
          modelData.modelUrl = document.getElementById("editModelUrl").value;
          modelData.modelType = "blocks"; // é»˜è®¤ç±»å‹
          modelData.size = parseFileSize(document.getElementById("editModelSize").value) || 0;
        }

        try {
          await apiCall(
            "/mall/personalModels/upsert",
            {
              method: "PUT",
              body: JSON.stringify(modelData),
            },
            true
          );

          showToast(modelId ? "æ›´æ–°æˆåŠŸï¼" : "åˆ›å»ºæˆåŠŸï¼", "success");
          elements.editModal.classList.add("hidden");
          loadPersonalModels();
        } catch (error) {
          // é”™è¯¯å·²åœ¨apiCallä¸­å¤„ç†
        }
      });

      // å…³é—­å¼¹æ¡†äº‹ä»¶ç›‘å¬å™¨
      elements.closeToast.addEventListener("click", hideToast);
      elements.uploadDrawer.addEventListener("click", (e) => {
        if (e.target === elements.uploadDrawer) {
          elements.closeDrawer.click();
        }
      });

      // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
      elements.editModal.addEventListener("click", (e) => {
        if (e.target === elements.editModal) {
          elements.editModal.classList.add("hidden");
        }
      });

      // ä¿å­˜ç¡®è®¤å¼¹æ¡†ç›¸å…³é€»è¾‘
      const saveConfirmModal = document.getElementById("saveConfirmModal");
      const saveConfirmCancelBtn = document.getElementById("saveConfirmCancelBtn");
      const saveConfirmOkBtn = document.getElementById("saveConfirmOkBtn");
      const saveConfirmName = document.getElementById("saveConfirmName");
      const saveConfirmUrl = document.getElementById("saveConfirmUrl");
      const saveConfirmSize = document.getElementById("saveConfirmSize");
      const saveConfirmBtnText = document.getElementById("saveConfirmBtnText");
      const saveConfirmLoading = document.getElementById("saveConfirmLoading");

      // æ˜¾ç¤ºä¿å­˜ç¡®è®¤å¼¹æ¡†
      async function showSaveConfirmModal(model) {
        // è®¾ç½®å­˜æ¡£åç§°ï¼ˆå¯ç¼–è¾‘ï¼‰
        saveConfirmName.value = model.name;
        saveConfirmName.readOnly = false;

        // é‡ç½®URLå’Œå¤§å°æ˜¾ç¤º
        saveConfirmUrl.textContent = "è·å–ä¸­...";
        saveConfirmSize.textContent = "è·å–ä¸­...";

        // æ˜¾ç¤ºå¼¹æ¡†
        saveConfirmModal.classList.remove("hidden");

        // å¼‚æ­¥è·å–æœ€æ–°çš„æ¨¡å‹æ•°æ®
        try {
          const modelUrlResponse = await startUploadModel();
          if (!modelUrlResponse.modelUrl) {
            showToast("è·å–å½“å‰å­˜æ¡£URLå¤±è´¥ï¼Œè¯·å…ˆè¿”å›æ¸¸æˆä¿å­˜å½“å‰å­˜æ¡£", "error");
            return;
          }
          saveConfirmUrl.textContent = modelUrlResponse.modelUrl || "æ— ";
          saveConfirmSize.textContent = formatFileSize(modelUrlResponse.size || 0);

          // å­˜å‚¨è·å–åˆ°çš„æ•°æ®ä¾›ç¡®è®¤æ—¶ä½¿ç”¨
          saveConfirmModal.dataset.modelUrl = modelUrlResponse.modelUrl || "";
          saveConfirmModal.dataset.modelSize = modelUrlResponse.size || 0;
          saveConfirmModal.dataset.modelId = model.id;
        } catch (error) {
          saveConfirmUrl.textContent = "è·å–å¤±è´¥";
          saveConfirmSize.textContent = "è·å–å¤±è´¥";
          showToast("è·å–æ¨¡å‹æ•°æ®å¤±è´¥", "error");
        }
      }

      // éšè—ä¿å­˜ç¡®è®¤å¼¹æ¡†
      function hideSaveConfirmModal() {
        saveConfirmModal.classList.add("hidden");
        // é‡ç½®æŒ‰é’®çŠ¶æ€
        saveConfirmBtnText.textContent = "ç¡®è®¤ä¿å­˜";
        saveConfirmLoading.classList.add("hidden");
        saveConfirmOkBtn.disabled = false;
      }

      // ä¿å­˜ç¡®è®¤å¼¹æ¡†äº‹ä»¶ç›‘å¬
      saveConfirmCancelBtn.addEventListener("click", hideSaveConfirmModal);

      saveConfirmOkBtn.addEventListener("click", async () => {
        const modelId = saveConfirmModal.dataset.modelId;
        const modelUrl = saveConfirmModal.dataset.modelUrl;
        const modelSize = parseInt(saveConfirmModal.dataset.modelSize) || 0;
        const modelName = saveConfirmName.value.trim();

        if (!modelName) {
          showToast("è¯·è¾“å…¥å­˜æ¡£åç§°", "warning");
          return;
        }

        if (!modelUrl) {
          showToast("æ²¡æœ‰å¯ä¿å­˜çš„æ¨¡å‹æ•°æ®", "error");
          return;
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        saveConfirmBtnText.textContent = "ä¿å­˜ä¸­...";
        saveConfirmLoading.classList.remove("hidden");
        saveConfirmOkBtn.disabled = true;

        try {
          // æ‰¾åˆ°åŸå§‹æ¨¡å‹æ•°æ®
          const originalModel = personalModels.find((m) => m.id == modelId);

          const updateData = {
            name: modelName, // ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åç§°
            modelUrl: modelUrl, // ä½¿ç”¨è·å–åˆ°çš„æœ€æ–°URL
            size: modelSize, // ä½¿ç”¨è·å–åˆ°çš„æœ€æ–°å¤§å°
            tag: originalModel?.tag || DEFAULT_TAG, // ä¿æŒåŸæœ‰æ ‡ç­¾
            updatedAt: new Date().toISOString(),
          };

          await apiCall(`/mall/personalModels/${modelId}`, {
            method: "PUT",
            body: JSON.stringify(updateData),
          });

          showToast("ä¿å­˜æˆåŠŸï¼", "success");
          hideSaveConfirmModal();
          loadPersonalModels(); // é‡æ–°åŠ è½½åˆ—è¡¨
        } catch (error) {
          showToast("ä¿å­˜å¤±è´¥", "error");
          // æ¢å¤æŒ‰é’®çŠ¶æ€
          saveConfirmBtnText.textContent = "ç¡®è®¤ä¿å­˜";
          saveConfirmLoading.classList.add("hidden");
          saveConfirmOkBtn.disabled = false;
        }
      });

      // ç‚¹å‡»å¼¹æ¡†èƒŒæ™¯å…³é—­
      saveConfirmModal.addEventListener("click", (e) => {
        if (e.target === saveConfirmModal) {
          hideSaveConfirmModal();
        }
      });

      // æ»šåŠ¨åŠ è½½ç›‘å¬å™¨
      elements.modelList.addEventListener("scroll", () => {
        const { scrollTop, scrollHeight, clientHeight } = elements.modelList;
        // å½“æ»šåŠ¨åˆ°è·ç¦»åº•éƒ¨50pxæ—¶è§¦å‘åŠ è½½
        if (scrollTop + clientHeight >= scrollHeight - 50 && hasMoreData && !isLoading) {
          loadMoreModels();
        }
      }); // åŠ è½½æ›´å¤šå­˜æ¡£
      async function loadMoreModels() {
        if (!hasMoreData || isLoading) return;

        // Show loading overlay for loading more
        elements.loadingMoreOverlay.classList.remove("hidden");

        try {
          if (currentView === "all") {
            await loadModels(currentTag, null, currentPage + 1, true);
          } else if (currentView === "liked") {
            await loadModels(currentTag, USER_ID, currentPage + 1, true);
          } else if (currentView === "downloaded") {
            await loadModels(currentTag, USER_ID, currentPage + 1, true);
          }
        } finally {
          // Hide loading overlay
          elements.loadingMoreOverlay.classList.add("hidden");
        }
      }

      async function initializeApp() {
        // Initialize sort button text
        updateSortButtonText();
        // Load all models by default
        loadAllModels();
        window.parent.postMessage({ type: "gameLoaded" }, "*");
        console.log("App initialized, currentTag:", currentTag);
      }

      function checkStartGame(timeoutMs) {
        if (!timeoutMs) {
          const urlParams = new URLSearchParams(window.location.search);
          timeoutMs = urlParams.get("parent") === "miniGameProxy" ? 3000 : 200;
          if (urlParams.get("parent") != "miniGameProxy") {
            currentTag = urlParams.get("tag") || DEFAULT_TAG;
          }
        }

        let gameStarted = false;
        const waitForMinigameProxyWithTimeout = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            if (!gameStarted) {
              resolve(null);
            }
          }, timeoutMs);
          let miniGameProxyReceived = false;
          let locationReceived = false;

          const messageHandler = function (e) {
            if (!e.data || !e.data.type) {
              return;
            }

            try {
              switch (e.data.type) {
                case "miniGameProxyDataResponse":
                  keepworkToken = e.data.keepworkToken || "";
                  keepworkUserInfo = e.data.keepworkUserInfo || {};
                  USER_ID = keepworkUserInfo?.id || 1;
                  sdk.setToken(keepworkToken);
                  miniGameProxyReceived = true;
                  break;
                case "locationResponse":
                  const locationParams = e.data;
                  if (locationParams?.search) {
                    const urlParams = new URLSearchParams(locationParams.search);
                    currentTag = urlParams.get("tag") || DEFAULT_TAG;
                  }
                  locationReceived = true;
                  break;
              }

              if (miniGameProxyReceived && locationReceived) {
                window.removeEventListener("message", messageHandler);
                clearTimeout(timeout);
                resolve(e.data);
              }
            } catch (error) {
              console.error("Error processing message:", error);
            }
          };

          window.addEventListener("message", messageHandler);
          window.parent.postMessage({ type: "getLocation" }, "*");
          window.parent.postMessage({ type: "getMiniGameProxyData" }, "*");
        });

        waitForMinigameProxyWithTimeout
          .then(async () => {
            if (!gameStarted) {
              gameStarted = true;
              await initializeApp();
            }
          })
          .catch(async (error) => {
            if (!gameStarted) {
              gameStarted = true;
              await initializeApp();
            }
          });
      }

      checkStartGame();
    </script>
  </body>
</html>
