<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>model world</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.10"></script>
    <style>
      .drawer {
        transform: translateY(100%);
        transition: transform 0.3s ease-in-out;
      }
      .drawer.open {
        transform: translateY(0);
      }
      .model-card {
        transition: all 0.3s ease;
      }
      .model-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .btn-primary:hover {
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
      }
      /* Ëá™ÂÆö‰πâÁ°ÆËÆ§ÂºπÊ°ÜÊ†∑Âºè */
      #customConfirmModal {
        backdrop-filter: blur(4px);
      }
      #customConfirmModal.show {
        display: flex !important;
      }
      #customConfirmModal.show .bg-white {
        transform: scale(1);
      }
      #customConfirmModal .bg-white {
        animation: modalSlideIn 0.3s ease-out;
      }
      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
      .btn-secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }
      .btn-secondary:hover {
        background: linear-gradient(135deg, #e081e9 0%, #e3455a 100%);
      }
      /* TabÊ†∑Âºè */
      .tab-btn {
        color: #6b7280;
        background: transparent;
      }
      .tab-btn:hover {
        color: #374151;
        background: rgba(255, 255, 255, 0.5);
      }
      .tab-btn.active {
        color: #1f2937;
        background: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .loading {
        display: inline-block;
        width: 40px;
        height: 40px;
        border: 4px solid #f3f4f6;
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
      }
      .loading-small {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      .loading-dots {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 20px;
      }

      .loading-dots div {
        position: absolute;
        top: 50%;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #3b82f6;
        animation: loading-dots 1.2s linear infinite;
        transform: translateY(-50%);
      }

      .loading-dots div:nth-child(1) {
        left: 8px;
        animation-delay: 0s;
      }
      .loading-dots div:nth-child(2) {
        left: 32px;
        animation-delay: -0.4s;
      }
      .loading-dots div:nth-child(3) {
        left: 56px;
        animation-delay: -0.8s;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes loading-dots {
        0%,
        80%,
        100% {
          transform: translateY(-50%) scale(0);
          opacity: 0.5;
        }
        40% {
          transform: translateY(-50%) scale(1);
          opacity: 1;
        }
      }
      /* Loading overlay for better UX */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
      }

      /* Enhanced loading animations */
      @keyframes shimmer {
        0% {
          background-position: -200px 0;
        }
        100% {
          background-position: calc(200px + 100%) 0;
        }
      }

      @keyframes pulse-glow {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.02);
        }
      }

      .skeleton-card {
        background: #f3f4f6;
        border-radius: 8px;
        padding: 16px;
        position: relative;
        overflow: hidden;
        animation: pulse-glow 2s ease-in-out infinite;
        border: 1px solid #e5e7eb;
      }

      .skeleton-card::after {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-image: linear-gradient(90deg, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0.6) 20%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0.6) 80%, rgba(255, 255, 255, 0) 100%);
        animation: shimmer 2.5s infinite;
      }

      .skeleton-line {
        height: 16px;
        background: #e5e7eb;
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .skeleton-line.short {
        width: 60%;
      }

      .skeleton-line.medium {
        width: 80%;
      }

      .skeleton-line.long {
        width: 100%;
      }

      .skeleton-button {
        height: 32px;
        background: #e5e7eb;
        border-radius: 6px;
        margin: 4px;
        flex: 1;
      }

      /* Loading text animations */
      .loading-text-animated {
        animation: loading-text-fade 3s ease-in-out infinite;
      }

      @keyframes loading-text-fade {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      /* Progress bar for loading */
      .loading-progress {
        width: 100%;
        max-width: 300px;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
        margin: 16px auto;
      }

      .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3b82f6, #6366f1);
        border-radius: 2px;
        animation: loading-progress 2s ease-in-out infinite;
      }

      @keyframes loading-progress {
        0% {
          transform: translateX(-100%);
        }
        50% {
          transform: translateX(0%);
        }
        100% {
          transform: translateX(100%);
        }
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen">
    <!-- ‰∏ªÈ°µÈù¢ -->
    <div class="w-full">
      <!-- Â§¥ÈÉ®Âå∫Âüü -->
      <div class="bg-white shadow-[0_1px_3px_0_rgba(0,0,0,0.1)] px-6 py-4 mb-6 w-full">
        <!-- ÊêúÁ¥¢ÂíåÊìç‰ΩúÂå∫Âüü -->
        <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
          <!-- ÊêúÁ¥¢Ê°Ü -->
          <div class="flex gap-2 items-center">
            <!-- TabÂàáÊç¢ÊåâÈíÆ -->
            <div class="flex bg-gray-100 rounded-lg p-1">
              <button id="allModelsBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn active">üìã ÂÖ®ÈÉ®</button>
              <button id="likeRecordBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn">‚ù§Ô∏è Êî∂Ëóè</button>
              <button id="downloadRecordBtn" class="px-6 py-2 rounded-md transition-all duration-200 font-medium tab-btn">üì• ÂéÜÂè≤</button>
            </div>
            <input type="text" id="searchInput" placeholder="ÊêúÁ¥¢Â≠òÊ°£‰∏ñÁïå..." class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-48" />
            <button id="searchBtn" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">üîç</button>
          </div>

          <!-- Êìç‰ΩúÊåâÈíÆ -->
          <div class="flex gap-2 flex-nowrap">
            <button
              id="uploadBtn"
              class="px-6 py-2 bg-gradient-to-r from-purple-500 to-blue-500 text-white rounded-lg hover:from-purple-600 hover:to-blue-600 transition-all shadow-lg font-semibold whitespace-nowrap"
            >
              ‚òÅÔ∏è ÊàëÁöÑ‰∫ëÂ≠òÊ°£
            </button>
          </div>
        </div>
      </div>
      <!-- Â≠òÊ°£ÂàóË°®Âå∫Âüü -->
      <div class="px-6">
        <!-- ÊéíÂ∫èÈÄâÊã©Âô® -->
        <div class="flex justify-between items-center mb-4">
          <div class="flex items-center gap-2">
            <span class="text-sm text-gray-600">ÊéíÂ∫èÔºö</span>
            <button id="sortByTime" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">‰øÆÊîπÊó∂Èó¥</button>
            <button id="sortByLikes" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">Êî∂ËóèÊï∞</button>
            <button id="sortByDownloads" class="px-3 py-1 border border-gray-300 rounded-md text-sm hover:bg-gray-50 transition-colors">‰∏ãËΩΩÊï∞</button>
          </div>
        </div>
        <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
        <div id="loadingState" class="text-center py-12 hidden">
          <div class="loading mx-auto mb-4"></div>
          <div class="loading-dots mx-auto mb-4">
            <div></div>
            <div></div>
            <div></div>
          </div>
          <p id="loadingText" class="text-gray-600 text-lg font-medium">Ê≠£Âú®Âä†ËΩΩÂ≠òÊ°£...</p>
          <p class="text-gray-400 text-sm mt-2">ËØ∑Á®çÂÄôÔºåÊ≠£Âú®Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆ</p>

          <!-- Enhanced loading animation with skeleton cards -->
          <div id="loadingSkeletons" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
            <!-- Skeleton cards will be generated by JavaScript -->
          </div>
        </div>

        <!-- Â≠òÊ°£ÂàóË°®ÂÆπÂô® -->
        <div class="relative">
          <!-- Âä†ËΩΩÊõ¥Â§öÁöÑË¶ÜÁõñÂ±Ç -->
          <div id="loadingMoreOverlay" class="loading-overlay hidden">
            <div class="bg-white rounded-lg p-6 shadow-lg text-center">
              <div class="loading mx-auto mb-3"></div>
              <p class="text-gray-600 font-medium">Âä†ËΩΩÊõ¥Â§öÂ≠òÊ°£...</p>
            </div>
          </div>

          <!-- Â≠òÊ°£ÂàóË°® -->
          <div id="modelList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Â≠òÊ°£Âç°ÁâáÂ∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
          </div>
        </div>

        <!-- Á©∫Áä∂ÊÄÅ -->
        <div id="emptyState" class="text-center py-12 hidden">
          <div class="text-gray-400 text-6xl mb-4">üì¶</div>
          <p class="text-gray-500 text-lg">ÊöÇÊó†Â≠òÊ°£Êï∞ÊçÆ</p>
        </div>
      </div>
    </div>

    <!-- ‰∏ä‰º†ÂàÜ‰∫´ÊäΩÂ±â -->
    <div id="uploadDrawer" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden">
      <div class="drawer fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl h-[60vh] overflow-hidden">
        <div class="px-6 py-4 h-full flex flex-col">
          <!-- ÊäΩÂ±âÂ§¥ÈÉ® -->
          <div class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold text-gray-800">ÊàëÁöÑ‰∫ëÂ≠òÊ°£</h2>
            <button id="closeDrawer" class="text-gray-500 hover:text-gray-700 text-3xl">√ó</button>
          </div>
          <!-- ‰∏™‰∫∫Â≠òÊ°£ÂàóË°®ÂÆπÂô® -->
          <div class="flex-1 overflow-y-auto">
            <div id="personalModelList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <!-- ‰∏™‰∫∫Â≠òÊ°£Âç°ÁâáÂ∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
            </div>

            <!-- ‰∏™‰∫∫Â≠òÊ°£Á©∫Áä∂ÊÄÅ -->
            <div id="personalEmptyState" class="text-center py-8 hidden">
              <div class="text-gray-400 text-4xl mb-2">üìÅ</div>
              <p class="text-gray-500">ËøòÊ≤°Êúâ‰∏ä‰º†‰ªª‰ΩïÂ≠òÊ°£</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Ëá™ÂÆö‰πâÁ°ÆËÆ§ÂºπÊ°Ü -->
    <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
      <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4 transform transition-all duration-300 scale-95">
        <div class="text-center">
          <!-- ÂõæÊ†á -->
          <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
            <svg class="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"
              />
            </svg>
          </div>
          <!-- Ê†áÈ¢ò -->
          <h3 class="text-lg font-medium text-gray-900 mb-2" id="confirmTitle">Á°ÆËÆ§Âà†Èô§</h3>
          <!-- ÂÜÖÂÆπ -->
          <p class="text-sm text-gray-500 mb-6" id="confirmMessage">Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Â≠òÊ°£ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ</p>
          <!-- ÊåâÈíÆ -->
          <div class="flex gap-3 justify-center">
            <button
              id="confirmCancelBtn"
              class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
            >
              ÂèñÊ∂à
            </button>
            <button
              id="confirmOkBtn"
              class="px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
            >
              Á°ÆÂÆöÂà†Èô§
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Â≠òÊ°£ÁºñËæëÊ®°ÊÄÅÊ°Ü -->
    <div id="editModal" class="fixed inset-0 bg-black bg-opacity-50 z-[70] hidden">
      <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
          <h3 class="text-lg font-semibold mb-4">ÁºñËæëÂ≠òÊ°£‰ø°ÊÅØ</h3>
          <form id="editForm">
            <input type="hidden" id="editModelId" />
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">Â≠òÊ°£ÂêçÁß∞</label>
              <input type="text" id="editModelName" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" required />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">Â≠òÊ°£URL</label>
              <input type="text" id="editModelUrl" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" readonly />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">Â≠òÊ°£Â§ßÂ∞è</label>
              <input type="url" id="editModelSize" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" readonly />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">Ê†áÁ≠æ</label>
              <input type="text" id="editModelTag" class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-100 focus:outline-none" value="maisiAI" readonly />
            </div>
            <div class="flex gap-2">
              <button type="submit" class="flex-1 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">üíæ‰øùÂ≠ò</button>
              <button type="button" id="cancelEdit" class="flex-1 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition-colors">‚ùåÂèñÊ∂à</button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <!-- ‰øùÂ≠òÂ≠òÊ°£Á°ÆËÆ§ÂºπÊ°Ü -->
    <div id="saveConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 z-[75] hidden">
      <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
          <div class="text-center">
            <!-- ÂõæÊ†á -->
            <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100 mb-4">
              <svg class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
              </svg>
            </div>
            <!-- Ê†áÈ¢ò -->
            <h3 class="text-lg font-medium text-gray-900 mb-2">‰øùÂ≠òÂ≠òÊ°£</h3>
            <!-- ÂÜÖÂÆπ -->
            <div class="text-sm text-gray-600 mb-6">
              <p class="mb-3">Á°ÆËÆ§Ë¶Å‰øùÂ≠òÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅÂà∞Â≠òÊ°£ÂêóÔºü</p>
              <div class="bg-gray-50 rounded-lg p-4 text-left">
                <div class="space-y-2">
                  <div class="flex justify-between">
                    <span class="text-gray-500">Â≠òÊ°£ÂêçÁß∞Ôºö</span>
                    <input type="text" id="saveConfirmName" class="text-gray-900 bg-transparent border-b border-gray-300 focus:border-blue-500 focus:outline-none text-right" readonly />
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-500">Â≠òÊ°£URLÔºö</span>
                    <span id="saveConfirmUrl" class="text-gray-900 text-xs truncate max-w-[200px]">Ëé∑Âèñ‰∏≠...</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-500">Êñá‰ª∂Â§ßÂ∞èÔºö</span>
                    <span id="saveConfirmSize" class="text-gray-900">Ëé∑Âèñ‰∏≠...</span>
                  </div>
                </div>
              </div>
              <div class="mt-3 text-xs text-gray-500">
                <p>üí° Âè™ËÉΩ‰øÆÊîπÂ≠òÊ°£ÂêçÁß∞ÔºåURLÂíåÂ§ßÂ∞èÂ∞ÜËá™Âä®‰ªéÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅËé∑Âèñ</p>
              </div>
            </div>
            <!-- ÊåâÈíÆ -->
            <div class="flex gap-3 justify-center">
              <button
                id="saveConfirmCancelBtn"
                class="px-6 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
              >
                ÂèñÊ∂à
              </button>
              <button
                id="saveConfirmOkBtn"
                class="px-6 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
              >
                <span class="flex items-center">
                  <span id="saveConfirmBtnText">Á°ÆËÆ§‰øùÂ≠ò</span>
                  <div id="saveConfirmLoading" class="loading-small ml-2 hidden"></div>
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ÈÄöÁî®Ê∂àÊÅØÂºπÊ°Ü -->
    <div id="messageToast" class="fixed top-4 right-4 z-[80] transform translate-x-full opacity-0 transition-all duration-300 ease-in-out pointer-events-none">
      <div class="bg-white border border-gray-200 rounded-lg shadow-lg p-4 min-w-[300px] max-w-[400px]">
        <div class="flex items-start space-x-3">
          <div id="toastIcon" class="flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center">
            <!-- ÂõæÊ†áÂ∞ÜÈÄöËøáJavaScriptÂä®ÊÄÅËÆæÁΩÆ -->
          </div>
          <div class="flex-1">
            <p id="toastMessage" class="text-sm text-gray-800 font-medium"></p>
          </div>
          <button id="closeToast" class="flex-shrink-0 text-gray-400 hover:text-gray-600 transition-colors">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script>
      // Initialize SDK
      const sdk = new KeepworkSDK({
        timeout: 30000,
      });
      const maxHistory = 100;
      // APIÈÖçÁΩÆ
      const API_BASE = "https://api.keepwork.com/core/v0";
      const DEFAULT_TAG = "maisiAI";
      const pageName = "modelWorld";      // È°µÈù¢Áä∂ÊÄÅ
      let USER_ID = 1; // Á§∫‰æãÁî®Êà∑IDÔºåÂÆûÈôÖÂ∫îÁî®‰∏≠Â∫î‰ªéÁôªÂΩïÁä∂ÊÄÅËé∑Âèñ
      let currentView = "all"; // 'all', 'liked', 'downloaded'
      let currentModels = [];
      let personalModels = [];
      let likeModels = [];
      let downloadModels = [];
      let currentTag = DEFAULT_TAG; // ‰ªéURLËé∑ÂèñÂΩìÂâçÊ†áÁ≠æ
      let keepworkToken = "";
      let keepworkUserInfo = {};
      
      // ÁºìÂ≠òÁöÑÊî∂ËóèÊï∞ÊçÆ
      let cachedLikedModels = null;
      let likedModelsLoading = false;

      // ÂàÜÈ°µÂíåÊéíÂ∫èÁä∂ÊÄÅ
      let currentPage = 1;
      let perPage = 20;
      let isLoading = false;
      let hasMoreData = true;
      let currentSort = { field: "", order: "desc" }; // DOMÂÖÉÁ¥†
      const elements = {
        searchInput: document.getElementById("searchInput"),
        searchBtn: document.getElementById("searchBtn"),
        allModelsBtn: document.getElementById("allModelsBtn"),
        uploadBtn: document.getElementById("uploadBtn"),
        likeRecordBtn: document.getElementById("likeRecordBtn"),
        downloadRecordBtn: document.getElementById("downloadRecordBtn"),
        modelList: document.getElementById("modelList"),
        loadingState: document.getElementById("loadingState"),
        loadingMoreOverlay: document.getElementById("loadingMoreOverlay"),
        emptyState: document.getElementById("emptyState"),
        sortByTime: document.getElementById("sortByTime"),
        sortByLikes: document.getElementById("sortByLikes"),
        sortByDownloads: document.getElementById("sortByDownloads"),
        uploadDrawer: document.getElementById("uploadDrawer"),
        closeDrawer: document.getElementById("closeDrawer"),
        personalModelList: document.getElementById("personalModelList"),
        personalEmptyState: document.getElementById("personalEmptyState"),
        editModal: document.getElementById("editModal"),
        editForm: document.getElementById("editForm"),
        cancelEdit: document.getElementById("cancelEdit"),
        messageToast: document.getElementById("messageToast"),
        toastIcon: document.getElementById("toastIcon"),
        toastMessage: document.getElementById("toastMessage"),
        closeToast: document.getElementById("closeToast"),
      };

      // ÈÄöÁî®Ê∂àÊÅØÂºπÊ°ÜÂáΩÊï∞
      function showToast(message, type = "info", duration = 2000) {
        const toast = elements.messageToast;
        const icon = elements.toastIcon;
        const messageEl = elements.toastMessage;

        // ËÆæÁΩÆÊ∂àÊÅØÂÜÖÂÆπ
        messageEl.textContent = message;

        // Ê†πÊçÆÁ±ªÂûãËÆæÁΩÆÂõæÊ†áÂíåÈ¢úËâ≤
        switch (type) {
          case "success":
            icon.innerHTML = "‚úÖ";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-green-100 text-green-600";
            break;
          case "error":
            icon.innerHTML = "‚ùå";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-red-100 text-red-600";
            break;
          case "warning":
            icon.innerHTML = "‚ö†Ô∏è";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-yellow-100 text-yellow-600";
            break;
          default: // info
            icon.innerHTML = "‚ÑπÔ∏è";
            icon.className = "flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center bg-blue-100 text-blue-600";
        }

        // ÊòæÁ§∫ÂºπÊ°Ü
        toast.classList.remove("translate-x-full", "opacity-0", "pointer-events-none");
        toast.classList.add("translate-x-0", "opacity-100", "pointer-events-auto");

        // Ëá™Âä®ÈöêËóè
        if (duration > 0) {
          setTimeout(() => {
            hideToast();
          }, duration);
        }
      }

      // ÈöêËóèÂºπÊ°Ü
      function hideToast() {
        const toast = elements.messageToast;
        toast.classList.remove("translate-x-0", "opacity-100", "pointer-events-auto");
        toast.classList.add("translate-x-full", "opacity-0", "pointer-events-none");
      }

      // ËÆæÁΩÆÊ¥ªË∑ÉÁöÑtab
      function setActiveTab(activeTabId) {
        // ÁßªÈô§ÊâÄÊúâtabÁöÑactiveÁ±ª
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        // ‰∏∫ÂΩìÂâçtabÊ∑ªÂä†activeÁ±ª
        document.getElementById(activeTabId).classList.add("active");
      }

      // APIË∞ÉÁî®ÂáΩÊï∞
      async function apiCall(endpoint, options = {}, needToken = true) {
        try {
          // ÂáÜÂ§áheaders
          let headers = {
            ...options.headers, // ÂÖàÂ±ïÂºÄ‰º†ÂÖ•ÁöÑheaders
          };
          if (options.body && !headers["Content-Type"] && !headers["content-type"]) {
            headers["Content-Type"] = "application/json";
          }
          if (needToken) {
            if (needToken) {
              headers["Authorization"] = `Bearer ${keepworkToken}`;
            }
          }

          const response = await fetch(`${API_BASE}${endpoint}`, {
            headers: headers,
            ...options,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // Â∞ùËØïËß£ÊûêJSONÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôËøîÂõûÂéüÂßãÊñáÊú¨
          const responseText = await response.text();
          try {
            return JSON.parse(responseText);
          } catch (jsonError) {
            return responseText;
          }
        } catch (error) {
          console.error("APIË∞ÉÁî®Â§±Ë¥•:", error);
          showToast("ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï", "error");
          throw error;
        }
      }

      async function startUploadModel() {
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error("Ëé∑ÂèñÂΩìÂâçÂ≠òÊ°£URLË∂ÖÊó∂"));
          }, 5000);

          const handleMessage = (e) => {
            if (e.data && e.data.type === "setGameConfig" && e.data.data && e.data.data.type === "modelUrlResponse") {
              clearTimeout(timeout);
              // Ê£ÄÊü•Ê®°ÂûãURLÊòØÂê¶‰∏∫Á©∫
              window.removeEventListener("message", handleMessage);
              if (!e.data.data.modelUrl || e.data.data.result === false) {
                reject(new Error("Ëé∑ÂèñÂΩìÂâçÂ≠òÊ°£URLÂ§±Ë¥•ÔºåËØ∑ÂÖàËøîÂõûÊ∏∏Êàè‰øùÂ≠òÂΩìÂâçÂ≠òÊ°£"));
                return;
              }
              resolve({
                modelUrl: e.data.data.modelUrl,
                size: e.data.data.size,
              });
            }
          };

          window.addEventListener("message", handleMessage);
          window.parent.postMessage({ type: "requestModelUrl" }, "*");
        });
      }

      // Ëé∑ÂèñÂ≠òÊ°£ÂàóË°®
      async function loadModels(tag = null, userId = null, page = 1, append = false) {
        if (isLoading) return;
        isLoading = true;

        if (!append) {
          showLoading(true);
          currentPage = 1;
          hasMoreData = true;
        }

        try {
          // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•tagÂèÇÊï∞Ôºå‰ΩøÁî®ÂΩìÂâçÊ†áÁ≠æ
          const tagToUse = tag || currentTag;
          const params = new URLSearchParams({
            tag: tagToUse,
            "x-page": page,
            "x-per-page": perPage,
          });

          if (userId) params.append("userId", userId);

          // Ê∑ªÂä†ÊéíÂ∫èÂèÇÊï∞
          if (currentSort.field) {
            params.append("x-order", `${currentSort.field}-${currentSort.order}`);
          }

          const result = await apiCall(`/mall/getModelsByTag?${params}`);
          const newModels = result?.rows || [];

          if (append) {
            currentModels = [...currentModels, ...newModels];
          } else {
            currentModels = newModels;
          }

          // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÊõ¥Â§öÊï∞ÊçÆ
          hasMoreData = newModels.length === perPage;
          currentPage = page;

          await renderModelList(currentModels, append);
        } catch (error) {
          if (!append) {
            showEmptyState();
          }
        } finally {
          isLoading = false;
          if (!append) {
            showLoading(false);
          }
        }
      }      // Ê∏≤ÊüìÂ≠òÊ°£ÂàóË°®
      async function renderModelList(models, append = false) {
        if (!models || models.length === 0) {
          if (!append) {
            showEmptyState();
          }
          return;
        }

        // Ëé∑ÂèñÊî∂ËóèÁä∂ÊÄÅÊï∞ÊçÆÔºàÂè™Âú®Á¨¨‰∏ÄÊ¨°Ê∏≤ÊüìÊàñÈùûËøΩÂä†Ê®°ÂºèÊó∂Ëé∑ÂèñÔºâ
        let likedModels = cachedLikedModels;
        if (!append || !cachedLikedModels) {
          likedModels = await loadLikedModelsCache();
        }

        if (append) {
          // ËøΩÂä†Ê®°ÂºèÔºöÂè™Ê∑ªÂä†Êñ∞ÁöÑÂ≠òÊ°£Âç°Áâá
          const newCards = models.slice(currentModels.length - (models.length - currentModels.length));
          const newCardsHtml = newCards.map((model) => createModelCard(model, likedModels)).join("");
          elements.modelList.insertAdjacentHTML("beforeend", newCardsHtml);
        } else {
          // ÊõøÊç¢Ê®°ÂºèÔºöÈáçÊñ∞Ê∏≤ÊüìÊâÄÊúâÂ≠òÊ°£
          const cardsHtml = models.map((model) => createModelCard(model, likedModels)).join("");
          elements.modelList.innerHTML = cardsHtml;
        }        elements.emptyState.classList.add("hidden");
      }

      // Âä†ËΩΩÊî∂ËóèÊ®°ÂûãÁºìÂ≠ò
      async function loadLikedModelsCache() {
        if (likedModelsLoading) {
          // Â¶ÇÊûúÊ≠£Âú®Âä†ËΩΩÔºåÁ≠âÂæÖÂä†ËΩΩÂÆåÊàê
          while (likedModelsLoading) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          return cachedLikedModels || [];
        }

        if (cachedLikedModels !== null) {
          return cachedLikedModels;
        }

        likedModelsLoading = true;
        try {
          cachedLikedModels = (await sdk.personalPageStore.loadPageData(pageName, "liked")) || [];
          return cachedLikedModels;
        } catch (error) {
          console.error("Failed to load liked models:", error);
          cachedLikedModels = [];
          return [];
        } finally {
          likedModelsLoading = false;
        }
      }

      // Âà∑Êñ∞Êî∂ËóèÁºìÂ≠ò
      function refreshLikedModelsCache() {
        cachedLikedModels = null;
      }

      // Êõ¥Êñ∞Âçï‰∏™Âç°ÁâáÁöÑÊî∂ËóèÁä∂ÊÄÅ
      function updateCardLikedStatus(modelId, isLiked) {
        const card = document.querySelector(`button[onclick="likeModel(${modelId})"]`);
        if (card) {
          if (isLiked) {
            card.className = "flex-1 py-2 bg-gray-100 text-gray-400 cursor-not-allowed rounded transition-colors text-sm";
            card.disabled = true;
            card.innerHTML = "‚ù§Ô∏èÂ∑≤Êî∂Ëóè";
          } else {
            card.className = "flex-1 py-2 bg-red-50 text-red-600 hover:bg-red-100 rounded transition-colors text-sm";
            card.disabled = false;
            card.innerHTML = "‚ù§Ô∏èÊî∂Ëóè";
          }
        }
      }

      // ÂàõÂª∫Â≠òÊ°£Âç°Áâá
      function createModelCard(model, likedModels = []) {
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Êî∂Ëóè
        const isLiked = likedModels.some((likedModel) => likedModel.id === model.id);

        return `
                <div class="model-card bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="font-semibold text-gray-800 truncate flex-1">${model.name || "Êú™ÂëΩÂêçÂ≠òÊ°£"}</h3>
                        <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">#${model.id || "0"}</span>
                    </div>
                    
                    <div class="flex items-center justify-between text-sm text-gray-600 mb-4">
                        <div class="flex items-center gap-4">
                            <span class="flex items-center gap-1">
                                ‚ù§Ô∏è ${model.likes || 0}
                            </span>
                            <span class="flex items-center gap-1">
                                üì• ${model.downloads || 0}
                            </span>
                        </div>
                        <span class="text-xs text-gray-400">Â§ßÂ∞èÔºö${formatFileSize(model.size)}</span>
                    </div>
                    
                    <div class="flex gap-2">
                        <button 
                            onclick="likeModel(${model.id})" 
                            class="flex-1 py-2 ${isLiked ? "bg-gray-100 text-gray-400 cursor-not-allowed" : "bg-red-50 text-red-600 hover:bg-red-100"} rounded transition-colors text-sm"
                            ${isLiked ? "disabled" : ""}
                        >
                            ${isLiked ? "‚ù§Ô∏èÂ∑≤Êî∂Ëóè" : "‚ù§Ô∏èÊî∂Ëóè"}
                        </button>
                        <button 
                            onclick="downloadModel(${model.id})" 
                            class="flex-1 py-2 bg-green-50 text-green-600 rounded hover:bg-green-100 transition-colors text-sm"
                        >
                            üì•‰∏ãËΩΩ
                        </button>
                    </div>
                </div>
            `;
      }

      // ÂàõÂª∫‰∏™‰∫∫Â≠òÊ°£Âç°Áâá
      function createPersonalModelCard(model) {
        return `
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 relative">
                    <!-- Âà†Èô§ÊåâÈíÆ - Âè≥‰∏äËßí -->
                    <button 
                        onclick="confirmDeleteModel(${model.id})" 
                        class="absolute top-2 right-2 w-6 h-6 flex items-center justify-center text-red-500 hover:bg-red-100 rounded-full transition-colors text-sm"
                        title="Âà†Èô§Ê®°Âûã"
                    >
                        üóëÔ∏è
                    </button>
                    
                    <div class="flex items-center justify-between mb-2 pr-8">
                        <div class="flex items-center gap-2 flex-1">
                            <h4 id="modelName_${model.id}" class="font-medium text-gray-800 truncate">${model.name || "Êú™ÂëΩÂêçÂ≠òÊ°£"}</h4>
                            <button 
                                onclick="editModelName(${model.id})" 
                                class="text-gray-400 hover:text-blue-500 transition-colors"
                                title="ÁºñËæëÂêçÁß∞"
                            >
                                ‚úèÔ∏è
                            </button>
                        </div>
                        <span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded">#${model.id || "0"}</span>
                    </div>
                    
                    <!-- ÂêçÁß∞ÁºñËæëÊ°Ü - ÈªòËÆ§ÈöêËóè -->
                    <div id="editNameBox_${model.id}" class="mb-2 pr-8 hidden">
                        <div class="flex gap-2">
                            <input 
                                type="text" 
                                id="editNameInput_${model.id}" 
                                value="${model.name || "Êú™ÂëΩÂêçÂ≠òÊ°£"}"
                                class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="ËæìÂÖ•Ê®°ÂûãÂêçÁß∞"
                            >
                            <button 
                                onclick="saveModelName(${model.id})" 
                                class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                            >
                                Á°ÆÂÆö
                            </button>
                            <button 
                                onclick="cancelEditName(${model.id})" 
                                class="px-3 py-1 bg-gray-300 text-gray-700 rounded text-sm hover:bg-gray-400"
                            >
                                ÂèñÊ∂à
                            </button>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between text-sm text-gray-600 mb-3">
                        <div class="flex items-center gap-3">
                            <span>‚ù§Ô∏è ${model.likes || 0}</span>
                            <span>üì• ${model.downloads || 0}</span>
                        </div>
                        <span class="text-xs">Â§ßÂ∞èÔºö${formatFileSize(model.size)}</span>
                        <span class="text-xs">Êõ¥Êñ∞Êó∂Èó¥Ôºö${formatTimeAgo(model.updatedAt)}</span>
                    </div>
                    
                    <div class="flex gap-2">
                        <button 
                            onclick="loadPersonalModel(${model.id})" 
                            class="flex-1 py-1 bg-green-50 text-green-600 rounded hover:bg-green-100 transition-colors text-sm"
                        >
                            üìÇ Âä†ËΩΩ
                        </button>
                        <button 
                            onclick="savePersonalModel(${model.id})" 
                            class="flex-1 py-1 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition-colors text-sm"
                        >
                            üíæ ‰øùÂ≠ò
                        </button>
                    </div>
                </div>
            `;
      }

      // ÂàõÂª∫‰∏ä‰º†Êñ∞Â≠òÊ°£ÁöÑÂç†‰ΩçUIÂç°Áâá
      function createUploadPlaceholderCard() {
        return `
                <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-dashed border-blue-300 rounded-lg p-4 relative hover:from-blue-100 hover:to-indigo-100 transition-all cursor-pointer" onclick="handleUploadClick()">
                    <div class="flex flex-col items-center justify-center">
                        <div class="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center mb-2 hover:bg-blue-600 transition-colors">
                            <span class="text-white text-2xl font-light">+</span>
                        </div>
                        <h4 class="font-medium text-blue-700 text-sm mb-1">‰∏ä‰º†Êñ∞Â≠òÊ°£</h4>
                        <p class="text-xs text-blue-500 text-center">ÁÇπÂáªËá™Âä®‰∏ä‰º†ÂΩìÂâçÂ≠òÊ°£</p>
                    </div>
                </div>
            `;
      } // ÊòæÁ§∫/ÈöêËóèÂä†ËΩΩÁä∂ÊÄÅ
      function showLoading(show) {
        elements.loadingState.classList.toggle("hidden", !show);
        elements.modelList.classList.toggle("hidden", show);

        if (show) {
          // Generate skeleton cards and animate loading text
          generateSkeletonCards();
          animateLoadingText();
          // Add progress bar
          addLoadingProgress();
        } else {
          // Clear skeleton cards when hiding
          clearSkeletonCards();
          clearLoadingAnimations();
        }
      }

      // Generate skeleton loading cards
      function generateSkeletonCards() {
        const skeletonsContainer = document.getElementById("loadingSkeletons");
        if (!skeletonsContainer) return;

        // Clear existing skeletons
        skeletonsContainer.innerHTML = "";

        // Generate 6 skeleton cards
        for (let i = 0; i < 6; i++) {
          const skeletonCard = document.createElement("div");
          skeletonCard.className = "skeleton-card";
          skeletonCard.innerHTML = `
            <div class="flex items-center justify-between mb-3">
              <div class="skeleton-line medium"></div>
              <div class="skeleton-line short" style="width: 40px; height: 20px;"></div>
            </div>
            <div class="flex items-center justify-between text-sm text-gray-600 mb-4">
              <div class="flex items-center gap-4">
                <div class="skeleton-line short" style="width: 30px; height: 14px;"></div>
                <div class="skeleton-line short" style="width: 30px; height: 14px;"></div>
              </div>
              <div class="skeleton-line short" style="width: 60px; height: 14px;"></div>
            </div>
            <div class="flex gap-2">
              <div class="skeleton-button"></div>
              <div class="skeleton-button"></div>
            </div>
          `;

          // Add staggered animation delay
          skeletonCard.style.animationDelay = `${i * 0.2}s`;
          skeletonsContainer.appendChild(skeletonCard);
        }
      }

      // Clear skeleton cards
      function clearSkeletonCards() {
        const skeletonsContainer = document.getElementById("loadingSkeletons");
        if (skeletonsContainer) {
          skeletonsContainer.innerHTML = "";
        }
      }

      // Animate loading text
      function animateLoadingText() {
        const loadingText = document.getElementById("loadingText");
        if (!loadingText) return;

        const loadingMessages = ["Ê≠£Âú®Âä†ËΩΩÂ≠òÊ°£...", "Ê≠£Âú®Ëé∑ÂèñÊï∞ÊçÆ...", "Ê≠£Âú®Ëß£ÊûêÂÜÖÂÆπ...", "Âç≥Â∞ÜÂÆåÊàêÂä†ËΩΩ..."];

        let messageIndex = 0;

        // Clear any existing interval
        if (window.loadingTextInterval) {
          clearInterval(window.loadingTextInterval);
        }

        // Set initial animation class
        loadingText.classList.add("loading-text-animated");

        // Change text every 2 seconds
        window.loadingTextInterval = setInterval(() => {
          messageIndex = (messageIndex + 1) % loadingMessages.length;
          loadingText.textContent = loadingMessages[messageIndex];
        }, 2000);
      }

      // Add loading progress bar
      function addLoadingProgress() {
        const loadingState = document.getElementById("loadingState");
        if (!loadingState) return;

        // Check if progress bar already exists
        let progressContainer = loadingState.querySelector(".loading-progress");
        if (progressContainer) return;

        // Create progress bar
        progressContainer = document.createElement("div");
        progressContainer.className = "loading-progress";

        const progressBar = document.createElement("div");
        progressBar.className = "loading-progress-bar";

        progressContainer.appendChild(progressBar);
        loadingState.appendChild(progressContainer);
      }

      // Clear loading animations
      function clearLoadingAnimations() {
        // Clear loading text interval
        if (window.loadingTextInterval) {
          clearInterval(window.loadingTextInterval);
          window.loadingTextInterval = null;
        }

        // Reset loading text
        const loadingText = document.getElementById("loadingText");
        if (loadingText) {
          loadingText.classList.remove("loading-text-animated");
          loadingText.textContent = "Ê≠£Âú®Âä†ËΩΩÂ≠òÊ°£...";
        }

        // Remove progress bar
        const loadingState = document.getElementById("loadingState");
        if (loadingState) {
          const progressContainer = loadingState.querySelector(".loading-progress");
          if (progressContainer) {
            progressContainer.remove();
          }
        }
      }

      // ÊòæÁ§∫Á©∫Áä∂ÊÄÅ
      function showEmptyState() {
        elements.emptyState.classList.remove("hidden");
        elements.modelList.classList.add("hidden");
      }

      // Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
      function formatFileSize(bytes) {
        if (!bytes) return "Êú™Áü•";
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + " " + sizes[i];
      }

      // Ê†ºÂºèÂåñÊó∂Èó¥‰∏∫Áõ∏ÂØπÊó∂Èó¥ÊòæÁ§∫
      function formatTimeAgo(utcTimeString) {
        if (!utcTimeString || utcTimeString === "Êú™Áü•") return "Êú™Áü•";

        try {
          const now = new Date();
          const time = new Date(utcTimeString);
          const diffMs = now - time;

          // Â¶ÇÊûúÊó∂Èó¥Â∑Æ‰∏∫Ë¥üÊï∞ÊàñÊó†ÊïàÔºåËøîÂõûÊú™Áü•
          if (diffMs < 0 || isNaN(diffMs)) return "Êú™Áü•";

          const diffSeconds = Math.floor(diffMs / 1000);
          const diffMinutes = Math.floor(diffSeconds / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          const diffDays = Math.floor(diffHours / 24);
          const diffMonths = Math.floor(diffDays / 30);
          const diffYears = Math.floor(diffDays / 365);

          if (diffYears > 0) {
            return `${diffYears}Âπ¥Ââç`;
          } else if (diffMonths > 0) {
            return `${diffMonths}‰∏™ÊúàÂâç`;
          } else if (diffDays > 0) {
            return `${diffDays}Â§©Ââç`;
          } else if (diffHours > 0) {
            return `${diffHours}Â∞èÊó∂Ââç`;
          } else if (diffMinutes > 0) {
            return `${diffMinutes}ÂàÜÈíüÂâç`;
          } else if (diffSeconds > 30) {
            return `${diffSeconds}ÁßíÂâç`;
          } else {
            return "ÂàöÂàö";
          }
        } catch (error) {
          console.error("Êó∂Èó¥Ê†ºÂºèÂåñÈîôËØØ:", error);
          return "Êú™Áü•";
        }
      }

      // Ëß£ÊûêÊñá‰ª∂Â§ßÂ∞èÂ≠óÁ¨¶‰∏≤‰∏∫Â≠óËäÇÊï∞
      function parseFileSize(sizeStr) {
        if (!sizeStr || sizeStr === "Êú™Áü•") return 0;

        const sizes = ["B", "KB", "MB", "GB"];
        const regex = /^([\d.]+)\s*(B|KB|MB|GB)$/i;
        const match = sizeStr.trim().match(regex);

        if (!match) return 0;

        const value = parseFloat(match[1]);
        const unit = match[2].toUpperCase();
        const unitIndex = sizes.indexOf(unit);

        if (unitIndex === -1) return 0;

        return Math.round(value * Math.pow(1024, unitIndex));
      } // ÁÇπËµûÂ≠òÊ°£
      async function likeModel(modelId) {
        // Find the like button and show loading state
        const likeButton = document.querySelector(`button[onclick="likeModel(${modelId})"]`);
        const originalText = likeButton ? likeButton.innerHTML : "";

        if (likeButton) {
          likeButton.disabled = true;
          likeButton.innerHTML = '<div class="loading-small mr-1"></div>Êî∂Ëóè‰∏≠...';
        }        try {
          // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊî∂ËóèËøáÔºà‰ΩøÁî®ÁºìÂ≠òÔºâ
          let likedModels = await loadLikedModelsCache();
          let likedModelsCopy = JSON.parse(JSON.stringify(likedModels));
          const alreadyLiked = likedModelsCopy.find((model) => model.id === modelId);

          if (alreadyLiked) {
            showToast("Â∑≤ÁªèÊî∂ËóèËøá‰∫ÜÔºÅ", "warning");
            return;
          }

          await apiCall(`/mall/personalModels/${modelId}/likes`, { method: "POST" });

          // Ëé∑ÂèñÂÆåÊï¥ÁöÑÊ®°ÂûãÊï∞ÊçÆÂπ∂Ê∑ªÂä†Âà∞Êî∂ËóèÂàóË°®
          const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}`);
          const allModels = result?.rows || [];
          const modelToLike = allModels.find((model) => model.id === modelId);

          if (modelToLike) {
            // Ê∑ªÂä†Êî∂ËóèÊó∂Èó¥Êà≥
            modelToLike.likedAt = new Date().toISOString();

            // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖËøámaxHistoryÊù°ÈôêÂà∂
            if (likedModelsCopy.length >= maxHistory) {
              // ÊåâÊî∂ËóèÊó∂Èó¥ÊéíÂ∫èÔºåÁßªÈô§ÊúÄÊó©ÁöÑËÆ∞ÂΩï
              likedModelsCopy.sort((a, b) => {
                const timeA = new Date(a.likedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.likedAt || b.created_at || 0).getTime();
                return timeA - timeB;
              });
              // ÁßªÈô§ÊúÄÊó©ÁöÑËÆ∞ÂΩï
              likedModelsCopy.shift();
            }

            likedModelsCopy.push(modelToLike);
            await sdk.personalPageStore.savePageData(pageName, "liked", likedModelsCopy);
            
            // Âà∑Êñ∞ÁºìÂ≠ò
            cachedLikedModels = likedModelsCopy;
            
            // Á´ãÂç≥Êõ¥Êñ∞ÂΩìÂâçÂç°ÁâáÁöÑÊî∂ËóèÁä∂ÊÄÅ
            updateCardLikedStatus(modelId, true);
          }

          showToast("Êî∂ËóèÊàêÂäüÔºÅ", "success");

          // ÈáçÊñ∞Âä†ËΩΩÂΩìÂâçËßÜÂõæÔºàÂè™ÊúâÂú®Êî∂ËóèËßÜÂõæÊó∂ÊâçÈúÄË¶ÅÂÆåÂÖ®ÈáçÊñ∞Âä†ËΩΩÔºâ
          if (currentView === "liked") {
            loadLikedModels();
          }
        } catch (error) {
          // ÈîôËØØÂ∑≤Âú®apiCall‰∏≠Â§ÑÁêÜ
        } finally {
          // Restore button state
          if (likeButton) {
            likeButton.disabled = false;
            likeButton.innerHTML = originalText;
          }
        }
      } // ‰∏ãËΩΩÂ≠òÊ°£
      async function downloadModel(modelId) {
        // Find the download button and show loading state
        const downloadButton = document.querySelector(`button[onclick="downloadModel(${modelId})"]`);
        const originalText = downloadButton ? downloadButton.innerHTML : "";

        if (downloadButton) {
          downloadButton.disabled = true;
          downloadButton.innerHTML = '<div class="loading-small mr-1"></div>‰∏ãËΩΩ‰∏≠...';
        }

        try {
          await apiCall(`/mall/personalModels/${modelId}/downloads`, { method: "POST" });

          // Ëé∑ÂèñÂÆåÊï¥ÁöÑÊ®°ÂûãÊï∞ÊçÆÂπ∂Ê∑ªÂä†Âà∞‰∏ãËΩΩÂàóË°®
          let personalDatas = (await sdk.personalPageStore.loadPageData(pageName, "downloaded")) || [];
          let downloadedModels = JSON.parse(JSON.stringify(personalDatas));
          let existingModel = downloadedModels.find((model) => model.id === modelId);
          let currentModel;
          if (existingModel) {
            // Â¶ÇÊûúÂ∑≤Â≠òÂú®ÔºåÊõ¥Êñ∞‰∏ãËΩΩÊ¨°Êï∞ÂíåÊó∂Èó¥
            existingModel.downloads = (existingModel.downloads || 0) + 1;
            existingModel.lastDownloadedAt = new Date().toISOString();
            currentModel = existingModel;
          } else {
            // Â¶ÇÊûú‰∏çÂ≠òÂú®ÔºåËé∑ÂèñÂÆåÊï¥Ê®°ÂûãÊï∞ÊçÆÂπ∂Ê∑ªÂä†
            const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}`);
            const allModels = result?.rows || [];
            const modelToDownload = allModels.find((model) => model.id === modelId);

            if (modelToDownload) {
              modelToDownload.downloads = 1;
              modelToDownload.lastDownloadedAt = new Date().toISOString();

              // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖËøámaxHistoryÊù°ÈôêÂà∂
              if (downloadedModels.length >= maxHistory) {
                // Êåâ‰∏ãËΩΩÊó∂Èó¥ÊéíÂ∫èÔºåÁßªÈô§ÊúÄÊó©ÁöÑËÆ∞ÂΩï
                downloadedModels.sort((a, b) => {
                  const timeA = new Date(a.lastDownloadedAt || a.created_at || 0).getTime();
                  const timeB = new Date(b.lastDownloadedAt || b.created_at || 0).getTime();
                  return timeA - timeB;
                });
                // ÁßªÈô§ÊúÄÊó©ÁöÑËÆ∞ÂΩï
                downloadedModels.shift();
              }
              currentModel = modelToDownload;
              downloadedModels.push(modelToDownload);
            }
          }

          showToast("‰∏ãËΩΩËÆ∞ÂΩïÂ∑≤‰øùÂ≠òÔºÅ", "success");
          await sdk.personalPageStore.savePageData(pageName, "downloaded", downloadedModels, true);
          await new Promise((resolve) => setTimeout(resolve, 500));

          // ÂèëÈÄÅloadModelÊ∂àÊÅØÁªôÁà∂Á™óÂè£
          console.log("Loading public model:", v);
          window.parent.postMessage(
            {
              type: "loadModel",
              modelId: currentModel.id,
              modelData: {
                id: currentModel.id,
                name: currentModel.name,
                modelUrl: currentModel.modelUrl,
                size: currentModel.size,
                tag: currentModel.tag,
                likes: currentModel.likes,
                downloads: currentModel.downloads,
                updatedAt: currentModel.updatedAt,
              },
            },
            "*"
          );
          if (currentView === "all") {
            loadModels();
          } else if (currentView === "downloaded") {
            loadDownloadedModels();
          }
        } catch (error) {
          // ÈîôËØØÂ∑≤Âú®apiCall‰∏≠Â§ÑÁêÜ
        } finally {
          // Restore button state
          if (downloadButton) {
            downloadButton.disabled = false;
            downloadButton.innerHTML = originalText;
          }
        }
      }

      // Ëá™ÂÆö‰πâÁ°ÆËÆ§ÂºπÊ°ÜÂáΩÊï∞
      function showCustomConfirm(title, message, onConfirm, onCancel) {
        const modal = document.getElementById("customConfirmModal");
        const titleEl = document.getElementById("confirmTitle");
        const messageEl = document.getElementById("confirmMessage");
        const confirmBtn = document.getElementById("confirmOkBtn");
        const cancelBtn = document.getElementById("confirmCancelBtn");

        // ËÆæÁΩÆÂÜÖÂÆπ
        titleEl.textContent = title;
        messageEl.textContent = message;

        // ÊòæÁ§∫ÂºπÊ°Ü
        modal.classList.remove("hidden");
        setTimeout(() => modal.classList.add("show"), 10);

        // ÁªëÂÆö‰∫ã‰ª∂
        const handleConfirm = () => {
          hideCustomConfirm();
          if (onConfirm) onConfirm();
        };

        const handleCancel = () => {
          hideCustomConfirm();
          if (onCancel) onCancel();
        };

        // ÁßªÈô§‰πãÂâçÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
        confirmBtn.replaceWith(confirmBtn.cloneNode(true));
        cancelBtn.replaceWith(cancelBtn.cloneNode(true));

        // ÈáçÊñ∞Ëé∑ÂèñÂÖÉÁ¥†Âπ∂Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
        const newConfirmBtn = document.getElementById("confirmOkBtn");
        const newCancelBtn = document.getElementById("confirmCancelBtn");

        newConfirmBtn.addEventListener("click", handleConfirm);
        newCancelBtn.addEventListener("click", handleCancel);

        // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            handleCancel();
          }
        });

        // ESCÈîÆÂÖ≥Èó≠
        const handleEsc = (e) => {
          if (e.key === "Escape") {
            handleCancel();
            document.removeEventListener("keydown", handleEsc);
          }
        };
        document.addEventListener("keydown", handleEsc);
      }

      function hideCustomConfirm() {
        const modal = document.getElementById("customConfirmModal");
        modal.classList.remove("show");
        setTimeout(() => modal.classList.add("hidden"), 300);
      }

      // Á°ÆËÆ§Âà†Èô§Â≠òÊ°£
      function confirmDeleteModel(modelId) {
        showCustomConfirm("Á°ÆËÆ§Âà†Èô§", "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Â≠òÊ°£ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ", () => deleteModel(modelId), null);
      }

      // Âà†Èô§Â≠òÊ°£
      async function deleteModel(modelId) {
        try {
          await apiCall(`/mall/personalModels/${modelId}`, { method: "DELETE" });
          showToast("Âà†Èô§ÊàêÂäüÔºÅ", "success");
          loadPersonalModels();
        } catch (error) {
          // ÈîôËØØÂ∑≤Âú®apiCall‰∏≠Â§ÑÁêÜ
        }
      }

      // Âä†ËΩΩ‰∏™‰∫∫Ê®°Âûã
      async function loadPersonalModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) {
          showToast("Ê®°Âûã‰∏çÂ≠òÂú®", "error");
          return;
        }

        try {
           console.log("Loading personal model:", model);
          // ÂèëÈÄÅloadModelÊ∂àÊÅØÁªôÁà∂Á™óÂè£
          window.parent.postMessage(
            {
              type: "loadModel",
              modelId: model.id,
              modelData: {
                id: model.id,
                name: model.name,
                modelUrl: model.modelUrl,
                size: model.size,
                tag: model.tag,
                likes: model.likes,
                downloads: model.downloads,
                updatedAt: model.updatedAt,
              },
            },
            "*"
          );

          showToast(`Â∑≤Âä†ËΩΩÊ®°ÂûãÔºö${model.name}`, "success");
        } catch (error) {
          showToast("Âä†ËΩΩÊ®°ÂûãÂ§±Ë¥•", "error");
        }
      }

      // ‰øùÂ≠ò‰∏™‰∫∫Ê®°Âûã
      async function savePersonalModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) {
          showToast("Ê®°Âûã‰∏çÂ≠òÂú®", "error");
          return;
        }

        // ÊòæÁ§∫‰øùÂ≠òÁ°ÆËÆ§ÂºπÊ°Ü
        await showSaveConfirmModal(model);
      }

      // ÁºñËæëÊ®°ÂûãÂêçÁß∞
      function editModelName(modelId) {
        const nameElement = document.getElementById(`modelName_${modelId}`);
        const editBox = document.getElementById(`editNameBox_${modelId}`);
        const input = document.getElementById(`editNameInput_${modelId}`);

        if (nameElement && editBox && input) {
          nameElement.style.display = "none";
          editBox.classList.remove("hidden");
          input.focus();
          input.select();
        }
      }

      // ‰øùÂ≠òÊ®°ÂûãÂêçÁß∞
      async function saveModelName(modelId) {
        const input = document.getElementById(`editNameInput_${modelId}`);
        const newName = input.value.trim();

        if (!newName) {
          showToast("ÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫", "error");
          return;
        }

        try {
          await apiCall(`/mall/personalModels/${modelId}`, {
            method: "PUT",
            body: JSON.stringify({ name: newName }),
          });

          showToast("ÂêçÁß∞‰øÆÊîπÊàêÂäüÔºÅ", "success");
          loadPersonalModels(); // ÈáçÊñ∞Âä†ËΩΩÂàóË°®
        } catch (error) {
          // ÈîôËØØÂ∑≤Âú®apiCall‰∏≠Â§ÑÁêÜ
        }
      }

      // ÂèñÊ∂àÁºñËæëÂêçÁß∞
      function cancelEditName(modelId) {
        const nameElement = document.getElementById(`modelName_${modelId}`);
        const editBox = document.getElementById(`editNameBox_${modelId}`);
        const input = document.getElementById(`editNameInput_${modelId}`);

        if (nameElement && editBox && input) {
          // ÊÅ¢Â§çÂéüÂßãÂÄº
          const model = personalModels.find((m) => m.id === modelId);
          if (model) {
            input.value = model.name || "Êú™ÂëΩÂêçÂ≠òÊ°£";
          }

          nameElement.style.display = "block";
          editBox.classList.add("hidden");
        }
      }

      // ÁºñËæëÂ≠òÊ°£
      function editModel(modelId) {
        const model = personalModels.find((m) => m.id === modelId);
        if (!model) return;

        document.getElementById("editModelId").value = model.id;
        document.getElementById("editModelName").value = model.name || "";
        document.getElementById("editModelUrl").value = model.modelUrl || "";
        document.getElementById("editModelSize").value = formatFileSize(model.size || 0);
        document.getElementById("editModelTag").value = model.tag || currentTag; // ‰ΩøÁî®Â≠òÊ°£ÁöÑÊ†áÁ≠æÊàñÂΩìÂâçÊ†áÁ≠æ

        elements.editModal.classList.remove("hidden");
      }

      // Âä†ËΩΩ‰∏™‰∫∫Â≠òÊ°£
      async function loadPersonalModels() {
        try {
          const result = await apiCall(`/mall/getModelsByTag?tag=${currentTag}&userId=${USER_ID}`);
          personalModels = result?.rows || [];
          renderPersonalModels(personalModels);
        } catch (error) {
          elements.personalEmptyState.classList.remove("hidden");
          elements.personalModelList.innerHTML = "";
        }
      }

      // Ê∏≤Êüì‰∏™‰∫∫Â≠òÊ°£ÂàóË°®
      function renderPersonalModels(models) {
        // ÂàõÂª∫Âç†‰ΩçUIÂç°Áâá‰Ωú‰∏∫Á¨¨‰∏Ä‰∏™ÂÖÉÁ¥†
        const placeholderCard = createUploadPlaceholderCard();

        if (!models || models.length === 0) {
          elements.personalEmptyState.classList.add("hidden");
          elements.personalModelList.innerHTML = placeholderCard;
          return;
        }

        elements.personalEmptyState.classList.add("hidden");
        const modelCards = models.map((model) => createPersonalModelCard(model)).join("");
        elements.personalModelList.innerHTML = placeholderCard + modelCards;
      }

      // Âä†ËΩΩÊâÄÊúâÂ≠òÊ°£
      async function loadAllModels() {
        currentView = "all";
        resetPagination();
        loadModels(); // ‰∏ç‰º†ÂèÇÊï∞Ôºå‰ΩøÁî®ÂΩìÂâçÊ†áÁ≠æ
      }

      // Âä†ËΩΩÁÇπËµûËÆ∞ÂΩï
      async function loadLikedModels() {
        currentView = "liked";
        resetPagination();
        showLoading(true);

        try {
          let likedModels = (await sdk.personalPageStore.loadPageData(pageName, "liked")) || [];

          // Â∫îÁî®ÊéíÂ∫èÈÄªËæë
          likedModels = applySortToPersonalData(likedModels);

          currentModels = likedModels;

          if (likedModels.length === 0) {
            // Ê∏ÖÈô§ÂéüÊúâÁöÑÂú®Á∫øÊï∞ÊçÆÂàóË°®UI
            elements.modelList.innerHTML = "";
            showEmptyState();
          } else {
            await renderModelList(likedModels);
          }
        } catch (error) {
          console.error("Âä†ËΩΩÊî∂ËóèËÆ∞ÂΩïÂ§±Ë¥•:", error);
          showToast("Âä†ËΩΩÊî∂ËóèËÆ∞ÂΩïÂ§±Ë¥•", "error");
          // Ê∏ÖÈô§ÂéüÊúâÁöÑÂú®Á∫øÊï∞ÊçÆÂàóË°®UI
          elements.modelList.innerHTML = "";
          showEmptyState();
        } finally {
          showLoading(false);
        }
      }

      // Âä†ËΩΩ‰∏ãËΩΩËÆ∞ÂΩï
      async function loadDownloadedModels() {
        currentView = "downloaded";
        resetPagination();
        showLoading(true);

        try {
          let downloadedModels = (await sdk.personalPageStore.loadPageData(pageName, "downloaded")) || [];

          // Â∫îÁî®ÊéíÂ∫èÈÄªËæë
          downloadedModels = applySortToPersonalData(downloadedModels);

          currentModels = downloadedModels;

          if (downloadedModels.length === 0) {
            // Ê∏ÖÈô§ÂéüÊúâÁöÑÂú®Á∫øÊï∞ÊçÆÂàóË°®UI
            elements.modelList.innerHTML = "";
            showEmptyState();
          } else {
            await renderModelList(downloadedModels);
          }
        } catch (error) {
          console.error("Âä†ËΩΩ‰∏ãËΩΩËÆ∞ÂΩïÂ§±Ë¥•:", error);
          showToast("Âä†ËΩΩ‰∏ãËΩΩËÆ∞ÂΩïÂ§±Ë¥•", "error");
          // Ê∏ÖÈô§ÂéüÊúâÁöÑÂú®Á∫øÊï∞ÊçÆÂàóË°®UI
          elements.modelList.innerHTML = "";
          showEmptyState();
        } finally {
          showLoading(false);
        }
      }

      // ÈáçÁΩÆÂàÜÈ°µÁä∂ÊÄÅ
      function resetPagination() {
        currentPage = 1;
        hasMoreData = true;
        currentModels = [];
      }

      // Â∫îÁî®ÊéíÂ∫è
      function applySort() {
        resetPagination();
        reloadCurrentView();
      }

      // ÈáçÊñ∞Âä†ËΩΩÂΩìÂâçËßÜÂõæ
      function reloadCurrentView() {
        if (currentView === "all") {
          loadModels();
        } else if (currentView === "liked") {
          loadLikedModels();
        } else if (currentView === "downloaded") {
          loadDownloadedModels();
        }
      }

      // ‰∏∫‰∏™‰∫∫Êï∞ÊçÆÂ∫îÁî®ÊéíÂ∫èÈÄªËæë
      function applySortToPersonalData(models) {
        if (!models || models.length === 0) return models;

        const sortedModels = [...models];

        switch (currentSort.field) {
          case "name":
            sortedModels.sort((a, b) => {
              const nameA = (a.name || "").toLowerCase();
              const nameB = (b.name || "").toLowerCase();
              return currentSort.order === "asc" ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
            });
            break;
          case "likes":
            sortedModels.sort((a, b) => {
              const likesA = a.likes || 0;
              const likesB = b.likes || 0;
              return currentSort.order === "asc" ? likesA - likesB : likesB - likesA;
            });
            break;
          case "downloads":
            sortedModels.sort((a, b) => {
              const downloadsA = a.downloads || 0;
              const downloadsB = b.downloads || 0;
              return currentSort.order === "asc" ? downloadsA - downloadsB : downloadsB - downloadsA;
            });
            break;
          case "size":
            sortedModels.sort((a, b) => {
              const sizeA = a.size || 0;
              const sizeB = b.size || 0;
              return currentSort.order === "asc" ? sizeA - sizeB : sizeB - sizeA;
            });
            break;
          case "created_at":
            sortedModels.sort((a, b) => {
              const timeA = new Date(a.created_at || 0).getTime();
              const timeB = new Date(b.created_at || 0).getTime();
              return currentSort.order === "asc" ? timeA - timeB : timeB - timeA;
            });
            break;
          default:
            // ÈªòËÆ§ÊåâÊ∑ªÂä†Êó∂Èó¥ÂÄíÂ∫èÊéíÂàóÔºàÊúÄÊñ∞ÁöÑÂú®ÂâçÔºâ
            if (currentView === "liked") {
              sortedModels.sort((a, b) => {
                const timeA = new Date(a.likedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.likedAt || b.created_at || 0).getTime();
                return timeB - timeA;
              });
            } else if (currentView === "downloaded") {
              sortedModels.sort((a, b) => {
                const timeA = new Date(a.lastDownloadedAt || a.created_at || 0).getTime();
                const timeB = new Date(b.lastDownloadedAt || b.created_at || 0).getTime();
                return timeB - timeA;
              });
            }
            break;
        }

        return sortedModels;
      }

      // ÊêúÁ¥¢ÂäüËÉΩ
      async function searchModels() {
        const query = elements.searchInput.value.trim().toLowerCase();
        if (!query) {
          await renderModelList(currentModels);
          return;
        }
        let modelId = parseInt(query);
        const filteredModels = currentModels.filter(
          (model) => (model.name || "").toLowerCase().includes(query) || (model.tag || "").toLowerCase().includes(query) || (model.id || "").includes(query) || (modelId && model.id === modelId)
        );
        await renderModelList(filteredModels);
      }

      // ‰∫ã‰ª∂ÁõëÂê¨Âô®
      elements.searchBtn.addEventListener("click", searchModels);
      elements.searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") searchModels();
      });

      elements.uploadBtn.addEventListener("click", () => {
        elements.uploadDrawer.classList.remove("hidden");
        setTimeout(() => {
          elements.uploadDrawer.querySelector(".drawer").classList.add("open");
        }, 10);
        loadPersonalModels();
      });

      elements.closeDrawer.addEventListener("click", () => {
        elements.uploadDrawer.querySelector(".drawer").classList.remove("open");
        setTimeout(() => {
          elements.uploadDrawer.classList.add("hidden");
        }, 300);
      });

      elements.likeRecordBtn.addEventListener("click", () => {
        setActiveTab("likeRecordBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // Êõ¥Êñ∞ÊåâÈíÆÊòæÁ§∫Áä∂ÊÄÅ
        loadLikedModels();
      });
      elements.downloadRecordBtn.addEventListener("click", () => {
        setActiveTab("downloadRecordBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // Êõ¥Êñ∞ÊåâÈíÆÊòæÁ§∫Áä∂ÊÄÅ
        loadDownloadedModels();
      });
      elements.allModelsBtn.addEventListener("click", () => {
        setActiveTab("allModelsBtn");
        currentSort = { field: "", order: "desc" };
        updateSortButtonText(); // Êõ¥Êñ∞ÊåâÈíÆÊòæÁ§∫Áä∂ÊÄÅ
        loadAllModels();
      });

      // Êõ¥Êñ∞ÊåâÈíÆÊñáÂ≠óÊòæÁ§∫
      function updateSortButtonText() {
        const buttons = [
          { element: elements.sortByTime, field: "updatedAt", name: "‰øÆÊîπÊó∂Èó¥" },
          { element: elements.sortByLikes, field: "likes", name: "Êî∂ËóèÊï∞" },
          { element: elements.sortByDownloads, field: "downloads", name: "‰∏ãËΩΩÊï∞" },
        ];

        buttons.forEach(({ element, field, name }) => {
          if (currentSort.field === field) {
            const arrow = currentSort.order === "desc" ? "‚Üì" : "‚Üë";
            element.textContent = `${name} ${arrow}`;
            element.classList.add("bg-blue-100", "text-blue-700", "border-blue-300");
            element.classList.remove("hover:bg-gray-50");
          } else {
            element.textContent = name;
            element.classList.remove("bg-blue-100", "text-blue-700", "border-blue-300");
            element.classList.add("hover:bg-gray-50");
          }
        });
      }

      // ÊéíÂ∫èÊåâÈíÆ‰∫ã‰ª∂ÁõëÂê¨
      elements.sortByTime.addEventListener("click", () => {
        if (currentSort.field === "updatedAt") {
          // ÂàáÊç¢ÊéíÂ∫èÈ°∫Â∫è
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // ËÆæÁΩÆÊñ∞ÁöÑÊéíÂ∫èÂ≠óÊÆµ
          currentSort.field = "updatedAt";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      elements.sortByLikes.addEventListener("click", () => {
        if (currentSort.field === "likes") {
          // ÂàáÊç¢ÊéíÂ∫èÈ°∫Â∫è
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // ËÆæÁΩÆÊñ∞ÁöÑÊéíÂ∫èÂ≠óÊÆµ
          currentSort.field = "likes";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      elements.sortByDownloads.addEventListener("click", () => {
        if (currentSort.field === "downloads") {
          // ÂàáÊç¢ÊéíÂ∫èÈ°∫Â∫è
          currentSort.order = currentSort.order === "desc" ? "asc" : "desc";
        } else {
          // ËÆæÁΩÆÊñ∞ÁöÑÊéíÂ∫èÂ≠óÊÆµ
          currentSort.field = "downloads";
          currentSort.order = "desc";
        }
        updateSortButtonText();
        applySort();
      });

      // Â§ÑÁêÜ‰∏ä‰º†Êñ∞Â≠òÊ°£ÁöÑÁÇπÂáª‰∫ã‰ª∂
      async function handleUploadClick() {
        // Ê∏ÖÁ©∫Ë°®Âçï
        document.getElementById("editModelId").value = "";
        document.getElementById("editModelName").value = "";
        document.getElementById("editModelUrl").value = "";
        document.getElementById("editModelSize").value = "";
        document.getElementById("editModelTag").value = currentTag; // ‰ΩøÁî®URLÂèÇÊï∞‰∏≠ÁöÑÊ†áÁ≠æ
        elements.editModal.classList.remove("hidden");
        try {
          const modelUrlResponse = await startUploadModel();
          if (!modelUrlResponse.modelUrl) {
            showToast("Ëé∑ÂèñÂΩìÂâçÂ≠òÊ°£URLÂ§±Ë¥•ÔºåËØ∑ÂÖàËøîÂõûÊ∏∏Êàè‰øùÂ≠òÂΩìÂâçÂ≠òÊ°£", "error");
            return;
          }
          document.getElementById("editModelUrl").value = modelUrlResponse.modelUrl;
          document.getElementById("editModelSize").value = formatFileSize(modelUrlResponse.size || 0);
        } catch (error) {
          showToast("‰∏ä‰º†Ê®°ÂûãÂ§±Ë¥•", "error");
        }
      }

      elements.cancelEdit.addEventListener("click", () => {
        elements.editModal.classList.add("hidden");
      });

      elements.editForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const modelName = document.getElementById("editModelName").value;
        if (!modelName) {
          showToast("ËØ∑ËæìÂÖ•Â≠òÊ°£ÂêçÁß∞", "warning");
          return;
        }
        const modelUrl = document.getElementById("editModelUrl").value;
        if (!modelUrl || !modelUrl.startsWith("https://")) {
          showToast("ËØ∑ËøîÂõûÊ∏∏Êàè‰øùÂ≠òÂΩìÂâçÂ≠òÊ°£ÔºåÈáçÊñ∞Ëé∑ÂèñÂΩìÂâçÂ≠òÊ°£URL", "warning");
          return;
        }
        const modelId = document.getElementById("editModelId").value;
        const modelData = {
          name: modelName,
          tag: currentTag, // ‰ΩøÁî®URLÂèÇÊï∞‰∏≠ÁöÑÊ†áÁ≠æ
        };

        if (modelId) {
          // ÁºñËæëÁé∞ÊúâÂ≠òÊ°£ÔºåÂè™Êõ¥Êñ∞ÂêçÁß∞
          modelData.id = parseInt(modelId);
        } else {
          // Êñ∞Âª∫Â≠òÊ°£ÔºåÈúÄË¶ÅURLÁ≠âÂÆåÊï¥‰ø°ÊÅØ
          modelData.modelUrl = document.getElementById("editModelUrl").value;
          modelData.modelType = "blocks"; // ÈªòËÆ§Á±ªÂûã
          modelData.size = parseFileSize(document.getElementById("editModelSize").value) || 0;
        }

        try {
          await apiCall(
            "/mall/personalModels/upsert",
            {
              method: "PUT",
              body: JSON.stringify(modelData),
            },
            true
          );

          showToast(modelId ? "Êõ¥Êñ∞ÊàêÂäüÔºÅ" : "ÂàõÂª∫ÊàêÂäüÔºÅ", "success");
          elements.editModal.classList.add("hidden");
          loadPersonalModels();
        } catch (error) {
          // ÈîôËØØÂ∑≤Âú®apiCall‰∏≠Â§ÑÁêÜ
        }
      });

      // ÂÖ≥Èó≠ÂºπÊ°Ü‰∫ã‰ª∂ÁõëÂê¨Âô®
      elements.closeToast.addEventListener("click", hideToast);
      elements.uploadDrawer.addEventListener("click", (e) => {
        if (e.target === elements.uploadDrawer) {
          elements.closeDrawer.click();
        }
      });

      // ÁÇπÂáªÊ®°ÊÄÅÊ°ÜËÉåÊôØÂÖ≥Èó≠
      elements.editModal.addEventListener("click", (e) => {
        if (e.target === elements.editModal) {
          elements.editModal.classList.add("hidden");
        }
      });

      // ‰øùÂ≠òÁ°ÆËÆ§ÂºπÊ°ÜÁõ∏ÂÖ≥ÈÄªËæë
      const saveConfirmModal = document.getElementById("saveConfirmModal");
      const saveConfirmCancelBtn = document.getElementById("saveConfirmCancelBtn");
      const saveConfirmOkBtn = document.getElementById("saveConfirmOkBtn");
      const saveConfirmName = document.getElementById("saveConfirmName");
      const saveConfirmUrl = document.getElementById("saveConfirmUrl");
      const saveConfirmSize = document.getElementById("saveConfirmSize");
      const saveConfirmBtnText = document.getElementById("saveConfirmBtnText");
      const saveConfirmLoading = document.getElementById("saveConfirmLoading");

      // ÊòæÁ§∫‰øùÂ≠òÁ°ÆËÆ§ÂºπÊ°Ü
      async function showSaveConfirmModal(model) {
        // ËÆæÁΩÆÂ≠òÊ°£ÂêçÁß∞ÔºàÂèØÁºñËæëÔºâ
        saveConfirmName.value = model.name;
        saveConfirmName.readOnly = false;

        // ÈáçÁΩÆURLÂíåÂ§ßÂ∞èÊòæÁ§∫
        saveConfirmUrl.textContent = "Ëé∑Âèñ‰∏≠...";
        saveConfirmSize.textContent = "Ëé∑Âèñ‰∏≠...";

        // ÊòæÁ§∫ÂºπÊ°Ü
        saveConfirmModal.classList.remove("hidden");

        // ÂºÇÊ≠•Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊ®°ÂûãÊï∞ÊçÆ
        try {
          const modelUrlResponse = await startUploadModel();
          if (!modelUrlResponse.modelUrl) {
            showToast("Ëé∑ÂèñÂΩìÂâçÂ≠òÊ°£URLÂ§±Ë¥•ÔºåËØ∑ÂÖàËøîÂõûÊ∏∏Êàè‰øùÂ≠òÂΩìÂâçÂ≠òÊ°£", "error");
            return;
          }
          saveConfirmUrl.textContent = modelUrlResponse.modelUrl || "Êó†";
          saveConfirmSize.textContent = formatFileSize(modelUrlResponse.size || 0);

          // Â≠òÂÇ®Ëé∑ÂèñÂà∞ÁöÑÊï∞ÊçÆ‰æõÁ°ÆËÆ§Êó∂‰ΩøÁî®
          saveConfirmModal.dataset.modelUrl = modelUrlResponse.modelUrl || "";
          saveConfirmModal.dataset.modelSize = modelUrlResponse.size || 0;
          saveConfirmModal.dataset.modelId = model.id;
        } catch (error) {
          saveConfirmUrl.textContent = "Ëé∑ÂèñÂ§±Ë¥•";
          saveConfirmSize.textContent = "Ëé∑ÂèñÂ§±Ë¥•";
          showToast("Ëé∑ÂèñÊ®°ÂûãÊï∞ÊçÆÂ§±Ë¥•", "error");
        }
      }

      // ÈöêËóè‰øùÂ≠òÁ°ÆËÆ§ÂºπÊ°Ü
      function hideSaveConfirmModal() {
        saveConfirmModal.classList.add("hidden");
        // ÈáçÁΩÆÊåâÈíÆÁä∂ÊÄÅ
        saveConfirmBtnText.textContent = "Á°ÆËÆ§‰øùÂ≠ò";
        saveConfirmLoading.classList.add("hidden");
        saveConfirmOkBtn.disabled = false;
      }

      // ‰øùÂ≠òÁ°ÆËÆ§ÂºπÊ°Ü‰∫ã‰ª∂ÁõëÂê¨
      saveConfirmCancelBtn.addEventListener("click", hideSaveConfirmModal);

      saveConfirmOkBtn.addEventListener("click", async () => {
        const modelId = saveConfirmModal.dataset.modelId;
        const modelUrl = saveConfirmModal.dataset.modelUrl;
        const modelSize = parseInt(saveConfirmModal.dataset.modelSize) || 0;
        const modelName = saveConfirmName.value.trim();

        if (!modelName) {
          showToast("ËØ∑ËæìÂÖ•Â≠òÊ°£ÂêçÁß∞", "warning");
          return;
        }

        if (!modelUrl) {
          showToast("Ê≤°ÊúâÂèØ‰øùÂ≠òÁöÑÊ®°ÂûãÊï∞ÊçÆ", "error");
          return;
        }

        // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
        saveConfirmBtnText.textContent = "‰øùÂ≠ò‰∏≠...";
        saveConfirmLoading.classList.remove("hidden");
        saveConfirmOkBtn.disabled = true;

        try {
          // ÊâæÂà∞ÂéüÂßãÊ®°ÂûãÊï∞ÊçÆ
          const originalModel = personalModels.find((m) => m.id == modelId);

          const updateData = {
            name: modelName, // ‰ΩøÁî®Áî®Êà∑ËæìÂÖ•ÁöÑÂêçÁß∞
            modelUrl: modelUrl, // ‰ΩøÁî®Ëé∑ÂèñÂà∞ÁöÑÊúÄÊñ∞URL
            size: modelSize, // ‰ΩøÁî®Ëé∑ÂèñÂà∞ÁöÑÊúÄÊñ∞Â§ßÂ∞è
            tag: originalModel?.tag || DEFAULT_TAG, // ‰øùÊåÅÂéüÊúâÊ†áÁ≠æ
            updatedAt: new Date().toISOString(),
          };

          await apiCall(`/mall/personalModels/${modelId}`, {
            method: "PUT",
            body: JSON.stringify(updateData),
          });

          showToast("‰øùÂ≠òÊàêÂäüÔºÅ", "success");
          hideSaveConfirmModal();
          loadPersonalModels(); // ÈáçÊñ∞Âä†ËΩΩÂàóË°®
        } catch (error) {
          showToast("‰øùÂ≠òÂ§±Ë¥•", "error");
          // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
          saveConfirmBtnText.textContent = "Á°ÆËÆ§‰øùÂ≠ò";
          saveConfirmLoading.classList.add("hidden");
          saveConfirmOkBtn.disabled = false;
        }
      });

      // ÁÇπÂáªÂºπÊ°ÜËÉåÊôØÂÖ≥Èó≠
      saveConfirmModal.addEventListener("click", (e) => {
        if (e.target === saveConfirmModal) {
          hideSaveConfirmModal();
        }
      });

      // ÊªöÂä®Âä†ËΩΩÁõëÂê¨Âô®
      elements.modelList.addEventListener("scroll", () => {
        const { scrollTop, scrollHeight, clientHeight } = elements.modelList;
        // ÂΩìÊªöÂä®Âà∞Ë∑ùÁ¶ªÂ∫ïÈÉ®50pxÊó∂Ëß¶ÂèëÂä†ËΩΩ
        if (scrollTop + clientHeight >= scrollHeight - 50 && hasMoreData && !isLoading) {
          loadMoreModels();
        }
      }); // Âä†ËΩΩÊõ¥Â§öÂ≠òÊ°£
      async function loadMoreModels() {
        if (!hasMoreData || isLoading) return;

        // Show loading overlay for loading more
        elements.loadingMoreOverlay.classList.remove("hidden");

        try {
          if (currentView === "all") {
            await loadModels(currentTag, null, currentPage + 1, true);
          } else if (currentView === "liked") {
            await loadModels(currentTag, USER_ID, currentPage + 1, true);
          } else if (currentView === "downloaded") {
            await loadModels(currentTag, USER_ID, currentPage + 1, true);
          }
        } finally {
          // Hide loading overlay
          elements.loadingMoreOverlay.classList.add("hidden");
        }
      }

      async function initializeApp() {
        // Initialize sort button text
        updateSortButtonText();
        // Load all models by default
        loadAllModels();
        window.parent.postMessage({ type: "gameLoaded" }, "*");
        console.log("App initialized, currentTag:", currentTag);
      }

      function checkStartGame(timeoutMs) {
        if (!timeoutMs) {
          const urlParams = new URLSearchParams(window.location.search);
          timeoutMs = urlParams.get("parent") === "miniGameProxy" ? 3000 : 200;
          if (urlParams.get("parent") != "miniGameProxy") {
            currentTag = urlParams.get("tag") || DEFAULT_TAG;
          }
        }

        let gameStarted = false;
        const waitForMinigameProxyWithTimeout = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            if (!gameStarted) {
              resolve(null);
            }
          }, timeoutMs);
          let miniGameProxyReceived = false;
          let locationReceived = false;

          const messageHandler = function (e) {
            if (!e.data || !e.data.type) {
              return;
            }

            try {
              switch (e.data.type) {
                case "miniGameProxyDataResponse":
                  keepworkToken = e.data.keepworkToken || "";
                  keepworkUserInfo = e.data.keepworkUserInfo || {};
                  USER_ID = keepworkUserInfo?.id || 1;
                  sdk.setToken(keepworkToken);
                  miniGameProxyReceived = true;
                  break;
                case "locationResponse":
                  const locationParams = e.data;
                  if (locationParams?.search) {
                    const urlParams = new URLSearchParams(locationParams.search);
                    currentTag = urlParams.get("tag") || DEFAULT_TAG;
                  }
                  locationReceived = true;
                  break;
              }

              if (miniGameProxyReceived && locationReceived) {
                window.removeEventListener("message", messageHandler);
                clearTimeout(timeout);
                resolve(e.data);
              }
            } catch (error) {
              console.error("Error processing message:", error);
            }
          };

          window.addEventListener("message", messageHandler);
          window.parent.postMessage({ type: "getLocation" }, "*");
          window.parent.postMessage({ type: "getMiniGameProxyData" }, "*");
        });

        waitForMinigameProxyWithTimeout
          .then(async () => {
            if (!gameStarted) {
              gameStarted = true;
              await initializeApp();
            }
          })
          .catch(async (error) => {
            if (!gameStarted) {
              gameStarted = true;
              await initializeApp();
            }
          });
      }

      checkStartGame();
    </script>
  </body>
</html>
