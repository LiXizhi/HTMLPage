<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç©ºé—´èƒ½åŠ›è®­ç»ƒæ¸¸æˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        .dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connected-dot {
            background-color: #ec4899;
            border: 2px solid #be185d;
        }

        .empty-dot {
            background-color: #9ca3af;
            border: 2px solid #6b7280;
        }

        .clickable-dot {
            cursor: pointer;
        }

        .clickable-dot:hover {
            transform: scale(1.2);
        }

        .selected-dot {
            transform: scale(1.3);
        }

        .line {
            position: absolute;
            background-color: #ec4899;
            z-index: 1;
        }

        .horizontal-line {
            height: 4px;
        }

        .vertical-line {
            width: 4px;
        }

        .pattern-area {
            background: #d4af85;
            border-radius: 2px 2px 2px 30px;
            position: relative;
            padding: 20px;
        }

        .custom-select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'><path fill='%23666' d='M2 0L0 2h4zm0 5L0 3h4z'/></svg>");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px;
            padding-right: 40px;
            min-width: 120px;
            white-space: nowrap;
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #22c55e;
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateX(400px);
            transition: all 0.3s ease;
            max-width: 400px;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: #ef4444;
        }

        .toast.warning {
            background: #f59e0b;
        }

        .toast.info {
            background: #3b82f6;
        }

        /* Success animation */
        @keyframes successPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .success-animation {
            animation: successPulse 0.6s ease;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #22c55e;
            animation: confetti-fall 1s linear forwards;
            z-index: 999;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(300px) rotate(720deg);
                opacity: 0;
            }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-red-300 to-red-500 min-h-screen p-4">
    <div class="max-w-4xl mx-auto">        <!-- æ¸¸æˆå¤´éƒ¨ -->
        <div class="bg-white bg-opacity-90 rounded-lg p-4 mb-4 flex justify-between items-center">
            <div class="flex gap-4 items-center">
                <span class="font-bold">å…³å¡: <span id="level">1/10</span></span>
                <span class="font-bold">åˆ†æ•°: <span id="score">0</span></span>
                <span class="font-bold text-blue-600">æœ€é«˜åˆ†: <span id="highestScore">0</span></span>
                <div class="flex items-center gap-2">
                    <span class="font-bold">éš¾åº¦:</span>
                    <select id="difficultySelect"
                        class="custom-select bg-white border border-gray-300 rounded px-3 py-1 font-medium">
                        <option value="easy">ç®€å• (3Ã—3)</option>
                        <option value="medium" selected>ä¸­ç­‰ (4Ã—4)</option>
                        <option value="hard">å›°éš¾ (5Ã—5)</option>
                        <option value="expert">ä¸“å®¶ (6Ã—6)</option>
                    </select>
                </div>
            </div>
            <button id="hintBtn"
                class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg font-bold">
                æç¤º
            </button>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="bg-gradient-to-br from-amber-800 to-amber-900 rounded-lg p-8">
            <div class="flex justify-center gap-8 mb-6">
                <!-- åŸå§‹å›¾æ¡ˆ -->
                <div class="text-center">
                    <div class="text-white mb-2 flex items-center gap-2 justify-center">
                        <div
                            class="w-12 h-8 rounded border-2 border-white flex items-center justify-center text-sm bg-white bg-opacity-20">
                            åŸå›¾
                        </div>
                    </div>
                    <div class="pattern-area" id="originalPattern">
                        <!-- åŸå§‹å›¾æ¡ˆå°†åœ¨è¿™é‡Œç”Ÿæˆ -->
                    </div>
                </div> <!-- å˜æ¢åå›¾æ¡ˆ -->
                <div class="text-center">
                    <div class="text-white mb-2 flex items-center gap-2 justify-center">
                        <span
                            class="w-8 h-8 rounded-full border-2 border-white flex items-center justify-center text-sm"
                            id="transformIcon">90Â°</span>
                        <span class="text-xs" id="transformText">é¡ºæ—¶é’ˆæ—‹è½¬ 90Â°</span>
                    </div>
                    <div class="pattern-area" id="targetPattern">
                        <!-- ç›®æ ‡å›¾æ¡ˆå°†åœ¨è¿™é‡Œç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <!-- æ“ä½œæç¤º -->
            <div class="text-white text-center mb-6">
                <p class="text-lg">ç‚¹å‡»å³ä¾§ç›¸é‚»çš„ç²‰è‰²ç‚¹è¿›è¡Œè¿çº¿ï¼Œé‡ç°å·¦ä¾§å˜æ¢åçš„å›¾æ¡ˆ</p>
            </div>            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="text-center">
                <button id="checkBtn"
                    class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-bold mr-4">
                    æ£€æŸ¥ç­”æ¡ˆ
                </button>
                <button id="clearBtn"
                    class="bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg font-bold">
                    æ¸…é™¤è¿çº¿
                </button>
            </div>
        </div>
    </div>

    <!-- Toast container -->
    <div id="toastContainer"></div>

    <script>        class SpatialGame {
            constructor() {
                this.level = 1;
                this.score = 0;
                this.difficulty = 'medium';
                this.currentTransform = 'rotate90';
                this.originalPattern = { dots: [], connections: [] };
                this.targetPattern = { dots: [], connections: [] };
                this.allGridPositions = [];
                this.userConnections = [];
                this.selectedDot = null;
                this.isProcessingCorrectAnswer = false;
                this.difficulties = {
                    easy: { gridSize: 3, cellSize: 50, minConnections: 2, maxConnections: 4 },
                    medium: { gridSize: 4, cellSize: 45, minConnections: 3, maxConnections: 6 },
                    hard: { gridSize: 5, cellSize: 40, minConnections: 4, maxConnections: 8 },
                    expert: { gridSize: 6, cellSize: 35, minConnections: 5, maxConnections: 10 }
                };

                this.transforms = ['rotate90', 'rotate-90', 'rotate180', 'flipH', 'flipV'];

                // æ¸¸æˆçŠ¶æ€è·Ÿè¸ª
                this.gameStarted = false;
                this.highestScore = 0; // è®°å½•æœ€é«˜åˆ†æ•°
                this.gameConfig = null; // å­˜å‚¨å¤–éƒ¨é…ç½®

                // æ–°çš„å…³å¡ç³»ç»Ÿï¼šæ¯ä¸ªéš¾åº¦10å…³ï¼Œæ¯å…³20åˆ†
                this.maxLevelsPerDifficulty = 10;
                this.pointsPerLevel = 20;

                this.init();

                // å‘é€æ¸¸æˆåŠ è½½å®Œæˆäº‹ä»¶
                window.parent.postMessage({ type: 'gameLoaded' }, '*');
            }

            // Toast notification system
            showToast(message, type = 'info', duration = 3000) {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;

                container.appendChild(toast);

                // Trigger animation
                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);

                // Auto remove
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (container.contains(toast)) {
                            container.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }

            // Success effect with confetti
            showSuccessEffect() {
                // Add success animation to check button
                const checkBtn = document.getElementById('checkBtn');
                checkBtn.classList.add('success-animation');
                setTimeout(() => {
                    checkBtn.classList.remove('success-animation');
                }, 600);

                // Create confetti effect
                for (let i = 0; i < 20; i++) {
                    this.createConfetti();
                }
            }
            createConfetti() {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';

                // è·å–å³ä¾§ç›®æ ‡å›¾æ¡ˆåŒºåŸŸçš„ä½ç½®å’Œå¤§å°
                const targetPattern = document.getElementById('targetPattern');
                const rect = targetPattern.getBoundingClientRect();

                // åœ¨ç›®æ ‡å›¾æ¡ˆåŒºåŸŸå†…éšæœºç”Ÿæˆconfettiä½ç½®ï¼Œè€ƒè™‘é¡µé¢æ»šåŠ¨
                const leftOffset = rect.left + window.scrollX + Math.random() * rect.width;
                const topOffset = rect.top + window.scrollY + Math.random() * rect.height;
                confetti.style.left = leftOffset + 'px';
                confetti.style.top = topOffset + 'px';

                confetti.style.background = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'][Math.floor(Math.random() * 5)];

                document.body.appendChild(confetti);

                setTimeout(() => {
                    if (document.body.contains(confetti)) {
                        document.body.removeChild(confetti);
                    }
                }, 1000);
            } init() {
                this.generatePattern();
                this.setupEventListeners();
                this.updateUI();
                this.setupMessageListener();
            }

            // è®¾ç½®æ¶ˆæ¯ç›‘å¬å™¨
            setupMessageListener() {
                window.addEventListener('message', (e) => {
                    switch (e.data.type) {
                        case 'setGameConfig':
                            this.gameConfig = e.data.data; // å­˜å‚¨é…ç½®ä¿¡æ¯
                            // å¯ä»¥åœ¨è¿™é‡Œæ ¹æ®é…ç½®æ›´æ–°æ¸¸æˆè®¾ç½®
                            break;
                        case 'getGameStats':
                            // è¿”å›å½“å‰æœ€é«˜åˆ†æ•°å’Œéš¾åº¦ç­‰çº§
                            const difficultyLevel = this.getDifficultyLevel();
                            window.parent.postMessage({
                                type: 'gameStats',
                                data: {
                                    score: this.highestScore, // è¿”å›æœ€é«˜åˆ†æ•°
                                    difficulty: difficultyLevel,
                                    currentScore: this.score,
                                    level: this.level
                                }
                            }, '*');
                            break;
                    }
                });
            }

            // å°†éš¾åº¦è½¬æ¢ä¸ºæ•°å­—ç­‰çº§
            getDifficultyLevel() {
                const difficultyMap = {
                    'easy': 1,
                    'medium': 2,
                    'hard': 3,
                    'expert': 3
                };
                return difficultyMap[this.difficulty] || 2;
            }
            getCurrentConfig() {
                return this.difficulties[this.difficulty];
            }            // æ ¹æ®å…³å¡è‡ªåŠ¨è®¾ç½®éš¾åº¦

            getConnectionsByLevel() {
                const baseDifficulty = this.difficulty;
                const config = this.difficulties[this.difficulty];

                // æ›´ç²¾ç»†çš„éš¾åº¦é€’å¢ï¼šæ¯å…³éƒ½ç•¥å¾®å¢åŠ å¤æ‚åº¦
                const levelInDifficulty = this.level % 3; // 0, 1, 2
                const difficultyBonus = Math.floor(this.level / 6); // æ¯6å…³å¢åŠ é¢å¤–éš¾åº¦
                const extraConnections = levelInDifficulty + difficultyBonus;

                // ç¡®ä¿è¿æ¥æ•°é€æ¸å¢åŠ ï¼Œä½†ä¸è¶…è¿‡åˆç†èŒƒå›´
                const minConnections = Math.min(config.minConnections + extraConnections, config.maxConnections + 3);
                const maxConnections = Math.min(config.maxConnections + extraConnections + 1, config.maxConnections + 5);

                return {
                    min: Math.max(2, minConnections), // è‡³å°‘2ä¸ªè¿æ¥
                    max: Math.max(3, maxConnections)  // è‡³å°‘3ä¸ªè¿æ¥
                };
            }

            // ç”Ÿæˆç½‘æ ¼åæ ‡
            getGridPositions() {
                const config = this.getCurrentConfig();
                const positions = [];
                const padding = 20; // ç»Ÿä¸€padding

                for (let row = 0; row < config.gridSize; row++) {
                    for (let col = 0; col < config.gridSize; col++) {
                        positions.push({
                            x: padding + col * config.cellSize,
                            y: padding + row * config.cellSize,
                            row: row,
                            col: col
                        });
                    }
                }
                return positions;
            } generatePattern() {
                // æ¸…é™¤æ‰€æœ‰çŠ¶æ€
                this.userConnections = [];
                this.selectedDot = null;
                this.originalPattern = { dots: [], connections: [] };
                this.targetPattern = { dots: [], connections: [] };

                // å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶ï¼ˆä»…ç¬¬ä¸€æ¬¡ï¼‰
                if (!this.gameStarted) {
                    this.gameStarted = true;
                    window.parent.postMessage({ type: 'gameStarted' }, '*');
                }

                // éšæœºé€‰æ‹©å˜æ¢ç±»å‹ï¼ˆç§»é™¤å¼ºåˆ¶æµ‹è¯•ä»£ç ï¼‰
                this.currentTransform = this.transforms[Math.floor(Math.random() * this.transforms.length)];

                const config = this.getCurrentConfig();
                this.allGridPositions = this.getGridPositions();

                console.log('Current level:', this.level);
                console.log('Current difficulty:', this.difficulty);
                console.log('Current transform:', this.currentTransform);
                console.log('Grid size:', config.gridSize);

                // æ ¹æ®å…³å¡è·å–è¿æ¥ç‚¹æ•°é‡
                const connectionRange = this.getConnectionsByLevel();
                const numConnectedDots = Math.floor(Math.random() *
                    (connectionRange.max - connectionRange.min + 1)) + connectionRange.min;

                console.log('Target connections:', numConnectedDots);

                // é€‰æ‹©è¿æ¥çš„ç‚¹
                const connectedIndices = new Set();
                const connections = [];

                // é€‰æ‹©èµ·å§‹ç‚¹
                let currentIndex = Math.floor(Math.random() * this.allGridPositions.length);
                connectedIndices.add(currentIndex);

                // é€šè¿‡ç›¸é‚»è¿æ¥çš„æ–¹å¼é€‰æ‹©å…¶ä»–ç‚¹
                while (connectedIndices.size < numConnectedDots) {
                    const currentPos = this.allGridPositions[currentIndex];
                    const neighbors = this.getNeighborIndices(currentPos);
                    const availableNeighbors = neighbors.filter(idx => !connectedIndices.has(idx));

                    if (availableNeighbors.length > 0) {
                        const nextIndex = availableNeighbors[Math.floor(Math.random() * availableNeighbors.length)];
                        connectedIndices.add(nextIndex);
                        connections.push([currentIndex, nextIndex]);
                        currentIndex = nextIndex;
                    } else {
                        // å¦‚æœæ²¡æœ‰å¯ç”¨çš„ç›¸é‚»ç‚¹ï¼Œä»å·²è¿æ¥çš„ç‚¹ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªç»§ç»­
                        const connectedArray = Array.from(connectedIndices);
                        currentIndex = connectedArray[Math.floor(Math.random() * connectedArray.length)];

                        // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°±éšæœºæ·»åŠ ä¸€äº›è¿æ¥
                        const remainingConnected = Array.from(connectedIndices);
                        for (let i = 0; i < remainingConnected.length - 1; i++) {
                            const pos1 = this.allGridPositions[remainingConnected[i]];
                            const pos2 = this.allGridPositions[remainingConnected[i + 1]];
                            if (this.areAdjacent(pos1, pos2) && Math.random() > 0.6) {
                                connections.push([remainingConnected[i], remainingConnected[i + 1]]);
                            }
                        }
                        break;
                    }
                }

                this.originalPattern = {
                    connectedIndices: Array.from(connectedIndices),
                    connections: connections
                };
                this.updatePatternSizes();
                this.renderOriginalPattern();
                this.renderTargetPattern();
                this.updateUI();
            }
            updatePatternSizes() {
                const config = this.getCurrentConfig();
                const padding = 20; // Same padding used in getGridPositions()

                // Calculate actual size needed based on grid dimensions
                const gridWidth = (config.gridSize - 1) * config.cellSize;
                const gridHeight = (config.gridSize - 1) * config.cellSize;
                const totalWidth = gridWidth + (padding * 2);
                const totalHeight = gridHeight + (padding * 2);

                document.getElementById('originalPattern').style.width = `${totalWidth}px`;
                document.getElementById('originalPattern').style.height = `${totalHeight}px`;
                document.getElementById('targetPattern').style.width = `${totalWidth}px`;
                document.getElementById('targetPattern').style.height = `${totalHeight}px`;
            }

            getNeighborIndices(pos) {
                const config = this.getCurrentConfig();
                const neighbors = [];
                const directions = [
                    { dr: -1, dc: 0 }, // ä¸Š
                    { dr: 1, dc: 0 },  // ä¸‹
                    { dr: 0, dc: -1 }, // å·¦
                    { dr: 0, dc: 1 }   // å³
                ];

                directions.forEach(dir => {
                    const newRow = pos.row + dir.dr;
                    const newCol = pos.col + dir.dc;

                    if (newRow >= 0 && newRow < config.gridSize && newCol >= 0 && newCol < config.gridSize) {
                        neighbors.push(newRow * config.gridSize + newCol);
                    }
                });

                return neighbors;
            }

            areAdjacent(pos1, pos2) {
                const rowDiff = Math.abs(pos1.row - pos2.row);
                const colDiff = Math.abs(pos1.col - pos2.col);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            } renderOriginalPattern() {
                const container = document.getElementById('originalPattern');
                container.innerHTML = '';

                // ç¡®ä¿åŸå§‹å›¾æ¡ˆå§‹ç»ˆä½¿ç”¨åŸå§‹çš„è¾¹æ¡†åœ†è§’
                container.style.borderRadius = '2px 2px 2px 30px';

                // ç»˜åˆ¶è¿çº¿
                this.originalPattern.connections.forEach(([startIdx, endIdx]) => {
                    const startDot = this.allGridPositions[startIdx];
                    const endDot = this.allGridPositions[endIdx];
                    const line = this.createLine(startDot, endDot);
                    container.appendChild(line);
                });

                // ç»˜åˆ¶æ‰€æœ‰ç½‘æ ¼ç‚¹
                this.allGridPositions.forEach((dot, index) => {
                    const dotElement = document.createElement('div');
                    const isConnected = this.originalPattern.connectedIndices.includes(index);
                    dotElement.className = `dot ${isConnected ? 'connected-dot' : 'empty-dot'}`;
                    dotElement.style.left = `${dot.x - 8}px`;
                    dotElement.style.top = `${dot.y - 8}px`;
                    container.appendChild(dotElement);
                });
            } 
            renderTargetPattern() {
                const container = document.getElementById('targetPattern');
                container.innerHTML = '';

                // è®¡ç®—å˜æ¢åçš„å›¾æ¡ˆ
                this.targetPattern = this.transformPattern(this.originalPattern, this.currentTransform);

                // æ›´æ–°ç›®æ ‡å›¾æ¡ˆçš„è¾¹æ¡†åœ†è§’
                this.updateTargetPatternBorderRadius();

                // ç»˜åˆ¶æ‰€æœ‰ç½‘æ ¼ç‚¹ï¼Œéœ€è¦è¿æ¥çš„ç‚¹æ˜¾ç¤ºä¸ºç²‰è‰²
                const transformedPositions = this.getTransformedPositions();
                transformedPositions.forEach((dot, index) => {
                    const dotElement = document.createElement('div');
                    const shouldBeConnected = this.targetPattern.connectedIndices.includes(index);
                    dotElement.className = `dot clickable-dot ${shouldBeConnected ? 'connected-dot' : 'empty-dot'}`;
                    dotElement.style.left = `${dot.x - 8}px`;
                    dotElement.style.top = `${dot.y - 8}px`;
                    dotElement.dataset.index = index;
                    dotElement.addEventListener('click', () => this.handleDotClick(index, dotElement));
                    container.appendChild(dotElement);
                });

                // æ¸…é™¤ç”¨æˆ·è¿çº¿å’Œé€‰æ‹©çŠ¶æ€
                this.userConnections = [];
                this.selectedDot = null;

                // æ¸…é™¤æ‰€æœ‰é€‰æ‹©çŠ¶æ€çš„è§†è§‰æ•ˆæœ
                document.querySelectorAll('.selected-dot').forEach(dot => {
                    dot.classList.remove('selected-dot');
                });
            }

            // æ›´æ–°ç›®æ ‡å›¾æ¡ˆçš„è¾¹æ¡†åœ†è§’ä»¥åŒ¹é…å˜æ¢
            updateTargetPatternBorderRadius() {
                const targetContainer = document.getElementById('targetPattern');

                // åŸå§‹è¾¹æ¡†åœ†è§’: top-left, top-right, bottom-right, bottom-left
                // åŸå§‹è®¾ç½®æ˜¯: 2px 2px 2px 30px (å·¦ä¸‹è§’æ˜¯30px)
                let borderRadius;

                switch (this.currentTransform) {
                    case 'rotate90':
                        // é¡ºæ—¶é’ˆ90åº¦ï¼šå·¦ä¸‹è§’ -> å·¦ä¸Šè§’
                        borderRadius = '30px 2px 2px 2px';
                        break;
                    case 'rotate-90':
                        // é€†æ—¶é’ˆ90åº¦ï¼šå·¦ä¸‹è§’ -> å³ä¸‹è§’  
                        borderRadius = '2px 2px 30px 2px';
                        break;
                    case 'rotate180':
                        // 180åº¦ï¼šå·¦ä¸‹è§’ -> å³ä¸Šè§’
                        borderRadius = '2px 30px 2px 2px';
                        break;
                    case 'flipH':
                        // æ°´å¹³ç¿»è½¬ï¼šå·¦ä¸‹è§’ -> å³ä¸‹è§’
                        borderRadius = '2px 2px 30px 2px';
                        break;
                    case 'flipV':
                        // å‚ç›´ç¿»è½¬ï¼šå·¦ä¸‹è§’ -> å·¦ä¸Šè§’
                        borderRadius = '30px 2px 2px 2px';
                        break;
                    default:
                        // æ— å˜æ¢ï¼šä¿æŒåŸæ ·
                        borderRadius = '2px 2px 2px 30px';
                        break;
                }

                targetContainer.style.borderRadius = borderRadius;
            }

            getTransformedPositions() {
                const config = this.getCurrentConfig();
                const positions = [];
                const padding = 20; // ç»Ÿä¸€padding

                for (let row = 0; row < config.gridSize; row++) {
                    for (let col = 0; col < config.gridSize; col++) {
                        positions.push({
                            x: padding + col * config.cellSize,
                            y: padding + row * config.cellSize,
                            row: row,
                            col: col
                        });
                    }
                }
                return positions;
            }

            transformPattern(pattern, transform) {
                const config = this.getCurrentConfig();
                const transformedConnectedIndices = [];

                console.log('Transform function called with:', transform);
                console.log('Original pattern:', pattern);
                console.log('Grid size:', config.gridSize);

                // å˜æ¢è¿æ¥çš„ç‚¹çš„ç´¢å¼•
                pattern.connectedIndices.forEach(index => {
                    const originalPos = this.allGridPositions[index];
                    let newRow, newCol;

                    console.log(`Transforming index ${index} from position (${originalPos.row}, ${originalPos.col})`);

                    switch (transform) {
                        case 'rotate90':
                            newRow = originalPos.col;
                            newCol = config.gridSize - 1 - originalPos.row;
                            break;
                        case 'rotate-90':
                            newRow = config.gridSize - 1 - originalPos.col;
                            newCol = originalPos.row;
                            break;
                        case 'rotate180':
                            newRow = config.gridSize - 1 - originalPos.row;
                            newCol = config.gridSize - 1 - originalPos.col;
                            break;
                        case 'flipH':
                            newRow = originalPos.row;
                            newCol = config.gridSize - 1 - originalPos.col;
                            break;
                        case 'flipV':
                            newRow = config.gridSize - 1 - originalPos.row;
                            newCol = originalPos.col;
                            break;
                    }

                    const newIndex = newRow * config.gridSize + newCol;
                    console.log(`  -> New position (${newRow}, ${newCol}), index ${newIndex}`);
                    transformedConnectedIndices.push(newIndex);
                });

                console.log('Transformed connected indices:', transformedConnectedIndices);

                // å˜æ¢è¿æ¥å…³ç³»
                const transformedConnections = [];
                pattern.connections.forEach(([startIdx, endIdx]) => {
                    const newStartIdx = transformedConnectedIndices[pattern.connectedIndices.indexOf(startIdx)];
                    const newEndIdx = transformedConnectedIndices[pattern.connectedIndices.indexOf(endIdx)];
                    transformedConnections.push([newStartIdx, newEndIdx]);
                });

                return {
                    connectedIndices: transformedConnectedIndices,
                    connections: transformedConnections
                };
            }

            createLine(start, end) {
                const line = document.createElement('div');
                line.className = 'line';

                if (start.x === end.x) {
                    // å‚ç›´çº¿ - è°ƒæ•´é•¿åº¦ï¼Œä¸è¦è¦†ç›–åˆ°åœ†ç‚¹
                    line.classList.add('vertical-line');
                    line.style.left = `${start.x - 2}px`;
                    const topY = Math.min(start.y, end.y) + 8; // ä»åœ†ç‚¹è¾¹ç¼˜å¼€å§‹
                    const height = Math.abs(end.y - start.y) - 16; // å‡å»ä¸¤ä¸ªåœ†ç‚¹çš„åŠå¾„
                    line.style.top = `${topY}px`;
                    line.style.height = `${Math.max(0, height)}px`;
                } else {
                    // æ°´å¹³çº¿ - è°ƒæ•´é•¿åº¦ï¼Œä¸è¦è¦†ç›–åˆ°åœ†ç‚¹
                    line.classList.add('horizontal-line');
                    const leftX = Math.min(start.x, end.x) + 8; // ä»åœ†ç‚¹è¾¹ç¼˜å¼€å§‹
                    const width = Math.abs(end.x - start.x) - 16; // å‡å»ä¸¤ä¸ªåœ†ç‚¹çš„åŠå¾„
                    line.style.left = `${leftX}px`;
                    line.style.top = `${start.y - 2}px`;
                    line.style.width = `${Math.max(0, width)}px`;
                }

                return line;
            } handleDotClick(index, element) {
                const transformedPositions = this.getTransformedPositions();

                // åªå…è®¸ç‚¹å‡»åº”è¯¥è¢«è¿æ¥çš„ç²‰è‰²ç‚¹
                if (!this.targetPattern.connectedIndices.includes(index)) {
                    return;
                }

                if (this.selectedDot === null) {
                    // é€‰æ‹©ç¬¬ä¸€ä¸ªç‚¹
                    this.selectedDot = index;
                    element.classList.add('selected-dot');
                } else if (this.selectedDot === index) {
                    // å–æ¶ˆé€‰æ‹©
                    this.selectedDot = null;
                    element.classList.remove('selected-dot');
                } else {
                    // è¿æ¥ä¸¤ä¸ªç‚¹
                    const dot1 = transformedPositions[this.selectedDot];
                    const dot2 = transformedPositions[index];

                    if (this.areAdjacent(dot1, dot2)) {
                        // æ£€æŸ¥æ˜¯å¦å·²ç»è¿æ¥
                        const existingConnection = this.userConnections.find(conn =>
                            (conn[0] === this.selectedDot && conn[1] === index) ||
                            (conn[0] === index && conn[1] === this.selectedDot)
                        );

                        if (existingConnection) {
                            // ç§»é™¤è¿æ¥
                            this.userConnections = this.userConnections.filter(conn => conn !== existingConnection);
                        } else {
                            // æ·»åŠ è¿æ¥
                            this.userConnections.push([this.selectedDot, index]);
                        } this.updateUserLines();

                        // è‡ªåŠ¨æ£€æµ‹æ˜¯å¦å®Œæˆ
                        setTimeout(() => {
                            this.autoCheckCompletion();
                        }, 100);

                        // å…³é”®æ”¹è¿›ï¼šä¸æ¸…é™¤é€‰æ‹©çŠ¶æ€ï¼Œè€Œæ˜¯å°†æ–°ç‚¹è®¾ä¸ºé€‰ä¸­çŠ¶æ€
                        // æ¸…é™¤ä¹‹å‰é€‰ä¸­ç‚¹çš„è§†è§‰æ•ˆæœ
                        document.querySelectorAll('.selected-dot').forEach(dot => {
                            dot.classList.remove('selected-dot');
                        });

                        // å°†æ–°ç‚¹è®¾ä¸ºé€‰ä¸­çŠ¶æ€ï¼Œè¿™æ ·å¯ä»¥è¿ç»­è¿æ¥
                        this.selectedDot = index;
                        element.classList.add('selected-dot');
                    } else {
                        // å¦‚æœä¸ç›¸é‚»ï¼Œåˆ™åˆ‡æ¢é€‰æ‹©åˆ°æ–°ç‚¹
                        document.querySelectorAll('.selected-dot').forEach(dot => {
                            dot.classList.remove('selected-dot');
                        });
                        this.selectedDot = index;
                        element.classList.add('selected-dot');
                    }
                }
            }

            updateUserLines() {
                const container = document.getElementById('targetPattern');
                const transformedPositions = this.getTransformedPositions();

                // æ¸…é™¤æ‰€æœ‰ç”¨æˆ·è¿çº¿
                container.querySelectorAll('.line').forEach(line => line.remove());

                // ç»˜åˆ¶ç”¨æˆ·è¿çº¿
                this.userConnections.forEach(([start, end]) => {
                    const startDot = transformedPositions[start];
                    const endDot = transformedPositions[end];
                    const line = this.createLine(startDot, endDot);
                    container.appendChild(line);
                });
            }

            // è‡ªåŠ¨æ£€æµ‹æ˜¯å¦å®Œæˆä»»åŠ¡
            autoCheckCompletion() {
                // åªæœ‰å½“è¿æ¥æ•°é‡æ­£ç¡®æ—¶æ‰è‡ªåŠ¨æ£€æµ‹
                if (this.userConnections.length === this.targetPattern.connections.length) {
                    const correctConnections = this.targetPattern.connections.map(([start, end]) => {
                        return [Math.min(start, end), Math.max(start, end)].join('-');
                    }).sort();

                    const userConnectionStrings = this.userConnections.map(([start, end]) => {
                        return [Math.min(start, end), Math.max(start, end)].join('-');
                    }).sort();

                    const isCorrect = JSON.stringify(correctConnections) === JSON.stringify(userConnectionStrings);

                    if (isCorrect) {
                        // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´è®©ç”¨æˆ·çœ‹åˆ°æœ€åçš„è¿çº¿
                        setTimeout(() => {
                            this.handleCorrectAnswer();
                        }, 500);
                    }
                }
            }

            // å¤„ç†æ­£ç¡®ç­”æ¡ˆçš„é€»è¾‘
            handleCorrectAnswer() {
                // é˜²æ­¢é‡å¤æ‰§è¡Œ
                if (this.isProcessingCorrectAnswer) {
                    return;
                }
                this.isProcessingCorrectAnswer = true;

                // å›ºå®šæ¯å…³20åˆ†
                this.score += this.pointsPerLevel;

                // æ›´æ–°æœ€é«˜åˆ†æ•°
                if (this.score > this.highestScore) {
                    this.highestScore = this.score;
                }

                // Show success effect and toast
                this.showSuccessEffect();
                this.showToast(`æ­£ç¡®ï¼æ­å–œä½ ï¼è·å¾— ${this.pointsPerLevel} åˆ†ï¼`, 'success');

                // æ£€æŸ¥æ˜¯å¦å®Œæˆäº†å½“å‰éš¾åº¦çš„æ‰€æœ‰å…³å¡
                if (this.level >= this.maxLevelsPerDifficulty) {
                    // å®Œæˆäº†å½“å‰éš¾åº¦çš„æ‰€æœ‰10å…³
                    setTimeout(() => {
                        this.showToast(`ğŸ‰ æ­å–œå®Œæˆ${this.difficulty}éš¾åº¦æ‰€æœ‰${this.maxLevelsPerDifficulty}å…³ï¼æ€»åˆ†ï¼š${this.score}åˆ†`, 'success', 6000);
                    }, 1000);

                    // å‘é€æ¸¸æˆå®Œæˆäº‹ä»¶
                    setTimeout(() => {
                        window.parent.postMessage({
                            type: 'gameFinished',
                            data: {
                                score: this.score,
                                level: this.level,
                                difficulty: this.getDifficultyLevel(),
                                completed: true,
                                totalLevels: this.maxLevelsPerDifficulty
                            }
                        }, '*');
                    }, 2000);

                    // é‡ç½®æ ‡å¿—
                    this.isProcessingCorrectAnswer = false;
                    return;
                } else {
                    // è¿˜æœ‰å…³å¡è¦å®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€å…³
                    this.level++;

                    setTimeout(() => {
                        this.showToast(`æ­å–œé€šè¿‡ç¬¬${this.level - 1}å…³ï¼è¿›å…¥ç¬¬${this.level}å…³ (${this.level}/${this.maxLevelsPerDifficulty})`, 'success', 4000);
                    }, 1000);

                    // è‡ªåŠ¨ç”Ÿæˆä¸‹ä¸€å…³é¢˜ç›®
                    setTimeout(() => {
                        this.generatePattern();
                        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸ä¸‹ä¸€å…³çš„å¤„ç†
                        this.isProcessingCorrectAnswer = false;
                    }, 2000);
                } this.updateUI();
            }

            checkAnswer() {
                // é˜²æ­¢é‡å¤æ‰§è¡Œ
                if (this.isProcessingCorrectAnswer) {
                    return;
                }

                // æ£€æŸ¥è¿çº¿æ˜¯å¦æ­£ç¡®
                if (this.userConnections.length !== this.targetPattern.connections.length) {
                    this.showToast(`è¿æ¥æ•°é‡ä¸å¯¹ï¼åº”è¯¥æœ‰ ${this.targetPattern.connections.length} æ¡è¿çº¿ï¼Œæ‚¨è¿äº† ${this.userConnections.length} æ¡ã€‚`, 'error');
                    return;
                }

                const correctConnections = this.targetPattern.connections.map(([start, end]) => {
                    return [Math.min(start, end), Math.max(start, end)].join('-');
                }).sort();

                const userConnectionStrings = this.userConnections.map(([start, end]) => {
                    return [Math.min(start, end), Math.max(start, end)].join('-');
                }).sort();

                const isCorrect = JSON.stringify(correctConnections) === JSON.stringify(userConnectionStrings);

                if (isCorrect) {
                    this.handleCorrectAnswer();
                } else {
                    this.showToast('è¿æ¥ä¸æ­£ç¡®ï¼Œè¯·å†è¯•è¯•ï¼', 'error');
                }

                this.updateUI();
            } clearLines() {
                this.userConnections = [];
                this.selectedDot = null;

                // æ¸…é™¤æ‰€æœ‰é€‰æ‹©çŠ¶æ€çš„è§†è§‰æ•ˆæœ
                document.querySelectorAll('.selected-dot').forEach(dot => {
                    dot.classList.remove('selected-dot');
                });

                // æ¸…é™¤ç”¨æˆ·è¿çº¿
                this.updateUserLines();
            } setDifficulty(newDifficulty) {
                this.difficulty = newDifficulty;

                // å®Œå…¨é‡ç½®æ¸¸æˆçŠ¶æ€ï¼Œä½†ä¿æŒæœ€é«˜åˆ†æ•°
                this.userConnections = [];
                this.selectedDot = null;
                this.originalPattern = { dots: [], connections: [] };
                this.targetPattern = { dots: [], connections: [] };
                // é‡ç½®å½“å‰åˆ†æ•°å’Œå…³å¡ï¼Œä½†ä¿æŒæœ€é«˜åˆ†æ•°
                this.score = 0;
                this.level = 1;
                this.gameStarted = false; // å…è®¸é‡æ–°å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶

                // æ¸…é™¤æ‰€æœ‰é€‰æ‹©çŠ¶æ€çš„è§†è§‰æ•ˆæœ
                document.querySelectorAll('.selected-dot').forEach(dot => {
                    dot.classList.remove('selected-dot');
                });

                // é‡æ–°ç”Ÿæˆé¢˜ç›®
                this.generatePattern();
                this.updateUI();
            } setupEventListeners() {
                document.getElementById('checkBtn').addEventListener('click', () => this.checkAnswer());
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearLines());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());

                document.getElementById('difficultySelect').addEventListener('change', (e) => {
                    this.setDifficulty(e.target.value);
                });
            }

            // æ–°æ¸¸æˆæ–¹æ³•
            newGame() {
                // é‡ç½®æ¸¸æˆçŠ¶æ€ä½†ä¿æŒæœ€é«˜åˆ†æ•°
                this.score = 0;
                this.level = 1;
                this.gameStarted = false; // å…è®¸é‡æ–°å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶
                this.generatePattern();
                this.updateUI();
            }

            updateTransformUI() {
                const transformTexts = {
                    'rotate90': 'é¡ºæ—¶é’ˆæ—‹è½¬ 90Â°',
                    'rotate-90': 'é€†æ—¶é’ˆæ—‹è½¬ 90Â°',
                    'rotate180': 'æ—‹è½¬ 180Â°',
                    'flipH': 'å·¦å³é•œé¢ç¿»è½¬',
                    'flipV': 'ä¸Šä¸‹é•œé¢ç¿»è½¬'
                };

                const transformIcons = {
                    'rotate90': '90Â°',
                    'rotate-90': '-90Â°',
                    'rotate180': '180Â°',
                    'flipH': 'âŸ·',
                    'flipV': 'â†•'
                };

                document.getElementById('transformText').textContent = transformTexts[this.currentTransform];
                document.getElementById('transformIcon').textContent = transformIcons[this.currentTransform];
            }
            showHint() {
                const difficultyNames = { easy: 'ç®€å•', medium: 'ä¸­ç­‰', hard: 'å›°éš¾', expert: 'ä¸“å®¶' };
                const difficultyName = difficultyNames[this.difficulty];
                const hintMessage = `æç¤ºï¼š
1. å½“å‰éš¾åº¦: ${difficultyName}
2. è§‚å¯Ÿå·¦ä¾§ç²‰è‰²ç‚¹å’Œè¿çº¿çš„æ¨¡å¼
3. æƒ³è±¡å®ƒç»è¿‡"${document.getElementById('transformText').textContent}"åçš„æ ·å­
4. å³ä¾§çš„ç²‰è‰²ç‚¹æ˜¯éœ€è¦è¿æ¥çš„ç‚¹
5. ç‚¹å‡»ç›¸é‚»çš„ç²‰è‰²ç‚¹è¿›è¡Œè¿çº¿
6. åªèƒ½è¿æ¥æ°´å¹³æˆ–å‚ç›´ç›¸é‚»çš„ç‚¹`;

                this.showToast(hintMessage, 'info', 8000);
            } updateUI() {
                document.getElementById('level').textContent = `${this.level}/${this.maxLevelsPerDifficulty}`;
                document.getElementById('score').textContent = this.score;
                document.getElementById('highestScore').textContent = this.highestScore;

                this.updateTransformUI();
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        new SpatialGame();
    </script>
</body>

</html>