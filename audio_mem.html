<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title data-i18n="title">éŸ³ä¹è®°å¿†å¤§å¸ˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <style>
        /* å…¨å±åŸºç¡€æ ·å¼ */
        * {
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            font-size: 16px; /* è®¾ç½®æ ¹å­—ä½“å¤§å° */
        }

        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(100%); opacity: 0; }
        }
        
        .playing {
            animation: pulse 0.5s ease-in-out;
            transform: scale(1.05);
        }
        
        .correct {
            animation: pulse 0.3s ease-in-out;
            background-color: #10b981 !important;
        }
        
        .wrong {
            animation: pulse 0.3s ease-in-out;
            background-color: #ef4444 !important;
        }

        /* è§„åˆ™å¼¹çª—æ ·å¼ */
        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: slideUp 0.3s ease-out;
        }
        
        .rules-modal.hide {
            animation: slideDown 0.3s ease-out;
        }
        
        .rules-content {
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            max-width: 768px;
            border-radius: 16px;
            padding: 36px;
            background: white;
            height: auto;
            max-height: 25rem;
            overflow-y: auto;
            box-shadow: 0 1.25rem 2.5rem rgba(0, 0, 0, 0.3);
        }

        .rules-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 36px;
            font-size: 36px;
        }

        .rules-list {
            list-style-type: decimal;
            margin-left: 36px;
            font-weight: 500;
            font-size: 27px;
        }

        .rules-list li {
            margin-bottom: 18px;
        }

        .rules-button {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            padding: 12px 36px;
            border-radius: 16px;
            font-weight: bold;
            font-size: 24px;
        }

        /* æ¸¸æˆä¸»å®¹å™¨ */
        .game-container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* éŸ³ç¬¦ç½‘æ ¼ */
        .sound-grid {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        /* å¤§ç¥éš¾åº¦ç‰¹æ®Šå¸ƒå±€ - 7ä¸ªä½ç½®æ’æˆä¸€è¡Œ */
        .sound-grid.genius {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
        }
        
        .sound-grid.genius .sound-btn {
            height: 6rem;
            font-size: 2rem;
        }
        
        /* éŸ³ç¬¦æŒ‰é’® */
        .sound-btn {
            aspect-ratio: 1;
            height: 7rem;
            border: none;
            border-radius: 1.2rem;
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0.4rem 1rem rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
        }

        .sound-btn:active {
            transform: scale(0.95);
        }

        .sound-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* å¤§ç¥éš¾åº¦éŸ³è°ƒèƒŒæ™¯è‰² - å½©è™¹è‰²è°ƒ */
        .tone-1 { 
            background: linear-gradient(135deg, #ef4444, #dc2626) !important; 
            border: 3px solid #fca5a5 !important;
        } /* çº¢è‰² - Do */
        .tone-2 { 
            background: linear-gradient(135deg, #f97316, #ea580c) !important; 
            border: 3px solid #fdba74 !important;
        } /* æ©™è‰² - Re */
        .tone-3 { 
            background: linear-gradient(135deg, #eab308, #ca8a04) !important; 
            border: 3px solid #fde047 !important;
        } /* é»„è‰² - Mi */
        .tone-4 { 
            background: linear-gradient(135deg, #22c55e, #16a34a) !important; 
            border: 3px solid #86efac !important;
        } /* ç»¿è‰² - Fa */
        .tone-5 { 
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important; 
            border: 3px solid #93c5fd !important;
        } /* è“è‰² - Sol */
        .tone-6 { 
            background: linear-gradient(135deg, #8b5cf6, #7c3aed) !important; 
            border: 3px solid #c4b5fd !important;
        } /* ç´«è‰² - La */
        .tone-7 { 
            background: linear-gradient(135deg, #ec4899, #db2777) !important; 
            border: 3px solid #f9a8d4 !important;
        } /* ç²‰è‰² - Si */

        /* æ‚¬æµ®è§„åˆ™æŒ‰é’® */
        .rules-float-btn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            box-shadow: 0 0.3rem 0.8rem rgba(0, 0, 0, 0.3);
            cursor: pointer;
            font-size: 1.8rem;
            z-index: 100;
            transition: all 0.2s ease;
        }

        .rules-float-btn:hover {
            transform: scale(1.1);
            background: white;
        }
        
        /* ç»“æœåé¦ˆæ ·å¼ */
        .feedback-item {
            display: inline-flex;
            align-items: center;
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .feedback-correct {
            background-color: #10b981;
            color: white;
        }
        
        .feedback-wrong {
            background-color: #ef4444;
            color: white;
        }

        /* ä¸»ç•Œé¢éš¾åº¦é€‰æ‹©æŒ‰é’®æ ·å¼ */
        .main-difficulty-btn {
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .main-difficulty-btn.selected {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .flex-1 {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <script>
const translations = {
  zhCN: {
    title: 'éŸ³ä¹è®°å¿†å¤§å¸ˆ',
    gameRules: {
      title: 'ğŸµ éŸ³ä¹è®°å¿†æŒ‘æˆ˜',
      rule1: 'è®°ä½ä¸åŒä¹å™¨æ¼”å¥çš„éŸ³è°ƒ',
      rule2: 'æŒ‰å¬åˆ°çš„éŸ³è°ƒé¡ºåºç‚¹å‡»å¯¹åº”ä¹å™¨',
      startTraining: 'å¼€å§‹è®­ç»ƒ'
    },
    ui: {
      level: 'å…³å¡:',
      score: 'å¾—åˆ†:',
      previewTitle: 'è¯•å¬ä¸åŒéŸ³è°ƒ',
      previewDesc: 'ç‚¹å‡»ä¹å™¨å›¾æ ‡ç†Ÿæ‚‰å„éŸ³è°ƒï¼Œå‡†å¤‡å¥½åç‚¹å‡»å¼€å§‹æŒ‘æˆ˜',
      startChallenge: 'å¼€å§‹æŒ‘æˆ˜',
      challengeRound: 'ç¬¬',
      challengeRoundSuffix: 'å…³',
      challengeMessage1: 'å‡†å¤‡å¬éŸ³è°ƒåºåˆ—...',
      challengeMessage2: 'ä»”ç»†å¬éŸ³è‰²åºåˆ—... ğŸ§',
      challengeMessage3: 'è¯·æŒ‰é¡ºåºç‚¹å‡»å¯¹åº”çš„ä¹å™¨ ğŸµ',
      waitingInput: 'ç­‰å¾…è¾“å…¥...',
      resetAnswer: 'é‡æ–°è¾“å…¥',
      confirmAnswer: 'ç¡®è®¤ç­”æ¡ˆ',
      difficultyTitle: 'é€‰æ‹©æ¸¸æˆéš¾åº¦',
      difficultyEasy: 'ç®€å•',
      difficultyEasyDesc: '3ç§éŸ³è°ƒ',
      difficultyMedium: 'ä¸­ç­‰',
      difficultyMediumDesc: '4ç§éŸ³è°ƒ',
      difficultyHard: 'å›°éš¾',
      difficultyHardDesc: '6ç§éŸ³è°ƒ',
      difficultyGenius: 'å¤§ç¥',
      difficultyGeniusDesc: '7ä¸ªä½ç½®+éŸ³è°ƒ',
      selectDifficultyFirst: 'é€‰æ‹©éš¾åº¦åå¼€å§‹',
      rulesButtonTitle: 'æŸ¥çœ‹æ¸¸æˆè§„åˆ™',
      replayingSequence: 'æ­£åœ¨é‡æ”¾éŸ³è‰²åºåˆ—...',
      correct: 'æ­£ç¡®:',
      roundScore: 'æœ¬å…³å¾—åˆ†:',
      totalScore: 'æ€»åˆ†:',
      gameComplete: 'ğŸ‰ {difficulty}éš¾åº¦æŒ‘æˆ˜å®Œæˆï¼æœ€ç»ˆå¾—åˆ†ï¼š{score} åˆ†',
      previewModeGenius: '{difficulty}éš¾åº¦ - è¯•å¬7ä¸ªä½ç½®çš„ä¸åŒä¹å™¨å’ŒéŸ³è°ƒç»„åˆ',
      previewModeNormal: '{difficulty}éš¾åº¦ - è¯•å¬{count}ç§ä¸åŒéŸ³è°ƒ',
      startDifficultyChallenge: 'å¼€å§‹{difficulty}æŒ‘æˆ˜'
    },
    difficulty: {
      easy: 'ç®€å•',
      medium: 'ä¸­ç­‰',
      hard: 'å›°éš¾',
      genius: 'å¤§ç¥'
    }
  },
  enUS: {
    title: 'Music Memory Master',
    gameRules: {
      title: 'ğŸµ Music Memory Challenge',
      rule1: 'Remember different tones played by instruments',
      rule2: 'Click instruments in the order you heard',
      startTraining: 'Start Training'
    },
    ui: {
      level: 'Level:',
      score: 'Score:',
      previewTitle: 'Preview Different Tones',
      previewDesc: 'Click instrument icons to familiarize with tones, then click start challenge when ready',
      startChallenge: 'Start Challenge',
      challengeRound: 'Round ',
      challengeRoundSuffix: '',
      challengeMessage1: 'Get ready to hear the tone sequence...',
      challengeMessage2: 'Listen carefully to the tone sequence... ğŸ§',
      challengeMessage3: 'Click instruments in order ğŸµ',
      waitingInput: 'Waiting for input...',
      resetAnswer: 'Reset',
      confirmAnswer: 'Confirm',
      difficultyTitle: 'Select Game Difficulty',
      difficultyEasy: 'Easy',
      difficultyEasyDesc: '3 tones',
      difficultyMedium: 'Medium',
      difficultyMediumDesc: '4 tones',
      difficultyHard: 'Hard',
      difficultyHardDesc: '6 tones',
      difficultyGenius: 'Master',
      difficultyGeniusDesc: '7 positions + tones',
      selectDifficultyFirst: 'Select difficulty to start',
      rulesButtonTitle: 'View game rules',
      replayingSequence: 'Replaying tone sequence...',
      correct: 'Correct:',
      roundScore: 'Round Score:',
      totalScore: 'Total Score:',
      gameComplete: 'ğŸ‰ {difficulty} difficulty challenge completed! Final score: {score} points',
      previewModeGenius: '{difficulty} difficulty - Preview 7 different instrument and tone combinations',
      previewModeNormal: '{difficulty} difficulty - Preview {count} different tones',
      startDifficultyChallenge: 'Start {difficulty} Challenge'
    },
    difficulty: {
      easy: 'Easy',
      medium: 'Medium',
      hard: 'Hard',
      genius: 'Master'
    }
  }
}
function getLanguage() {
  const urlParams = new URLSearchParams(window.location.search)
  const langParam = urlParams.get('lang')
  
  if (langParam === 'zhCN' || langParam === 'enUS') {
    return langParam
  }
  
  const browserLang = navigator.language || navigator.userLanguage
  
  if (browserLang.startsWith('zh')) {
    return 'zhCN'
  } else {
    return 'enUS'
  }
}
function updatePageText() {
  const t = translations[currentLanguage]
  
  document.title = t.title
  
  // Update document language
  document.documentElement.lang = currentLanguage === 'zhCN' ? 'zh-CN' : 'en-US'
  
  function updateElementText(element, key) {
    const keys = key.split('.')
    let value = t
    for (const k of keys) {
      value = value[k]
      if (!value) return false
    }
    element.textContent = value
    return true
  }
  
  function updateElementTitle(element, key) {
    const keys = key.split('.')
    let value = t
    for (const k of keys) {
      value = value[k]
      if (!value) return false
    }
    element.title = value
    return true
  }
  
  document.querySelectorAll('[data-i18n]').forEach(element => {
    const key = element.getAttribute('data-i18n')
    updateElementText(element, key)
  })
  
  document.querySelectorAll('[data-i18n-title]').forEach(element => {
    const key = element.getAttribute('data-i18n-title')
    updateElementTitle(element, key)
  })
}
currentLanguage = getLanguage()
t = translations[currentLanguage]; // global translation table
</script>    <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
    <div id="rulesModal" class="rules-modal" style="display: none;">
        <div class="rules-content">
            <div class="rules-header">
                <h2 class="font-bold text-purple-800" data-i18n="gameRules.title">ğŸµ éŸ³ä¹è®°å¿†æŒ‘æˆ˜</h2>
                <button id="closeRules" class="text-gray-500 hover:text-gray-700">&times;</button>
            </div>
            <ol class="rules-list text-gray-700">
                <li data-i18n="gameRules.rule1">è®°ä½ä¸åŒä¹å™¨æ¼”å¥çš„éŸ³è°ƒ</li>
                <li data-i18n="gameRules.rule2">æŒ‰å¬åˆ°çš„éŸ³è°ƒé¡ºåºç‚¹å‡»å¯¹åº”ä¹å™¨</li>
            </ol>
            <button id="startTrainingBtn" class="rules-button bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 shadow-lg" data-i18n="gameRules.startTraining">
                å¼€å§‹è®­ç»ƒ
            </button>
        </div>
    </div>

    <!-- ä¸»æ¸¸æˆç•Œé¢ -->
    <div class="game-container">        <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
        <div class="flex-shrink-0 p-4">
            <div class="flex justify-center gap-6 text-2xl">
                <div class="bg-white bg-opacity-20 px-4 py-2 rounded-lg text-white">
                    <span class="font-semibold" data-i18n="ui.level">å…³å¡:</span> <span id="level">-</span>
                </div>
                <div class="bg-white bg-opacity-20 px-4 py-2 rounded-lg text-white">
                    <span class="font-semibold" data-i18n="ui.score">å¾—åˆ†:</span> <span id="score">0</span>
                </div>
            </div>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="flex-1 flex flex-col justify-center p-4">            <!-- è¯•å¬é˜¶æ®µç•Œé¢ -->
            <div id="previewSection" class="text-center mb-6" style="display: none;">
                <h3 class="text-white text-4xl font-bold mb-4" data-i18n="ui.previewTitle">è¯•å¬ä¸åŒéŸ³è°ƒ</h3>
                <p class="text-white text-2xl mb-6" data-i18n="ui.previewDesc">ç‚¹å‡»ä¹å™¨å›¾æ ‡ç†Ÿæ‚‰å„éŸ³è°ƒï¼Œå‡†å¤‡å¥½åç‚¹å‡»å¼€å§‹æŒ‘æˆ˜</p>
                <button id="startChallengeBtn" class="bg-gradient-to-r from-green-500 to-blue-500 text-white px-8 py-4 rounded-full text-3xl font-bold hover:from-green-600 hover:to-blue-600 transition-all transform hover:scale-105 shadow-lg" data-i18n="ui.startChallenge">
                    å¼€å§‹æŒ‘æˆ˜
                </button>
            </div>
              <!-- æŒ‘æˆ˜é˜¶æ®µç•Œé¢ -->
            <div id="challengeSection" class="text-center mb-6" style="display: none;">
                <h3 class="text-white text-4xl font-bold mb-4"><span data-i18n="ui.challengeRound">ç¬¬</span> <span id="currentRound">1</span> <span data-i18n="ui.challengeRoundSuffix">å…³</span></h3>
                <p id="challengeMessage" class="text-white text-2xl mb-4" data-i18n="ui.challengeMessage1">å‡†å¤‡å¬éŸ³è°ƒåºåˆ—...</p>
                <!-- 
                <div class="text-2xl bg-white bg-opacity-20 px-4 py-2 rounded-lg text-white inline-block mb-4">
                    <span class="font-semibold">æœ¬å…³éŸ³è°ƒæ•°:</span> <span id="sequenceLength">0</span>
                </div>
                -->
                  <!-- ç”¨æˆ·è¾“å…¥æ˜¾ç¤ºå’Œæ§åˆ¶æŒ‰é’® -->
                <div id="inputSection" class="mt-6" style="display: none;">
                    <div id="userSequenceDisplay" class="text-white text-3xl mb-4 min-h-[3rem] bg-white bg-opacity-20 p-4 rounded-lg" data-i18n="ui.waitingInput">
                        ç­‰å¾…è¾“å…¥...
                    </div>
                    <div class="flex justify-center gap-4">
                        <button id="resetAnswerBtn" class="bg-orange-500 hover:bg-orange-600 text-white px-6 py-3 rounded-lg text-xl font-bold transition-all transform hover:scale-105" data-i18n="ui.resetAnswer">
                            é‡æ–°è¾“å…¥
                        </button>
                        <button id="confirmAnswerBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg text-xl font-bold transition-all transform hover:scale-105" disabled data-i18n="ui.confirmAnswer">
                            ç¡®è®¤ç­”æ¡ˆ
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- ç»“ç®—é˜¶æ®µç•Œé¢ -->
            <div id="resultSection" class="text-center mb-6" style="display: none;">
                <!-- <h3 class="text-white text-2xl font-bold mb-4">å…³å¡ç»“ç®—</h3> -->
                <div id="resultDisplay" class="bg-white bg-opacity-20 p-6 rounded-lg text-white mb-4">
                    <div id="answerFeedback" class="mb-4"></div>
                    <div id="scoreInfo" class="text-2xl"></div>
                </div>
            </div>

            <div class="sound-grid mb-6" id="soundGrid">
                <button class="sound-btn bg-red-400 hover:bg-red-500" data-sound="0">ğŸ¹</button>
                <button class="sound-btn bg-orange-400 hover:bg-orange-500" data-sound="1">ğŸ¸</button>
                <button class="sound-btn bg-yellow-400 hover:bg-yellow-500" data-sound="2">ğŸ¥</button>
                <button class="sound-btn bg-green-400 hover:bg-green-500" data-sound="3">ğŸº</button>
                <button class="sound-btn bg-blue-400 hover:bg-blue-500" data-sound="4">ğŸ»</button>
                <button class="sound-btn bg-purple-400 hover:bg-purple-500" data-sound="5">ğŸ·</button>
                <button class="sound-btn bg-pink-400 hover:bg-pink-500" data-sound="6">ğŸ¼</button>
            </div>            <!-- éš¾åº¦é€‰æ‹©ç•Œé¢ -->
            <div id="difficultySection" class="text-center">
                <h3 class="text-white text-4xl font-bold mb-6" data-i18n="ui.difficultyTitle">é€‰æ‹©æ¸¸æˆéš¾åº¦</h3>
                <div class="grid grid-cols-2 gap-6 max-w-3xl mx-auto mb-8">
                    <button class="main-difficulty-btn bg-green-400 hover:bg-green-500 text-white py-4 px-6 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 shadow-lg" data-difficulty="easy">
                        <span data-i18n="ui.difficultyEasy">ç®€å•</span><br><span class="text-lg" data-i18n="ui.difficultyEasyDesc">3ç§éŸ³è°ƒ</span>
                    </button>
                    <button class="main-difficulty-btn bg-orange-400 hover:bg-orange-500 text-white py-4 px-6 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 shadow-lg" data-difficulty="medium">
                        <span data-i18n="ui.difficultyMedium">ä¸­ç­‰</span><br><span class="text-lg" data-i18n="ui.difficultyMediumDesc">4ç§éŸ³è°ƒ</span>
                    </button>
                    <button class="main-difficulty-btn bg-red-400 hover:bg-red-500 text-white py-4 px-6 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 shadow-lg" data-difficulty="hard">
                        <span data-i18n="ui.difficultyHard">å›°éš¾</span><br><span class="text-lg" data-i18n="ui.difficultyHardDesc">6ç§éŸ³è°ƒ</span>
                    </button>
                    <button class="main-difficulty-btn bg-purple-600 hover:bg-purple-700 text-white py-4 px-6 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 shadow-lg" data-difficulty="genius">
                        <span data-i18n="ui.difficultyGenius">å¤§ç¥</span><br><span class="text-lg" data-i18n="ui.difficultyGeniusDesc">7ä¸ªä½ç½®+éŸ³è°ƒ</span>
                    </button>
                </div>
                <button id="startGameBtn" class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-12 py-5 rounded-full text-4xl font-bold hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 shadow-lg" disabled data-i18n="ui.selectDifficultyFirst">
                    é€‰æ‹©éš¾åº¦åå¼€å§‹
                </button>
            </div>

            <!-- æ¶ˆæ¯å’Œæ§åˆ¶åŒºåŸŸ -->
            <div class="text-center mt-6">
                <p id="message" class="text-white text-3xl font-semibold min-h-[32px]"></p>
            </div>
        </div>

    </div>    <!-- æ‚¬æµ®è§„åˆ™æŒ‰é’® -->
    <button id="rulesFloatBtn" class="rules-float-btn" data-i18n-title="ui.rulesButtonTitle" title="æŸ¥çœ‹æ¸¸æˆè§„åˆ™">
        â“
    </button>

    <script>
        // å…¨å±€å˜é‡å’Œé…ç½®
        let game_config = '';
        let gameStarted = false;
        
        // éŸ³é¢‘ä¸Šä¸‹æ–‡
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // éŸ³ç¬¦é¢‘ç‡ï¼ˆCå¤§è°ƒéŸ³é˜¶ï¼‰
        let frequencies = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88]; // C4 åˆ° B4ï¼Œ7ä¸ªéŸ³è°ƒ
          // éš¾åº¦é…ç½®
        const difficultyConfig = {
            easy: { instruments: 3, rounds: 5, name: 'easy' },
            medium: { instruments: 4, rounds: 7, name: 'medium' },
            hard: { instruments: 6, rounds: 10, name: 'hard' },
            genius: { instruments: 7, rounds: 12, name: 'genius' }
        };
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            difficulty: null,
            currentRound: 1,
            totalRounds: 0,
            instrumentCount: 0,
            currentSequence: [],
            playerSequence: [],
            totalScore: 0,
            gamePhase: 'menu', // menu, preview, challenge, playing, answering, result, finished
            roundScores: [],
            // å¤§ç¥éš¾åº¦ä¸“ç”¨é…ç½®
            geniusMode: false,
            currentInstruments: [], // å¤§ç¥éš¾åº¦ä¸‹æ¯ä¸ªä½ç½®çš„å®é™…ä¹å™¨
            currentTones: [] // å¤§ç¥éš¾åº¦ä¸‹æ¯ä¸ªä½ç½®çš„éŸ³è°ƒ(1-7)
        };

        // DOM å…ƒç´ 
        const rulesModal = document.getElementById('rulesModal');
        const closeRulesBtn = document.getElementById('closeRules');
        const rulesFloatBtn = document.getElementById('rulesFloatBtn');
        const startTrainingBtn = document.getElementById('startTrainingBtn');
        const mainDifficultyBtns = document.querySelectorAll('.main-difficulty-btn');
        const difficultySection = document.getElementById('difficultySection');
        const previewSection = document.getElementById('previewSection');
        const challengeSection = document.getElementById('challengeSection');
        const resultSection = document.getElementById('resultSection');
        const startChallengeBtn = document.getElementById('startChallengeBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const soundBtns = document.querySelectorAll('.sound-btn');
        
        // æ–°å¢çš„DOMå…ƒç´ 
        const inputSection = document.getElementById('inputSection');
        const userSequenceDisplay = document.getElementById('userSequenceDisplay');
        const resetAnswerBtn = document.getElementById('resetAnswerBtn');
        const confirmAnswerBtn = document.getElementById('confirmAnswerBtn');        // ä¸»ç•Œé¢éš¾åº¦é€‰æ‹©å¤„ç†
        mainDifficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                mainDifficultyBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.difficulty = btn.dataset.difficulty;
                startGameBtn.disabled = false;
                startGameBtn.textContent = t.ui.startDifficultyChallenge.replace('{difficulty}', t.difficulty[gameState.difficulty]);
            });
        });

        // è§„åˆ™å¼¹çª—æ§åˆ¶
        function showRules() {
            rulesModal.style.display = 'flex';
        }

        function hideRules() {
            rulesModal.style.display = 'none';
        }        function resetMainDifficultySelection() {
            mainDifficultyBtns.forEach(b => b.classList.remove('selected'));
            gameState.difficulty = null;
            startGameBtn.disabled = true;
            startGameBtn.textContent = t.ui.selectDifficultyFirst;
        }

        // ä»ä¸»ç•Œé¢å¼€å§‹æ¸¸æˆ
        function startGameFromMain() {
            if (!gameState.difficulty) return;
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå¤§ç¥éš¾åº¦
            gameState.geniusMode = (gameState.difficulty === 'genius');
            
            // å¤§ç¥éš¾åº¦ç‰¹æ®Šåˆå§‹åŒ–
            if (gameState.geniusMode) {
                initGeniusMode();
            }
            
            difficultySection.style.display = 'none';
            initGame();
        }

        // åˆå§‹åŒ–å¤§ç¥éš¾åº¦
        function initGeniusMode() {
            // ä¸º7ä¸ªä½ç½®éšæœºåˆ†é…ä¹å™¨ï¼ˆå¯èƒ½ç›¸åŒï¼‰
            const availableInstruments = ['piano', 'guitar', 'drum', 'trumpet', 'violin', 'saxophone'];
            gameState.currentInstruments = [];
            gameState.currentTones = [];
            
            for (let i = 0; i < 7; i++) {
                // éšæœºé€‰æ‹©ä¹å™¨ï¼ˆå¯èƒ½é‡å¤ï¼‰
                const randomInstrument = availableInstruments[Math.floor(Math.random() * availableInstruments.length)];
                gameState.currentInstruments.push(randomInstrument);
                
                // éŸ³è°ƒä»1åˆ°7æ’åˆ—
                gameState.currentTones.push(i + 1);
            }
            
            console.log('Genius mode initialized:', gameState.currentInstruments, gameState.currentTones);
        }

        // æ’­æ”¾éŸ³ç¬¦
        function playSound(index, duration = 600, showAnimation = true) {
            // åœ¨ä¸»ç•Œé¢æ—¶å…è®¸æ’­æ”¾æ‰€æœ‰ä¹å™¨ï¼Œåœ¨æ¸¸æˆä¸­æ—¶é™åˆ¶ä¹å™¨æ•°é‡
            if (gameState.gamePhase !== 'menu' && index >= gameState.instrumentCount) return;
            
            // å¤§ç¥éš¾åº¦ä¸‹ä½¿ç”¨ç‰¹æ®Šé€»è¾‘
            if (gameState.geniusMode && gameState.currentInstruments.length > 0) {
                if (index < gameState.currentInstruments.length) {
                    const instrument = gameState.currentInstruments[index];
                    const tone = gameState.currentTones[index];
                    const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4']; // 7ä¸ªéŸ³è°ƒ
                    const note = notes[tone - 1]; // tone æ˜¯ 1-7ï¼Œæ•°ç»„ç´¢å¼•æ˜¯ 0-6
                    
                    const volume = instrument === 'drum' ? 3.5 : 1;
                    playInstrument(instrument, note, duration, volume, showAnimation, index);
                }
                return;
            }
            
            // æ™®é€šéš¾åº¦çš„é€»è¾‘
            const instruments = ['piano', 'guitar', 'drum', 'trumpet', 'violin', 'saxophone', 'organ'];
            const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4'];
            
            if (index < instruments.length) {
                // ä½¿ç”¨å¯¹åº”çš„ä¹å™¨éŸ³è‰²ï¼Œé¼“å£°éœ€è¦æ›´å¤§éŸ³é‡
                const volume = instruments[index] === 'drum' ? 3.5 : 1;
                playInstrument(instruments[index], notes[index], duration, volume, showAnimation, index);
            } else {
                // åå¤‡æ–¹æ¡ˆï¼šä½¿ç”¨åŸæ¥çš„ç®€å•éŸ³è°ƒ
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequencies[index];
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
                
                // åªåœ¨å…è®¸æ˜¾ç¤ºåŠ¨ç”»æ—¶æ‰æ·»åŠ è·³åŠ¨æ•ˆæœ
                if (showAnimation) {
                    const btn = document.querySelector(`[data-sound="${index}"]`);
                    if (btn) {
                        btn.classList.add('playing');
                        setTimeout(() => btn.classList.remove('playing'), duration);
                    }
                }
            }
        }

        // ä¹å™¨éŸ³è‰²é…ç½®
        const instrumentConfig = {
            piano: {
                type: 'triangle',
                attack: 0.01,
                decay: 0.3,
                sustain: 0.3,
                release: 0.8,
                harmonics: [1, 0.5, 0.25, 0.125]
            },
            guitar: {
                type: 'sawtooth',
                attack: 0.02,
                decay: 0.1,
                sustain: 0.7,
                release: 1.5,
                harmonics: [1, 0.7, 0.4, 0.2, 0.1]
            },
            violin: {
                type: 'sawtooth',
                attack: 0.1,
                decay: 0.2,
                sustain: 0.8,
                release: 0.5,
                harmonics: [1, 0.8, 0.6, 0.4, 0.3, 0.2]
            },
            flute: {
                type: 'sine',
                attack: 0.05,
                decay: 0.1,
                sustain: 0.9,
                release: 0.3,
                harmonics: [1, 0.3, 0.1, 0.05]
            },
            trumpet: {
                type: 'square',
                attack: 0.05,
                decay: 0.2,
                sustain: 0.6,
                release: 0.4,
                harmonics: [1, 0.6, 0.4, 0.3, 0.2, 0.1]
            },
            saxophone: {
                type: 'square',
                attack: 0.08,
                decay: 0.15,
                sustain: 0.7,
                release: 0.6,
                harmonics: [1, 0.8, 0.5, 0.3, 0.2]
            },
            organ: {
                type: 'square',
                attack: 0.01,
                decay: 0.05,
                sustain: 0.9,
                release: 0.2,
                harmonics: [1, 0.8, 0.6, 0.4, 0.3, 0.2, 0.1]
            },
            bell: {
                type: 'triangle',
                attack: 0.01,
                decay: 0.8,
                sustain: 0.1,
                release: 2.0,
                harmonics: [1, 0.6, 0.4, 0.3, 0.2, 0.15, 0.1, 0.08]
            },
            drum: {
                type: 'white_noise',
                attack: 0.005,
                decay: 0.05,
                sustain: 0.2,
                release: 0.5,
                filter: { type: 'lowpass', frequency: 500 }
            },
            bass: {
                type: 'triangle',
                attack: 0.02,
                decay: 0.1,
                sustain: 0.8,
                release: 0.5,
                harmonics: [1, 0.8, 0.3, 0.1]
            }
        };

        // éŸ³ç¬¦é¢‘ç‡è¡¨ (C4-B7)
        const noteFrequencies = {
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23,
            'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46,
            'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            'C6': 1046.50, 'C#6': 1108.73, 'D6': 1174.66, 'D#6': 1244.51, 'E6': 1318.51, 'F6': 1396.91,
            'F#6': 1479.98, 'G6': 1567.98, 'G#6': 1661.22, 'A6': 1760.00, 'A#6': 1864.66, 'B6': 1975.53,
            'C7': 2093.00, 'C#7': 2217.46, 'D7': 2349.32, 'D#7': 2489.02, 'E7': 2637.02, 'F7': 2793.83,
            'F#7': 2959.96, 'G7': 3135.96, 'G#7': 3322.44, 'A7': 3520.00, 'A#7': 3729.31, 'B7': 3951.07
        };

        // æ’­æ”¾ä¹å™¨éŸ³è‰²
        function playInstrument(instrument, note, duration = 600, volume = 1, showAnimation = true, buttonIndex = null) {
            if (!instrumentConfig[instrument]) {
                console.warn(`ä¹å™¨ "${instrument}" ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤é’¢ç´éŸ³è‰²`);
                instrument = 'piano';
            }

            const frequency = typeof note === 'string' ? noteFrequencies[note] : note;
            if (!frequency) {
                console.warn(`éŸ³ç¬¦ "${note}" ä¸å­˜åœ¨`);
                return;
            }

            const config = instrumentConfig[instrument];
            const durationInSeconds = duration / 1000;

            // åˆ›å»ºéŸ³é¢‘èŠ‚ç‚¹
            const gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);

            if (config.type === 'white_noise') {
                // åˆ›å»ºç™½å™ªå£°ç”¨äºæ‰“å‡»ä¹å™¨
                playWhiteNoise(gainNode, config, durationInSeconds, volume);
            } else {
                // åˆ›å»ºä¸»æŒ¯è¡å™¨
                const oscillator = audioContext.createOscillator();
                oscillator.connect(gainNode);
                oscillator.frequency.value = frequency;
                oscillator.type = config.type;

                // å¦‚æœæœ‰æ³›éŸ³ï¼Œæ·»åŠ é¢å¤–çš„æŒ¯è¡å™¨
                if (config.harmonics && config.harmonics.length > 1) {
                    for (let i = 1; i < config.harmonics.length; i++) {
                        const harmonic = audioContext.createOscillator();
                        const harmonicGain = audioContext.createGain();
                        
                        harmonic.connect(harmonicGain);
                        harmonicGain.connect(gainNode);
                        
                        harmonic.frequency.value = frequency * (i + 1);
                        harmonic.type = config.type;
                        
                        harmonicGain.gain.setValueAtTime(
                            volume * config.harmonics[i], 
                            audioContext.currentTime
                        );
                        
                        harmonic.start(audioContext.currentTime);
                        harmonic.stop(audioContext.currentTime + durationInSeconds);
                    }
                }

                // è®¾ç½®åŒ…ç»œçº¿ (ADSR)
                setADSREnvelope(gainNode, config, durationInSeconds, volume);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + durationInSeconds);
            }

            // åŠ¨ç”»æ•ˆæœ
            if (showAnimation) {
                if (gameState.geniusMode && gameState.currentInstruments.length > 0) {
                    // ä½¿ç”¨ä¼ å…¥çš„æŒ‰é’®ç´¢å¼•ï¼Œç¡®ä¿åŠ¨ç”»æ˜¾ç¤ºåœ¨æ­£ç¡®çš„æŒ‰é’®ä¸Š
                    if (buttonIndex !== null && buttonIndex >= 0) {
                        const btn = document.querySelector(`[data-sound="${buttonIndex}"]`);
                        if (btn) {
                            btn.classList.add('playing');
                            setTimeout(() => btn.classList.remove('playing'), duration);
                        }
                    }
                } else {
                    // æ™®é€šéš¾åº¦ï¼šæ‰¾åˆ°å¯¹åº”çš„æŒ‰é’®ç´¢å¼•
                    const instruments = ['piano', 'guitar', 'drum', 'trumpet', 'violin', 'saxophone', 'organ'];
                    const instrumentIndex = instruments.indexOf(instrument);
                    if (instrumentIndex !== -1) {
                        const btn = document.querySelector(`[data-sound="${instrumentIndex}"]`);
                        if (btn) {
                            btn.classList.add('playing');
                            setTimeout(() => btn.classList.remove('playing'), duration);
                        }
                    }
                }
            }
        }

        // è®¾ç½®ADSRåŒ…ç»œçº¿
        function setADSREnvelope(gainNode, config, duration, volume) {
            const currentTime = audioContext.currentTime;
            const attackTime = config.attack || 0.01;
            const decayTime = config.decay || 0.1;
            const sustainLevel = (config.sustain || 0.7) * volume;
            const releaseTime = config.release || 0.5;

            // Attack
            gainNode.gain.setValueAtTime(0, currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, currentTime + attackTime);

            // Decay
            gainNode.gain.linearRampToValueAtTime(sustainLevel, currentTime + attackTime + decayTime);

            // Sustain (æŒç»­åˆ°é‡Šæ”¾å¼€å§‹)
            const sustainDuration = Math.max(0, duration - attackTime - decayTime - releaseTime);
            
            // Release
            const releaseStartTime = currentTime + attackTime + decayTime + sustainDuration;
            gainNode.gain.setValueAtTime(sustainLevel, releaseStartTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, releaseStartTime + releaseTime);
        }

        // æ’­æ”¾ç™½å™ªå£°ï¼ˆç”¨äºæ‰“å‡»ä¹å™¨ï¼‰
        function playWhiteNoise(gainNode, config, duration, volume) {
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // ç”Ÿæˆç™½å™ªå£°
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * volume;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            // æ·»åŠ æ»¤æ³¢å™¨
            if (config.filter) {
                const filter = audioContext.createBiquadFilter();
                filter.type = config.filter.type;
                filter.frequency.value = config.filter.frequency;
                source.connect(filter);
                filter.connect(gainNode);
            } else {
                source.connect(gainNode);
            }

            // è®¾ç½®åŒ…ç»œçº¿
            setADSREnvelope(gainNode, config, duration, volume);

            source.start(audioContext.currentTime);
        }

        // æ’­æ”¾å’Œå¼¦
        function playChord(instrument, notes, duration = 600, volume = 1) {
            notes.forEach((note, index) => {
                setTimeout(() => {
                    playInstrument(instrument, note, duration, volume, false);
                }, index * 10); // è½»å¾®å»¶è¿Ÿåˆ›é€ å’Œå¼¦æ•ˆæœ
            });
        }


        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            if (!gameStarted) {
                window.parent.postMessage({ type: 'gameStarted' }, '*');
                gameStarted = true;
            }

            const config = difficultyConfig[gameState.difficulty];
            gameState.currentRound = 1;
            gameState.totalRounds = config.rounds;
            gameState.instrumentCount = config.instruments;
            gameState.totalScore = 0;
            gameState.roundScores = [];
            gameState.gamePhase = 'preview';

            updateDisplay();
            showPreviewPhase();
        }

        // æ˜¾ç¤ºè¯•å¬é˜¶æ®µ
        function showPreviewPhase() {
            hideAllSections();
            previewSection.style.display = 'block';
            
            // æ›´æ–°éŸ³ç¬¦ç½‘æ ¼å¸ƒå±€
            updateSoundGridLayout();
            
            // éšè—è¶…å‡ºéš¾åº¦çš„ä¹å™¨
            soundBtns.forEach((btn, index) => {
                if (index < gameState.instrumentCount) {
                    btn.style.display = 'block';
                    btn.disabled = false;
                } else {
                    btn.style.display = 'none';
                }
            });            // æ›´æ–°æ¶ˆæ¯æ–‡æœ¬
            if (gameState.geniusMode) {
                updateMessage(t.ui.previewModeGenius.replace('{difficulty}', t.difficulty[gameState.difficulty]));
            } else {
                updateMessage(t.ui.previewModeNormal.replace('{difficulty}', t.difficulty[gameState.difficulty]).replace('{count}', gameState.instrumentCount));
            }
        }

        // æ›´æ–°éŸ³ç¬¦ç½‘æ ¼å¸ƒå±€
        function updateSoundGridLayout() {
            const soundGrid = document.getElementById('soundGrid');
            soundGrid.className = `sound-grid ${gameState.difficulty}`;
            
            // å¤§ç¥éš¾åº¦ä¸‹æ›´æ–°æŒ‰é’®å¤–è§‚
            if (gameState.geniusMode && gameState.currentInstruments.length > 0) {
                updateGeniusButtons();
            }
        }

        // æ›´æ–°å¤§ç¥éš¾åº¦ä¸‹çš„æŒ‰é’®å¤–è§‚
        function updateGeniusButtons() {
            const soundBtns = document.querySelectorAll('.sound-btn');
            const instrumentEmojis = {
                'piano': 'ğŸ¹',
                'guitar': 'ğŸ¸', 
                'drum': 'ğŸ¥',
                'trumpet': 'ğŸº',
                'violin': 'ğŸ»',
                'saxophone': 'ğŸ·',
                'organ': 'ğŸ¼'
            };
            
            soundBtns.forEach((btn, index) => {
                if (index < gameState.currentInstruments.length) {
                    // ç§»é™¤æ‰€æœ‰éŸ³è°ƒç±»
                    btn.classList.remove('tone-1', 'tone-2', 'tone-3', 'tone-4', 'tone-5', 'tone-6', 'tone-7');
                    
                    // æ·»åŠ å½“å‰éŸ³è°ƒç±»
                    const tone = gameState.currentTones[index];
                    btn.classList.add(`tone-${tone}`);
                    
                    // æ›´æ–°ä¹å™¨å›¾æ ‡
                    const instrument = gameState.currentInstruments[index];
                    btn.textContent = instrumentEmojis[instrument] || 'ğŸ¼';
                    
                    btn.style.display = 'block';
                    btn.disabled = false;
                } else {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
            });
        }

        // å¼€å§‹æŒ‘æˆ˜
        function startChallenge() {
            gameState.gamePhase = 'challenge';
            startNewRound();
        }

        // å¼€å§‹æ–°ä¸€è½®
        function startNewRound() {
            hideAllSections();
            challengeSection.style.display = 'block';
            
            // æ›´æ–°éŸ³ç¬¦ç½‘æ ¼å¸ƒå±€
            updateSoundGridLayout();
            
            // ç”Ÿæˆå½“å‰è½®æ¬¡çš„éŸ³è‰²åºåˆ—ï¼ˆé•¿åº¦é€’å¢ï¼‰
            const sequenceLength = Math.min(gameState.currentRound + 1, 8); // æœ€å¤š8ä¸ªéŸ³ç¬¦
            gameState.currentSequence = [];
            for (let i = 0; i < sequenceLength; i++) {
                gameState.currentSequence.push(Math.floor(Math.random() * gameState.instrumentCount));
            }
            
            gameState.playerSequence = [];
            
            document.getElementById('currentRound').textContent = gameState.currentRound;
            // document.getElementById('sequenceLength').textContent = sequenceLength;
            
            // éšè—è¾“å…¥åŒºåŸŸå¹¶ç¦ç”¨æ‰€æœ‰æŒ‰é’®
            inputSection.style.display = 'none';
            disableAllButtons();
            
            // æ’­æ”¾åºåˆ—
            playSequence();
        }        // æ’­æ”¾éŸ³è‰²åºåˆ—
        async function playSequence() {
            document.getElementById('challengeMessage').textContent = t.ui.challengeMessage2;
            inputSection.style.display = 'none'; // éšè—è¾“å…¥åŒºåŸŸ
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            for (let i = 0; i < gameState.currentSequence.length; i++) {
                playSound(gameState.currentSequence[i], 800, false); // æŒ‘æˆ˜é˜¶æ®µä¸æ˜¾ç¤ºè·³åŠ¨åŠ¨ç”»
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // å¯ç”¨æŒ‰é’®ï¼Œå…è®¸ç”¨æˆ·ä½œç­”
            enableAnswerButtons();
            document.getElementById('challengeMessage').textContent = t.ui.challengeMessage3;
            gameState.gamePhase = 'answering';
            
            // æ˜¾ç¤ºè¾“å…¥åŒºåŸŸå’Œåˆå§‹åŒ–æ˜¾ç¤º
            inputSection.style.display = 'block';
            updateUserSequenceDisplay();
            updateConfirmButton();
        }

        // å¤„ç†ç”¨æˆ·ç‚¹å‡»
        function handlePlayerInput(soundIndex) {
            if (gameState.gamePhase !== 'answering') return;
            if (soundIndex >= gameState.instrumentCount) return;
            
            playSound(soundIndex, 600, true); // ç”¨æˆ·ç‚¹å‡»æ—¶æ˜¾ç¤ºè·³åŠ¨åŠ¨ç”»
            gameState.playerSequence.push(soundIndex);
            
            // æ›´æ–°æ˜¾ç¤º
            updateUserSequenceDisplay();
            updateConfirmButton();
        }
          // æ›´æ–°ç”¨æˆ·åºåˆ—æ˜¾ç¤º
        function updateUserSequenceDisplay() {
            if (gameState.playerSequence.length === 0) {
                userSequenceDisplay.innerHTML = t.ui.waitingInput;
            } else {
                let displaySequence;
                if (gameState.geniusMode && gameState.currentInstruments.length > 0) {
                    // å¤§ç¥éš¾åº¦ï¼šæ˜¾ç¤ºå®é™…çš„ä¹å™¨å›¾æ ‡
                    const instrumentEmojis = {
                        'piano': 'ğŸ¹',
                        'guitar': 'ğŸ¸', 
                        'drum': 'ğŸ¥',
                        'trumpet': 'ğŸº',
                        'violin': 'ğŸ»',
                        'saxophone': 'ğŸ·',
                        'organ': 'ğŸ¼'
                    };
                    displaySequence = gameState.playerSequence.map(index => {
                        const instrument = gameState.currentInstruments[index];
                        return instrumentEmojis[instrument] || 'ğŸ¼';
                    }).join(' ');
                } else {
                    // æ™®é€šéš¾åº¦ï¼šä½¿ç”¨å›ºå®šçš„ä¹å™¨å›¾æ ‡
                    const instruments = ['ğŸ¹', 'ğŸ¸', 'ğŸ¥', 'ğŸº', 'ğŸ»', 'ğŸ·', 'ğŸ¼'];
                    displaySequence = gameState.playerSequence.map(index => instruments[index]).join(' ');
                }
                userSequenceDisplay.innerHTML = displaySequence;
            }
        }
          // æ›´æ–°ç¡®è®¤æŒ‰é’®çŠ¶æ€
        function updateConfirmButton() {
            const hasInput = gameState.playerSequence.length > 0;
            const isComplete = gameState.playerSequence.length === gameState.currentSequence.length;
            
            confirmAnswerBtn.disabled = !hasInput;
            
            if (isComplete) {
                confirmAnswerBtn.textContent = t.ui.confirmAnswer;
                confirmAnswerBtn.className = 'bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg text-xl font-bold transition-all transform hover:scale-105';
            } else {
                confirmAnswerBtn.textContent = `${t.ui.confirmAnswer} (${gameState.playerSequence.length}/${gameState.currentSequence.length})`;
                confirmAnswerBtn.className = 'bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg text-xl font-bold transition-all transform hover:scale-105';
            }
        }
        
        // é‡ç½®ç”¨æˆ·ç­”æ¡ˆ
        function resetPlayerAnswer() {
            gameState.playerSequence = [];
            updateUserSequenceDisplay();
            updateConfirmButton();
        }
        
        // ç¡®è®¤ç”¨æˆ·ç­”æ¡ˆ
        function confirmPlayerAnswer() {
            if (gameState.playerSequence.length === 0) return;
            
            disableAllButtons();
            inputSection.style.display = 'none';
            setTimeout(() => showRoundResult(), 500);
        }

        // æ˜¾ç¤ºæœ¬è½®ç»“æœ
        async function showRoundResult() {
            hideAllSections();
            resultSection.style.display = 'block';
            gameState.gamePhase = 'result';
            
            // æ›´æ–°éŸ³ç¬¦ç½‘æ ¼å¸ƒå±€
            updateSoundGridLayout();
            
            // è®¡ç®—æ­£ç¡®æ•°é‡
            let correctCount = 0;
            const feedback = [];
            
            for (let i = 0; i < gameState.currentSequence.length; i++) {
                const isCorrect = gameState.playerSequence[i] === gameState.currentSequence[i];
                if (isCorrect) correctCount++;
                feedback.push({
                    index: i,
                    correct: isCorrect,
                    expected: gameState.currentSequence[i],
                    actual: gameState.playerSequence[i]
                });
            }
            
            // æ˜¾ç¤ºåé¦ˆ
            await showDetailedFeedback(feedback);
            
            // è®¡ç®—æœ¬è½®å¾—åˆ†
            const maxRoundScore = 100 / gameState.totalRounds;
            const roundScore = (correctCount / gameState.currentSequence.length) * maxRoundScore;
            gameState.roundScores.push(roundScore);
            gameState.totalScore += roundScore;
              // æ˜¾ç¤ºå¾—åˆ†ä¿¡æ¯
            document.getElementById('scoreInfo').innerHTML = `
                <div class="mb-2">${t.ui.correct} ${correctCount}/${gameState.currentSequence.length}</div>
                <div class="mb-2">${t.ui.roundScore} ${roundScore.toFixed(1)}</div>
                <div class="text-3xl font-bold">${t.ui.totalScore} ${gameState.totalScore.toFixed(1)}</div>
            `;
            
            updateDisplay();
            
            // ç­‰å¾…2ç§’åè‡ªåŠ¨æ‰§è¡Œä¸‹ä¸€æ­¥
            setTimeout(() => {
                if (gameState.currentRound >= gameState.totalRounds) {
                    finishGame();
                } else {
                    gameState.currentRound++;
                    startNewRound();
                }
            }, 2000);
        }        // æ˜¾ç¤ºè¯¦ç»†åé¦ˆ
        async function showDetailedFeedback(feedback) {
            const feedbackContainer = document.getElementById('answerFeedback');
            feedbackContainer.innerHTML = `<div class="text-2xl font-bold mb-3">${t.ui.replayingSequence}</div>`;
            
            // é‡æ–°æ’­æ”¾åºåˆ—å¹¶æ˜¾ç¤ºåé¦ˆ
            for (let i = 0; i < feedback.length; i++) {
                const item = feedback[i];
                playSound(item.expected, 800, false); // ç»“ç®—é˜¶æ®µé‡æ”¾æ—¶ä¸æ˜¾ç¤ºè·³åŠ¨åŠ¨ç”»
                
                // æ·»åŠ åé¦ˆå›¾æ ‡ï¼ˆåˆ é™¤æ•°å­—åºå·ï¼‰
                const feedbackElement = document.createElement('div');
                feedbackElement.className = `feedback-item ${item.correct ? 'feedback-correct' : 'feedback-wrong'}`;
                feedbackElement.innerHTML = `${item.correct ? 'âœ“' : 'âœ—'}`;
                feedbackContainer.appendChild(feedbackElement);
                
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // å®Œæˆæ¸¸æˆ
        function finishGame() {
            gameState.gamePhase = 'finished';
            
            // å‘é€æ¸¸æˆå®Œæˆæ¶ˆæ¯
            const difficulty = gameState.difficulty === 'easy' ? 1 : (gameState.difficulty === 'medium' ? 2 : 3);
            window.parent.postMessage({ 
                type: 'gameFinished', 
                data: {
                    score: Math.round(gameState.totalScore),
                    level: gameState.currentRound,
                    difficulty: difficulty,
                    completed: true
                }
            }, '*');
            
            updateMessage(t.ui.gameComplete.replace('{difficulty}', t.difficulty[gameState.difficulty]).replace('{score}', gameState.totalScore.toFixed(1)));
            
            // é‡æ–°æ˜¾ç¤ºéš¾åº¦é€‰æ‹©ç•Œé¢
            hideAllSections();
            difficultySection.style.display = 'block';
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.gamePhase = 'menu';
            
            // é‡ç½®éš¾åº¦é€‰æ‹©çŠ¶æ€
            resetMainDifficultySelection();
            // é‡æ–°åˆå§‹åŒ–ä¸»ç•Œé¢
            initMainInterface();
            updateDisplay();
        }

        // è¾…åŠ©å‡½æ•°
        function hideAllSections() {
            difficultySection.style.display = 'none';
            previewSection.style.display = 'none';
            challengeSection.style.display = 'none';
            resultSection.style.display = 'none';
        }

        function disableAllButtons() {
            soundBtns.forEach(btn => btn.disabled = true);
            resetAnswerBtn.disabled = true;
            confirmAnswerBtn.disabled = true;
        }

        function enableAnswerButtons() {
            soundBtns.forEach((btn, index) => {
                if (index < gameState.instrumentCount) {
                    btn.disabled = false;
                }
            });
            resetAnswerBtn.disabled = false;
            // confirmAnswerBtn çš„çŠ¶æ€ç”± updateConfirmButton() æ§åˆ¶
        }

        function updateDisplay() {
            if (gameState.gamePhase === 'menu' || gameState.gamePhase === 'finished') {
                document.getElementById('level').textContent = '-';
                document.getElementById('score').textContent = '0';
            } else {
                document.getElementById('level').textContent = `${gameState.currentRound} / ${gameState.totalRounds}`;
                document.getElementById('score').textContent = Math.round(gameState.totalScore);
            }
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        // äº‹ä»¶ç›‘å¬å™¨
        closeRulesBtn.addEventListener('click', hideRules);
        rulesFloatBtn.addEventListener('click', showRules);
        startTrainingBtn.addEventListener('click', hideRules);
        startChallengeBtn.addEventListener('click', startChallenge);
        startGameBtn.addEventListener('click', startGameFromMain);
        
        // æ–°å¢æŒ‰é’®äº‹ä»¶ç›‘å¬
        resetAnswerBtn.addEventListener('click', resetPlayerAnswer);
        confirmAnswerBtn.addEventListener('click', confirmPlayerAnswer);

        // ä¸ºä¹å™¨æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬
        soundBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const soundIndex = parseInt(btn.getAttribute('data-sound'));
                
                if (gameState.gamePhase === 'menu') {
                    // ä¸»ç•Œé¢é˜¶æ®µï¼Œå…è®¸è¯•å¬æ‰€æœ‰ä¹å™¨éŸ³è‰²
                    playSound(soundIndex, 600, true);
                } else if (gameState.gamePhase === 'preview') {
                    // è¯•å¬é˜¶æ®µï¼Œç›´æ¥æ’­æ”¾éŸ³è‰²ï¼ˆæ˜¾ç¤ºè·³åŠ¨åŠ¨ç”»ï¼‰
                    playSound(soundIndex, 600, true);
                } else if (gameState.gamePhase === 'answering') {
                    // ä½œç­”é˜¶æ®µï¼Œè®°å½•ç”¨æˆ·é€‰æ‹©ï¼ˆæ˜¾ç¤ºè·³åŠ¨åŠ¨ç”»ï¼‰
                    handlePlayerInput(soundIndex);
                }
            });
        });

        // æ¶ˆæ¯ç›‘å¬å™¨
        window.addEventListener('message', function (e) {
            switch (e.data.type) {
                case 'setGameConfig':
                    game_config = e.data.data;
                    updateGameConfig(game_config);
                    break;
                case 'getGameStats':
                    const difficulty = gameState.difficulty === 'easy' ? 1 : (gameState.difficulty === 'medium' ? 2 : 3);
                    window.parent.postMessage({ 
                        type: 'gameStats', 
                        data: {
                            score: Math.round(gameState.totalScore),
                            difficulty: difficulty || 1
                        }
                    }, '*');
                    break;
            }
        });

        // æ›´æ–°æ¸¸æˆé…ç½®
        function updateGameConfig(config) {
            try {
                if (typeof config === 'string' && config.trim()) {
                    const newConfig = parseGameConfig(config);
                    if (newConfig.frequencies && newConfig.frequencies.length > 0) {
                        frequencies = newConfig.frequencies;
                        console.log(`é…ç½®å·²æ›´æ–°ï¼ŒåŠ è½½äº† ${frequencies.length} ä¸ªéŸ³ç¬¦é¢‘ç‡`);
                    }
                }
            } catch (error) {
                console.warn('è§£ææ¸¸æˆé…ç½®å¤±è´¥ï¼Œä¿æŒåŸé…ç½®:', error);
            }
        }

        // è§£ææ¸¸æˆé…ç½®
        function parseGameConfig(config) {
            const result = { frequencies: [] };
            
            try {
                const jsonData = JSON.parse(config);
                if (jsonData.frequencies && Array.isArray(jsonData.frequencies)) {
                    result.frequencies = jsonData.frequencies.filter(f => typeof f === 'number' && f > 0);
                } else if (Array.isArray(jsonData)) {
                    result.frequencies = jsonData.filter(f => typeof f === 'number' && f > 0);
                }
            } catch (e) {
                const lines = config.trim().split('\n');
                
                for (let line of lines) {
                    line = line.trim();
                    if (!line || line.startsWith('#')) continue;
                    
                    const numbers = line.split(/[,\s]+/).map(s => parseFloat(s.trim())).filter(n => !isNaN(n) && n > 0);
                    result.frequencies.push(...numbers);
                }
            }
            
            return result;
        }

        // è§¦æ‘¸äº‹ä»¶ä¼˜åŒ–
        function addTouchSupport() {
            soundBtns.forEach(btn => {
                btn.addEventListener('mousedown', () => {
                    btn.style.transform = 'scale(0.95)';
                });
                
                btn.addEventListener('mouseup', () => {
                    btn.style.transform = '';
                });
                
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = '';
                });
            });
        }        // åˆå§‹åŒ–ä¸»ç•Œé¢
        function initMainInterface() {
            // ç¡®ä¿æ‰€æœ‰ä¹å™¨æŒ‰é’®åœ¨ä¸»ç•Œé¢éƒ½å¯è§å’Œå¯ç‚¹å‡»
            soundBtns.forEach((btn, index) => {
                btn.style.display = 'block';
                btn.disabled = false;
            });
            
            // Update any dynamic content that might need language support
            if (gameState.difficulty) {
                startGameBtn.textContent = t.ui.startDifficultyChallenge.replace('{difficulty}', t.difficulty[gameState.difficulty]);
            } else {
                startGameBtn.textContent = t.ui.selectDifficultyFirst;
            }
        }

        // åˆå§‹åŒ–
        updatePageText(); // Apply translations to the page
        updateDisplay();
        addTouchSupport();
        initMainInterface(); // åˆå§‹åŒ–ä¸»ç•Œé¢
        showRules();
        
        window.parent.postMessage({ type: 'gameLoaded' }, '*');
        // åˆå§‹æ˜¾ç¤ºéš¾åº¦é€‰æ‹©ç•Œé¢ï¼Œä¸å†è‡ªåŠ¨æ˜¾ç¤ºè§„åˆ™å¼¹çª—
    </script>
</body>
</html>

