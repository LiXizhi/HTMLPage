
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway Network V4 (Loops Fixed)</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --primary: #3b82f6;
            --accent: #10b981;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border: #334155;
        }

        body {
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 1px; }
        .subtitle { font-size: 0.8rem; color: var(--text-muted); margin-top: 5px; }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            max-width: 1100px;
            width: 100%;
        }

        .canvas-wrapper {
            background: #020617;
            padding: 4px;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            height: fit-content;
        }

        canvas {
            cursor: crosshair;
            display: block;
            border-radius: 8px;
        }

        .sidebar {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            background: var(--panel-bg);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 24px;
            height: fit-content;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-muted);
        }
        .val-display { color: var(--primary); font-family: monospace; }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--primary);
            height: 6px;
            border-radius: 3px;
        }

        .btn-row { display: flex; gap: 12px; }
        
        button {
            flex: 1;
            padding: 14px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .btn-primary { 
            background: var(--primary); color: white; 
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        .btn-primary:hover { background: #2563eb; transform: translateY(-1px); }
        
        .btn-secondary { background: #334155; color: white; }
        .btn-secondary:hover { background: #475569; }

        #log {
            background: #0f172a;
            color: var(--accent);
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            padding: 16px;
            border-radius: 8px;
            height: 180px;
            overflow-y: auto;
            border: 1px solid var(--border);
            line-height: 1.6;
        }
        
        .status-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-right: 6px;
        }
        .tag-phase1 { background: #1e3a8a; color: #93c5fd; }
        .tag-phase2 { background: #064e3b; color: #6ee7b7; }

    </style>
</head>
<body>

    <div class="header">
        <h1>RAILWAY OPTIMIZER <span style="color:var(--primary)">V4</span></h1>
        <div class="subtitle">Efficiency-First Steiner Tree with Smart Loop Injection</div>
    </div>

    <div class="main-container">
        <div class="canvas-wrapper">
            <canvas id="gridCanvas" width="600" height="600"></canvas>
        </div>

        <div class="sidebar">
            
            <div class="control-group">
                <div class="control-label">
                    <span>STATION COUNT</span>
                    <span class="val-display" id="stationVal">12</span>
                </div>
                <input type="range" id="stationSlider" min="4" max="40" value="12">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>LOOP SENSITIVITY (Detour Tolerance)</span>
                    <span class="val-display" id="loopVal">Medium</span>
                </div>
                <input type="range" id="loopSlider" min="0" max="100" value="50">
                <div style="font-size: 0.75rem; color: #64748b; line-height: 1.4;">
                    <strong>0%</strong> = Strict Tree (No Loops).<br>
                    <strong>100%</strong> = Build Shortcut if any detour exists.
                </div>
            </div>

            <div class="btn-row">
                <button class="btn-secondary" onclick="initMap()">Reset Map</button>
                <button class="btn-primary" onclick="solveNetwork()">Build Network</button>
            </div>

            <div id="log">
                <div>> Ready. Adjust sliders and click 'Build Network'.</div>
            </div>
        </div>
    </div>

<script>
/* --- CONFIGURATION --- */
const GRID_SIZE = 30;
const COST_EMPTY = 10;     // Expensive to build new
const COST_EXISTING = 1;   // Cheap to use existing

// State
let stations = []; 
let roadSet = new Set(); 
let canvas, ctx;
let isComputing = false;

// Helpers
const getKey = (x, y) => `${x},${y}`;
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

/* --- DATA STRUCTURES --- */
class PriorityQueue {
    constructor() { this.items = []; }
    enqueue(element, priority) {
        const qElement = { element, priority };
        let added = false;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].priority > qElement.priority) {
                this.items.splice(i, 0, qElement);
                added = true;
                break;
            }
        }
        if (!added) this.items.push(qElement);
    }
    dequeue() { return this.items.shift(); }
    isEmpty() { return this.items.length === 0; }
}

class UnionFind {
    constructor(elements) {
        this.parent = {};
        elements.forEach(e => this.parent[e] = e);
    }
    find(id) {
        if (this.parent[id] === id) return id;
        this.parent[id] = this.find(this.parent[id]);
        return this.parent[id];
    }
    union(id1, id2) {
        const root1 = this.find(id1);
        const root2 = this.find(id2);
        if (root1 !== root2) {
            this.parent[root1] = root2;
            return true;
        }
        return false;
    }
    connected(id1, id2) { return this.find(id1) === this.find(id2); }
}

/* --- CORE LOGIC --- */

function log(msg, type="info") {
    const el = document.getElementById('log');
    const div = document.createElement('div');
    div.style.marginBottom = "4px";
    
    let tag = "";
    if(type === "phase1") tag = `<span class="status-tag tag-phase1">PHASE 1</span>`;
    if(type === "phase2") tag = `<span class="status-tag tag-phase2">PHASE 2</span>`;
    
    div.innerHTML = `${tag}${msg}`;
    el.appendChild(div);
    el.scrollTop = el.scrollHeight;
}

function getCost(x, y) {
    // Dynamic weighting: if road exists, cost is 1, else 10
    return roadSet.has(getKey(x,y)) ? COST_EXISTING : COST_EMPTY;
}

// A* Search
function findPath(start, end) {
    const openSet = new PriorityQueue();
    openSet.enqueue(start, 0);
    const cameFrom = {};
    const gScore = {};
    const startKey = getKey(start.x, start.y);
    gScore[startKey] = 0;

    while (!openSet.isEmpty()) {
        const current = openSet.dequeue().element;
        const currentKey = getKey(current.x, current.y);

        if (current.x === end.x && current.y === end.y) {
            const path = [];
            let curr = currentKey;
            while (cameFrom[curr]) {
                const [x, y] = curr.split(',').map(Number);
                path.push({x, y});
                curr = cameFrom[curr];
            }
            return { path: path.reverse(), cost: gScore[currentKey] };
        }

        const neighbors = [
            {x: current.x+1, y: current.y}, {x: current.x-1, y: current.y},
            {x: current.x, y: current.y+1}, {x: current.x, y: current.y-1}
        ];

        for (let n of neighbors) {
            if (n.x < 0 || n.x >= GRID_SIZE || n.y < 0 || n.y >= GRID_SIZE) continue;
            const nKey = getKey(n.x, n.y);
            const newCost = gScore[currentKey] + getCost(n.x, n.y);

            if (newCost < (gScore[nKey] ?? Infinity)) {
                cameFrom[nKey] = currentKey;
                gScore[nKey] = newCost;
                // Heuristic: Manhattan * 1 (Admissible because min cost is 1)
                const h = (Math.abs(n.x - end.x) + Math.abs(n.y - end.y));
                openSet.enqueue(n, newCost + h);
            }
        }
    }
    return { path: [], cost: Infinity };
}

async function solveNetwork() {
    if (isComputing) return;
    isComputing = true;
    roadSet.clear();
    
    // Get UI params
    const loopVal = parseInt(document.getElementById('loopSlider').value);
    // Map 0-100 slider to a detour ratio. 
    // 0 -> Ratio 1000 (Impossible detour)
    // 50 -> Ratio 3.0
    // 100 -> Ratio 1.5
    const detourRatio = loopVal === 0 ? 1000 : 5.0 - (loopVal / 25); 

    // Prepare edges
    let edges = [];
    for (let i = 0; i < stations.length; i++) {
        for (let j = i + 1; j < stations.length; j++) {
            const dist = Math.abs(stations[i].x - stations[j].x) + Math.abs(stations[i].y - stations[j].y);
            edges.push({ u: stations[i], v: stations[j], dist: dist });
        }
    }
    // Sort by Air Distance (Manhattan)
    edges.sort((a, b) => a.dist - b.dist);

    const uf = new UnionFind(stations.map(s => s.id));
    let rejectedEdges = [];

    // --- PHASE 1: MST SKELETON ---
    log("Building main skeleton...", "phase1");
    
    // We process edges in batches for UI responsiveness
    for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        
        // If already connected, save for Phase 2 check, skip build
        if (uf.connected(edge.u.id, edge.v.id)) {
            rejectedEdges.push(edge);
            continue;
        }

        // Calculate optimal path on current grid
        const pathRes = findPath(edge.u, edge.v);
        
        // Double check connection after async/processing (rare but safe)
        if (!uf.connected(edge.u.id, edge.v.id)) {
            uf.union(edge.u.id, edge.v.id);
            addPathToGrid(pathRes.path);
            if (i % 3 === 0) { draw(); await sleep(10); }
        }
    }
    draw();

    // --- PHASE 2: LOOP INJECTION ---
    if (loopVal > 0) {
        log(`Checking for efficient shortcuts (Ratio: ${detourRatio.toFixed(1)})...`, "phase2");
        
        // Only check edges that are somewhat close. Long distance loops are rarely efficient.
        // Limit to edges < 15 units of Manhattan distance
        const localEdges = rejectedEdges.filter(e => e.dist < 15);

        for (let edge of localEdges) {
            // Calculate path on existing network
            const currentRailPath = findPath(edge.u, edge.v);
            
            if (currentRailPath.cost - edge.dist > 8) {
                // We found a detour with significant "away" movement! Build a shortcut.
                log(`Shortcut: Station ${edge.u.id} to ${edge.v.id} (Away: ${(currentRailPath.cost - edge.dist).toFixed(0)}, Path: ${currentRailPath.cost}, Direct: ${edge.dist})`, "phase2");
                
                // Force build this path. 
                // Note: The findPath above followed the track. We want a NEW path.
                // But findPath prefers tracks (cost 1). How to force new path?
                // We just add the direct line? No, A* with blocked rails?
                // Simple solution: Draw a line manually or re-run A* with COST_EXISTING = 10 temporarily?
                
                // Let's just assume the A* path found earlier was the track path.
                // We want to build a direct road.
                // A simple L-shape builder is efficient enough for a shortcut.
                buildDirectRoad(edge.u, edge.v);
                
                draw();
                await sleep(20);
            }
        }
    }

    log("Optimization Complete.");
    isComputing = false;
}

function addPathToGrid(path) {
    path.forEach(p => roadSet.add(getKey(p.x, p.y)));
}

// Builds a simple L-shaped road between two points ignoring weights (forcing a build)
function buildDirectRoad(start, end) {
    // Horizontal then Vertical
    let x = start.x;
    let y = start.y;
    
    // Move X
    while(x !== end.x) {
        roadSet.add(getKey(x, y));
        x += (end.x > x ? 1 : -1);
    }
    // Move Y
    while(y !== end.y) {
        roadSet.add(getKey(x, y));
        y += (end.y > y ? 1 : -1);
    }
    roadSet.add(getKey(end.x, end.y));
}

/* --- UI HANDLERS --- */

function initMap() {
    if(isComputing) return;
    canvas = document.getElementById('gridCanvas');
    ctx = canvas.getContext('2d');
    
    const count = parseInt(document.getElementById('stationSlider').value);
    stations = [];
    roadSet.clear();
    
    // Generate stations with even x AND y coordinates (0, 2, 4, 6, ...)
    // Each station has a population that affects repulsion
    let attempts = 0;
    while(stations.length < count && attempts < 500) {
        // Snap both x and y to even numbers: 0, 2, 4, 6, ...
        const x = Math.floor(Math.random() * (GRID_SIZE / 2)) * 2;
        const y = Math.floor(Math.random() * (GRID_SIZE / 2)) * 2;
        // Random population from 1 to 5 (affects repulsion strength)
        const population = Math.floor(Math.random() * 5) + 1;
        if(!stations.some(s => s.x === x && s.y === y)) {
            stations.push({id: stations.length, x, y, population});
        }
        attempts++;
    }
    
    // Repel stations based on population
    repelStationsByPopulation();
    
    document.getElementById('log').innerHTML = '<div>> Map Reset.</div>';
    draw();
}

// Snap coordinate to even grid
function snapToEvenGrid(val, maxVal) {
    let snapped = Math.round(val / 2) * 2;
    if (snapped < 0) snapped = 0;
    if (snapped >= maxVal) snapped = Math.floor((maxVal - 1) / 2) * 2;
    return snapped;
}

// Repel stations based on population - higher population pushes others away more
function repelStationsByPopulation() {
    const MIN_DISTANCE = 2; // Minimum grid distance between stations (in even grid units)
    const MAX_ITERATIONS = 100;
    const REPEL_RADIUS = 6; // Only repel stations within this distance
    
    for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
        let moved = false;
        
        // For each pair of stations, calculate repulsion
        for (let i = 0; i < stations.length; i++) {
            for (let j = i + 1; j < stations.length; j++) {
                const s1 = stations[i];
                const s2 = stations[j];
                
                const dx = s2.x - s1.x;
                const dy = s2.y - s1.y;
                const dist = Math.abs(dx) + Math.abs(dy); // Manhattan distance
                
                // Skip if too far apart
                if (dist > REPEL_RADIUS) continue;
                
                // If same position or too close, repel
                if (dist < MIN_DISTANCE * 2) {
                    // Calculate repulsion based on population ratio
                    // Higher population station stays more still, lower population moves more
                    const totalPop = s1.population + s2.population;
                    const ratio1 = s2.population / totalPop; // s1 moves by this ratio (opposite population)
                    const ratio2 = s1.population / totalPop; // s2 moves by this ratio
                    
                    // Determine push direction (opposite directions)
                    let pushX = 0, pushY = 0;
                    
                    if (dx === 0 && dy === 0) {
                        // Same position - push in random direction on even grid
                        pushX = (Math.random() > 0.5 ? 2 : -2);
                        pushY = (Math.random() > 0.5 ? 2 : -2);
                    } else if (Math.abs(dx) >= Math.abs(dy)) {
                        // Primarily horizontal difference - push in x
                        pushX = 2;
                    } else {
                        // Primarily vertical difference - push in y
                        pushY = 2;
                    }
                    
                    // Apply movement based on population ratio (move in even grid steps)
                    // s1 moves in negative direction, s2 moves in positive direction
                    if (ratio1 > 0.3) { // Only move if ratio is significant
                        const newX1 = snapToEvenGrid(s1.x - pushX * Math.sign(dx || 1), GRID_SIZE);
                        const newY1 = snapToEvenGrid(s1.y - pushY * Math.sign(dy || 1), GRID_SIZE);
                        if (newX1 !== s1.x || newY1 !== s1.y) {
                            // Check no collision at new position
                            if (!stations.some((s, idx) => idx !== i && s.x === newX1 && s.y === newY1)) {
                                s1.x = newX1;
                                s1.y = newY1;
                                moved = true;
                            }
                        }
                    }
                    
                    if (ratio2 > 0.3) { // Only move if ratio is significant
                        const newX2 = snapToEvenGrid(s2.x + pushX * Math.sign(dx || 1), GRID_SIZE);
                        const newY2 = snapToEvenGrid(s2.y + pushY * Math.sign(dy || 1), GRID_SIZE);
                        if (newX2 !== s2.x || newY2 !== s2.y) {
                            // Check no collision at new position
                            if (!stations.some((s, idx) => idx !== j && s.x === newX2 && s.y === newY2)) {
                                s2.x = newX2;
                                s2.y = newY2;
                                moved = true;
                            }
                        }
                    }
                }
            }
        }
        
        if (!moved) break;
    }
}

function draw() {
    // BG
    ctx.fillStyle = '#020617';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const cs = canvas.width / GRID_SIZE;

    // Grid
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<=GRID_SIZE; i++) {
        ctx.moveTo(i*cs, 0); ctx.lineTo(i*cs, canvas.height);
        ctx.moveTo(0, i*cs); ctx.lineTo(canvas.width, i*cs);
    }
    ctx.stroke();

    // Roads (Neon Blue)
    ctx.fillStyle = '#3b82f6';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#3b82f6';
    roadSet.forEach(k => {
        const [x,y] = k.split(',').map(Number);
        ctx.fillRect(x*cs + 2, y*cs + 2, cs - 4, cs - 4);
    });
    ctx.shadowBlur = 0;

    // Stations (Red/Pink) - size based on population
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 11px sans-serif';
    
    stations.forEach(s => {
        const cx = s.x * cs + cs/2;
        const cy = s.y * cs + cs/2;
        
        // Size based on population (1-5) -> radius multiplier (0.3-0.6)
        const radiusMultiplier = 0.25 + (s.population || 1) * 0.07;
        const radius = cs * radiusMultiplier;
        
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.fillStyle = '#ef4444';
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.fillText(s.id, cx, cy);
    });
}

// Event Listeners
window.onload = () => {
    initMap();
    
    document.getElementById('stationSlider').addEventListener('input', (e) => {
        document.getElementById('stationVal').innerText = e.target.value;
        initMap();
    });

    document.getElementById('loopSlider').addEventListener('input', (e) => {
        const v = e.target.value;
        let label = "Medium";
        if (v < 10) label = "Strict (Tree)";
        else if (v > 80) label = "Max (Grid)";
        document.getElementById('loopVal').innerText = label;
    });

    document.getElementById('gridCanvas').addEventListener('mousedown', (e) => {
        if (isComputing) return;
        const rect = canvas.getBoundingClientRect();
        const cs = canvas.width / GRID_SIZE;
        let x = Math.floor((e.clientX - rect.left) / (rect.width/GRID_SIZE));
        let y = Math.floor((e.clientY - rect.top) / (rect.height/GRID_SIZE));
        
        // Snap both x and y to even grid (0, 2, 4, 6, ...)
        x = snapToEvenGrid(x, GRID_SIZE);
        y = snapToEvenGrid(y, GRID_SIZE);

        if(x>=0 && x<GRID_SIZE && y>=0 && y<GRID_SIZE) {
            const idx = stations.findIndex(s => s.x === x && s.y === y);
            if(idx >= 0) {
                stations.splice(idx, 1);
                stations.forEach((s,i) => s.id = i);
            } else {
                // Add new station with random population
                const population = Math.floor(Math.random() * 5) + 1;
                stations.push({id: stations.length, x, y, population});
                // Repel stations after adding new one
                repelStationsByPopulation();
            }
            roadSet.clear();
            draw();
        }
    });
};

</script>
</body>
</html>
