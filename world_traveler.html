<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello World - Travel, Build, Talk</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #202025;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
        outline: none;
        touch-action: none;
      }

      /* UI Overlay - ä¿æŒåŸæ ·ï¼Œä½†å¢åŠ ç©¿é€æ€§ */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 20;
      }
      .hud-panel {
        pointer-events: auto;
      }

      /* Animations */
      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }
      .animate-bounce-custom {
        animation: bounce 1s infinite;
      }

      .modal {
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        transition: opacity 0.3s;
      }

      /* Station Labels floating in 3D space */
      .station-label {
        position: absolute;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        transform: translate(-50%, -150%);
        white-space: nowrap;
        text-shadow: 0 1px 2px black;
        z-index: 10;
      }

      /* Destination label highlight */
      .station-label.destination {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        font-size: 16px;
        padding: 6px 16px;
        border: 2px solid #fff;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        animation: destination-pulse 1.5s ease-in-out infinite;
        z-index: 15;
      }

      @keyframes destination-pulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.6);
        }
      }

      /* Off-screen destination indicator */
      .destination-indicator {
        position: fixed;
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        white-space: nowrap;
        border: 2px solid #fff;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 6px;
        animation: indicator-pulse 1s ease-in-out infinite;
      }

      @keyframes indicator-pulse {
        0%,
        100% {
          opacity: 1;
          box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        }
        50% {
          opacity: 0.9;
          box-shadow: 0 0 25px rgba(251, 191, 36, 1);
        }
      }

      /* ç©·ç¥ç›¸å…³æ ·å¼ */
      .binbougami-indicator {
        animation: binbougami-shake 0.5s ease-in-out infinite;
      }

      @keyframes binbougami-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-2px) rotate(-1deg);
        }
        75% {
          transform: translateX(2px) rotate(1deg);
        }
      }

      .binbougami-effect {
        animation: binbougami-appear 0.5s ease-out;
      }

      @keyframes binbougami-appear {
        0% {
          transform: scale(0) rotate(-180deg);
          opacity: 0;
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* ç©·ç¥å¤§é­”ç‹æ¨¡å¼ */
      .binbougami-king {
        animation: king-pulse 1s ease-in-out infinite;
        filter: drop-shadow(0 0 10px #ff0000);
      }

      @keyframes king-pulse {
        0%,
        100% {
          transform: scale(1);
          filter: drop-shadow(0 0 10px #ff0000);
        }
        50% {
          transform: scale(1.1);
          filter: drop-shadow(0 0 20px #ff4444);
        }
      }

      /* å¡ç‰Œæ ·å¼ */
      .card-item {
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .card-item:hover {
        transform: translateY(-8px) scale(1.05);
        z-index: 100;
      }

      .card-rarity-common {
        border-color: #9ca3af;
        background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
      }
      .card-rarity-rare {
        border-color: #3b82f6;
        background: linear-gradient(135deg, #dbeafe, #bfdbfe);
      }
      .card-rarity-epic {
        border-color: #8b5cf6;
        background: linear-gradient(135deg, #ede9fe, #ddd6fe);
      }
      .card-rarity-legendary {
        border-color: #f59e0b;
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
      }

      .card-panel {
        max-height: 120px;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .card-panel::-webkit-scrollbar {
        height: 4px;
      }

      .card-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <!-- Game Container -->
    <div id="game-container" class="w-full h-full relative"></div>

    <!-- Labels Layer (Dynamic HTML for 3D objects) -->
    <div id="labels-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>

    <!-- Off-screen Destination Indicator -->
    <div id="destination-indicator" class="destination-indicator hidden">
      <span>ğŸ¯</span>
      <span>ç›®çš„åœ°: </span>
      <span id="indicator-name">---</span>
      <span id="indicator-arrow">â†’</span>
    </div>

    <!-- Title and Subtitle (Outside UI Layer) -->
    <div id="game-title" class="absolute top-4 left-4 z-50 pointer-events-auto hidden">
      <h1
        class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg"
        style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
      >
        HelloWorld
      </h1>
      <p class="text-sm text-white font-semibold tracking-wider drop-shadow-md mt-1 ml-1">powered by paracraft</p>
    </div>

    <!-- Login Window -->
    <div id="login-modal" class="fixed inset-0 flex items-center justify-center z-[60] bg-black/40 backdrop-blur-sm">
      <div class="text-center">
        <h1
          class="text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg mb-2"
          style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
        >
          Hello World
        </h1>
        <p class="text-2xl text-white font-semibold tracking-wider drop-shadow-md mb-8">Travel the World, Build Your Home, Talk With People</p>
        <button
          id="login-btn"
          class="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-4 px-12 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 border-2 border-white/50"
        >
          ç«‹å³å‡ºå‘
        </button>
      </div>
      <div class="absolute bottom-8 text-white/90 text-sm font-bold tracking-widest drop-shadow-lg">powered by Paracraft (c) copy right 2025</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-2 md:p-4 pointer-events-none">
      <!-- Top Bar Container -->
      <div class="flex flex-col w-full items-center gap-2 pointer-events-none">
        <!-- Row 1: Destination & Time (Always visible at top, compact on mobile) -->
        <div
          class="hud-panel pointer-events-auto bg-gradient-to-r from-purple-900/90 to-pink-900/90 text-white px-3 py-2 pr-12 md:pr-3 rounded-xl border-2 border-yellow-400 shadow-lg hidden w-full max-w-2xl flex justify-between items-center gap-2 z-50"
          id="destination-panel"
        >
          <div class="flex items-center gap-2">
            <span class="text-xs text-gray-300">ğŸ“…</span>
            <span class="text-sm md:text-lg font-bold text-yellow-300 whitespace-nowrap"><span id="game-year">1</span>å¹´<span id="game-month">4</span>æœˆ</span>
          </div>
          <div class="w-px h-6 bg-gray-500"></div>
          <div class="flex items-center gap-2 overflow-hidden flex-1 justify-center">
            <span class="text-xs text-gray-300">ğŸ¯</span>
            <span class="text-sm md:text-lg font-bold text-green-300 truncate" id="destination-name">---</span>
          </div>
          <div class="w-px h-6 bg-gray-500 hidden md:block"></div>
          <div class="flex items-center gap-2 hidden md:flex">
            <span class="text-xs text-gray-300">ğŸ’°</span>
            <span class="text-sm md:text-lg font-bold text-yellow-400">Â¥5000</span>
          </div>
        </div>

        <!-- Row 2: Players & Turn -->
        <div class="flex justify-between w-full max-w-4xl mx-auto items-start relative">
          <!-- P1 Info (Compact) -->
          <div
            class="hud-panel bg-blue-900/90 text-white p-2 md:p-4 rounded-xl border-2 border-blue-400 shadow-lg w-32 md:w-48 transition-all pointer-events-auto cursor-pointer hover:border-yellow-400 flex flex-col"
            id="p1-panel"
            onclick="game.focusOnPlayer(0)"
          >
            <h2 class="text-sm md:text-xl font-bold flex items-center gap-1 md:gap-2">
              <div class="w-3 h-3 md:w-4 md:h-4 rounded-full bg-blue-400"></div>
              <span>P1</span>
              <span id="p1-binbougami" class="hidden text-lg md:text-2xl binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
            </h2>
            <p class="text-yellow-300 text-lg md:text-2xl font-mono mt-0 md:mt-1">Â¥<span id="p1-money">0</span></p>
            <p class="text-[10px] text-gray-300 hidden md:block">èµ„äº§: Â¥<span id="p1-assets">0</span></p>
            <div class="text-[10px] md:text-xs text-cyan-300 mt-0 md:mt-1 flex items-center gap-1"><span>ğŸ“</span><span id="p1-distance">--</span></div>
            <div class="text-[10px] md:text-xs text-amber-300 mt-0 md:mt-1 flex items-center gap-1"><span>ğŸƒ</span><span id="p1-cards">0</span></div>
          </div>

          <!-- Turn Indicator -->
          <div
            class="hud-panel bg-gray-800/80 text-white px-3 py-1 md:px-6 md:py-2 rounded-full border border-gray-600 h-fit mt-1 pointer-events-auto absolute left-1/2 transform -translate-x-1/2 top-0 z-10"
          >
            <span id="turn-indicator" class="font-bold text-xs md:text-lg tracking-widest whitespace-nowrap">ç­‰å¾…...</span>
          </div>

          <!-- COM Info (Compact) -->
          <div
            class="hud-panel bg-red-900/90 text-white p-2 md:p-4 rounded-xl border-2 border-red-400 shadow-lg w-32 md:w-48 transition-all opacity-70 pointer-events-auto cursor-pointer hover:border-yellow-400 flex flex-col items-end md:items-start"
            id="com-panel"
            onclick="game.focusOnPlayer(1)"
          >
            <h2 class="text-sm md:text-xl font-bold flex items-center gap-1 md:gap-2 flex-row-reverse md:flex-row">
              <div class="w-3 h-3 md:w-4 md:h-4 rounded-full bg-red-500"></div>
              <span>COM</span>
              <span id="com-binbougami" class="hidden text-lg md:text-2xl binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
            </h2>
            <p class="text-yellow-300 text-lg md:text-2xl font-mono mt-0 md:mt-1">Â¥<span id="com-money">0</span></p>
            <p class="text-[10px] text-gray-300 hidden md:block">èµ„äº§: Â¥<span id="com-assets">0</span></p>
            <div class="text-[10px] md:text-xs text-cyan-300 mt-0 md:mt-1 flex items-center gap-1 flex-row-reverse md:flex-row"><span>ğŸ“</span><span id="com-distance">--</span></div>
            <div class="text-[10px] md:text-xs text-amber-300 mt-0 md:mt-1 flex items-center gap-1 flex-row-reverse md:flex-row"><span>ğŸƒ</span><span id="com-cards">0</span></div>
          </div>
        </div>
      </div>

      <!-- Airport Button -->
      <button
        onclick="game.toggleMap()"
        class="hud-panel absolute top-2 right-2 md:top-4 md:right-4 bg-blue-600 hover:bg-blue-700 text-white p-2 md:p-3 rounded-full shadow-lg border-2 border-white z-50 pointer-events-auto transition-transform hover:scale-110"
        title="åˆ‡æ¢åŸå¸‚"
      >
        âœˆï¸
      </button>

      <!-- Action Log -->
      <div class="absolute top-40 md:top-24 right-2 md:right-4 w-48 md:w-64 pointer-events-none z-20">
        <div id="game-log" class="flex flex-col gap-1 md:gap-2 items-end text-xs md:text-sm font-bold text-white shadow-black drop-shadow-md">
          <!-- Log entries go here -->
        </div>
      </div>

      <!-- Bottom Controls -->
      <div class="flex flex-col items-center gap-4 mb-4 pointer-events-none">
        <!-- å¡ç‰Œæ‰‹ç‰ŒåŒºåŸŸ -->
        <div id="card-hand-panel" class="hud-panel pointer-events-auto bg-gray-900/80 px-4 py-2 rounded-xl border border-gray-600 hidden">
          <div class="text-xs text-gray-400 mb-1 text-center">ğŸƒ æ‰‹ç‰Œ (ç‚¹å‡»ä½¿ç”¨)</div>
          <div id="card-hand" class="card-panel flex gap-2">
            <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
          </div>
        </div>

        <!-- æŒ‰é’®åŒºåŸŸ -->
        <div class="flex gap-3">
          <button
            id="use-card-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-purple-400 to-purple-600 text-white font-bold text-lg px-6 py-3 rounded-xl shadow-lg border-b-4 border-purple-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸƒ ä½¿ç”¨å¡ç‰Œ
          </button>
          <button
            id="roll-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-yellow-400 to-yellow-600 text-black font-black text-2xl px-12 py-4 rounded-2xl shadow-xl border-b-4 border-yellow-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸ² æ·éª°å­
          </button>
        </div>
      </div>
    </div>

    <!-- Money Change Modal -->
    <div id="money-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100">
        <div id="money-modal-icon" class="text-6xl mb-4">ğŸ’°</div>
        <h3 class="text-2xl font-black text-gray-800 mb-2" id="money-modal-title">ç©å®¶</h3>
        <div class="text-2xl font-bold mb-2" id="money-modal-delta"></div>
        <div class="text-5xl font-mono font-bold my-4 text-gray-800" id="money-modal-amount">Â¥0</div>
        <div class="text-gray-500 text-sm" id="money-modal-desc">èµ„é‡‘å˜åŠ¨</div>
      </div>
    </div>

    <!-- Property Buy Modal -->
    <div id="buy-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full border-4 border-green-600 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-1 rounded-full font-bold shadow-lg">åˆ°è¾¾è½¦ç«™</div>
        <h3 class="text-2xl font-bold text-center mt-4 mb-2 text-gray-800" id="station-name">ä¸œäº¬ç«™</h3>
        <div class="text-center text-yellow-600 font-bold text-xl mb-2">æŒæœ‰èµ„é‡‘: Â¥<span id="buy-modal-money">0</span></div>
        <p class="text-center text-gray-500 mb-4">è¿™å—åœ°çš®çœ‹èµ·æ¥å¾ˆæœ‰æ½œåŠ›ï¼è¦æŠ•èµ„å—ï¼Ÿ</p>

        <div id="building-list" class="space-y-3 mb-6">
          <!-- Buildings injected here -->
        </div>

        <div class="flex gap-3">
          <button onclick="game.closeBuyModal()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 rounded-lg transition">ç¦»å¼€</button>
        </div>
      </div>
    </div>

    <!-- ç©·ç¥æ•ˆæœå¼¹çª— -->
    <div id="binbougami-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-gray-900 to-purple-900 p-8 rounded-2xl shadow-2xl max-w-md w-full border-4 border-purple-500 relative text-center">
        <div id="binbougami-modal-icon" class="text-8xl mb-4 binbougami-effect">ğŸ‘»</div>
        <h3 class="text-3xl font-black text-purple-300 mb-2" id="binbougami-modal-title">ç©·ç¥æ¥è¢­ï¼</h3>
        <p class="text-xl text-gray-300 mb-4" id="binbougami-modal-desc">ç©·ç¥æ­£åœ¨æ£ä¹±...</p>
        <div class="text-4xl font-mono font-bold text-red-400 mb-4" id="binbougami-modal-effect"></div>
        <div class="text-sm text-gray-400" id="binbougami-modal-hint"></div>
      </div>
    </div>

    <!-- ç©·ç¥é™„èº«å…¨å±åŠ¨ç”» -->
    <div id="possession-modal" class="fixed inset-0 flex items-center justify-center hidden z-[100] bg-black/90 backdrop-blur-sm transition-opacity duration-500">
      <div class="text-center transform transition-all duration-500 scale-0" id="possession-content">
        <div class="text-9xl mb-8 animate-bounce">ğŸ‘»</div>
        <h1 class="text-6xl font-black text-purple-500 mb-4 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]">ç©·ç¥é™„èº«ï¼</h1>
        <p class="text-4xl text-white font-bold" id="possession-text">ç©å®¶ XX è¢«ç©·ç¥é™„èº«äº†ï¼</p>
      </div>
    </div>

    <!-- å¡ç‰Œè·å–å¼¹çª— -->
    <div id="card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-amber-900 to-yellow-900 p-6 rounded-2xl shadow-2xl max-w-lg w-full border-4 border-yellow-500 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ å¡ç‰‡ç«™</div>
        <h3 class="text-2xl font-bold text-center mt-4 mb-4 text-yellow-300">è·å–å¡ç‰Œ</h3>
        <div id="card-modal-content" class="space-y-3 mb-4">
          <!-- å¡ç‰Œé€‰é¡¹ä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">ç¦»å¼€</button>
        </div>
      </div>
    </div>

    <!-- ä½¿ç”¨å¡ç‰Œé€‰æ‹©å¼¹çª— -->
    <div id="use-card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-indigo-900 to-purple-900 p-6 rounded-2xl shadow-2xl max-w-2xl w-full border-4 border-indigo-400 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-indigo-500 text-white px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ é€‰æ‹©è¦ä½¿ç”¨çš„å¡ç‰Œ</div>
        <div id="use-card-list" class="flex flex-wrap gap-3 justify-center mt-6 mb-4">
          <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeUseCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">å–æ¶ˆ</button>
        </div>
      </div>
    </div>

    <script>
      /**
       * 3D Metro Tycoon Game Engine (Three.js Edition)
       */

      // --- Constants & Config ---
      const TILE_SIZE = 4; // World unit size for a tile
      const TILE_SPACING = 0.2; // Gap between tiles
      const COLORS = {
        bg: 0x87ceeb, // Sky Blue
        ground: 0x1a1a20,

        // Tile Materials
        blue: 0x3b82f6, // Money +
        red: 0xef4444, // Money -
        yellow: 0xeab308, // Event
        green: 0x22c55e, // Station
        start: 0xffffff, // Start

        road: 0x9ca3af, // Plain Road
        env_nature: 0x15803d, // Nature
        env_culture: 0x52525b, // Culture

        // Buildings
        building: [0x60a5fa, 0x818cf8, 0xa78bfa],
      };

      const BUILDING_COSTS = [1000, 5000, 20000];
      const BUILDING_NAMES = ["æ‹‰é¢æ‘Š", "å•†åŠ¡é…’åº—", "æ‘©å¤©å¤§æ¥¼"];
      const BUILDING_INCOME = [200, 800, 4000];

      // ç›®çš„åœ°å¥–åŠ±é‡‘é¢
      const DESTINATION_REWARD = 5000;

      // --- ç©·ç¥ç³»ç»Ÿ ---
      const BINBOUGAMI_EFFECTS = {
        // æ™®é€šç©·ç¥æ•ˆæœ
        normal: [
          { type: "loseMoney", min: 300, max: 1500, msg: "ç©·ç¥å·èµ°äº†ä½ çš„é’±ï¼" },
          { type: "loseMoney", min: 500, max: 2000, msg: "ç©·ç¥è¯·å®¢åƒé¥­ï¼Œç”¨çš„æ˜¯ä½ çš„é’±ï¼" },
          { type: "sellProperty", msg: "ç©·ç¥å¼ºè¡ŒåŠä»·å–æ‰äº†ä½ çš„ç‰©ä»¶ï¼" },
          { type: "nothing", msg: "ç©·ç¥ä»Šå¤©å¿ƒæƒ…å¥½ï¼Œæ”¾è¿‡ä½ äº†~" },
          { type: "loseMoney", min: 200, max: 800, msg: "ç©·ç¥æ‰“ç¢äº†ä½ çš„å­˜é’±ç½ï¼" },
        ],
        // å¤§é­”ç‹ç©·ç¥æ•ˆæœï¼ˆå‡çº§åï¼‰
        king: [
          { type: "loseMoney", min: 2000, max: 5000, msg: "å¤§é­”ç‹ç©·ç¥ç–¯ç‹‚åå™¬ä½ çš„è´¢äº§ï¼" },
          { type: "sellAllProperty", msg: "å¤§é­”ç‹ç©·ç¥åå™¬äº†ä½ æ‰€æœ‰çš„ç‰©ä»¶ï¼" },
          { type: "debt", min: 3000, max: 8000, msg: "å¤§é­”ç‹ç©·ç¥è®©ä½ èƒŒä¸Šå·¨é¢å€ºåŠ¡ï¼" },
          { type: "loseMoney", min: 1500, max: 4000, msg: "å¤§é­”ç‹ç©·ç¥å¬å¼€è±ªåå®´ä¼šï¼Œè´¦å•ç»™ä½ ï¼" },
        ],
      };
      // ç©·ç¥å‡çº§æ‰€éœ€çš„å›åˆæ•°
      const BINBOUGAMI_UPGRADE_TURNS = 8;

      // --- å¡ç‰Œç³»ç»Ÿ ---
      const CARD_TYPES = {
        // ç§»åŠ¨ç±»å¡ç‰Œ
        express: { name: "æ€¥è¡Œå¡", desc: "æ·2ä¸ªéª°å­", icon: "ğŸšƒ", type: "move", diceCount: 2, rarity: "common", price: 500 },
        superExpress: { name: "ç‰¹æ€¥å¡", desc: "æ·3ä¸ªéª°å­", icon: "ğŸš„", type: "move", diceCount: 3, rarity: "rare", price: 1500 },
        rocket: { name: "ç«ç®­å¡", desc: "æ·4ä¸ªéª°å­", icon: "ğŸš€", type: "move", diceCount: 4, rarity: "epic", price: 3000 },
        backward: { name: "åé€€å¡", desc: "å¯ä»¥å‘åç§»åŠ¨", icon: "âª", type: "special", effect: "backward", rarity: "common", price: 300 },
        teleport: { name: "ä»»æ„é—¨", desc: "ä¼ é€åˆ°ä»»æ„è½¦ç«™", icon: "ğŸšª", type: "special", effect: "teleport", rarity: "legendary", price: 5000 },

        // æ”»å‡»/å¦¨ç¢ç±»å¡ç‰Œ
        hibernate: { name: "å†¬çœ å¡", desc: "è®©å¯¹æ‰‹åœ1å›åˆ", icon: "ğŸ’¤", type: "attack", effect: "skip", rarity: "rare", price: 1200 },
        fart: { name: "æ”¾å±å¡", desc: "å¹é£å¯¹æ‰‹1-3æ ¼", icon: "ğŸ’¨", type: "attack", effect: "blowAway", rarity: "common", price: 600 },
        trap: { name: "é™·é˜±å¡", desc: "åœ¨å½“å‰æ ¼å­è®¾ç½®é™·é˜±", icon: "ğŸ•³ï¸", type: "attack", effect: "trap", rarity: "rare", price: 800 },

        // é˜²å¾¡/ç‰¹æ®Šç±»å¡ç‰Œ
        shield: { name: "æŠ¤èº«ç¬¦", desc: "å…ç–«ä¸€æ¬¡ç©·ç¥æ•ˆæœ", icon: "ğŸ›¡ï¸", type: "defense", effect: "immunity", rarity: "rare", price: 2000 },
        exorcism: { name: "é©±é­”ç¬¦", desc: "ç«‹å³é©±é™¤ç©·ç¥", icon: "ğŸ“¿", type: "special", effect: "exorcise", rarity: "epic", price: 4000 },
        doubleIncome: { name: "å€æ”¶å¡", desc: "ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€", icon: "ğŸ’", type: "buff", effect: "doubleIncome", rarity: "epic", price: 3500 },
      };

      // å¡ç‰ŒæŠ½å–æ± ï¼ˆæŒ‰ç¨€æœ‰åº¦åˆ†ç±»ï¼‰
      const CARD_POOL = {
        common: ["express", "backward", "fart"],
        rare: ["superExpress", "hibernate", "trap", "shield"],
        epic: ["rocket", "exorcism", "doubleIncome"],
        legendary: ["teleport"],
      };

      // æœ€å¤§æ‰‹ç‰Œæ•°
      const MAX_HAND_SIZE = 8;
      // ä¸€å¹´çš„å›åˆæ•°ï¼ˆæ¯æœˆä¸€å›åˆï¼Œ12å›åˆ=1å¹´ï¼Œ3æœˆå†³ç®—ï¼‰
      const TURNS_PER_YEAR = 12;
      const SETTLEMENT_MONTH = 3; // 3æœˆå†³ç®—

      const STATION_NAMES = [
        "ç½—æ¹–å£å²¸",
        "å›½è´¸",
        "è€è¡—",
        "å¤§å‰§é™¢",
        "ç§‘å­¦é¦†",
        "åå¼ºè·¯",
        "å²—å¦",
        "ä¼šå±•ä¸­å¿ƒ",
        "è´­ç‰©å…¬å›­",
        "é¦™èœœæ¹–",
        "è½¦å…¬åº™",
        "ç«¹å­æ—",
        "ä¾¨åŸä¸œ",
        "åä¾¨åŸ",
        "ä¸–ç•Œä¹‹çª—",
        "ç™½çŸ³æ´²",
        "é«˜æ–°å›­",
        "æ·±å¤§",
        "æ¡ƒå›­",
        "å¤§æ–°",
        "å‰æµ·æ¹¾",
        "å®å®‰ä¸­å¿ƒ",
        "æ·±åœ³åŒ—ç«™",
        "å¸‚æ°‘ä¸­å¿ƒ",
        "å°‘å¹´å®«",
        "è²èŠ±åŒ—",
        "ä¸Šæ¢…æ—",
        "ç¦æ°‘",
        "ç¦ç”°å£å²¸",
        "åæµ·",
        "ç§‘è‹‘",
        "çº¢æ ‘æ¹¾",
        "é£æœºåœº",
      ];

      // --- Utilities ---
      const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const wait = (ms) => new Promise((r) => setTimeout(r, ms));

      // Home city - always shown on map in green
      let homeCity = "æ·±åœ³";

      // Global toast function for notifications
      function showToast(msg, color = "white") {
        const logEl = document.getElementById("game-log");
        const entry = document.createElement("div");
        entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
        logEl.appendChild(entry);
        if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
        setTimeout(() => {
          entry.style.opacity = "0";
          setTimeout(() => entry.remove(), 500);
        }, 4000);
      }

      // --- Load World Map Data from External File ---
      let CITIES = [];
      let CONTINENTS = {}; // continents loaded from data file (if any)

      async function loadCitiesData() {
        // Fallback default cities
        const defaultCities = [
          { name: "æ·±åœ³", lat: 22.5431, lon: 114.0579, population: 12590000, level: 1 },
          { name: "ä¸œäº¬", lat: 35.6762, lon: 139.6503, population: 13960000, level: 1 },
        ];

        try {
          const response = await fetch("world_traveler_data");
          const text = await response.text();

          // Extract JSON array from markdown (between [ and ])
          // The data file may either be a JSON array (legacy) or a JSON object with { cities: [], continents: {} }
          const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
          if (jsonMatch) {
            // Clean up the JSON text: remove comments
            const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, "");
            const parsed = JSON.parse(jsonText);
            if (Array.isArray(parsed)) {
              CITIES = parsed;
              CONTINENTS = {};
            } else {
              CITIES = parsed.cities || defaultCities;
              CONTINENTS = parsed.continents || {};
            }
            console.log(`Loaded ${CITIES.length} cities from world_traveler_data.md`);
          } else {
            console.error("Could not parse cities data from world_traveler_data.md");
            CITIES = defaultCities;
          }
        } catch (error) {
          console.error("Error loading cities data:", error);
          CITIES = defaultCities;
        }
      }

      // --- World Map Class ---
      class WorldMapManager {
        constructor(game) {
          this.game = game;
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x000000);
          this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

          // Center camera on initial location with zoom to show level 1 and 2
          const initialLat = 25;
          const initialLon = 105;
          const cameraDistance = 28; // Close enough to show level 2 (threshold is 35)
          const phi = (90 - initialLat) * (Math.PI / 180);
          const theta = (initialLon + 180) * (Math.PI / 180);
          const camX = -(cameraDistance * Math.sin(phi) * Math.cos(theta));
          const camZ = cameraDistance * Math.sin(phi) * Math.sin(theta);
          const camY = cameraDistance * Math.cos(phi);
          this.camera.position.set(camX, camY, camZ);

          this.group = new THREE.Group();
          this.scene.add(this.group);

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();

          this.cities = [];
          this.planes = []; // active plane animations
          this.controls = new THREE.OrbitControls(this.camera, this.game.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 15;
          this.controls.maxDistance = 60;
          this.controls.enablePan = false;

          this.autoRotate = true;
          this.clock = new THREE.Clock();
          this.cameraRestoreAnim = null; // {fromPos, toPos, fromTarget, toTarget, t, duration}
          this.init();
        }

        init() {
          // Earth Sphere
          const geometry = new THREE.SphereGeometry(10, 64, 64);
          const material = new THREE.MeshPhongMaterial({
            color: 0x1a237e,
            emissive: 0x112244,
            specular: 0x111111,
            shininess: 10,
          });
          this.earth = new THREE.Mesh(geometry, material);
          this.group.add(this.earth);

          // Atmosphere glow
          const atmGeo = new THREE.SphereGeometry(10.2, 64, 64);
          const atmMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide });
          this.group.add(new THREE.Mesh(atmGeo, atmMat));

          // Lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          this.scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 1);
          dirLight.position.set(50, 30, 50);
          this.scene.add(dirLight);

          // Event Listeners
          // Use pointer events for better mobile support
          const canvas = this.game.renderer.domElement;
          let downX = 0;
          let downY = 0;

          canvas.addEventListener("pointerdown", (e) => {
            downX = e.clientX;
            downY = e.clientY;
            // Stop auto-rotation when user starts interacting
            this.autoRotate = false;
          });

          canvas.addEventListener("pointerup", (e) => {
            const moveDist = Math.sqrt(Math.pow(e.clientX - downX, 2) + Math.pow(e.clientY - downY, 2));
            // Allow small movement (jitter) but filter out drags
            if (moveDist < 10) {
              this.onClick(e);
            }
          });

          // Also stop auto-rotation when OrbitControls detects drag start
          this.controls.addEventListener("start", () => {
            this.autoRotate = false;
          });
        }

        renderMapObjects() {
          this.createContinentOutlines();
          this.createCities();
        }

        // Create continent outline curves on globe
        createContinentOutlines() {
          const radius = 10.05; // Slightly above earth surface
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x44ff88, linewidth: 2, transparent: true, opacity: 0.8 });

          // Continent outline data (simplified lat/lon coordinates)
          const defaultContinents = {
            // äºšæ´² (Asia) - simplified outline
            asia: [
              [66, 170],
              [70, 140],
              [75, 100],
              [70, 70],
              [55, 60],
              [45, 35],
              [35, 35],
              [25, 55],
              [10, 75],
              [8, 80],
              [20, 90],
              [22, 90],
              [25, 95],
              [10, 100],
              [5, 105],
              [1, 104],
              [-8, 110],
              [-8, 115],
              [-5, 120],
              [5, 120],
              [10, 125],
              [20, 120],
              [25, 122],
              [35, 130],
              [40, 130],
              [45, 140],
              [50, 140],
              [55, 160],
              [60, 170],
              [66, 170],
            ],
          };
          const continents = typeof CONTINENTS !== "undefined" && Object.keys(CONTINENTS).length > 0 ? CONTINENTS : defaultContinents;

          // Draw each continent outline
          Object.values(continents).forEach((coords) => {
            const points = [];
            // Create points for each coordinate, with interpolation along sphere surface
            for (let i = 0; i < coords.length; i++) {
              const [lat1, lon1] = coords[i];
              const [lat2, lon2] = coords[(i + 1) % coords.length]; // Wrap to first point for closure

              // Add start point
              points.push(this.latLonToVector3(lat1, lon1, radius));

              // Interpolate points along the great circle to keep lines on sphere surface
              const segments = 5; // Number of intermediate points between each pair
              for (let j = 1; j < segments; j++) {
                const t = j / segments;
                const latInterp = lat1 + (lat2 - lat1) * t;
                const lonInterp = lon1 + (lon2 - lon1) * t;
                points.push(this.latLonToVector3(latInterp, lonInterp, radius));
              }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, lineMaterial);
            this.group.add(line);
          });
        }

        latLonToVector3(lat, lon, radius) {
          const phi = (90 - lat) * (Math.PI / 180);
          const theta = (lon + 180) * (Math.PI / 180);
          const x = -(radius * Math.sin(phi) * Math.cos(theta));
          const z = radius * Math.sin(phi) * Math.sin(theta);
          const y = radius * Math.cos(phi);
          return new THREE.Vector3(x, y, z);
        }

        createCities() {
          // Sort cities by population (descending) - higher population has priority
          const sortedCities = [...CITIES].sort((a, b) => b.population - a.population);

          // Initialize city positions
          const cityData = sortedCities.map((city) => ({
            city,
            pos: this.latLonToVector3(city.lat, city.lon, 10),
            mass: city.population, // Use population as mass
          }));

          const minMarkerDistance = 0.5; // Minimum distance between markers on sphere
          const maxIterations = 50; // Max iterations for separation

          // Iteratively separate overlapping markers using mass-based repulsion
          for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;

            for (let i = 0; i < cityData.length; i++) {
              for (let j = i + 1; j < cityData.length; j++) {
                const a = cityData[i];
                const b = cityData[j];
                const dist = a.pos.distanceTo(b.pos);

                if (dist < minMarkerDistance && dist > 0.001) {
                  hasOverlap = true;

                  // Calculate repulsion direction (from a to b)
                  const direction = new THREE.Vector3().subVectors(b.pos, a.pos).normalize();

                  // Calculate displacement based on mass ratio
                  // Heavier (more population) moves less
                  const totalMass = a.mass + b.mass;
                  const overlap = minMarkerDistance - dist;
                  const moveA = overlap * (b.mass / totalMass); // Lighter moves more
                  const moveB = overlap * (a.mass / totalMass);

                  // Move positions apart along sphere surface
                  a.pos.addScaledVector(direction, -moveA);
                  b.pos.addScaledVector(direction, moveB);

                  // Re-project onto sphere surface (radius = 10)
                  a.pos.normalize().multiplyScalar(10);
                  b.pos.normalize().multiplyScalar(10);
                }
              }
            }

            if (!hasOverlap) break;
          }

          // Create markers and labels
          cityData.forEach(({ city, pos }) => {
            // Marker size based on level
            const markerSize = city.level === 1 ? 0.25 : city.level === 2 ? 0.18 : 0.12;
            const markerGeo = new THREE.SphereGeometry(markerSize, 16, 16);

            // Color based on level and home city
            let color;
            if (city.name === homeCity) {
              color = 0x00ff00; // Green for home city
            } else if (city.level === 1) {
              color = 0xffaa00; // Orange for level 1
            } else if (city.level === 2) {
              color = 0x88aaff; // Light blue for level 2
            } else {
              color = 0xaaaaaa; // Gray for level 3
            }

            const markerMat = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(pos);
            marker.userData = { city: city };
            this.group.add(marker);

            // Simple Label (using Sprite) - size based on population/level
            const canvas = document.createElement("canvas");
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext("2d");
            const fontSize = city.level === 1 ? 28 : city.level === 2 ? 22 : 18;
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = city.level === 1 ? "#ffffff" : city.level === 2 ? "#ccddff" : "#999999";
            context.textAlign = "center";
            context.fillText(city.name, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);

            // Position label above marker
            const labelPos = pos.clone().normalize().multiplyScalar(10.5);
            sprite.position.copy(labelPos);

            // Scale based on level
            const spriteScale = city.level === 1 ? 2.5 : city.level === 2 ? 2.0 : 1.5;
            sprite.scale.set(spriteScale, spriteScale * 0.25, 1);

            this.group.add(sprite);

            this.cities.push({ marker, sprite, data: city, basePos: pos.clone() });
          });
        }

        onClick(event) {
          if (this.game.mode !== "MAP") return;
          // ignore clicks while a plane is animating so user cannot start multiple flights
          if (this.planes && this.planes.length > 0) return;

          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const markers = this.cities.map((c) => c.marker);
          const intersects = this.raycaster.intersectObjects(markers);

          if (intersects.length > 0) {
            const city = intersects[0].object.userData.city;
            this.game.travelToCity(city);
          }
        }

        update() {
          this.controls.update();

          if (this.autoRotate) {
            this.group.rotation.y += 0.001;
          }

          // Level of Detail logic based on zoom distance
          const dist = this.camera.position.distanceTo(new THREE.Vector3(0, 0, 0));

          // Zoom thresholds for showing different levels
          const showLevel2 = dist < 35; // Show level 2 when closer
          const showLevel3 = dist < 22; // Show level 3 when even closer

          // Collect visible labels for overlap detection
          const visibleLabels = [];

          // First pass: determine visibility based on level
          this.cities.forEach((c) => {
            const level = c.data.level || 1;
            const isHomeCity = c.data.name === homeCity;
            let shouldShowByLevel = false;

            if (isHomeCity || level === 1) {
              shouldShowByLevel = true; // Always show home city and level 1
            } else if (level === 2) {
              shouldShowByLevel = showLevel2;
            } else if (level === 3) {
              shouldShowByLevel = showLevel3;
            }

            // Check if in front of camera using dot product (more stable than screenZ)
            const cameraPos = this.camera.position.clone().normalize();
            const markerDir = c.marker.position.clone().normalize();
            const dotProduct = markerDir.dot(cameraPos);
            const isFrontFacing = dotProduct > -0.1; // Visible if on front hemisphere

            const shouldShow = shouldShowByLevel && isFrontFacing;

            c.marker.visible = shouldShow;
            c.sprite.visible = false; // Default to hidden, will be shown in overlap pass
            c.potentiallyVisible = shouldShow;

            if (shouldShow) {
              // Calculate screen position for overlap detection
              const screenPos = c.marker.position.clone().project(this.camera);
              c.screenX = ((screenPos.x + 1) / 2) * window.innerWidth;
              c.screenY = ((-screenPos.y + 1) / 2) * window.innerHeight;

              visibleLabels.push(c);
            }
          });

          // Sort by population (higher population has priority for label display)
          visibleLabels.sort((a, b) => b.data.population - a.data.population);

          // Second pass: show non-overlapping labels (keep higher population visible)
          const labelRadius = 50; // Approximate label radius in screen pixels
          const shownLabels = [];

          visibleLabels.forEach((c) => {
            let hasOverlap = false;

            for (const shown of shownLabels) {
              const dx = c.screenX - shown.screenX;
              const dy = c.screenY - shown.screenY;
              const screenDist = Math.sqrt(dx * dx + dy * dy);

              // Smaller overlap threshold for higher level cities
              const minDist = labelRadius * (c.data.level === 1 ? 1.2 : c.data.level === 2 ? 1.0 : 0.8);

              if (screenDist < minDist) {
                hasOverlap = true;
                break;
              }
            }

            if (!hasOverlap) {
              c.sprite.visible = true;
              shownLabels.push(c);
            }
          });

          // Update plane animations
          if (this.planes && this.planes.length > 0) {
            const toRemove = [];
            for (let i = 0; i < this.planes.length; i++) {
              const anim = this.planes[i];
              const mesh = anim.mesh;
              // Basic speed factor based on distance
              const angleBetween = anim.start.clone().normalize().dot(anim.end.clone().normalize());
              const dtheta = Math.acos(THREE.MathUtils.clamp(angleBetween, -1, 1));
              const baseSpeed = 0.002 + 0.01 / (dtheta + 1.0);

              if (anim.state === "takeoff") {
                // scale up and start moving forward slightly
                anim.t += 0.005;
                const s = THREE.MathUtils.lerp(0.01, 0.9, Math.min(1, anim.t / 0.15));
                mesh.scale.set(s, s, s);
                // lift up a bit
                const pos = this.computeGreatCirclePoint(anim.start, anim.end, 0, anim.radius, anim.altitude * 0.2);
                mesh.position.copy(pos);
                mesh.lookAt(this.computeGreatCirclePoint(anim.start, anim.end, 0.05, anim.radius, anim.altitude * 0.2));
                if (anim.t >= 0.15) {
                  anim.state = "cruise";
                  anim.t = 0;
                }
              } else if (anim.state === "cruise") {
                anim.t += baseSpeed;
                const t = Math.min(1, anim.t);
                const pos = this.computeGreatCirclePoint(anim.start, anim.end, t, anim.radius, anim.altitude);
                mesh.position.copy(pos);
                // bigger plane in cruise
                mesh.scale.set(1.4, 1.4, 1.4);
                const lookAheadT = Math.min(1, t + 0.02);
                const aheadPos = this.computeGreatCirclePoint(anim.start, anim.end, lookAheadT, anim.radius, anim.altitude);
                mesh.lookAt(aheadPos);
                if (t >= 1) {
                  // Arrived at destination; start circling for a round
                  anim.state = "circle";
                  anim.circleAngle = 0;
                  // Save circle orientation basis
                  anim.center = anim.end.clone().setLength(anim.radius + anim.altitude);
                  // Choose circle radius based on city size (small around 0.8)
                  anim.circleRadius = Math.max(0.6, 0.6);
                  // Orthonormal basis u, v perpendicular to center normal
                  const normal = anim.center.clone().normalize();
                  const arbitrary = new THREE.Vector3(0, 1, 0);
                  if (Math.abs(normal.dot(arbitrary)) > 0.95) arbitrary.set(1, 0, 0);
                  anim.u = new THREE.Vector3().crossVectors(normal, arbitrary).normalize();
                  anim.v = new THREE.Vector3().crossVectors(normal, anim.u).normalize();
                }
              } else if (anim.state === "circle") {
                // Rotate around destination center
                anim.circleAngle += 0.04; // rotation speed
                const a = anim.circleAngle;
                const pos = anim.center
                  .clone()
                  .add(anim.u.clone().multiplyScalar(Math.cos(a) * anim.circleRadius))
                  .add(anim.v.clone().multiplyScalar(Math.sin(a) * anim.circleRadius));
                mesh.position.copy(pos);
                // point in tangent direction
                const tangent = anim.u
                  .clone()
                  .multiplyScalar(-Math.sin(a) * anim.circleRadius)
                  .add(anim.v.clone().multiplyScalar(Math.cos(a) * anim.circleRadius));
                const lookAt = pos.clone().add(tangent);
                mesh.lookAt(lookAt);
                // When one round complete, start landing
                if (anim.circleAngle >= Math.PI * 2 * anim.circleRoundsLeft) {
                  anim.state = "landing";
                  anim.t = 0;
                }
              } else if (anim.state === "landing") {
                // shrink and move down to surface
                anim.t += 0.03;
                const s = THREE.MathUtils.lerp(mesh.scale.x, 0.02, 0.2);
                mesh.scale.set(s, s, s);
                // move towards end surface
                const current = mesh.position.clone();
                const dirToEnd = anim.end.clone().sub(current).multiplyScalar(0.15);
                mesh.position.add(dirToEnd);
                mesh.lookAt(anim.end);
                // When close to end, remove
                if (mesh.position.distanceTo(anim.end) < 0.08 || mesh.scale.x <= 0.03) {
                  // Trigger completion callback if any
                  if (typeof anim.onComplete === "function") {
                    try {
                      anim.onComplete();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                  // Remove mesh
                  // Remove trail
                  if (anim.trailMesh) {
                    try {
                      this.group.remove(anim.trailMesh);
                    } catch (e) {}
                  }
                  this.group.remove(mesh);
                  // Restore control state but keep the camera at the destination
                  if (this.controls && typeof anim.prevControlsEnabled !== "undefined") {
                    this.controls.enabled = anim.prevControlsEnabled;
                  }
                  // Instead of restoring the previous camera position, honor the desired camera distance
                  // and center the map on the destination (anim.end). This keeps the camera distance
                  // consistent while focusing on the new map location.
                  try {
                    // Determine camera distance to preserve (fallback to current camera length)
                    const preservedDistance = anim.prevCameraLen || this.camera.position.length();
                    // Direction from origin to destination (for final camera radial position)
                    const toDir = anim.end ? anim.end.clone().normalize() : this.camera.position.clone().normalize();
                    const toPos = toDir.clone().multiplyScalar(preservedDistance);

                    // Queue a smooth camera restore animation instead of snapping the camera.
                    this.cameraRestoreAnim = {
                      fromPos: this.camera.position.clone(),
                      toPos: toPos,
                      fromTarget: this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0),
                      toTarget: new THREE.Vector3(0, 0, 0),
                      t: 0,
                      duration: 0.35, // seconds for smooth transition
                    };
                  } catch (e) {}
                  // Hide destination UI indicator
                  try {
                    const indicator = document.getElementById("destination-indicator");
                    if (indicator) indicator.classList.add("hidden");
                  } catch (e) {}
                  toRemove.push(i);
                }
              }
              // Camera follow & trail updates
              if (anim.followCamera && mesh) {
                // Camera zoom during takeoff
                if (anim.state === "takeoff") {
                  anim.zoomInT = Math.min(1, anim.zoomInT + anim.zoomSpeed);
                  const camLen = THREE.MathUtils.lerp(anim.prevCameraLen, anim.zoomInDistance, anim.zoomInT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.25);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.25);
                  if (this.controls) this.controls.update();
                } else if (anim.state === "cruise") {
                  // Zoom out smoothly to cruise distance
                  anim.zoomOutT = Math.min(1, anim.zoomOutT + anim.zoomSpeed * 0.25);
                  const camLen = THREE.MathUtils.lerp(anim.zoomInDistance, anim.zoomOutDistance, anim.zoomOutT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.12);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.12);
                  if (this.controls) this.controls.update();
                  // Update trail when cruising
                  if (anim.trailMesh) {
                    anim.trailPoints.push(mesh.position.clone());
                    if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                    anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                    try {
                      anim.trailMesh.computeLineDistances();
                    } catch (e) {}
                    anim.trailMesh.visible = true;
                  }
                } else if (anim.state === "circle") {
                  // As the plane circles before landing, start zooming in to landing distance
                  const shouldZoomIn = anim.circleRoundsLeft <= 1;
                  if (shouldZoomIn) {
                    anim.zoomLandingT = Math.min(1, anim.zoomLandingT + anim.zoomLandingSpeed);
                  } else {
                    // slowly decay to avoid abrupt camera jumps if there are multiple circles
                    anim.zoomLandingT = Math.max(0, anim.zoomLandingT - anim.zoomLandingSpeed * 0.5);
                  }
                  const camLen = THREE.MathUtils.lerp(anim.zoomOutDistance, anim.zoomLandingDistance, anim.zoomLandingT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.18);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.18);
                  if (this.controls) this.controls.update();
                  // Update trail when circling
                  if (anim.trailMesh) {
                    anim.trailPoints.push(mesh.position.clone());
                    if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                    anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                    try {
                      anim.trailMesh.computeLineDistances();
                    } catch (e) {}
                    anim.trailMesh.visible = true;
                  }
                }
              }
            }
            // Remove finished planes from array in reverse order
            for (let r = toRemove.length - 1; r >= 0; r--) {
              this.planes.splice(toRemove[r], 1);
            }
          }

          // Smooth camera restore animation (if queued)
          try {
            const dt = this.clock.getDelta();
            if (this.cameraRestoreAnim) {
              const a = this.cameraRestoreAnim;
              a.t = Math.min(a.duration, a.t + dt);
              const u = Math.min(1, a.t / a.duration);
              // Interpolate camera world position and controls target
              if (a.fromPos && a.toPos) {
                this.camera.position.lerpVectors(a.fromPos, a.toPos, u);
              }
              if (this.controls && a.fromTarget && a.toTarget) {
                this.controls.target.lerpVectors(a.fromTarget, a.toTarget, u);
                this.controls.update();
              }
              if (u >= 1) {
                this.cameraRestoreAnim = null;
              }
            }
          } catch (e) {}
        }

        // --- Plane animation helpers ---
        createPlaneMesh() {
          // Simple stylized plane mesh: a small group with body and wings
          const group = new THREE.Group();

          const body = new THREE.BoxGeometry(0.5, 0.12, 0.8);
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffee88 });
          const bodyMesh = new THREE.Mesh(body, bodyMat);
          group.add(bodyMesh);

          const wingGeo = new THREE.BoxGeometry(0.9, 0.02, 0.08);
          const wingMat = new THREE.MeshStandardMaterial({ color: 0xdd3333 });
          const wing = new THREE.Mesh(wingGeo, wingMat);
          wing.position.set(0, 0, 0);
          group.add(wing);

          const tailGeo = new THREE.BoxGeometry(0.16, 0.2, 0.02);
          const tailMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
          const tail = new THREE.Mesh(tailGeo, tailMat);
          tail.position.set(-0.28, 0.08, 0);
          group.add(tail);

          // Small shadows and low lighting
          group.scale.set(0.001, 0.001, 0.001); // start from very small
          group.castShadow = true;
          group.receiveShadow = false;
          return group;
        }

        // Compute a point along a great circle between two vectors; r is radius and altitude added
        computeGreatCirclePoint(startVec, endVec, t, radius, altitude) {
          // startVec and endVec are THREE.Vector3 on surface (radius length), we slerp and then lift
          const v0 = startVec.clone().normalize();
          const v1 = endVec.clone().normalize();
          const dot = THREE.MathUtils.clamp(v0.dot(v1), -1, 1);
          const theta = Math.acos(dot);
          if (theta === 0) {
            // Same point
            const final = v0.clone().multiplyScalar(radius + altitude);
            return final;
          }
          const sinTheta = Math.sin(theta);
          const s0 = Math.sin((1 - t) * theta) / sinTheta;
          const s1 = Math.sin(t * theta) / sinTheta;
          const interpolated = v0.multiplyScalar(s0).add(v1.multiplyScalar(s1)).normalize();
          const lift = Math.sin(Math.PI * t) * altitude; // arc-shaped altitude
          return interpolated.multiplyScalar(radius + lift);
        }

        // Main method to play a plane animation from cityAName to cityBName
        flyPlane(
          cityAName,
          cityBName,
          {
            loopRounds = 1,
            altitude = 2.0,
            onComplete = null,
            followCamera = true,
            zoomInDistance = 18,
            zoomOutDistance = 25,
            zoomSpeed = 0.08,
            trailMaxPoints = 64,
            trailColor = 0xffffff,
            zoomLandingDistance = 14,
            zoomLandingSpeed = 0.06,
          } = {}
        ) {
          if (!this.cities || this.cities.length === 0) return;

          const cityA = this.cities.find((c) => c.data.name === cityAName) || this.cities.find((c) => c.data.name === homeCity);
          const cityB = this.cities.find((c) => c.data.name === cityBName) || this.cities.find((c) => c.data.name === homeCity);
          if (!cityA || !cityB) return;

          const startPosSurface = cityA.basePos.clone();
          const endPosSurface = cityB.basePos.clone();

          // Spawn plane
          const plane = this.createPlaneMesh();
          this.group.add(plane);

          const anim = {
            mesh: plane,
            start: startPosSurface
              .clone()
              .normalize()
              .multiplyScalar(10 + 0.01), // just above surface
            end: endPosSurface
              .clone()
              .normalize()
              .multiplyScalar(10 + 0.01),
            t: 0,
            state: "takeoff", // takeoff, cruise, circle, landing
            radius: 10,
            altitude: altitude,
            circleAngle: 0,
            circleRoundsLeft: loopRounds,
            onComplete: onComplete,
          };

          // camera follow options
          anim.followCamera = followCamera;
          anim.zoomInDistance = zoomInDistance;
          anim.zoomOutDistance = zoomOutDistance;
          anim.zoomSpeed = zoomSpeed;
          anim.zoomInT = 0;
          anim.zoomOutT = 0;
          // Landing / circling zoom
          anim.zoomLandingDistance = zoomLandingDistance;
          anim.zoomLandingSpeed = zoomLandingSpeed;
          anim.zoomLandingT = 0;
          anim.prevCameraPos = this.camera.position.clone();
          anim.prevControlsTarget = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
          anim.prevCameraLen = this.camera.position.length();

          // trail initialization (dashed line)
          anim.trailPoints = [];
          anim.trailMaxPoints = trailMaxPoints;
          const trailMat = new THREE.LineDashedMaterial({ color: trailColor, dashSize: 0.25, gapSize: 0.15, scale: 1 });
          const trailGeo = new THREE.BufferGeometry().setFromPoints(anim.trailPoints);
          const trailLine = new THREE.Line(trailGeo, trailMat);
          trailLine.computeLineDistances();
          trailLine.visible = false; // show when cruise begins
          this.group.add(trailLine);
          anim.trailMesh = trailLine;

          // Initialize position at start (tiny -> grow)
          const startWorld = anim.start.clone().setLength(anim.radius + 0.1);
          plane.position.copy(startWorld);
          plane.lookAt(anim.end);
          plane.scale.set(0.01, 0.01, 0.01);

          // Add to active planes
          this.planes.push(anim);
          // Show destination indicator
          try {
            const indicator = document.getElementById("destination-indicator");
            if (indicator) {
              indicator.classList.remove("hidden");
              const nameElem = document.getElementById("indicator-name");
              if (nameElem) nameElem.textContent = cityBName;
            }
          } catch (e) {}
          // Disable interaction while plane is active
          if (this.controls) {
            anim.prevControlsEnabled = this.controls.enabled;
            this.controls.enabled = false;
          }

          // Add a small flag to avoid clicking multiple times
          anim.isAnimating = true;
        }
      }

      // --- Game Classes ---

      class Tile {
        constructor(id, gridX, gridY, type) {
          this.id = id;
          this.gridX = gridX;
          this.gridY = gridY;
          this.type = type;
          this.buildings = [];
          this.owner = null;

          this.stationName = "";
          if (type === "green") {
            const rawIdx = (gridX * 13 + gridY * 7) % STATION_NAMES.length;
            const idx = (rawIdx + STATION_NAMES.length) % STATION_NAMES.length;
            this.stationName = STATION_NAMES[idx];
          }

          this.neighbors = [];
          this.mesh = null; // Three.js Mesh
          this.labelElement = null; // HTML Element for station name
        }

        get isRoad() {
          return !this.type.startsWith("env");
        }

        get isColored() {
          return ["blue", "red", "yellow", "green", "start"].includes(this.type);
        }

        // Helper to get world position based on grid
        get worldPos() {
          return new THREE.Vector3(this.gridX * TILE_SIZE, 0, this.gridY * TILE_SIZE);
        }
      }

      class Player {
        constructor(id, name, color, isAI) {
          this.id = id;
          this.name = name;
          this.color = color;
          this.isAI = isAI;
          this.money = 10000;
          this.assets = 0;

          this.currentTile = null;
          this.previousTile = null;

          this.mesh = null; // Three.js Mesh (Group)

          // For smooth movement animation
          this.animating = false;
          this.targetPos = new THREE.Vector3();

          // --- ç©·ç¥ç³»ç»Ÿ ---
          this.hasBinbougami = false; // æ˜¯å¦è¢«ç©·ç¥é™„èº«
          this.binbougamiTurns = 0; // ç©·ç¥é™„èº«å›åˆæ•°
          this.binbougamiLevel = 0; // 0=æ™®é€š, 1=å¤§é­”ç‹
          this.binbougamiMesh = null; // ç©·ç¥3Dæ¨¡å‹

          // --- å¡ç‰Œç³»ç»Ÿ ---
          this.cards = []; // æ‰‹ç‰Œ
          this.skipNextTurn = false; // ä¸‹å›åˆæ˜¯å¦è·³è¿‡ï¼ˆå†¬çœ æ•ˆæœï¼‰
          this.doubleIncomeNext = false; // ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€
          this.hasShield = false; // æ˜¯å¦æœ‰æŠ¤èº«ç¬¦ä¿æŠ¤
        }
      }

      class Game {
        constructor() {
          this.container = document.getElementById("game-container");
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // Three.js Components
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;

          this.map = [];
          this.players = [];
          this.turn = 0;
          this.state = "INIT";
          this.cameraLocked = true;
          this.isUserInteracting = false;

          // ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ—¶é—´ç³»ç»Ÿï¼ˆå¹´/æœˆï¼‰
          this.gameYear = 1;
          this.gameMonth = 4; // ä»4æœˆå¼€å§‹
          this.totalTurns = 0;

          this.mode = "MAP"; // 'MAP' or 'GAME'
          this.worldMap = null;
          this.currentCity = null;

          this.initThree();
          // this.initGame(); // Delayed until city selection

          window.addEventListener("resize", () => this.onResize());
          document.getElementById("roll-btn").onclick = () => this.playerRoll();

          this.initWorldMap();

          // Start Loop
          this.animate();
        }

        initThree() {
          // 1. Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x202025);
          this.scene.fog = new THREE.Fog(0x202025, 90, 180);

          // 2. Camera (Perspective)
          const fov = 45;
          const aspect = this.width / this.height;
          const near = 0.1;
          const far = 1000;
          this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

          // Perspective View Setup: Position and LookAt
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(this.scene.position); // Will be updated to follow player

          // 3. Renderer
          if (!this.renderer) {
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);
          }

          // Controls
          if (this.controls) this.controls.dispose();
          this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 50;
          this.controls.maxDistance = 130;
          this.controls.target.set(0, 0, 0);

          // Lock rotation, enable pan
          this.controls.enableRotate = false;
          this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
          this.controls.touches = {
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };

          // Stop auto-following if user interacts
          this.controls.addEventListener("start", () => {
            this.cameraLocked = false;
            this.isUserInteracting = true;
          });

          this.controls.addEventListener("end", () => {
            this.isUserInteracting = false;
            if (this.state === "MOVING") {
              this.cameraLocked = true;
            }
          });

          // 4. Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(50, 100, 50);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          dirLight.shadow.camera.near = 0.5;
          dirLight.shadow.camera.far = 500;
          const shadowSize = 50;
          dirLight.shadow.camera.left = -shadowSize;
          dirLight.shadow.camera.right = shadowSize;
          dirLight.shadow.camera.top = shadowSize;
          dirLight.shadow.camera.bottom = -shadowSize;
          this.scene.add(dirLight);
        }

        initWorldMap() {
          this.worldMap = new WorldMapManager(this);
          if (this.controls) this.controls.enabled = false;

          // Hide Game UI initially
          document.getElementById("ui-layer").style.display = "none";
          document.getElementById("labels-layer").style.display = "none";
          document.getElementById("game-title").classList.add("hidden");

          // Setup Login
          const loginModal = document.getElementById("login-modal");
          if (loginModal) {
            loginModal.classList.remove("hidden");
            document.getElementById("login-btn").onclick = () => this.startGame();
          }
        }

        startGame() {
          const loginModal = document.getElementById("login-modal");
          if (loginModal) loginModal.classList.add("hidden");

          document.getElementById("game-title").classList.remove("hidden");

          if (this.worldMap) {
            // this.worldMap.autoRotate = false;
          }
        }

        selectCity(city) {
          this.currentCity = city;
          // If we're in MAP mode, we should ensure worldMap is visible during travel
          this.mode = "GAME";

          if (this.worldMap) this.worldMap.controls.enabled = false;

          // Reset Game Scene if needed or just init
          // Clear existing map if any?
          while (this.scene.children.length > 0) {
            this.scene.remove(this.scene.children[0]);
          }

          // é‡ç½®ç›®çš„åœ°æ ‡è®°
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ¸…ç©ºæ ‡ç­¾å±‚
          document.getElementById("labels-layer").innerHTML = "";

          this.initThree(); // Re-init scene/camera/lights for Game
          this.initGame(); // Generate city map

          // Update UI
          document.getElementById("ui-layer").style.display = "flex";
          document.getElementById("labels-layer").style.display = "block";
          document.getElementById("game-title").classList.add("hidden");
        }

        // Travel from current city (or homeCity) to the provided city. Will perform plane animation then select City
        travelToCity(cityOrName, enterCity = true) {
          let cityObj = null;
          if (!cityOrName) return;
          if (typeof cityOrName === "string") {
            // find by name
            cityObj = (CITIES || []).find((c) => c.name === cityOrName);
          } else {
            cityObj = cityOrName;
          }
          if (!cityObj) {
            console.warn("travelToCity: city not found", cityOrName);
            return this.selectCity(cityOrName);
          }

          const fromName = this.currentCity && this.currentCity.name ? this.currentCity.name : homeCity;
          // If no worldMap, just switch immediately
          if (!this.worldMap || typeof this.worldMap.flyPlane !== "function") {
            return this.selectCity(cityObj);
          }

          // When the plane finishes flying to cityObj, we call selectCity
          this.worldMap.flyPlane(fromName, cityObj.name, {
            altitude: 2.2,
            followCamera: true,
            zoomInDistance: 18,
            zoomOutDistance: 30,
            zoomSpeed: 0.08,
            trailMaxPoints: 96,
            trailColor: 0xffee88,
            onComplete: () => {
              if (enterCity) {
                this.selectCity(cityObj);
              }
            },
          });
        }

        toggleMap() {
          if (this.mode === "GAME") {
            this.mode = "MAP";
            if (this.controls) this.controls.enabled = false;
            if (this.worldMap) this.worldMap.controls.enabled = true;

            document.getElementById("ui-layer").style.display = "none";
            document.getElementById("labels-layer").style.display = "none";
            document.getElementById("destination-indicator").classList.add("hidden");
            document.getElementById("game-title").classList.remove("hidden");
          } else {
            if (this.currentCity) {
              this.mode = "GAME";
              if (this.worldMap) this.worldMap.controls.enabled = false;
              if (this.controls) this.controls.enabled = true;

              document.getElementById("ui-layer").style.display = "flex";
              document.getElementById("labels-layer").style.display = "block";
              document.getElementById("game-title").classList.add("hidden");
            }
          }
        }

        async initGame() {
          // Materials Cache
          this.materials = {
            road: new THREE.MeshLambertMaterial({ color: COLORS.road }),
            start: new THREE.MeshLambertMaterial({ color: COLORS.start }),
            blue: new THREE.MeshLambertMaterial({ color: COLORS.blue }),
            red: new THREE.MeshLambertMaterial({ color: COLORS.red }),
            yellow: new THREE.MeshLambertMaterial({ color: COLORS.yellow }),
            green: new THREE.MeshLambertMaterial({ color: COLORS.green }),
            env_nature: new THREE.MeshLambertMaterial({ color: COLORS.env_nature }),
            env_culture: new THREE.MeshLambertMaterial({ color: COLORS.env_culture }),
            rail: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 }),
          };

          this.geometries = {
            tile: new THREE.BoxGeometry(TILE_SIZE - TILE_SPACING, 1, TILE_SIZE - TILE_SPACING),
            envBlock: new THREE.BoxGeometry(TILE_SIZE, 4, TILE_SIZE), // Taller blocks for env
          };

          // Generate Map
          const startTile = this.generateMap();

          // Init Players
          this.players = [new Player("p1", "ç©å®¶", 0x3b82f6, false), new Player("com", "ç”µè„‘", 0xef4444, true)];

          this.players.forEach((p) => {
            this.createPlayerMesh(p);
            p.currentTile = startTile;
            p.mesh.position.copy(startTile.worldPos);
            p.mesh.position.y = 1.5; // Sit on top of tile
          });

          // Initial Camera Setup: Center on P1, looking from South
          const p1Pos = this.players[0].mesh.position;
          this.camera.position.set(p1Pos.x, p1Pos.y + 60, p1Pos.z + 60);
          this.controls.target.copy(p1Pos);
          this.controls.update();

          // åˆå§‹åŒ–ç›®çš„åœ°å’Œæ—¶é—´
          this.gameYear = 1;
          this.gameMonth = 4;
          this.totalTurns = 0;
          await this.setNewDestination();
          document.getElementById("destination-panel").classList.remove("hidden");

          this.updateUI();
          this.startTurn();

          // Debug: Quickly attach binbougami to P1 if 'testBinbougami' query present
          try {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get("testBinbougami") === "1") {
              await wait(500);
              await this.attachBinbougami(this.players[0]);
            }
          } catch (e) {}
        }

        createPlayerMesh(player) {
          const group = new THREE.Group();

          // Body
          const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 16);
          const bodyMat = new THREE.MeshStandardMaterial({ color: player.color });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 1;
          body.castShadow = true;
          group.add(body);

          // Head
          const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
          const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
          const head = new THREE.Mesh(headGeo, headMat);
          head.position.y = 2.2;
          head.castShadow = true;
          group.add(head);
          // expose head reference for attaching UI / effects
          player.headMesh = head;

          // Hat/Indicator (Cone)
          const hatGeo = new THREE.ConeGeometry(0.6, 1, 16);
          const hatMat = new THREE.MeshStandardMaterial({ color: player.color });
          const hat = new THREE.Mesh(hatGeo, hatMat);
          hat.position.y = 3;
          hat.rotation.x = Math.PI; // Point down? No point up like a party hat
          group.add(hat);

          this.scene.add(group);
          player.mesh = group;
        }

        generateMap() {
          this.map = [];

          // 0. Prepare Station Names
          const availableNames = [...STATION_NAMES];
          // Shuffle
          for (let i = availableNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableNames[i], availableNames[j]] = [availableNames[j], availableNames[i]];
          }

          const totalStations = availableNames.length;

          // 1. Calculate Grid Dimensions to fit all stations
          const ratio = 4 / 3;
          let cols = Math.ceil(Math.sqrt(totalStations * ratio));
          let rows = Math.ceil(totalStations / cols);
          while (cols * rows < totalStations) rows++;

          // 2. Generate Coordinates (Centered around 0)
          const xCoords = [];
          let cx = -Math.floor(cols * 2.5);
          for (let i = 0; i < cols; i++) {
            xCoords.push(cx);
            cx += rand(2, 5);
          }

          const zCoords = [];
          let cz = -Math.floor(rows * 2.5);
          for (let i = 0; i < rows; i++) {
            zCoords.push(cz);
            cz += rand(2, 5);
          }

          // 3. Build Graph Nodes (Intersections)
          const nodes = [];
          for (let i = 0; i < xCoords.length; i++) {
            const row = [];
            for (let j = 0; j < zCoords.length; j++) {
              row.push({ x: xCoords[i], z: zCoords[j], id: `${i},${j}` });
            }
            nodes.push(row);
          }

          // 4. Build All Potential Edges
          const allEdges = [];
          for (let i = 0; i < xCoords.length - 1; i++) {
            for (let j = 0; j < zCoords.length; j++) {
              allEdges.push({ u: nodes[i][j], v: nodes[i + 1][j], type: "h" });
            }
          }
          for (let i = 0; i < xCoords.length; i++) {
            for (let j = 0; j < zCoords.length - 1; j++) {
              allEdges.push({ u: nodes[i][j], v: nodes[i][j + 1], type: "v" });
            }
          }

          // MST Logic
          for (let i = allEdges.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allEdges[i], allEdges[j]] = [allEdges[j], allEdges[i]];
          }

          const parent = new Map();
          const find = (id) => {
            if (!parent.has(id)) parent.set(id, id);
            if (parent.get(id) !== id) parent.set(id, find(parent.get(id)));
            return parent.get(id);
          };
          const union = (id1, id2) => {
            const root1 = find(id1);
            const root2 = find(id2);
            if (root1 !== root2) {
              parent.set(root1, root2);
              return true;
            }
            return false;
          };

          const activeEdges = new Set();
          const rejectedEdges = [];

          for (const edge of allEdges) {
            if (union(edge.u.id, edge.v.id)) {
              activeEdges.add(edge);
            } else {
              rejectedEdges.push(edge);
            }
          }

          for (const edge of rejectedEdges) {
            if (Math.random() < 0.4) {
              activeEdges.add(edge);
            }
          }

          const degrees = new Map();
          const incDeg = (id) => degrees.set(id, (degrees.get(id) || 0) + 1);
          activeEdges.forEach((e) => {
            incDeg(e.u.id);
            incDeg(e.v.id);
          });

          for (const edge of rejectedEdges) {
            if (activeEdges.has(edge)) continue;
            if ((degrees.get(edge.u.id) || 0) < 2 || (degrees.get(edge.v.id) || 0) < 2) {
              activeEdges.add(edge);
              incDeg(edge.u.id);
              incDeg(edge.v.id);
            }
          }

          // 5. Sparse Map Generation
          const tileData = new Map(); // "x,z" -> { type, stationName? }
          const setTile = (x, z, type, props = {}) => {
            const key = `${x},${z}`;
            // Don't overwrite road/station with env
            if (!tileData.has(key) || (tileData.get(key).type === "env" && type !== "env")) {
              tileData.set(key, { x, z, type, ...props });
            }
          };

          // Place Stations
          let nameIndex = 0;
          nodes.forEach((row) =>
            row.forEach((node) => {
              let stationName = "";
              if (nameIndex < availableNames.length) {
                stationName = availableNames[nameIndex++];
              } else {
                stationName = `éƒŠåŒº ${nameIndex++ - availableNames.length + 1}`;
              }
              setTile(node.x, node.z, "green", { stationName });
            })
          );

          // Place Roads
          activeEdges.forEach((edge) => {
            const u = edge.u;
            const v = edge.v;
            if (edge.type === "h") {
              // Varying X
              const minX = Math.min(u.x, v.x);
              const maxX = Math.max(u.x, v.x);
              for (let x = minX + 1; x < maxX; x++) {
                const type = Math.random() < 0.3 ? this.getRandomColoredType() : "road";
                setTile(x, u.z, type);
              }
            } else {
              // Varying Z
              const minZ = Math.min(u.z, v.z);
              const maxZ = Math.max(u.z, v.z);
              for (let z = minZ + 1; z < maxZ; z++) {
                const type = Math.random() < 0.3 ? this.getRandomColoredType() : "road";
                setTile(u.x, z, type);
              }
            }
          });

          // Grow Environment around roads/stations
          const roadTiles = Array.from(tileData.values());
          roadTiles.forEach((t) => {
            // Random range 3-8
            const range = rand(3, 8);
            for (let dx = -range; dx <= range; dx++) {
              for (let dz = -range; dz <= range; dz++) {
                // Organic shape (Diamond/Circle hybrid)
                if (Math.abs(dx) + Math.abs(dz) <= range * 1.4) {
                  const nx = t.x + dx;
                  const nz = t.z + dz;
                  const key = `${nx},${nz}`;
                  if (!tileData.has(key)) {
                    const envType = Math.random() > 0.7 ? "env_culture" : "env_nature";
                    setTile(nx, nz, envType); // Default to env
                  }
                }
              }
            }
          });

          // 6. Instantiate Tiles
          const mapGroup = new THREE.Group();
          this.scene.add(mapGroup);
          this.tilesMap = new Map();

          let idCounter = 0;
          tileData.forEach((data) => {
            const tile = new Tile(idCounter++, data.x, data.z, data.type);
            if (data.stationName) tile.stationName = data.stationName;

            this.map.push(tile);
            this.tilesMap.set(`${data.x},${data.z}`, tile);
            this.createTileVisuals(tile, mapGroup);
          });

          // 7. Link Neighbors
          this.map.forEach((tile) => {
            if (!tile.isRoad) return;

            const dirs = [
              [0, 1],
              [0, -1],
              [1, 0],
              [-1, 0],
            ];
            dirs.forEach(([dx, dz]) => {
              const nx = tile.gridX + dx;
              const nz = tile.gridY + dz;
              const neighbor = this.tilesMap.get(`${nx},${nz}`);
              if (neighbor && neighbor.isRoad) {
                tile.neighbors.push(neighbor);
              }
            });
          });

          // Set Start Position
          const stations = this.map.filter((t) => t.type === "green");
          let startTile = stations.length > 0 ? stations[Math.floor(Math.random() * stations.length)] : this.map[0];

          if (!startTile) startTile = this.map[0];

          if (startTile) {
            startTile.type = "start";
            startTile.mesh.material = this.materials.start;
            startTile.mesh.position.y = 0.2;
            if (startTile.labelElement) {
              startTile.labelElement.remove();
              startTile.labelElement = null;
            }
          }

          return startTile;
        }

        createTileVisuals(tile, parentGroup) {
          const x = tile.gridX * TILE_SIZE;
          const z = tile.gridY * TILE_SIZE;

          // 1. Base Block
          let geometry = this.geometries.tile;
          let yPos = 0;

          // Environment blocks are taller to create "canyons" for the track
          if (!tile.isRoad) {
            geometry = new THREE.BoxGeometry(TILE_SIZE, rand(2, 6), TILE_SIZE);
            yPos = -1; // Sink them a bit
          }

          const material = this.materials[tile.type] || this.materials.road;
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, yPos, z);
          mesh.receiveShadow = true;

          // 2. Decorations
          if (tile.type === "env_nature") {
            if (Math.random() > 0.5) {
              const treeGeo = new THREE.ConeGeometry(1, 3, 8);
              const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
              const tree = new THREE.Mesh(treeGeo, treeMat);
              tree.position.set(0, 2.5, 0);
              tree.castShadow = true;
              mesh.add(tree); // Local coordinate
            }
          } else if (tile.type === "green") {
            // Station Marker
            const stationGeo = new THREE.BoxGeometry(2.5, 1, 2.5);
            const stationMesh = new THREE.Mesh(stationGeo, new THREE.MeshLambertMaterial({ color: 0xffffff }));
            stationMesh.position.y = 0.6;
            mesh.add(stationMesh);

            // Add HTML Label
            this.createStationLabel(tile);
          }

          tile.mesh = mesh;
          parentGroup.add(mesh);
        }

        createStationLabel(tile) {
          const div = document.createElement("div");
          div.className = "station-label";
          div.innerText = tile.stationName;
          document.getElementById("labels-layer").appendChild(div);
          tile.labelElement = div;

          // Determine best label position: prefer non-road adjacent tiles
          // Check left (-x), right (+x), and top (-z) directions
          const leftKey = `${tile.gridX - 1},${tile.gridY}`;
          const rightKey = `${tile.gridX + 1},${tile.gridY}`;
          const topKey = `${tile.gridX},${tile.gridY - 1}`;

          const leftTile = this.tilesMap.get(leftKey);
          const rightTile = this.tilesMap.get(rightKey);
          const topTile = this.tilesMap.get(topKey);

          // Check if tile is a road/walkable tile (not environment)
          const isRoadTile = (t) => t && t.isRoad;

          // Priority: place label toward non-road areas (top > left > right)
          if (!isRoadTile(topTile)) {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // top (default)
          } else if (!isRoadTile(leftTile)) {
            tile.labelOffset = { x: -50, y: 0, align: "right" }; // left side
          } else if (!isRoadTile(rightTile)) {
            tile.labelOffset = { x: 50, y: 0, align: "left" }; // right side
          } else {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // fallback to top
          }
        }

        getRandomColoredType() {
          const r = Math.random();
          if (r < 0.25) return "green";
          if (r < 0.5) return "red";
          if (r < 0.75) return "yellow";
          return "blue";
        }

        // --- ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ ---

        async setNewDestination() {
          // è·å–æ‰€æœ‰è½¦ç«™ï¼ˆç»¿è‰²æ ¼å­ï¼‰ï¼Œæ’é™¤å½“å‰èµ·å§‹ç‚¹å’Œç©å®¶æ‰€åœ¨ä½ç½®
          const stations = this.map.filter((t) => t.type === "green" && t !== this.destinationTile && !this.players.some((p) => p.currentTile === t));

          if (stations.length === 0) return;

          // ç§»é™¤æ—§ç›®çš„åœ°çš„é«˜äº®æ ·å¼
          if (this.destinationTile && this.destinationTile.labelElement) {
            this.destinationTile.labelElement.classList.remove("destination");
          }

          // éšæœºé€‰æ‹©ä¸€ä¸ªè½¦ç«™ä½œä¸ºç›®çš„åœ°
          const newDest = stations[Math.floor(Math.random() * stations.length)];

          // æ˜¾ç¤ºæŠ½å¥–åŠ¨ç”»
          await this.showDestinationLottery(stations, newDest);

          this.destinationTile = newDest;

          // æ›´æ–°UIæ˜¾ç¤º
          document.getElementById("destination-name").innerText = newDest.stationName;

          // æ·»åŠ ç›®çš„åœ°æ ‡ç­¾é«˜äº®æ ·å¼
          if (newDest.labelElement) {
            newDest.labelElement.classList.add("destination");
          }

          // ç§»é™¤æ—§çš„ç›®çš„åœ°æ ‡è®°
          if (this.destinationMarker) {
            this.scene.remove(this.destinationMarker);
          }

          // åˆ›å»ºæ–°çš„ç›®çš„åœ°æ ‡è®°ï¼ˆå‘å…‰çš„åœ†æŸ±+æ——å¸œï¼‰
          this.createDestinationMarker(newDest);

          this.log(`ğŸ¯ æ–°ç›®çš„åœ°: ${newDest.stationName}`, "#fbbf24");
          showToast(`ğŸ¯ ç›®çš„åœ°å·²æ›´æ–°: ${newDest.stationName}`, "#fbbf24");

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // ä½¿ç”¨BFSè®¡ç®—ä»ä¸€ä¸ªæ ¼å­åˆ°ç›®çš„åœ°çš„æœ€çŸ­è·ç¦»ï¼ˆç«™æ•°ï¼‰
        calculateDistanceToDestination(fromTile) {
          if (!this.destinationTile || !fromTile) return -1;
          if (fromTile === this.destinationTile) return 0;

          // BFSæœç´¢æœ€çŸ­è·¯å¾„
          const visited = new Set();
          const queue = [{ tile: fromTile, distance: 0 }];
          visited.add(fromTile);

          while (queue.length > 0) {
            const { tile, distance } = queue.shift();

            for (const neighbor of tile.neighbors) {
              if (neighbor === this.destinationTile) {
                // åªè®¡ç®—å½©è‰²æ ¼å­ï¼ˆæœ‰æ•ˆæ­¥æ•°ï¼‰
                return distance + (neighbor.isColored ? 1 : 0);
              }

              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                // åªæœ‰å½©è‰²æ ¼å­æ‰ç®—ä¸€æ­¥
                const newDist = distance + (neighbor.isColored ? 1 : 0);
                queue.push({ tile: neighbor, distance: newDist });
              }
            }
          }

          return -1; // æ— æ³•åˆ°è¾¾
        }

        // AIé€‰æ‹©æœ€ä¼˜æ–¹å‘ï¼šé€‰æ‹©è·ç¦»ç›®çš„åœ°æœ€è¿‘çš„è·¯å¾„
        chooseBestDirection(options) {
          if (!this.destinationTile || options.length === 0) {
            return options[Math.floor(Math.random() * options.length)];
          }

          let bestTile = options[0];
          let bestDistance = this.calculateDistanceToDestination(options[0]);

          for (let i = 1; i < options.length; i++) {
            const dist = this.calculateDistanceToDestination(options[i]);
            // é€‰æ‹©è·ç¦»æ›´çŸ­çš„ï¼ˆå¦‚æœè·ç¦»ä¸º-1è¡¨ç¤ºæ— æ³•åˆ°è¾¾ï¼Œè·³è¿‡ï¼‰
            if (dist >= 0 && (bestDistance < 0 || dist < bestDistance)) {
              bestDistance = dist;
              bestTile = options[i];
            }
          }

          return bestTile;
        }

        // æ›´æ–°æ‰€æœ‰ç©å®¶çš„è·ç¦»æ˜¾ç¤º
        updateDistanceDisplay() {
          if (!this.destinationTile || this.players.length === 0) return;

          // ç©å®¶1è·ç¦»
          const p1Dist = this.calculateDistanceToDestination(this.players[0].currentTile);
          document.getElementById("p1-distance").innerText = p1Dist >= 0 ? p1Dist : "--";

          // ç”µè„‘è·ç¦»
          if (this.players.length > 1) {
            const comDist = this.calculateDistanceToDestination(this.players[1].currentTile);
            document.getElementById("com-distance").innerText = comDist >= 0 ? comDist : "--";
          }
        }

        // æ›´æ–°å±å¹•å¤–ç›®çš„åœ°æŒ‡ç¤ºå™¨
        updateDestinationIndicator() {
          const indicator = document.getElementById("destination-indicator");
          if (!indicator) return;

          // å¦‚æœæ²¡æœ‰ç›®çš„åœ°ï¼Œéšè—æŒ‡ç¤ºå™¨
          if (!this.destinationTile) {
            indicator.classList.add("hidden");
            return;
          }

          // è·å–ç›®çš„åœ°åœ¨å±å¹•ä¸Šçš„ä½ç½®
          const destPos = this.getScreenPosition(this.destinationTile.mesh.position);
          const margin = 80; // è¾¹ç¼˜margin

          // æ£€æŸ¥ç›®çš„åœ°æ˜¯å¦åœ¨å±å¹•å¯è§èŒƒå›´å†…
          const isOnScreen = destPos.x >= margin && destPos.x <= this.width - margin && destPos.y >= margin && destPos.y <= this.height - margin;

          if (isOnScreen) {
            // ç›®çš„åœ°åœ¨å±å¹•å†…ï¼Œéšè—æŒ‡ç¤ºå™¨
            indicator.classList.add("hidden");
            return;
          }

          // ç›®çš„åœ°åœ¨å±å¹•å¤–ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨
          indicator.classList.remove("hidden");

          // æ›´æ–°ç›®çš„åœ°åç§°
          document.getElementById("indicator-name").innerText = this.destinationTile.stationName;

          // è®¡ç®—å±å¹•ä¸­å¿ƒåˆ°ç›®çš„åœ°ä½ç½®çš„æ–¹å‘
          const centerX = this.width / 2;
          const centerY = this.height / 2;
          const dx = destPos.x - centerX;
          const dy = destPos.y - centerY;
          const angle = Math.atan2(dy, dx);

          // è®¡ç®—æŒ‡ç¤ºå™¨åœ¨å±å¹•è¾¹ç¼˜çš„ä½ç½®
          const edgeMargin = 60;
          let indicatorX, indicatorY;

          // æ ¹æ®è§’åº¦ç¡®å®šæŒ‡ç¤ºå™¨ä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
          const maxX = this.width - edgeMargin;
          const maxY = this.height - edgeMargin;
          const minX = edgeMargin;
          const minY = edgeMargin;

          // è®¡ç®—ä¸å±å¹•è¾¹ç¼˜çš„äº¤ç‚¹
          const tanAngle = Math.tan(angle);

          // æ£€æŸ¥å³è¾¹ç¼˜
          if (dx > 0) {
            const y = centerY + (maxX - centerX) * tanAngle;
            if (y >= minY && y <= maxY) {
              indicatorX = maxX;
              indicatorY = y;
            }
          }
          // æ£€æŸ¥å·¦è¾¹ç¼˜
          if (dx < 0) {
            const y = centerY + (minX - centerX) * tanAngle;
            if (y >= minY && y <= maxY) {
              indicatorX = minX;
              indicatorY = y;
            }
          }
          // æ£€æŸ¥ä¸‹è¾¹ç¼˜
          if (dy > 0 && indicatorX === undefined) {
            const x = centerX + (maxY - centerY) / tanAngle;
            if (x >= minX && x <= maxX) {
              indicatorX = x;
              indicatorY = maxY;
            }
          }
          // æ£€æŸ¥ä¸Šè¾¹ç¼˜
          if (dy < 0 && indicatorX === undefined) {
            const x = centerX + (minY - centerY) / tanAngle;
            if (x >= minX && x <= maxX) {
              indicatorX = x;
              indicatorY = minY;
            }
          }

          // å¦‚æœè¿˜æ²¡æœ‰ç¡®å®šä½ç½®ï¼Œä½¿ç”¨ç®€å•çš„clamping
          if (indicatorX === undefined) {
            indicatorX = Math.max(minX, Math.min(maxX, destPos.x));
            indicatorY = Math.max(minY, Math.min(maxY, destPos.y));
          }

          // è®¾ç½®æŒ‡ç¤ºå™¨ä½ç½®ï¼Œæ ¹æ®è¾¹ç¼˜ä½ç½®è°ƒæ•´transformé¿å…è¶…å‡ºå±å¹•
          let finalX = indicatorX;
          let finalY = indicatorY;

          // æ ¹æ®æŒ‡ç¤ºå™¨åœ¨å±å¹•çš„ä½ç½®è°ƒæ•´å¯¹é½æ–¹å¼
          let transformX = "-50%";
          let transformY = "-50%";

          const padding = 10; // è·ç¦»å±å¹•è¾¹ç¼˜çš„padding

          // é è¿‘å³è¾¹ç¼˜æ—¶ï¼Œå‘å·¦å¯¹é½ï¼ˆå…ƒç´ å³è¾¹è´´ç€å±å¹•å³è¾¹ï¼‰
          if (indicatorX >= this.width - edgeMargin) {
            transformX = "-100%";
            finalX = this.width - padding;
          }
          // é è¿‘å·¦è¾¹ç¼˜æ—¶ï¼Œå‘å³å¯¹é½ï¼ˆå…ƒç´ å·¦è¾¹è´´ç€å±å¹•å·¦è¾¹ï¼‰
          else if (indicatorX <= edgeMargin) {
            transformX = "0%";
            finalX = padding;
          }

          // é è¿‘ä¸‹è¾¹ç¼˜æ—¶ï¼Œå‘ä¸Šå¯¹é½ï¼ˆå…ƒç´ ä¸‹è¾¹è´´ç€å±å¹•ä¸‹è¾¹ï¼‰
          if (indicatorY >= this.height - edgeMargin) {
            transformY = "-100%";
            finalY = this.height - padding;
          }
          // é è¿‘ä¸Šè¾¹ç¼˜æ—¶ï¼Œå‘ä¸‹å¯¹é½ï¼ˆå…ƒç´ ä¸Šè¾¹è´´ç€å±å¹•ä¸Šè¾¹ï¼‰
          else if (indicatorY <= edgeMargin) {
            transformY = "0%";
            finalY = padding;
          }

          indicator.style.left = `${finalX}px`;
          indicator.style.top = `${finalY}px`;
          indicator.style.transform = `translate(${transformX}, ${transformY})`;

          // æ›´æ–°ç®­å¤´æ–¹å‘
          const arrowEl = document.getElementById("indicator-arrow");
          if (arrowEl) {
            // æ ¹æ®æ–¹å‘é€‰æ‹©ç®­å¤´
            const degAngle = (angle * 180) / Math.PI;
            let arrow = "â†’";
            if (degAngle > -22.5 && degAngle <= 22.5) arrow = "â†’";
            else if (degAngle > 22.5 && degAngle <= 67.5) arrow = "â†˜";
            else if (degAngle > 67.5 && degAngle <= 112.5) arrow = "â†“";
            else if (degAngle > 112.5 && degAngle <= 157.5) arrow = "â†™";
            else if (degAngle > 157.5 || degAngle <= -157.5) arrow = "â†";
            else if (degAngle > -157.5 && degAngle <= -112.5) arrow = "â†–";
            else if (degAngle > -112.5 && degAngle <= -67.5) arrow = "â†‘";
            else if (degAngle > -67.5 && degAngle <= -22.5) arrow = "â†—";

            arrowEl.innerText = arrow;
          }
        }

        // æ˜¾ç¤ºç›®çš„åœ°æŠ½å¥–åŠ¨ç”»
        async showDestinationLottery(stations, finalDest) {
          // åˆ›å»ºå…¨å±å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "lottery-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.9)";
          overlay.style.backdropFilter = "blur(8px)";

          overlay.innerHTML = `
            <div class="text-center">
                <div class="text-2xl text-gray-400 mb-4">ğŸ² æ­£åœ¨é€‰æ‹©ç›®çš„åœ°...</div>
                <div class="relative overflow-hidden h-32 w-80 mx-auto mb-6 rounded-xl" style="background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(30,30,50,0.9) 50%, rgba(0,0,0,0.8) 100%);">
                    <div class="absolute inset-x-0 top-0 h-8 bg-gradient-to-b from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 bottom-0 h-8 bg-gradient-to-t from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 top-1/2 -translate-y-1/2 h-12 border-y-2 border-yellow-400 bg-yellow-400/10 z-10"></div>
                    <div id="lottery-scroll" class="absolute inset-x-0 transition-transform" style="top: 50%; transform: translateY(-50%);">
                        <!-- åœ°åä¼šåœ¨è¿™é‡Œæ»šåŠ¨ -->
                    </div>
                </div>
                <div id="lottery-result" class="text-5xl font-black text-yellow-400 mb-4 opacity-0 transition-opacity duration-500"></div>
                <div id="lottery-subtitle" class="text-xl text-gray-300 opacity-0 transition-opacity duration-500">å‡ºå‘å§!</div>
            </div>
        `;

          document.body.appendChild(overlay);

          const scrollContainer = document.getElementById("lottery-scroll");

          // åˆ›å»ºæ»šåŠ¨å†…å®¹ï¼ˆæ‰€æœ‰è½¦ç«™åéšæœºæ’åˆ—ï¼Œé‡å¤å¤šæ¬¡ï¼‰
          const allNames = stations.map((s) => s.stationName);
          // æ‰“ä¹±é¡ºåº
          for (let i = allNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allNames[i], allNames[j]] = [allNames[j], allNames[i]];
          }

          // ç¡®ä¿æœ€ç»ˆç›®çš„åœ°åœ¨æœ€å
          const finalIndex = allNames.indexOf(finalDest.stationName);
          if (finalIndex > -1) {
            allNames.splice(finalIndex, 1);
          }

          // åˆ›å»ºæ»šåŠ¨åˆ—è¡¨ï¼ˆé‡å¤å¤šæ¬¡ + æœ€ç»ˆç›®çš„åœ°ï¼‰
          const repeatCount = 4;
          let scrollItems = [];
          for (let i = 0; i < repeatCount; i++) {
            scrollItems = scrollItems.concat([...allNames].sort(() => Math.random() - 0.5));
          }
          scrollItems.push(finalDest.stationName); // æœ€ç»ˆåœåœ¨è¿™é‡Œ

          // æ¸²æŸ“æ»šåŠ¨é¡¹
          const itemHeight = 48;
          scrollContainer.innerHTML = scrollItems
            .map(
              (name, idx) => `
            <div class="h-12 flex items-center justify-center text-2xl font-bold ${name === finalDest.stationName && idx === scrollItems.length - 1 ? "text-yellow-400" : "text-white"}" 
                 style="height: ${itemHeight}px;">${name}</div>
        `
            )
            .join("");

          // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆä»ç¬¬ä¸€ä¸ªå¼€å§‹ï¼‰
          scrollContainer.style.transform = `translateY(-${itemHeight / 2}px)`;
          scrollContainer.style.transition = "none";

          await wait(100);

          // å¼€å§‹æ»šåŠ¨åŠ¨ç”»
          const totalItems = scrollItems.length;
          const finalOffset = (totalItems - 1) * itemHeight + itemHeight / 2;

          // å…ˆå¿«åæ…¢çš„æ»šåŠ¨æ•ˆæœ
          scrollContainer.style.transition = "transform 3s cubic-bezier(0.15, 0.85, 0.35, 1)";
          scrollContainer.style.transform = `translateY(-${finalOffset}px)`;

          // ç­‰å¾…æ»šåŠ¨å®Œæˆ
          await wait(3200);

          // æ˜¾ç¤ºç»“æœ
          document.getElementById("lottery-result").innerText = `ğŸ¯ ${finalDest.stationName}`;
          document.getElementById("lottery-result").style.opacity = "1";
          document.getElementById("lottery-subtitle").style.opacity = "1";

          // ç­‰å¾…å±•ç¤º
          await wait(1500);

          // æ·¡å‡º
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();
        }

        createDestinationMarker(tile) {
          const group = new THREE.Group();

          // å‘å…‰åœ†ç¯
          const ringGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 32);
          const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.y = 0.3;
          group.add(ring);

          // æ——æ†
          const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
          const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
          const pole = new THREE.Mesh(poleGeo, poleMat);
          pole.position.set(1.5, 3, 1.5);
          group.add(pole);

          // æ——å¸œ
          const flagGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
          const flagMat = new THREE.MeshLambertMaterial({ color: 0xff4444, side: THREE.DoubleSide });
          const flag = new THREE.Mesh(flagGeo, flagMat);
          flag.position.set(2.5, 5, 1.5);
          group.add(flag);

          // ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»çš„æ˜Ÿæ˜Ÿ
          const starGeo = new THREE.OctahedronGeometry(0.5, 0);
          const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const star = new THREE.Mesh(starGeo, starMat);
          star.position.y = 3;
          star.userData.baseY = 3;
          star.userData.animate = true;
          group.add(star);

          // å®šä½åˆ°ç›®çš„åœ°æ ¼å­
          group.position.copy(tile.worldPos);
          group.position.y = 1;

          this.scene.add(group);
          this.destinationMarker = group;

          // æ˜Ÿæ˜ŸåŠ¨ç”»
          const animateStar = () => {
            if (!this.destinationMarker) return;
            const star = this.destinationMarker.children.find((c) => c.userData.animate);
            if (star) {
              star.position.y = star.userData.baseY + Math.sin(Date.now() * 0.003) * 0.5;
              star.rotation.y += 0.02;
            }
            requestAnimationFrame(animateStar);
          };
          animateStar();
        }

        // æ˜¾ç¤ºåˆ°è¾¾ç›®çš„åœ°çš„ç»“ç®—åŠ¨ç”»
        async showDestinationArrival(player) {
          if (!this.destinationTile) return;

          const destName = this.destinationTile.stationName;

          // åˆ›å»ºç»“ç®—åŠ¨ç”»å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "arrival-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.backdropFilter = "blur(4px)";

          overlay.innerHTML = `
            <div class="text-center transform scale-0 transition-transform duration-500" id="arrival-content">
                <div class="text-8xl mb-6 animate-bounce">ğŸ†</div>
                <div class="text-4xl font-black text-white mb-4">åˆ°è¾¾ç›®çš„åœ°!</div>
                <div class="text-3xl font-bold text-yellow-400 mb-6">${destName}</div>
                <div class="text-6xl font-mono font-black text-green-400 mb-4">+Â¥${DESTINATION_REWARD}</div>
                <div class="text-xl text-gray-300">${player.name} è·å¾—æ´åŠ©é‡‘!</div>
                <div class="mt-6 flex justify-center gap-2">
                    <span class="text-4xl">ğŸ‰</span>
                    <span class="text-4xl">ğŸŠ</span>
                    <span class="text-4xl">âœ¨</span>
                </div>
            </div>
        `;

          document.body.appendChild(overlay);

          // å¼¹å‡ºåŠ¨ç”»
          await wait(100);
          document.getElementById("arrival-content").style.transform = "scale(1)";

          // æ’­æ”¾é‡‘å¸éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
          this.log(`ğŸ† ${player.name} åˆ°è¾¾ç›®çš„åœ° ${destName}!`, "#22c55e");
          showToast(`ğŸ† ${player.name} è·å¾—æ´åŠ©é‡‘ Â¥${DESTINATION_REWARD}!`, "#22c55e");

          player.money += DESTINATION_REWARD;

          // --- ç©·ç¥é™„èº«é€»è¾‘ ---
          // å¯»æ‰¾è·ç¦»ç›®çš„åœ°æœ€è¿œçš„ç©å®¶ï¼ˆé™¤äº†åˆ°è¾¾è€…ï¼‰
          let maxDist = -1;
          let victim = null;

          // è®¡ç®—æ‰€æœ‰å…¶ä»–ç©å®¶åˆ°å½“å‰ç›®çš„åœ°çš„è·ç¦»
          for (const p of this.players) {
            if (p === player) continue;

            const dist = this.calculateDistanceToDestination(p.currentTile);
            // å¦‚æœæ— æ³•åˆ°è¾¾(-1)ï¼Œè§†ä¸ºæ— ç©·è¿œ
            const effectiveDist = dist === -1 ? 9999 : dist;

            if (effectiveDist > maxDist) {
              maxDist = effectiveDist;
              victim = p;
            } else if (effectiveDist === maxDist) {
              // è·ç¦»ç›¸åŒæ—¶ï¼Œéšæœºé€‰æ‹©
              if (Math.random() > 0.5) victim = p;
            }
          }

          if (victim) {
            // å¦‚æœç©·ç¥å·²ç»åœ¨æŸäººèº«ä¸Šï¼Œä¸”é‚£ä¸ªäººä¸æ˜¯victimï¼Œåˆ™è½¬ç§»
            // å¦‚æœç©·ç¥è¿˜æ²¡å‡ºç°ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰ï¼Œåˆ™é™„èº«victim
            const currentOwner = this.players.find((p) => p.hasBinbougami);
            if (currentOwner !== victim) {
              await wait(500);
              await this.attachBinbougami(victim);
            }
          }

          this.updateUI();

          // ç­‰å¾…åŠ¨ç”»å±•ç¤º
          await wait(2500);

          // æ·¡å‡ºåŠ¨ç”»
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();

          // è®¾ç½®æ–°çš„ç›®çš„åœ°
          await this.setNewDestination();
        }

        // --- å¹´åº¦å†³ç®—ç³»ç»Ÿ ---

        advanceTime() {
          this.totalTurns++;
          this.gameMonth++;

          if (this.gameMonth > 12) {
            this.gameMonth = 1;
            this.gameYear++;
          }

          // æ›´æ–°æ—¶é—´æ˜¾ç¤º
          document.getElementById("game-year").innerText = this.gameYear;
          document.getElementById("game-month").innerText = this.gameMonth;

          // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å†³ç®—æœˆï¼ˆ3æœˆï¼‰
          if (this.gameMonth === SETTLEMENT_MONTH) {
            return true; // éœ€è¦å†³ç®—
          }
          return false;
        }

        async performSettlement() {
          this.log(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—å¼€å§‹ï¼`, "#fbbf24");
          showToast(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—ï¼`, "#fbbf24");

          await wait(500);

          for (const player of this.players) {
            let totalIncome = 0;
            const ownedStations = new Map(); // stationName -> buildingCount

            // ç»Ÿè®¡æ¯ä¸ªè½¦ç«™çš„ç‰©ä»¶
            this.map.forEach((tile) => {
              if (tile.type === "green" && tile.owner === player.id) {
                const stationBuildings = tile.buildings.length;
                if (stationBuildings > 0) {
                  ownedStations.set(tile.stationName, stationBuildings);

                  // è®¡ç®—è¯¥è½¦ç«™çš„æ”¶ç›Š
                  let stationIncome = 0;
                  tile.buildings.forEach((tierIndex) => {
                    stationIncome += BUILDING_INCOME[tierIndex];
                  });

                  // ç‹¬å å¥–åŠ±ï¼šå¦‚æœæ‹¥æœ‰å…¨éƒ¨3ç§ç‰©ä»¶ï¼Œæ”¶ç›Šç¿»å€
                  const isMonopoly = tile.buildings.length === 3;
                  if (isMonopoly) {
                    stationIncome *= 2;
                    this.log(`ğŸ† ${tile.stationName} ç‹¬å åŠ æˆï¼`, "#a855f7");
                  }

                  totalIncome += stationIncome;
                }
              }
            });

            if (totalIncome > 0) {
              player.money += totalIncome;
              this.log(`ğŸ’° ${player.name} æ”¶åˆ°çº¢åˆ© Â¥${totalIncome}`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
              await this.showMoneyChangeDialog(player, totalIncome);
            } else {
              this.log(`${player.name} æ²¡æœ‰ç‰©ä»¶æ”¶ç›Š`, "#9ca3af");
            }
          }

          this.updateUI();
          await wait(500);
        }

        // --- UI & Interaction ---

        log(msg, color = "white") {
          const logEl = document.getElementById("game-log");
          const entry = document.createElement("div");
          entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
          logEl.appendChild(entry);
          if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
          setTimeout(() => {
            entry.style.opacity = "0";
            setTimeout(() => entry.remove(), 500);
          }, 4000);
        }

        startTurn() {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          const p = this.players[this.turn];
          document.getElementById("turn-indicator").innerText = `${p.name} çš„å›åˆ`;

          // Center camera on the current player
          this.centerCameraOnPlayer(p);

          const p1Panel = document.getElementById("p1-panel");
          const comPanel = document.getElementById("com-panel");

          p1Panel.style.opacity = this.turn === 0 ? "1" : "0.6";
          p1Panel.style.transform = this.turn === 0 ? "scale(1.05)" : "scale(1)";
          p1Panel.classList.toggle("border-yellow-400", this.turn === 0);

          comPanel.style.opacity = this.turn === 1 ? "1" : "0.6";
          comPanel.style.transform = this.turn === 1 ? "scale(1.05)" : "scale(1)";
          comPanel.classList.toggle("border-yellow-400", this.turn === 1);

          this.state = "IDLE";

          // Check for skip turn (Hibernate)
          if (p.skipNextTurn) {
            p.skipNextTurn = false;
            this.log(`ğŸ’¤ ${p.name} æ­£åœ¨å†¬çœ ï¼Œè·³è¿‡å›åˆ`, "#9ca3af");
            setTimeout(() => this.nextTurn(), 1500);
            return;
          }

          if (p.isAI) {
            document.getElementById("roll-btn").classList.add("hidden");
            document.getElementById("use-card-btn").classList.add("hidden");
            setTimeout(() => this.aiAction(), 1000);
          } else {
            document.getElementById("roll-btn").classList.remove("hidden");
            const useCardBtn = document.getElementById("use-card-btn");
            if (p.cards.length > 0) {
              useCardBtn.classList.remove("hidden");
              useCardBtn.onclick = () => this.openUseCardModal();
            } else {
              useCardBtn.classList.add("hidden");
            }
          }
        }

        async playerRoll() {
          if (this.state !== "IDLE") return;
          document.getElementById("roll-btn").classList.add("hidden");
          await this.processMove();
        }

        async aiAction() {
          this.log("ç”µè„‘æ­£åœ¨æ€è€ƒ...", "#fca5a5");
          await wait(1000);
          await this.processMove();
        }

        async processMove(diceCount = 1) {
          this.state = "MOVING";
          // Calculate steps based on dice count
          let steps = 0;
          const rolls = [];
          for (let i = 0; i < diceCount; i++) {
            const r = rand(1, 6);
            rolls.push(r);
            steps += r;
          }

          const player = this.players[this.turn];
          this.log(`${player.name} æ·å‡ºäº† ${rolls.join("+")} = ${steps} ç‚¹!`, "#fbbf24");

          let remainingSteps = steps;
          let reachedDestination = false;

          while (remainingSteps > 0) {
            const current = player.currentTile;
            const neighbors = current.neighbors;

            let validNext = neighbors.filter((n) => n !== player.previousTile);
            if (validNext.length === 0 && neighbors.length > 0) {
              validNext = neighbors; // Dead end fallback
            }

            let nextTile = null;

            if (validNext.length === 1) {
              nextTile = validNext[0];
            } else if (validNext.length > 1) {
              if (player.isAI) {
                nextTile = this.chooseBestDirection(validNext);
              } else {
                nextTile = await this.askDirection(player, validNext);
              }
            } else {
              break;
            }

            // Physics Move
            player.previousTile = player.currentTile;
            player.currentTile = nextTile;

            await this.animateMove(player, nextTile.worldPos);

            // --- Binbougami Transfer Check ---
            // Check if we passed another player
            for (const other of this.players) {
              if (other !== player && other.currentTile === player.currentTile) {
                // Collision!
                if (player.hasBinbougami) {
                  // Transfer FROM player TO other
                  this.log(`ğŸ‘» ç©·ç¥ä» ${player.name} è½¬ç§»åˆ°äº† ${other.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(other);
                } else if (other.hasBinbougami) {
                  // Transfer FROM other TO player
                  this.log(`ğŸ‘» ç©·ç¥ä» ${other.name} è½¬ç§»åˆ°äº† ${player.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(player);
                }
              }
            }

            // æ›´æ–°è·ç¦»æ˜¾ç¤º
            this.updateDistanceDisplay();

            // æ£€æŸ¥æ˜¯å¦è·¯è¿‡ç›®çš„åœ°ï¼ˆå³ä½¿è¿˜æœ‰æ­¥æ•°ä¹Ÿç®—åˆ°è¾¾ï¼‰
            if (!reachedDestination && this.destinationTile && nextTile === this.destinationTile) {
              reachedDestination = true;
              await this.showDestinationArrival(player);
            }

            if (nextTile.isColored) {
              remainingSteps--;
            }
          }

          await wait(300);
          await this.triggerTileEvent(player, reachedDestination);
        }

        animateMove(player, targetVec3) {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          return new Promise((resolve) => {
            const startPos = player.mesh.position.clone();
            const startTime = Date.now();
            const duration = 300; // ms

            // Simple Hop Animation
            const animateStep = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Linear Interpolation for X/Z
              player.mesh.position.lerpVectors(startPos, targetVec3, progress);

              // Parabolic Arc for Y (Jump)
              // y = 4 * height * x * (1-x) + baseline
              const jumpHeight = 2;
              const baseHeight = 1.5;
              player.mesh.position.y = baseHeight + 4 * jumpHeight * progress * (1 - progress);

              if (progress < 1) {
                requestAnimationFrame(animateStep);
              } else {
                player.mesh.position.copy(targetVec3);
                player.mesh.position.y = baseHeight;
                resolve();
              }
            };
            animateStep();
          });
        }

        async askDirection(player, options) {
          // Center camera on the player before showing direction options
          await this.centerCameraOnPlayer(player, 300);

          return new Promise((resolve) => {
            const overlay = document.createElement("div");
            overlay.className = "absolute inset-0 pointer-events-auto z-50";
            overlay.id = "direction-overlay";
            document.getElementById("ui-layer").appendChild(overlay);

            options.forEach((tile) => {
              // Lift the icon slightly so it appears on top of the tile
              const targetPos = tile.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
              const screenPos = this.getScreenPosition(targetPos);

              let label = "ğŸ“";
              const dx = tile.gridX - player.currentTile.gridX;
              const dy = tile.gridY - player.currentTile.gridY; // using gridY as Z

              if (dx > 0) label = "â¡ï¸";
              else if (dx < 0) label = "â¬…ï¸";
              else if (dy > 0) label = "â¬‡ï¸"; // Z+ is down on screen roughly
              else if (dy < 0) label = "â¬†ï¸";

              // Container for positioning (handles centering)
              const container = document.createElement("div");
              container.className = "absolute";
              container.style.left = `${screenPos.x}px`;
              container.style.top = `${screenPos.y}px`;
              container.style.transform = "translate(-50%, -50%)";

              // Button for appearance and interaction (handles animation)
              const btn = document.createElement("button");
              btn.innerText = label;
              btn.className = "w-12 h-12 bg-yellow-400 hover:bg-white rounded-full text-2xl shadow-xl border-4 border-yellow-600 animate-bounce-custom cursor-pointer";

              btn.onclick = () => {
                document.getElementById("direction-overlay").remove();
                resolve(tile);
              };

              container.appendChild(btn);

              // Store 3D position on container for frame updates
              container.target3D = targetPos;

              overlay.appendChild(container);
            });
          });
        }

        async showMoneyChangeDialog(player, changeAmount) {
          return new Promise((resolve) => {
            const modal = document.getElementById("money-modal");
            const title = document.getElementById("money-modal-title");
            const amountEl = document.getElementById("money-modal-amount");
            const deltaEl = document.getElementById("money-modal-delta");
            const icon = document.getElementById("money-modal-icon");
            const container = modal.firstElementChild;

            modal.classList.remove("hidden");

            const endMoney = player.money;
            const startMoneyVal = endMoney - changeAmount;

            const isGain = changeAmount > 0;
            const colorClass = isGain ? "text-blue-600" : "text-red-600";
            const borderClass = isGain ? "border-blue-500" : "border-red-500";

            container.className = `bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100 ${borderClass}`;

            title.innerText = player.name;
            icon.innerText = isGain ? "ğŸ¤‘" : "ğŸ’¸";

            deltaEl.className = `text-3xl font-black mb-2 ${colorClass}`;
            deltaEl.innerText = (isGain ? "+" : "") + "Â¥" + changeAmount;

            // Animation
            const duration = 1500;
            const startTime = Date.now();

            const animate = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);
              const ease = 1 - Math.pow(1 - progress, 4); // Ease out

              const currentVal = Math.floor(startMoneyVal + changeAmount * ease);
              amountEl.innerText = "Â¥" + currentVal;

              if (progress < 1) {
                requestAnimationFrame(animate);
              } else {
                amountEl.innerText = "Â¥" + endMoney;
                setTimeout(() => {
                  modal.classList.add("hidden");
                  resolve();
                }, 800);
              }
            };

            animate();
          });
        }

        // --- ç©·ç¥ç³»ç»Ÿæ–¹æ³• ---

        async attachBinbougami(player) {
          // Remove from current owner
          const currentOwner = this.players.find((p) => p.hasBinbougami);
          if (currentOwner) {
            currentOwner.hasBinbougami = false;
            // Remove visual from current owner
            if (currentOwner.binbougamiMesh) {
              // Remove from whichever parent it was attached to
              try {
                if (typeof currentOwner.binbougamiMesh.removeFromParent === "function") currentOwner.binbougamiMesh.removeFromParent();
                else if (currentOwner.binbougamiMesh.parent) currentOwner.binbougamiMesh.parent.remove(currentOwner.binbougamiMesh);
              } catch (e) {
                // swallow
              }
              currentOwner.binbougamiMesh = null;
            }
          }

          // Attach to new player
          player.hasBinbougami = true;
          player.binbougamiTurns = 0;
          player.binbougamiLevel = 0; // Reset to normal

          this.log(`ğŸ‘» ç©·ç¥é™„èº«åœ¨äº† ${player.name} èº«ä¸Šï¼`, "#a855f7");

          // Play possession sequence
          await this.showBinbougamiPossessionSequence(player);

          this.updateUI();
        }

        async showBinbougamiPossessionSequence(player) {
          // 1. Show Fullscreen UI
          const modal = document.getElementById("possession-modal");
          const content = document.getElementById("possession-content");
          const text = document.getElementById("possession-text");

          if (modal && content && text) {
            text.innerText = `${player.name} è¢«ç©·ç¥é™„èº«äº†ï¼`;
            modal.classList.remove("hidden");

            // Trigger animation
            // Force reflow
            void modal.offsetWidth;

            content.classList.remove("scale-0");
            content.classList.add("scale-100");

            // Wait for UI
            await new Promise((resolve) => setTimeout(resolve, 2500));

            // Hide UI
            content.classList.remove("scale-100");
            content.classList.add("scale-0");
            setTimeout(() => {
              modal.classList.add("hidden");
            }, 500);
          }

          // 2. Move Camera to Player
          this.cameraLocked = false;
          await this.centerCameraOnPlayer(player, 800);

          // 3. Create Falling Binbougami
          this.createBinbougamiMesh(player, true);

          // Wait for fall animation (approx 1s)
          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Shake effect (simple camera shake)
          const originalPos = this.camera.position.clone();
          for (let i = 0; i < 10; i++) {
            this.camera.position.x = originalPos.x + (Math.random() - 0.5) * 2;
            this.camera.position.y = originalPos.y + (Math.random() - 0.5) * 2;
            this.camera.position.z = originalPos.z + (Math.random() - 0.5) * 2;
            await new Promise((r) => setTimeout(r, 30));
          }
          this.camera.position.copy(originalPos);

          // Restore camera lock if in game mode
          if (this.mode === "GAME") {
            this.cameraLocked = true;
          }
        }

        createBinbougamiMesh(player, animateFalling = false) {
          if (player.binbougamiMesh) return;

          const group = new THREE.Group();
          // Use a modest world scale so the ghost matches character size
          const scale = 1.2; // slightly bigger than player head

          // Simple Ghost Shape
          const bodyGeo = new THREE.SphereGeometry(0.4, 16, 16);
          const bodyMat = new THREE.MeshLambertMaterial({ color: 0xa855f7 }); // Purple
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 0.5;
          group.add(body);

          // Tail
          const tailGeo = new THREE.ConeGeometry(0.2, 0.6, 16);
          const tail = new THREE.Mesh(tailGeo, bodyMat);
          tail.position.y = 0.1;
          tail.rotation.x = Math.PI;
          group.add(tail);

          // Eyes
          const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
          const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.position.set(-0.15, 0.55, 0.3);
          group.add(leftEye);

          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.position.set(0.15, 0.55, 0.3);
          group.add(rightEye);

          // Apply scale
          group.scale.set(scale, scale, scale);

          // ç®€åŒ–ä½ç½®ç®—æ³•ï¼šç›´æ¥æŒ‚åœ¨ player.mesh ä¸Šï¼Œä½¿ç”¨å›ºå®šé«˜åº¦
          // ç©å®¶æ¨¡å‹é«˜åº¦çº¦ä¸º 3 å•ä½ï¼ˆå¤´é¡¶ hat åœ¨ y=3ï¼‰ï¼Œç©·ç¥æ˜¾ç¤ºåœ¨ y=4.5 çš„ä½ç½®
          const fixedHeight = 4.5;

          // å…ˆé™„åŠ åˆ°ç©å®¶meshå¹¶è®¾ç½®å¼•ç”¨ï¼Œè¿™æ ·åŠ¨ç”»å›è°ƒå¯ä»¥æ­£å¸¸å·¥ä½œ
          player.mesh.add(group);
          player.binbougamiMesh = group;

          if (animateFalling) {
            const startHeight = fixedHeight + 10; // ä»ä¸Šæ–¹10å•ä½è½ä¸‹
            group.position.set(0, startHeight, 0);

            const startTime = Date.now();
            const duration = 600; // 0.6 second fall

            const animateFall = () => {
              if (!player.binbougamiMesh || !group.parent) return;

              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Quadratic ease in (accelerate)
              const currentY = startHeight - (startHeight - fixedHeight) * (progress * progress);
              group.position.y = currentY;

              if (progress < 1) {
                requestAnimationFrame(animateFall);
              } else {
                group.position.y = fixedHeight;
                this.animateBinbougamiHover(group, fixedHeight);
              }
            };
            animateFall();
          } else {
            group.position.set(0, fixedHeight, 0);
            this.animateBinbougamiHover(group, fixedHeight);
          }
        }

        animateBinbougamiHover(group, baseY) {
          const animate = () => {
            if (!group.parent) return; // Removed from scene

            const time = Date.now() * 0.002;
            group.position.y = baseY + Math.sin(time) * 0.5;
            group.rotation.y = Math.sin(time * 0.5) * 0.2; // Slight rotation

            requestAnimationFrame(animate);
          };
          animate();
        }

        async handleBinbougamiAction(player) {
          if (!player.hasBinbougami) return;

          player.binbougamiTurns++;

          // æ£€æŸ¥æ˜¯å¦å‡çº§ä¸ºå¤§é­”ç‹ (ä¾‹å¦‚8å›åˆå)
          if (player.binbougamiLevel === 0 && player.binbougamiTurns >= BINBOUGAMI_UPGRADE_TURNS) {
            player.binbougamiLevel = 1;
            this.log(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            showToast(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            // Update visual to look scarier (scale up, turn red)
            if (player.binbougamiMesh) {
              player.binbougamiMesh.children[0].material.color.setHex(0xef4444); // Red body
              // Scale up modestly for 'king' mode rather than huge value
              player.binbougamiMesh.scale.set(2.4, 2.4, 2.4);
            }
            await wait(1000);
          }

          // å†³å®šæ•ˆæœ
          const effects = player.binbougamiLevel === 1 ? BINBOUGAMI_EFFECTS.king : BINBOUGAMI_EFFECTS.normal;
          const effect = effects[Math.floor(Math.random() * effects.length)];

          // æ˜¾ç¤ºå¼¹çª—
          await this.showBinbougamiDialog(player, effect);

          // æ‰§è¡Œæ•ˆæœ
          switch (effect.type) {
            case "loseMoney":
              const amount = rand(effect.min, effect.max);
              player.money -= amount;
              this.log(`${player.name} æŸå¤±äº† Â¥${amount}`, "#ef4444");
              break;
            case "debt":
              const debt = rand(effect.min, effect.max);
              player.money -= debt;
              this.log(`${player.name} èƒŒè´Ÿäº† Â¥${debt} å€ºåŠ¡`, "#ef4444");
              break;
            case "sellProperty":
              await this.sellRandomProperty(player);
              break;
            case "sellAllProperty":
              // Sell multiple properties
              let count = 0;
              while ((await this.sellRandomProperty(player, false)) && count < 5) {
                count++;
              }
              break;
            case "nothing":
              this.log("ç©·ç¥ä»€ä¹ˆä¹Ÿæ²¡åš", "#9ca3af");
              break;
          }

          this.updateUI();
        }

        async sellRandomProperty(player, showLog = true) {
          // Find owned properties
          const ownedTiles = this.map.filter((t) => t.owner === player.id && t.buildings.length > 0);
          if (ownedTiles.length === 0) {
            if (showLog) this.log("ç©·ç¥æƒ³å–åœ°ï¼Œä½†ä½ ä¸€æ— æ‰€æœ‰...", "#9ca3af");
            return false;
          }

          const tile = ownedTiles[Math.floor(Math.random() * ownedTiles.length)];
          // Sell the most expensive building on this tile
          const buildingIdx = tile.buildings.pop(); // Remove last added

          const sellPrice = Math.floor(BUILDING_COSTS[buildingIdx] / 2);
          player.money += sellPrice;
          player.assets -= BUILDING_COSTS[buildingIdx];

          // If no buildings left, clear owner
          if (tile.buildings.length === 0) {
            tile.owner = null;
          }

          this.removeBuildingVisually(tile);

          if (showLog) this.log(`ç©·ç¥å–æ‰äº† ${tile.stationName} çš„ç‰©ä»¶ï¼Œè·å¾— Â¥${sellPrice}`, "#ef4444");
          return true;
        }

        removeBuildingVisually(stationTile) {
          // Find environment tiles around station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              if (t && !t.isRoad && t.mesh.children.length > 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            // Pick one and remove a child
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            if (target.mesh.children.length > 0) {
              target.mesh.remove(target.mesh.children[target.mesh.children.length - 1]);
            }
          }
        }

        async showBinbougamiDialog(player, effect) {
          return new Promise((resolve) => {
            const modal = document.getElementById("binbougami-modal");
            const title = document.getElementById("binbougami-modal-title");
            const desc = document.getElementById("binbougami-modal-desc");
            const effectEl = document.getElementById("binbougami-modal-effect");
            const hint = document.getElementById("binbougami-modal-hint");

            modal.classList.remove("hidden");

            title.innerText = player.binbougamiLevel === 1 ? "å¤§é­”ç‹é™ä¸´ï¼" : "ç©·ç¥æ¥è¢­ï¼";
            desc.innerText = effect.msg;
            effectEl.innerText = "";
            hint.innerText = "ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...";

            // Auto close after delay
            setTimeout(() => {
              modal.classList.add("hidden");
              resolve();
            }, 2500);
          });
        }

        // --- å¡ç‰Œç³»ç»Ÿæ–¹æ³• ---

        async handleCardStation(player) {
          // Randomly pick a card from pool based on rarity weights
          const r = Math.random();
          let pool = CARD_POOL.common;
          if (r > 0.7) pool = CARD_POOL.rare;
          if (r > 0.95) pool = CARD_POOL.epic;

          const cardKey = pool[Math.floor(Math.random() * pool.length)];
          const card = CARD_TYPES[cardKey];

          // Add to player hand
          if (player.cards.length < MAX_HAND_SIZE) {
            player.cards.push(cardKey);
            this.log(`ğŸ´ ${player.name} è·å¾—äº† [${card.name}]`, "#fbbf24");
            await this.showCardGetDialog(player, card);
          } else {
            this.log(`ğŸ´ ${player.name} æ‰¾åˆ°äº† [${card.name}]ï¼Œä½†æ˜¯æ‰‹ç‰Œæ»¡äº†...`, "#9ca3af");
            showToast("æ‰‹ç‰Œå·²æ»¡ï¼Œæ— æ³•è·å–æ–°å¡ç‰‡", "gray");
          }
        }

        async showCardGetDialog(player, card) {
          return new Promise((resolve) => {
            const modal = document.getElementById("card-modal");
            const content = document.getElementById("card-modal-content");

            modal.classList.remove("hidden");
            content.innerHTML = `
                <div class="text-center">
                    <div class="text-6xl mb-4">${card.icon}</div>
                    <div class="text-3xl font-bold text-gray-800 mb-2">${card.name}</div>
                    <div class="text-gray-600">${card.desc}</div>
                    <div class="mt-4 text-sm text-yellow-600 font-bold">ç¨€æœ‰åº¦: ${card.rarity.toUpperCase()}</div>
                </div>
            `;

            if (player.isAI) {
              setTimeout(() => {
                this.closeCardModal();
                resolve();
              }, 1500);
            } else {
              this._resolveCardModal = resolve;
            }
          });
        }

        closeCardModal() {
          document.getElementById("card-modal").classList.add("hidden");
          if (this._resolveCardModal) {
            this._resolveCardModal();
            this._resolveCardModal = null;
          }
        }

        openUseCardModal() {
          const player = this.players[0]; // Human player
          if (player.cards.length === 0) return;

          const modal = document.getElementById("use-card-modal");
          const list = document.getElementById("use-card-list");
          list.innerHTML = "";

          player.cards.forEach((cardKey, index) => {
            const card = CARD_TYPES[cardKey];
            const div = document.createElement("div");
            div.className = `card-item w-32 p-3 rounded-xl border-2 flex flex-col items-center gap-2 bg-white shadow-md card-rarity-${card.rarity}`;
            div.onclick = () => this.useCard(index);

            div.innerHTML = `
                <div class="text-3xl">${card.icon}</div>
                <div class="font-bold text-sm text-center">${card.name}</div>
                <div class="text-xs text-gray-600 text-center leading-tight">${card.desc}</div>
            `;
            list.appendChild(div);
          });

          modal.classList.remove("hidden");
        }

        closeUseCardModal() {
          document.getElementById("use-card-modal").classList.add("hidden");
        }

        async useCard(cardIndex) {
          this.closeUseCardModal();
          const player = this.players[0];
          const cardKey = player.cards[cardIndex];
          const card = CARD_TYPES[cardKey];

          // Remove card from hand
          player.cards.splice(cardIndex, 1);
          this.updateUI();

          this.log(`ğŸƒ ${player.name} ä½¿ç”¨äº† [${card.name}]`, "#a855f7");

          // Hide buttons
          document.getElementById("roll-btn").classList.add("hidden");
          document.getElementById("use-card-btn").classList.add("hidden");

          // Execute Effect
          if (card.type === "move") {
            await this.processMove(card.diceCount);
          } else if (card.type === "attack") {
            await this.handleAttackCard(player, card);
            this.nextTurn();
          } else if (card.type === "special") {
            await this.handleSpecialCard(player, card);
            this.nextTurn();
          }
        }

        async handleAttackCard(player, card) {
          const target = this.players.find((p) => p !== player); // Simple 1v1 logic

          if (card.effect === "skip") {
            target.skipNextTurn = true;
            this.log(`ğŸ’¤ ${target.name} ä¸‹å›åˆå°†æ— æ³•è¡ŒåŠ¨ï¼`, "#3b82f6");
            showToast(`${target.name} è¿›å…¥å†¬çœ ï¼`, "#3b82f6");
          } else if (card.effect === "blowAway") {
            const randomTile = this.map[Math.floor(Math.random() * this.map.length)];
            target.currentTile = randomTile;
            target.mesh.position.copy(randomTile.worldPos);
            target.mesh.position.y = 1.5;
            this.log(`ğŸ’¨ ${target.name} è¢«å¹é£åˆ°äº†ä¸çŸ¥åçš„åœ°æ–¹ï¼`, "#3b82f6");
            this.updateDistanceDisplay();
          } else if (card.effect === "trap") {
            this.log("é™·é˜±å¡å°šæœªå®è£…", "gray");
          }
          await wait(1000);
        }

        async handleSpecialCard(player, card) {
          if (card.effect === "backward") {
            this.log("åé€€å¡å°šæœªå®è£…", "gray");
          } else if (card.effect === "teleport") {
            const stations = this.map.filter((t) => t.type === "green");
            const target = stations[Math.floor(Math.random() * stations.length)];
            player.currentTile = target;
            player.mesh.position.copy(target.worldPos);
            player.mesh.position.y = 1.5;
            this.log(`ğŸšª ${player.name} ä½¿ç”¨ä»»æ„é—¨ä¼ é€åˆ°äº† ${target.stationName}`, "#a855f7");
            this.updateDistanceDisplay();
          } else if (card.effect === "exorcise") {
            if (player.hasBinbougami) {
              player.hasBinbougami = false;
              if (player.binbougamiMesh) {
                try {
                  if (typeof player.binbougamiMesh.removeFromParent === "function") player.binbougamiMesh.removeFromParent();
                  else if (player.binbougamiMesh.parent) player.binbougamiMesh.parent.remove(player.binbougamiMesh);
                } catch (e) {}
                player.binbougamiMesh = null;
              }
              this.log(`ğŸ“¿ ç©·ç¥è¢«é©±æ•£äº†ï¼`, "#fbbf24");
            } else {
              this.log("ä½ èº«ä¸Šæ²¡æœ‰ç©·ç¥...", "gray");
            }
          }
          await wait(1000);
        }

        async triggerTileEvent(player, alreadyReachedDestination = false) {
          this.state = "EVENT";
          const tile = player.currentTile;
          let endTurn = true;

          // ç›®çš„åœ°åˆ°è¾¾å·²åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­å¤„ç†ï¼Œä¸å†é‡å¤æ£€æŸ¥

          switch (tile.type) {
            case "blue":
              const bonus = rand(500, 2000);
              player.money += bonus;
              this.log(`å¹¸è¿ï¼è·å¾—èµ„é‡‘ Â¥${bonus}`, "#60a5a5");
              await this.showMoneyChangeDialog(player, bonus);
              break;
            case "red":
              const loss = rand(500, 1500);
              player.money -= loss;
              this.log(`å€’éœ‰ï¼æŸå¤± Â¥${loss}`, "#f87171");
              await this.showMoneyChangeDialog(player, -loss);
              break;
            case "yellow":
              await this.handleCardStation(player);
              break;
            case "green":
              endTurn = false;
              await this.handleStation(player, tile);
              break;
          }

          // Handle Binbougami at end of turn
          if (player.hasBinbougami) {
            await wait(500);
            await this.handleBinbougamiAction(player);
          }

          this.updateUI();
          if (endTurn) this.nextTurn();
        }

        spawnFloatingText(pos, text, color) {
          const div = document.createElement("div");
          div.innerText = text;
          div.style.color = color;
          div.className = "absolute text-2xl font-black shadow-white drop-shadow-md pointer-events-none transition-all duration-1000 ease-out";

          const screenPos = this.getScreenPosition(pos);
          div.style.left = screenPos.x + "px";
          div.style.top = screenPos.y + "px";

          document.getElementById("ui-layer").appendChild(div);

          // Animate via CSS
          requestAnimationFrame(() => {
            div.style.transform = "translateY(-50px)";
            div.style.opacity = "0";
          });

          setTimeout(() => div.remove(), 1000);
        }

        async handleStation(player, tile) {
          if (player.isAI) {
            // AIç­–ç•¥ï¼šä¼˜å…ˆè€ƒè™‘æ˜¯å¦è¦è´­ä¹°
            let bought = false;
            for (let i = 2; i >= 0; i--) {
              // ä»é«˜çº§ç‰©ä»¶å¼€å§‹è€ƒè™‘
              if (!tile.buildings.includes(i) && player.money >= BUILDING_COSTS[i] * 1.2) {
                this.doBuy(player, tile, i);
                bought = true;
                await wait(800);
                // AIä¸è´ªå©ªï¼Œä¸€æ¬¡åªä¹°ä¸€ä¸ª
                break;
              }
            }
            if (!bought) this.log("ç”µè„‘æ²¡æœ‰è´­ä¹°æ„å‘", "#fca5a5");
            this.nextTurn();
          } else {
            this.state = "BUYING";
            this.showBuyModal(tile);
          }
        }

        showBuyModal(tile) {
          const modal = document.getElementById("buy-modal");
          const list = document.getElementById("building-list");
          document.getElementById("station-name").innerText = tile.stationName;
          document.getElementById("buy-modal-money").innerText = this.players[0].money;
          list.innerHTML = "";

          // æ˜¾ç¤ºæ˜¯å¦ä¸ºç›®çš„åœ°
          const isDestination = tile === this.destinationTile;
          if (isDestination) {
            const destBadge = document.createElement("div");
            destBadge.className = "bg-yellow-500 text-black text-center py-1 px-3 rounded-full text-sm font-bold mb-3";
            destBadge.innerText = "ğŸ¯ å½“å‰ç›®çš„åœ°ï¼";
            list.appendChild(destBadge);
          }

          BUILDING_NAMES.forEach((name, index) => {
            const cost = BUILDING_COSTS[index];
            const income = BUILDING_INCOME[index];
            const isOwned = tile.buildings.includes(index);
            const canAfford = this.players[0].money >= cost;

            const div = document.createElement("div");
            div.className = `flex justify-between items-center p-3 rounded border ${isOwned ? "bg-blue-100 border-blue-500" : "bg-gray-50 border-gray-200"}`;

            let btnHtml = "";
            if (isOwned) {
              let ownerName = "æœªçŸ¥";
              if (tile.owner) {
                const owner = this.players.find((p) => p.id === tile.owner);
                if (owner) {
                  ownerName = owner.id === this.players[0].id ? "æˆ‘" : owner.name;
                }
              }
              btnHtml = `<span class="text-blue-600 font-bold text-sm">å·²æ‹¥æœ‰ (${ownerName})</span>`;
            } else {
              btnHtml = canAfford
                ? `<button onclick="game.playerBuy(${index})" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm shadow">è´­ä¹°</button>`
                : `<span class="text-red-400 text-sm">ç¼ºé’±</span>`;
            }

            div.innerHTML = `
                <div>
                    <div class="font-bold text-gray-800">${name}</div>
                    <div class="text-xs text-gray-500">Â¥${cost} Â· <span class="text-green-600">å¹´æ”¶ç›Š Â¥${income}</span></div>
                </div>
                <div>${btnHtml}</div>
            `;
            list.appendChild(div);
          });

          // æ˜¾ç¤ºç‹¬å å¥–åŠ±æç¤º
          const monopolyHint = document.createElement("div");
          monopolyHint.className = "text-xs text-center text-purple-600 mt-2";
          monopolyHint.innerText = tile.buildings.length === 3 ? "ğŸ† å·²ç‹¬å ï¼æ”¶ç›Šç¿»å€ï¼" : "ğŸ’¡ ä¹°é½3ç§ç‰©ä»¶å¯è·å¾—ç‹¬å åŠ æˆ(æ”¶ç›Šx2)";
          list.appendChild(monopolyHint);

          modal.classList.remove("hidden");
        }

        playerBuy(tierIndex) {
          const player = this.players[0];
          const tile = player.currentTile;
          if (tile.buildings.includes(tierIndex) || player.money < BUILDING_COSTS[tierIndex]) return;

          this.doBuy(player, tile, tierIndex);
          this.showBuyModal(tile);
          this.updateUI();
        }

        doBuy(player, tile, tierIndex) {
          player.money -= BUILDING_COSTS[tierIndex];
          player.assets += BUILDING_COSTS[tierIndex];
          tile.buildings.push(tierIndex);
          tile.buildings.sort();
          tile.owner = player.id;

          this.placeBuildingVisually(tile, tierIndex);
          this.log(`${player.name} è´­ä¹°äº† ${BUILDING_NAMES[tierIndex]}!`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
        }

        placeBuildingVisually(stationTile, tierIndex) {
          // Find a spot near the station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              // Must be environment (not road) and empty
              if (t && !t.isRoad && t.mesh.children.length === 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            const target = candidates[Math.floor(Math.random() * candidates.length)];

            const bColor = COLORS.building[tierIndex];
            const h = (tierIndex + 1) * 3; // Height varies by tier

            const bGeo = new THREE.BoxGeometry(2.5, h, 2.5);
            const bMat = new THREE.MeshLambertMaterial({ color: bColor });
            const bMesh = new THREE.Mesh(bGeo, bMat);
            bMesh.position.y = h / 2 + 1; // Adjust for height
            bMesh.castShadow = true;
            bMesh.receiveShadow = true;

            // Add windows texture logic (simplified as black boxes)
            const winGeo = new THREE.BoxGeometry(2.6, h * 0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x334155 });
            const wins = new THREE.Mesh(winGeo, winMat);
            bMesh.add(wins);

            target.mesh.add(bMesh);

            // Juice effect
            const scaleUp = () => {
              bMesh.scale.set(0.1, 0.1, 0.1);
              let s = 0.1;
              const grow = setInterval(() => {
                s += 0.1;
                bMesh.scale.set(s, s, s);
                if (s >= 1) clearInterval(grow);
              }, 16);
            };
            scaleUp();
          }
        }

        closeBuyModal() {
          document.getElementById("buy-modal").classList.add("hidden");
          this.nextTurn();
        }

        async nextTurn() {
          // æ—¶é—´æ¨è¿›ï¼ˆæ¯ä¸¤ä¸ªå›åˆï¼ˆP1+COMå„èµ°ä¸€æ¬¡ï¼‰ç®—ä¸€ä¸ªæœˆï¼‰
          // è¿™é‡Œæ¯ä¸ªç©å®¶å›åˆç»“æŸåï¼Œå¦‚æœæ˜¯COMå›åˆç»“æŸï¼Œåˆ™æ¨è¿›ä¸€ä¸ªæœˆ
          if (this.turn === 1) {
            // COMåˆšç»“æŸå›åˆ
            const needSettlement = this.advanceTime();
            if (needSettlement) {
              await this.performSettlement();
            }
          }

          this.turn = (this.turn + 1) % 2;
          this.startTurn();
        }

        updateUI() {
          const p1 = this.players[0];
          const com = this.players[1];
          document.getElementById("p1-money").innerText = p1.money.toLocaleString();
          document.getElementById("p1-assets").innerText = p1.assets.toLocaleString();
          document.getElementById("com-money").innerText = com.money.toLocaleString();
          document.getElementById("com-assets").innerText = com.assets.toLocaleString();

          // Update Binbougami Indicators
          const p1Binbougami = document.getElementById("p1-binbougami");
          const comBinbougami = document.getElementById("com-binbougami");

          if (this.players[0].hasBinbougami) p1Binbougami.classList.remove("hidden");
          else p1Binbougami.classList.add("hidden");

          if (this.players[1].hasBinbougami) comBinbougami.classList.remove("hidden");
          else comBinbougami.classList.add("hidden");

          // Update Cards Display
          const p1Cards = document.getElementById("p1-cards");
          const comCards = document.getElementById("com-cards");
          p1Cards.innerText = this.players[0].cards.length;
          comCards.innerText = this.players[1].cards.length;

          // Update Hand Panel (for P1)
          const handPanel = document.getElementById("card-hand-panel");
          const handContainer = document.getElementById("card-hand");

          if (this.turn === 0 && !this.players[0].isAI && this.players[0].cards.length > 0) {
            handPanel.classList.remove("hidden");
            handContainer.innerHTML = "";
            this.players[0].cards.forEach((cardKey, index) => {
              const card = CARD_TYPES[cardKey];
              const div = document.createElement("div");
              div.className = `flex-shrink-0 w-16 h-20 bg-white rounded border-2 flex flex-col items-center justify-center cursor-pointer hover:scale-110 transition-transform card-rarity-${card.rarity}`;
              div.title = `${card.name}: ${card.desc}`;
              div.onclick = () => this.useCard(index);
              div.innerHTML = `<div class="text-2xl">${card.icon}</div><div class="text-[10px] font-bold truncate w-full text-center">${card.name}</div>`;
              handContainer.appendChild(div);
            });
          } else {
            handPanel.classList.add("hidden");
          }

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // --- Rendering Loop ---

        getScreenPosition(vec3) {
          const v = vec3.clone();
          v.project(this.camera);
          const x = (v.x * 0.5 + 0.5) * this.width;
          const y = (-(v.y * 0.5) + 0.5) * this.height;
          return { x, y };
        }

        centerCameraOnPlayer(player, duration = 500) {
          return new Promise((resolve) => {
            if (!player || !player.mesh) {
              resolve();
              return;
            }

            const targetPos = player.mesh.position.clone();
            const startTarget = this.controls.target.clone();
            const startCamPos = this.camera.position.clone();

            // Calculate camera offset from current target
            const offset = startCamPos.clone().sub(startTarget);
            const endCamPos = targetPos.clone().add(offset);

            const startTime = Date.now();

            const animateCamera = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(elapsed / duration, 1);

              // Ease out cubic for smooth deceleration
              const eased = 1 - Math.pow(1 - progress, 3);

              this.controls.target.lerpVectors(startTarget, targetPos, eased);
              this.camera.position.lerpVectors(startCamPos, endCamPos, eased);

              if (progress < 1) {
                requestAnimationFrame(animateCamera);
              } else {
                resolve();
              }
            };

            animateCamera();
          });
        }

        // Focus camera on a specific player by index (0 = P1, 1 = COM)
        focusOnPlayer(playerIndex) {
          if (this.mode !== "GAME") return;
          if (playerIndex < 0 || playerIndex >= this.players.length) return;

          const player = this.players[playerIndex];
          if (!player || !player.mesh) return;

          // Temporarily disable camera lock to allow manual focus
          this.cameraLocked = false;

          // Center camera on the selected player
          this.centerCameraOnPlayer(player, 400);
        }

        onResize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // Update Game Camera
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();

          // Update Map Camera
          if (this.worldMap) {
            this.worldMap.camera.aspect = this.width / this.height;
            this.worldMap.camera.updateProjectionMatrix();
          }

          this.renderer.setSize(this.width, this.height);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          if (this.mode === "MAP") {
            if (this.worldMap) {
              this.worldMap.update();
              this.renderer.render(this.worldMap.scene, this.worldMap.camera);
            }
            return;
          }

          // Camera Follow Logic
          if (this.cameraLocked) {
            const activePlayer = this.players[this.turn];
            if (activePlayer && activePlayer.mesh) {
              const targetPos = activePlayer.mesh.position;

              // Smoothly move both target and camera to maintain angle
              const currentTarget = this.controls.target.clone();
              const newTarget = currentTarget.clone().lerp(targetPos, 0.1);
              const delta = new THREE.Vector3().subVectors(newTarget, currentTarget);

              this.camera.position.add(delta);
              this.controls.target.copy(newTarget);
            }
          }

          if (this.controls) this.controls.update();

          // Update Station Labels
          this.map.forEach((tile) => {
            if (tile.labelElement) {
              // Only update if visible (optional optimization)
              const pos = this.getScreenPosition(tile.mesh.position);
              const offset = tile.labelOffset || { x: 0, y: -30, align: "center" };

              // Apply position based on label alignment
              let transform;
              if (offset.align === "left") {
                // Label on right side of station, align left edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(0%, -50%)`;
              } else if (offset.align === "right") {
                // Label on left side of station, align right edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-100%, -50%)`;
              } else {
                // Label on top (default), center aligned
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-50%, -100%)`;
              }
              tile.labelElement.style.transform = transform;

              // Hide if offscreen
              if (pos.x < 0 || pos.x > this.width || pos.y < 0 || pos.y > this.height) {
                tile.labelElement.style.opacity = "0";
              } else {
                tile.labelElement.style.opacity = "1";
              }
            }
          });

          // Update off-screen destination indicator
          this.updateDestinationIndicator();

          // Update Overlay Buttons if active
          const overlay = document.getElementById("direction-overlay");
          if (overlay) {
            Array.from(overlay.children).forEach((btn) => {
              if (btn.target3D) {
                const screenPos = this.getScreenPosition(btn.target3D);
                btn.style.left = `${screenPos.x}px`;
                btn.style.top = `${screenPos.y}px`;
              }
            });
          }

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Boot
      window.onload = async () => {
        // Initialize game first (starts rendering loop and rotating earth)
        window.game = new Game();

        // Load cities data
        await loadCitiesData();

        // Render map objects (cities, continents) after data is loaded
        if (window.game.worldMap) {
          window.game.worldMap.renderMapObjects();
        }
      };
    </script>
  </body>
</html>
