
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åœ°é“å¤§äº¨ - Three.js é‡åˆ¶ç‰ˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #202025; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; outline: none; }
        
        /* UI Overlay - ä¿æŒåŸæ ·ï¼Œä½†å¢åŠ ç©¿é€æ€§ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        .hud-panel { pointer-events: auto; }
        
        /* Animations */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-custom { animation: bounce 1s infinite; }
        
        .modal {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            transition: opacity 0.3s;
        }

        /* Station Labels floating in 3D space */
        .station-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            transform: translate(-50%, -150%);
            white-space: nowrap;
            text-shadow: 0 1px 2px black;
            z-index: 10;
        }
    </style>
</head>
<body>

    <!-- Game Container -->
    <div id="game-container" class="w-full h-full relative"></div>

    <!-- Labels Layer (Dynamic HTML for 3D objects) -->
    <div id="labels-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- Top Info Bar -->
        <div class="flex justify-between w-full max-w-4xl mx-auto pointer-events-none">
            <!-- P1 Info -->
            <div class="hud-panel bg-blue-900/90 text-white p-4 rounded-xl border-2 border-blue-400 shadow-lg w-48 transition-all pointer-events-auto" id="p1-panel">
                <h2 class="text-xl font-bold flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-blue-400"></div> ç©å®¶ (P1)
                </h2>
                <p class="text-yellow-300 text-2xl font-mono mt-1">Â¥<span id="p1-money">0</span></p>
                <p class="text-xs text-gray-300 mt-1">èµ„äº§: Â¥<span id="p1-assets">0</span></p>
            </div>

            <!-- Turn Indicator -->
            <div class="hud-panel bg-gray-800/80 text-white px-6 py-2 rounded-full border border-gray-600 h-fit mt-2 pointer-events-auto">
                <span id="turn-indicator" class="font-bold text-lg tracking-widest">ç­‰å¾…å¼€å§‹...</span>
            </div>

            <!-- COM Info -->
            <div class="hud-panel bg-red-900/90 text-white p-4 rounded-xl border-2 border-red-400 shadow-lg w-48 transition-all opacity-70 pointer-events-auto" id="com-panel">
                <h2 class="text-xl font-bold flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-red-500"></div> ç”µè„‘ (COM)
                </h2>
                <p class="text-yellow-300 text-2xl font-mono mt-1">Â¥<span id="com-money">0</span></p>
                <p class="text-xs text-gray-300 mt-1">èµ„äº§: Â¥<span id="com-assets">0</span></p>
            </div>
        </div>

        <!-- Action Log -->
        <div class="absolute top-24 right-4 w-64 pointer-events-none z-20">
            <div id="game-log" class="flex flex-col gap-2 items-end text-sm font-bold text-white shadow-black drop-shadow-md">
                <!-- Log entries go here -->
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-center items-end mb-8 pointer-events-none">
            <button id="roll-btn" class="hud-panel pointer-events-auto bg-gradient-to-b from-yellow-400 to-yellow-600 text-black font-black text-2xl px-12 py-4 rounded-2xl shadow-xl border-b-4 border-yellow-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden">
                ğŸ² æ·éª°å­
            </button>
        </div>
    </div>

    <!-- Property Buy Modal -->
    <div id="buy-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full border-4 border-green-600 relative">
            <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-1 rounded-full font-bold shadow-lg">
                åˆ°è¾¾è½¦ç«™
            </div>
            <h3 class="text-2xl font-bold text-center mt-4 mb-2 text-gray-800" id="station-name">ä¸œäº¬ç«™</h3>
            <p class="text-center text-gray-500 mb-4">è¿™å—åœ°çš®çœ‹èµ·æ¥å¾ˆæœ‰æ½œåŠ›ï¼è¦æŠ•èµ„å—ï¼Ÿ</p>
            
            <div id="building-list" class="space-y-3 mb-6">
                <!-- Buildings injected here -->
            </div>

            <div class="flex gap-3">
                <button onclick="game.closeBuyModal()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 rounded-lg transition">
                    ç¦»å¼€
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * 3D Metro Tycoon Game Engine (Three.js Edition)
 */

// --- Constants & Config ---
const TILE_SIZE = 4; // World unit size for a tile
const TILE_SPACING = 0.2; // Gap between tiles
const COLORS = {
    bg: 0x87CEEB, // Sky Blue
    ground: 0x1a1a20,
    
    // Tile Materials
    blue: 0x3b82f6,    // Money +
    red: 0xef4444,     // Money -
    yellow: 0xeab308,  // Event
    green: 0x22c55e,   // Station
    start: 0xffffff,   // Start
    
    road: 0x9ca3af,    // Plain Road
    env_nature: 0x15803d, // Nature
    env_culture: 0x52525b, // Culture

    // Buildings
    building: [0x60a5fa, 0x818cf8, 0xa78bfa] 
};

const BUILDING_COSTS = [1000, 5000, 20000];
const BUILDING_NAMES = ["æ‹‰é¢æ‘Š", "å•†åŠ¡é…’åº—", "æ‘©å¤©å¤§æ¥¼"];
const BUILDING_INCOME = [200, 800, 4000];

const STATION_NAMES = [
    "ç½—æ¹–å£å²¸", "å›½è´¸", "è€è¡—", "å¤§å‰§é™¢", "ç§‘å­¦é¦†", "åå¼ºè·¯", "å²—å¦", 
    "ä¼šå±•ä¸­å¿ƒ", "è´­ç‰©å…¬å›­", "é¦™èœœæ¹–", "è½¦å…¬åº™", "ç«¹å­æ—", "ä¾¨åŸä¸œ", 
    "åä¾¨åŸ", "ä¸–ç•Œä¹‹çª—", "ç™½çŸ³æ´²", "é«˜æ–°å›­", "æ·±å¤§", "æ¡ƒå›­", "å¤§æ–°", 
    "å‰æµ·æ¹¾", "å®å®‰ä¸­å¿ƒ", "æ·±åœ³åŒ—ç«™", "å¸‚æ°‘ä¸­å¿ƒ", "å°‘å¹´å®«", "è²èŠ±åŒ—", 
    "ä¸Šæ¢…æ—", "ç¦æ°‘", "ç¦ç”°å£å²¸", "åæµ·", "ç§‘è‹‘", "çº¢æ ‘æ¹¾"
];

// --- Utilities ---
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const wait = (ms) => new Promise(r => setTimeout(r, ms));

// --- Game Classes ---

class Tile {
    constructor(id, gridX, gridY, type) {
        this.id = id;
        this.gridX = gridX;
        this.gridY = gridY;
        this.type = type; 
        this.buildings = []; 
        this.owner = null; 
        
        this.stationName = '';
        if (type === 'green') {
             const rawIdx = (gridX * 13 + gridY * 7) % STATION_NAMES.length;
             const idx = (rawIdx + STATION_NAMES.length) % STATION_NAMES.length;
             this.stationName = STATION_NAMES[idx];
        }

        this.neighbors = []; 
        this.mesh = null; // Three.js Mesh
        this.labelElement = null; // HTML Element for station name
    }

    get isRoad() {
        return !this.type.startsWith('env');
    }

    get isColored() {
        return ['blue', 'red', 'yellow', 'green', 'start'].includes(this.type);
    }

    // Helper to get world position based on grid
    get worldPos() {
        return new THREE.Vector3(this.gridX * TILE_SIZE, 0, this.gridY * TILE_SIZE);
    }
}

class Player {
    constructor(id, name, color, isAI) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.isAI = isAI;
        this.money = 10000;
        this.assets = 0;
        
        this.currentTile = null;
        this.previousTile = null;
        
        this.mesh = null; // Three.js Mesh (Group)
        
        // For smooth movement animation
        this.animating = false;
        this.targetPos = new THREE.Vector3();
    }
}

class Game {
    constructor() {
        this.container = document.getElementById('game-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // Three.js Components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;

        this.map = []; 
        this.players = [];
        this.turn = 0;
        this.state = 'INIT'; 
        this.cameraLocked = true;
        this.isUserInteracting = false;
        
        this.initThree();
        this.initGame();

        window.addEventListener('resize', () => this.onResize());
        document.getElementById('roll-btn').onclick = () => this.playerRoll();
        
        // Start Loop
        this.animate();
    }

    initThree() {
        // 1. Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x202025);
        this.scene.fog = new THREE.Fog(0x202025, 90, 180);

        // 2. Camera (Perspective)
        const fov = 45;
        const aspect = this.width / this.height;
        const near = 0.1;
        const far = 1000;
        this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        
        // Perspective View Setup: Position and LookAt
        this.camera.position.set(0, 60, 60); 
        this.camera.lookAt(this.scene.position); // Will be updated to follow player

        // 3. Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(this.width, this.height);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.container.appendChild(this.renderer.domElement);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 130;
        this.controls.target.set(0, 0, 0);
        
        // Lock rotation, enable pan
        this.controls.enableRotate = false;
        this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };
        this.controls.touches = {
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN
        };
        
        // Stop auto-following if user interacts
        this.controls.addEventListener('start', () => {
            this.cameraLocked = false;
            this.isUserInteracting = true;
        });

        this.controls.addEventListener('end', () => {
            this.isUserInteracting = false;
            if (this.state === 'MOVING') {
                this.cameraLocked = true;
            }
        });

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        const shadowSize = 50;
        dirLight.shadow.camera.left = -shadowSize;
        dirLight.shadow.camera.right = shadowSize;
        dirLight.shadow.camera.top = shadowSize;
        dirLight.shadow.camera.bottom = -shadowSize;
        this.scene.add(dirLight);
    }

    initGame() {
        // Materials Cache
        this.materials = {
            road: new THREE.MeshLambertMaterial({ color: COLORS.road }),
            start: new THREE.MeshLambertMaterial({ color: COLORS.start }),
            blue: new THREE.MeshLambertMaterial({ color: COLORS.blue }),
            red: new THREE.MeshLambertMaterial({ color: COLORS.red }),
            yellow: new THREE.MeshLambertMaterial({ color: COLORS.yellow }),
            green: new THREE.MeshLambertMaterial({ color: COLORS.green }),
            env_nature: new THREE.MeshLambertMaterial({ color: COLORS.env_nature }),
            env_culture: new THREE.MeshLambertMaterial({ color: COLORS.env_culture }),
            rail: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 })
        };
        
        this.geometries = {
            tile: new THREE.BoxGeometry(TILE_SIZE - TILE_SPACING, 1, TILE_SIZE - TILE_SPACING),
            envBlock: new THREE.BoxGeometry(TILE_SIZE, 4, TILE_SIZE) // Taller blocks for env
        };

        // Generate Map
        const startTile = this.generateMap();

        // Init Players
        this.players = [
            new Player('p1', 'ç©å®¶', 0x3b82f6, false),
            new Player('com', 'ç”µè„‘', 0xef4444, true)
        ];
        
        this.players.forEach(p => {
            this.createPlayerMesh(p);
            p.currentTile = startTile;
            p.mesh.position.copy(startTile.worldPos);
            p.mesh.position.y = 1.5; // Sit on top of tile
        });

        // Initial Camera Setup: Center on P1, looking from South
        const p1Pos = this.players[0].mesh.position;
        this.camera.position.set(p1Pos.x, p1Pos.y + 60, p1Pos.z + 60);
        this.controls.target.copy(p1Pos);
        this.controls.update();
        
        this.updateUI();
        this.startTurn();
    }

    createPlayerMesh(player) {
        const group = new THREE.Group();

        // Body
        const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 16);
        const bodyMat = new THREE.MeshStandardMaterial({ color: player.color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1;
        body.castShadow = true;
        group.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 2.2;
        head.castShadow = true;
        group.add(head);

        // Hat/Indicator (Cone)
        const hatGeo = new THREE.ConeGeometry(0.6, 1, 16);
        const hatMat = new THREE.MeshStandardMaterial({ color: player.color });
        const hat = new THREE.Mesh(hatGeo, hatMat);
        hat.position.y = 3;
        hat.rotation.x = Math.PI; // Point down? No point up like a party hat
        group.add(hat);

        this.scene.add(group);
        player.mesh = group;
    }

    generateMap() {
        this.map = [];
        
        // 0. Prepare Station Names
        const availableNames = [...STATION_NAMES];
        // Shuffle
        for (let i = availableNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableNames[i], availableNames[j]] = [availableNames[j], availableNames[i]];
        }
        
        const totalStations = availableNames.length;
        
        // 1. Calculate Grid Dimensions to fit all stations
        const ratio = 4/3;
        let cols = Math.ceil(Math.sqrt(totalStations * ratio));
        let rows = Math.ceil(totalStations / cols);
        while (cols * rows < totalStations) rows++;

        // 2. Generate Coordinates (Centered around 0)
        const xCoords = [];
        let cx = -Math.floor(cols * 2.5); 
        for(let i=0; i<cols; i++) {
            xCoords.push(cx);
            cx += rand(2, 5);
        }

        const zCoords = [];
        let cz = -Math.floor(rows * 2.5);
        for(let i=0; i<rows; i++) {
            zCoords.push(cz);
            cz += rand(2, 5);
        }
        
        // 3. Build Graph Nodes (Intersections)
        const nodes = []; 
        for(let i=0; i<xCoords.length; i++) {
            const row = [];
            for(let j=0; j<zCoords.length; j++) {
                row.push({ x: xCoords[i], z: zCoords[j], id: `${i},${j}` });
            }
            nodes.push(row);
        }

        // 4. Build All Potential Edges
        const allEdges = [];
        for(let i=0; i<xCoords.length-1; i++) {
            for(let j=0; j<zCoords.length; j++) {
                allEdges.push({ u: nodes[i][j], v: nodes[i+1][j], type: 'h' });
            }
        }
        for(let i=0; i<xCoords.length; i++) {
            for(let j=0; j<zCoords.length-1; j++) {
                allEdges.push({ u: nodes[i][j], v: nodes[i][j+1], type: 'v' });
            }
        }

        // MST Logic
        for (let i = allEdges.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allEdges[i], allEdges[j]] = [allEdges[j], allEdges[i]];
        }

        const parent = new Map();
        const find = (id) => {
            if (!parent.has(id)) parent.set(id, id);
            if (parent.get(id) !== id) parent.set(id, find(parent.get(id)));
            return parent.get(id);
        };
        const union = (id1, id2) => {
            const root1 = find(id1);
            const root2 = find(id2);
            if (root1 !== root2) {
                parent.set(root1, root2);
                return true;
            }
            return false;
        };

        const activeEdges = new Set();
        const rejectedEdges = [];

        for(const edge of allEdges) {
            if (union(edge.u.id, edge.v.id)) {
                activeEdges.add(edge);
            } else {
                rejectedEdges.push(edge);
            }
        }

        for(const edge of rejectedEdges) {
            if (Math.random() < 0.4) {
                activeEdges.add(edge);
            }
        }

        const degrees = new Map();
        const incDeg = (id) => degrees.set(id, (degrees.get(id) || 0) + 1);
        activeEdges.forEach(e => { incDeg(e.u.id); incDeg(e.v.id); });

        for(const edge of rejectedEdges) {
            if (activeEdges.has(edge)) continue;
            if ((degrees.get(edge.u.id)||0) < 2 || (degrees.get(edge.v.id)||0) < 2) {
                activeEdges.add(edge);
                incDeg(edge.u.id);
                incDeg(edge.v.id);
            }
        }

        // 5. Sparse Map Generation
        const tileData = new Map(); // "x,z" -> { type, stationName? }
        const setTile = (x, z, type, props={}) => {
            const key = `${x},${z}`;
            // Don't overwrite road/station with env
            if (!tileData.has(key) || (tileData.get(key).type === 'env' && type !== 'env')) { 
                tileData.set(key, { x, z, type, ...props });
            }
        };

        // Place Stations
        let nameIndex = 0;
        nodes.forEach(row => row.forEach(node => {
            let stationName = "";
            if (nameIndex < availableNames.length) {
                stationName = availableNames[nameIndex++];
            } else {
                stationName = `éƒŠåŒº ${nameIndex++ - availableNames.length + 1}`;
            }
            setTile(node.x, node.z, 'green', { stationName });
        }));

        // Place Roads
        activeEdges.forEach(edge => {
            const u = edge.u;
            const v = edge.v;
            if (edge.type === 'h') { // Varying X
                const minX = Math.min(u.x, v.x);
                const maxX = Math.max(u.x, v.x);
                for(let x = minX + 1; x < maxX; x++) {
                    const type = (Math.random() < 0.3) ? this.getRandomColoredType() : 'road';
                    setTile(x, u.z, type);
                }
            } else { // Varying Z
                const minZ = Math.min(u.z, v.z);
                const maxZ = Math.max(u.z, v.z);
                for(let z = minZ + 1; z < maxZ; z++) {
                    const type = (Math.random() < 0.3) ? this.getRandomColoredType() : 'road';
                    setTile(u.x, z, type);
                }
            }
        });

        // Grow Environment around roads/stations
        const roadTiles = Array.from(tileData.values());
        roadTiles.forEach(t => {
            // Random range 3-8
            const range = rand(3, 8);
            for(let dx = -range; dx <= range; dx++) {
                for(let dz = -range; dz <= range; dz++) {
                    // Organic shape (Diamond/Circle hybrid)
                    if (Math.abs(dx) + Math.abs(dz) <= range * 1.4) {
                         const nx = t.x + dx;
                         const nz = t.z + dz;
                         const key = `${nx},${nz}`;
                         if (!tileData.has(key)) {
                             const envType = Math.random() > 0.7 ? 'env_culture' : 'env_nature';
                             setTile(nx, nz, envType); // Default to env
                         }
                    }
                }
            }
        });

        // 6. Instantiate Tiles
        const mapGroup = new THREE.Group();
        this.scene.add(mapGroup);
        this.tilesMap = new Map();
        
        let idCounter = 0;
        tileData.forEach(data => {
            const tile = new Tile(idCounter++, data.x, data.z, data.type);
            if (data.stationName) tile.stationName = data.stationName;
            
            this.map.push(tile);
            this.tilesMap.set(`${data.x},${data.z}`, tile);
            this.createTileVisuals(tile, mapGroup);
        });
        
        // 7. Link Neighbors
        this.map.forEach(tile => {
            if (!tile.isRoad) return;
            
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            dirs.forEach(([dx, dz]) => {
                const nx = tile.gridX + dx;
                const nz = tile.gridY + dz;
                const neighbor = this.tilesMap.get(`${nx},${nz}`);
                if (neighbor && neighbor.isRoad) {
                    tile.neighbors.push(neighbor);
                }
            });
        });
        
        // Set Start Position
        const stations = this.map.filter(t => t.type === 'green');
        let startTile = stations.length > 0 ? stations[Math.floor(Math.random() * stations.length)] : this.map[0];
        
        if (!startTile) startTile = this.map[0];

        if (startTile) {
            startTile.type = 'start';
            startTile.mesh.material = this.materials.start;
            startTile.mesh.position.y = 0.2; 
            if (startTile.labelElement) {
                startTile.labelElement.remove();
                startTile.labelElement = null;
            }
        }
        
        return startTile;
    }

    createTileVisuals(tile, parentGroup) {
        const x = tile.gridX * TILE_SIZE;
        const z = tile.gridY * TILE_SIZE;

        // 1. Base Block
        let geometry = this.geometries.tile;
        let yPos = 0;

        // Environment blocks are taller to create "canyons" for the track
        if (!tile.isRoad) {
            geometry = new THREE.BoxGeometry(TILE_SIZE, rand(2, 6), TILE_SIZE);
            yPos = -1; // Sink them a bit
        }

        const material = this.materials[tile.type] || this.materials.road;
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, yPos, z);
        mesh.receiveShadow = true;
        
        // 2. Decorations
        if (tile.type === 'env_nature') {
            if (Math.random() > 0.5) {
                const treeGeo = new THREE.ConeGeometry(1, 3, 8);
                const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
                const tree = new THREE.Mesh(treeGeo, treeMat);
                tree.position.set(0, 2.5, 0);
                tree.castShadow = true;
                mesh.add(tree); // Local coordinate
            }
        } else if (tile.type === 'green') {
            // Station Marker
            const stationGeo = new THREE.BoxGeometry(2.5, 1, 2.5);
            const stationMesh = new THREE.Mesh(stationGeo, new THREE.MeshLambertMaterial({color: 0xffffff}));
            stationMesh.position.y = 0.6;
            mesh.add(stationMesh);

            // Add HTML Label
            this.createStationLabel(tile);
        }

        tile.mesh = mesh;
        parentGroup.add(mesh);
    }

    createStationLabel(tile) {
        const div = document.createElement('div');
        div.className = 'station-label';
        div.innerText = tile.stationName;
        document.getElementById('labels-layer').appendChild(div);
        tile.labelElement = div;
    }

    getRandomColoredType() {
        const r = Math.random();
        if (r < 0.25) return 'green';
        if (r < 0.5) return 'red';
        if (r < 0.75) return 'yellow';
        return 'blue';
    }

    // --- UI & Interaction ---

    log(msg, color = 'white') {
        const logEl = document.getElementById('game-log');
        const entry = document.createElement('div');
        entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
        logEl.appendChild(entry);
        if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
        setTimeout(() => {
            entry.style.opacity = '0';
            setTimeout(() => entry.remove(), 500);
        }, 4000);
    }

    startTurn() {
        if (!this.isUserInteracting) {
            this.cameraLocked = true;
        }
        const p = this.players[this.turn];
        document.getElementById('turn-indicator').innerText = `${p.name} çš„å›åˆ`;
        
        const p1Panel = document.getElementById('p1-panel');
        const comPanel = document.getElementById('com-panel');
        
        p1Panel.style.opacity = this.turn === 0 ? '1' : '0.6';
        p1Panel.style.transform = this.turn === 0 ? 'scale(1.05)' : 'scale(1)';
        p1Panel.classList.toggle('border-yellow-400', this.turn === 0);
        
        comPanel.style.opacity = this.turn === 1 ? '1' : '0.6';
        comPanel.style.transform = this.turn === 1 ? 'scale(1.05)' : 'scale(1)';
        comPanel.classList.toggle('border-yellow-400', this.turn === 1);

        this.state = 'IDLE';

        if (p.isAI) {
            document.getElementById('roll-btn').classList.add('hidden');
            setTimeout(() => this.aiAction(), 1000);
        } else {
            document.getElementById('roll-btn').classList.remove('hidden');
        }
    }

    async playerRoll() {
        if (this.state !== 'IDLE') return;
        document.getElementById('roll-btn').classList.add('hidden');
        await this.processMove();
    }

    async aiAction() {
        this.log("ç”µè„‘æ­£åœ¨æ€è€ƒ...", "#fca5a5");
        await wait(1000);
        await this.processMove();
    }

    async processMove() {
        this.state = 'MOVING';
        const steps = rand(1, 6);
        const player = this.players[this.turn];
        
        this.log(`${player.name} æ·å‡ºäº† ${steps} ç‚¹!`, "#fbbf24");

        let remainingSteps = steps;
        
        while (remainingSteps > 0) {
            const current = player.currentTile;
            const neighbors = current.neighbors;
            
            let validNext = neighbors.filter(n => n !== player.previousTile);
            if (validNext.length === 0 && neighbors.length > 0) {
                validNext = neighbors; // Dead end fallback
            }

            let nextTile = null;

            if (validNext.length === 1) {
                nextTile = validNext[0];
            } else if (validNext.length > 1) {
                if (player.isAI) {
                    nextTile = validNext[Math.floor(Math.random() * validNext.length)];
                } else {
                    nextTile = await this.askDirection(player, validNext);
                }
            } else {
                break;
            }

            // Physics Move
            player.previousTile = player.currentTile;
            player.currentTile = nextTile;
            
            await this.animateMove(player, nextTile.worldPos);

            if (nextTile.isColored) {
                remainingSteps--;
            }
        }

        await wait(300);
        await this.triggerTileEvent(player);
    }

    animateMove(player, targetVec3) {
        if (!this.isUserInteracting) {
            this.cameraLocked = true;
        }
        return new Promise(resolve => {
            const startPos = player.mesh.position.clone();
            const startTime = Date.now();
            const duration = 300; // ms
            
            // Simple Hop Animation
            const animateStep = () => {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                
                // Linear Interpolation for X/Z
                player.mesh.position.lerpVectors(startPos, targetVec3, progress);
                
                // Parabolic Arc for Y (Jump)
                // y = 4 * height * x * (1-x) + baseline
                const jumpHeight = 2;
                const baseHeight = 1.5;
                player.mesh.position.y = baseHeight + (4 * jumpHeight * progress * (1 - progress));

                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    player.mesh.position.copy(targetVec3);
                    player.mesh.position.y = baseHeight;
                    resolve();
                }
            };
            animateStep();
        });
    }

    askDirection(player, options) {
        return new Promise(resolve => {
            const overlay = document.createElement('div');
            overlay.className = 'absolute inset-0 pointer-events-auto z-50';
            overlay.id = 'direction-overlay';
            document.getElementById('ui-layer').appendChild(overlay);

            options.forEach(tile => {
                const screenPos = this.getScreenPosition(tile.mesh.position);
                
                let label = 'ğŸ“';
                const dx = tile.gridX - player.currentTile.gridX;
                const dy = tile.gridY - player.currentTile.gridY; // using gridY as Z
                
                if (dx > 0) label = 'â¡ï¸';
                else if (dx < 0) label = 'â¬…ï¸';
                else if (dy > 0) label = 'â¬‡ï¸'; // Z+ is down on screen roughly
                else if (dy < 0) label = 'â¬†ï¸';

                const btn = document.createElement('button');
                btn.innerText = label; 
                btn.className = 'absolute w-12 h-12 bg-yellow-400 hover:bg-white rounded-full text-2xl shadow-xl border-4 border-yellow-600 animate-bounce-custom cursor-pointer';
                btn.style.left = `${screenPos.x}px`;
                btn.style.top = `${screenPos.y}px`;
                btn.style.transform = 'translate(-50%, -50%)';

                // Keep button moving with camera by storing reference (simplified here to static for moment)
                // Ideally we update position in render loop, but since game pauses for input, this is okay if camera doesn't move.
                
                btn.onclick = () => {
                    document.getElementById('direction-overlay').remove();
                    resolve(tile);
                };
                overlay.appendChild(btn);
            });
        });
    }

    async triggerTileEvent(player) {
        this.state = 'EVENT';
        const tile = player.currentTile;
        let endTurn = true;

        switch (tile.type) {
            case 'blue':
                const bonus = rand(500, 2000);
                player.money += bonus;
                this.log(`å¹¸è¿ï¼è·å¾—èµ„é‡‘ Â¥${bonus}`, "#60a5fa");
                this.spawnFloatingText(player.mesh.position, `+Â¥${bonus}`, '#60a5fa');
                break;
            case 'red':
                const loss = rand(500, 1500);
                player.money -= loss;
                this.log(`å€’éœ‰ï¼æŸå¤± Â¥${loss}`, "#f87171");
                this.spawnFloatingText(player.mesh.position, `-Â¥${loss}`, '#ef4444');
                break;
            case 'yellow':
                this.log(`å¡ç‰Œäº‹ä»¶ (æœªå®è£…)`, "#fbbf24");
                break;
            case 'green':
                endTurn = false;
                await this.handleStation(player, tile);
                break;
        }

        this.updateUI();
        if (endTurn) this.nextTurn();
    }

    spawnFloatingText(pos, text, color) {
        const div = document.createElement('div');
        div.innerText = text;
        div.style.color = color;
        div.className = 'absolute text-2xl font-black shadow-white drop-shadow-md pointer-events-none transition-all duration-1000 ease-out';
        
        const screenPos = this.getScreenPosition(pos);
        div.style.left = screenPos.x + 'px';
        div.style.top = screenPos.y + 'px';
        
        document.getElementById('ui-layer').appendChild(div);
        
        // Animate via CSS
        requestAnimationFrame(() => {
            div.style.transform = 'translateY(-50px)';
            div.style.opacity = '0';
        });
        
        setTimeout(() => div.remove(), 1000);
    }

    async handleStation(player, tile) {
        if (player.isAI) {
            // Simple AI
            let bought = false;
            for (let i = 0; i < 3; i++) {
                if (!tile.buildings.includes(i) && player.money >= BUILDING_COSTS[i] * 1.2) {
                     this.doBuy(player, tile, i);
                     bought = true;
                     await wait(800);
                     break;
                }
            }
            if(!bought) this.log("ç”µè„‘æ²¡æœ‰è´­ä¹°æ„å‘", "#fca5a5");
            this.nextTurn();
        } else {
            this.state = 'BUYING';
            this.showBuyModal(tile);
        }
    }

    showBuyModal(tile) {
        const modal = document.getElementById('buy-modal');
        const list = document.getElementById('building-list');
        document.getElementById('station-name').innerText = tile.stationName;
        list.innerHTML = '';

        BUILDING_NAMES.forEach((name, index) => {
            const cost = BUILDING_COSTS[index];
            const isOwned = tile.buildings.includes(index);
            const canAfford = this.players[0].money >= cost;
            
            const div = document.createElement('div');
            div.className = `flex justify-between items-center p-3 rounded border ${isOwned ? 'bg-blue-100 border-blue-500' : 'bg-gray-50 border-gray-200'}`;
            
            let btnHtml = isOwned ? 
                `<span class="text-blue-600 font-bold text-sm">å·²æ‹¥æœ‰</span>` : 
                (canAfford ? `<button onclick="game.playerBuy(${index})" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm shadow">è´­ä¹°</button>` : `<span class="text-red-400 text-sm">ç¼ºé’±</span>`);

            div.innerHTML = `
                <div>
                    <div class="font-bold text-gray-800">${name}</div>
                    <div class="text-xs text-gray-500">Â¥${cost}</div>
                </div>
                <div>${btnHtml}</div>
            `;
            list.appendChild(div);
        });

        modal.classList.remove('hidden');
    }

    playerBuy(tierIndex) {
        const player = this.players[0];
        const tile = player.currentTile;
        if (tile.buildings.includes(tierIndex) || player.money < BUILDING_COSTS[tierIndex]) return;

        this.doBuy(player, tile, tierIndex);
        this.showBuyModal(tile); 
        this.updateUI();
    }

    doBuy(player, tile, tierIndex) {
        player.money -= BUILDING_COSTS[tierIndex];
        player.assets += BUILDING_COSTS[tierIndex];
        tile.buildings.push(tierIndex);
        tile.buildings.sort();
        tile.owner = player.id;
        
        this.placeBuildingVisually(tile, tierIndex);
        this.log(`${player.name} è´­ä¹°äº† ${BUILDING_NAMES[tierIndex]}!`, player.color === 0x3b82f6 ? '#60a5fa' : '#f87171');
    }

    placeBuildingVisually(stationTile, tierIndex) {
        // Find a spot near the station
        const range = 2;
        const candidates = [];
        for(let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for(let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
                const t = this.tilesMap.get(`${x},${z}`);
                // Must be environment (not road) and empty
                if (t && !t.isRoad && t.mesh.children.length === 0) {
                    candidates.push(t);
                }
            }
        }

        if (candidates.length > 0) {
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            
            const bColor = COLORS.building[tierIndex];
            const h = (tierIndex + 1) * 3; // Height varies by tier
            
            const bGeo = new THREE.BoxGeometry(2.5, h, 2.5);
            const bMat = new THREE.MeshLambertMaterial({ color: bColor });
            const bMesh = new THREE.Mesh(bGeo, bMat);
            bMesh.position.y = h / 2 + 1; // Adjust for height
            bMesh.castShadow = true;
            bMesh.receiveShadow = true;
            
            // Add windows texture logic (simplified as black boxes)
            const winGeo = new THREE.BoxGeometry(2.6, h*0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x334155 });
            const wins = new THREE.Mesh(winGeo, winMat);
            bMesh.add(wins);

            target.mesh.add(bMesh);
            
            // Juice effect
            const scaleUp = () => {
                bMesh.scale.set(0.1, 0.1, 0.1);
                let s = 0.1;
                const grow = setInterval(() => {
                    s += 0.1;
                    bMesh.scale.set(s, s, s);
                    if (s >= 1) clearInterval(grow);
                }, 16);
            };
            scaleUp();
        }
    }

    closeBuyModal() {
        document.getElementById('buy-modal').classList.add('hidden');
        this.nextTurn();
    }

    nextTurn() {
        this.turn = (this.turn + 1) % 2;
        this.startTurn();
    }

    updateUI() {
        const p1 = this.players[0];
        const com = this.players[1];
        document.getElementById('p1-money').innerText = p1.money.toLocaleString();
        document.getElementById('p1-assets').innerText = p1.assets.toLocaleString();
        document.getElementById('com-money').innerText = com.money.toLocaleString();
        document.getElementById('com-assets').innerText = com.assets.toLocaleString();
    }

    // --- Rendering Loop ---

    getScreenPosition(vec3) {
        const v = vec3.clone();
        v.project(this.camera);
        const x = (v.x * .5 + .5) * this.width;
        const y = (-(v.y * .5) + .5) * this.height;
        return { x, y };
    }

    onResize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // Update Perspective frustum
        this.camera.aspect = this.width / this.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.width, this.height);
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        // Camera Follow Logic
        if (this.cameraLocked) {
            const activePlayer = this.players[this.turn];
            if (activePlayer && activePlayer.mesh) {
                const targetPos = activePlayer.mesh.position;
                
                // Smoothly move both target and camera to maintain angle
                const currentTarget = this.controls.target.clone();
                const newTarget = currentTarget.clone().lerp(targetPos, 0.1);
                const delta = new THREE.Vector3().subVectors(newTarget, currentTarget);
                
                this.camera.position.add(delta);
                this.controls.target.copy(newTarget);
            }
        }

        if (this.controls) this.controls.update();

        // Update Station Labels
        this.map.forEach(tile => {
            if (tile.labelElement) {
                // Only update if visible (optional optimization)
                const pos = this.getScreenPosition(tile.mesh.position);
                // Offset label to float above the station block
                tile.labelElement.style.transform = `translate(${pos.x}px, ${pos.y - 30}px) translate(-50%, -100%)`;
                
                // Hide if offscreen
                if (pos.x < 0 || pos.x > this.width || pos.y < 0 || pos.y > this.height) {
                    tile.labelElement.style.opacity = '0';
                } else {
                    tile.labelElement.style.opacity = '1';
                }
            }
        });

        // Update Overlay Buttons if active
        const overlay = document.getElementById('direction-overlay');
        if (overlay) {
            // Re-calc positions for buttons in case camera moved
            // (Omitted for brevity/performance, but would be here)
        }

        this.renderer.render(this.scene, this.camera);
    }
}

// Boot
window.onload = () => {
    window.game = new Game();
};

</script>
</body>
</html>
