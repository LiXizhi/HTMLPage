<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello World - Travel, Build, Talk</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.keepwork.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.16"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #202025;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
        outline: none;
        touch-action: none;
      }

      /* UI Overlay - ä¿æŒåŸæ ·ï¼Œä½†å¢åŠ ç©¿é€æ€§ */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 20;
      }
      .hud-panel {
        pointer-events: auto;
      }

      /* Animations */
      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }
      .animate-bounce-custom {
        animation: bounce 1s infinite;
      }

      .modal {
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        transition: opacity 0.3s;
      }

      /* Station Labels floating in 3D space */
      .station-label {
        position: absolute;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        transform: translate(-50%, -150%);
        white-space: nowrap;
        text-shadow: 0 1px 2px black;
        z-index: 10;
        user-select: none;
        -webkit-user-select: none;
      }

      /* Destination label highlight */
      .station-label.destination {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        font-size: 16px;
        padding: 6px 16px;
        border: 2px solid #fff;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        animation: destination-pulse 1.5s ease-in-out infinite;
        z-index: 15;
      }

      @keyframes destination-pulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.6);
        }
      }

      /* Off-screen destination indicator */
      .destination-indicator {
        position: fixed;
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        white-space: nowrap;
        border: 2px solid #fff;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        z-index: 1;
        display: flex;
        align-items: center;
        gap: 6px;
        animation: indicator-pulse 1s ease-in-out infinite;
      }

      @keyframes indicator-pulse {
        0%,
        100% {
          opacity: 1;
          box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        }
        50% {
          opacity: 0.9;
          box-shadow: 0 0 25px rgba(251, 191, 36, 1);
        }
      }

      /* ç©·ç¥ç›¸å…³æ ·å¼ */
      .binbougami-indicator {
        animation: binbougami-shake 0.5s ease-in-out infinite;
      }

      @keyframes binbougami-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-2px) rotate(-1deg);
        }
        75% {
          transform: translateX(2px) rotate(1deg);
        }
      }

      .binbougami-effect {
        animation: binbougami-appear 0.5s ease-out;
      }

      @keyframes binbougami-appear {
        0% {
          transform: scale(0) rotate(-180deg);
          opacity: 0;
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* ç©·ç¥å¤§é­”ç‹æ¨¡å¼ */
      .binbougami-king {
        animation: king-pulse 1s ease-in-out infinite;
        filter: drop-shadow(0 0 10px #ff0000);
      }

      @keyframes king-pulse {
        0%,
        100% {
          transform: scale(1);
          filter: drop-shadow(0 0 10px #ff0000);
        }
        50% {
          transform: scale(1.1);
          filter: drop-shadow(0 0 20px #ff4444);
        }
      }

      /* å¡ç‰Œæ ·å¼ */
      .card-item {
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .card-item:hover {
        transform: translateY(-8px) scale(1.05);
        z-index: 100;
      }

      .card-rarity-common {
        border-color: #9ca3af;
        background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
      }
      .card-rarity-rare {
        border-color: #3b82f6;
        background: linear-gradient(135deg, #dbeafe, #bfdbfe);
      }
      .card-rarity-epic {
        border-color: #8b5cf6;
        background: linear-gradient(135deg, #ede9fe, #ddd6fe);
      }
      .card-rarity-legendary {
        border-color: #f59e0b;
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
      }

      .card-panel {
        max-height: 120px;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .card-panel::-webkit-scrollbar {
        height: 4px;
      }

      .card-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }

      /* --- 3D Dice Animation Styles --- */
      :root {
        --die-size: 80px;
        --die-half: 40px;
        --dot-size: 10px;
      }

      .dice-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .dice-modal.show {
        opacity: 1;
        pointer-events: auto;
      }

      .dice-scene {
        position: relative;
        width: 400px;
        height: 300px;
        perspective: 2000px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: visible;
      }

      .dice-floor {
        position: absolute;
        width: 500px;
        height: 500px;
        background-image: radial-gradient(rgba(255,255,255,0.3) 1px, transparent 1px);
        background-size: 20px 20px;
        opacity: 0.5;
        transform: rotateX(60deg) scale(1.5);
        pointer-events: none;
      }

      .dice-stage {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-style: preserve-3d;
        opacity: 0;
      }

      @keyframes diceStageEnter {
        0% {
          opacity: 0;
          transform: translate(300px, 200px) scale(0.2);
        }
        60% {
          opacity: 1;
          transform: translate(-20px, -20px) scale(1.05);
        }
        100% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
      }

      .dice-stage.entering {
        animation: diceStageEnter 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }

      .dice-camera {
        position: relative;
        transform-style: preserve-3d;
        transform: rotateX(-35deg) rotateY(45deg);
        display: flex;
        gap: 30px;
        transition: transform 0.5s;
      }

      .die-wrapper {
        position: relative;
        width: var(--die-size);
        height: var(--die-size);
        transform-style: preserve-3d;
      }

      .die {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transform: rotateX(-90deg);
      }

      .die-shadow {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        filter: blur(15px);
        transform: translateY(50px) rotateX(90deg) scale(1.2);
        border-radius: 50%;
        z-index: -1;
      }

      .die-face {
        position: absolute;
        width: var(--die-size);
        height: var(--die-size);
        background: white;
        border: 2px solid #cbd5e1;
        border-radius: 10px;
        box-sizing: border-box;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        padding: 10px;
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);
        backface-visibility: visible;
      }

      .die-dot {
        width: var(--dot-size);
        height: var(--dot-size);
        background: #1e293b;
        border-radius: 50%;
        align-self: center;
        justify-self: center;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      }

      .die-face-1 { transform: translateZ(var(--die-half)); }
      .die-face-2 { transform: rotateX(90deg) translateZ(var(--die-half)); }
      .die-face-3 { transform: rotateY(-90deg) translateZ(var(--die-half)); }
      .die-face-4 { transform: rotateY(90deg) translateZ(var(--die-half)); }
      .die-face-5 { transform: rotateX(-90deg) translateZ(var(--die-half)); }
      .die-face-6 { transform: rotateY(180deg) translateZ(var(--die-half)); }

      .dice-result {
        position: absolute;
        top: -60px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: 900;
        color: white;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        opacity: 0;
        transition: opacity 0.3s;
        white-space: nowrap;
      }

      .dice-result.show {
        opacity: 1;
      }

      .dice-result-value {
        color: #fbbf24;
      }

      /* ç¤¼èŠ±åŠ¨ç”»æ ·å¼ */
      .fireworks-container {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 60;
      }

      .firework {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        animation: firework-explode 1.5s ease-out forwards;
      }

      @keyframes firework-explode {
        0% {
          transform: scale(0);
          opacity: 1;
        }
        50% {
          opacity: 1;
        }
        100% {
          transform: scale(1) translate(var(--tx), var(--ty));
          opacity: 0;
        }
      }

      .firework-trail {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        animation: firework-trail 0.8s ease-out forwards;
      }

      @keyframes firework-trail {
        0% {
          transform: translateY(100vh) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(var(--end-y)) scale(0.5);
          opacity: 0;
        }
      }

      .sparkle {
        position: absolute;
        font-size: 24px;
        animation: sparkle-float 2s ease-out forwards;
        pointer-events: none;
      }

      @keyframes sparkle-float {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 1;
        }
        50% {
          opacity: 1;
        }
        100% {
          transform: scale(1.5) rotate(180deg) translateY(-100px);
          opacity: 0;
        }
      }

      .arrival-btn {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        font-weight: bold;
        padding: 12px 48px;
        border-radius: 12px;
        border: 3px solid #fff;
        cursor: pointer;
        font-size: 20px;
        transition: all 0.2s ease;
        box-shadow: 0 4px 15px rgba(251, 191, 36, 0.5);
      }

      .arrival-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(251, 191, 36, 0.7);
      }

      .arrival-btn:active {
        transform: scale(0.98);
      }
    </style>
  </head>
  <body>
    <!-- Game Container -->
    <div id="game-container" class="w-full h-full relative"></div>

    <!-- World Map Iframe Container (for city selection globe) - loaded on demand -->
    <iframe id="world-map-iframe" class="fixed inset-0 w-full h-full z-[55] border-none" style="display: none;"></iframe>

    <!-- Labels Layer (Dynamic HTML for 3D objects) -->
    <div id="labels-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>

    <!-- Off-screen Destination Indicator -->
    <div id="destination-indicator" class="destination-indicator hidden">
      <span id="indicator-arrow">â†’</span>
      <span id="indicator-name">---</span>
    </div>

    <!-- Title and Subtitle (Outside UI Layer) -->
    <div id="game-title" class="absolute top-4 left-4 z-50 pointer-events-auto hidden">
      <h1
        class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg"
        style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
      >
        HelloWorld
      </h1>
      <p class="text-sm text-white font-semibold tracking-wider drop-shadow-md mt-1 ml-1">powered by paracraft</p>
    </div>

    <!-- Login Window (Start Screen) -->
    <div id="login-modal" class="fixed inset-0 flex items-center justify-center z-[60] bg-black/40 backdrop-blur-sm">
      <div class="text-center">
        <h1
          class="text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg mb-2"
          style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
        >
          Hello World
        </h1>
        <p class="text-2xl text-white font-semibold tracking-wider drop-shadow-md mb-8">Travel the World, Build Your Home, Talk With People</p>
        <button
          id="login-btn"
          class="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-4 px-12 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 border-2 border-white/50"
        >
          ç«‹å³å‡ºå‘
        </button>
      </div>
      <div class="absolute bottom-8 text-white/90 text-sm font-bold tracking-widest drop-shadow-lg">powered by Paracraft (c) copy right 2025</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-2 md:p-4 pointer-events-none">
      <!-- Top Bar Container -->
      <div class="flex flex-col w-full items-center gap-2 pointer-events-none">
        <!-- Row 1: Destination & Time (Always visible at top, compact on mobile) -->
        <div
          class="hud-panel pointer-events-auto bg-gradient-to-r from-purple-900/90 to-pink-900/90 text-white px-3 py-2 pr-12 md:pr-3 rounded-xl border-2 border-yellow-400 shadow-lg hidden w-full max-w-2xl flex justify-between items-center gap-2 z-50"
          id="destination-panel"
        >
          <div class="flex items-center gap-2">
            <span class="text-xs text-gray-300">ğŸ“…</span>
            <span class="text-sm md:text-lg font-bold text-yellow-300 whitespace-nowrap"><span id="game-year">1</span>å¹´<span id="game-month">4</span>æœˆ</span>
          </div>
          <div class="w-px h-6 bg-gray-500"></div>
          <div class="flex items-center gap-2 overflow-hidden flex-1 justify-center">
            <span class="text-xs text-gray-300">ğŸ¯</span>
            <span class="text-sm md:text-lg font-bold text-green-300 truncate" id="destination-name">---</span>
          </div>
          <div class="w-px h-6 bg-gray-500 hidden md:block"></div>
          <div class="flex items-center gap-2 hidden md:flex">
            <span class="text-xs text-gray-300">ğŸ’°</span>
            <span class="text-sm md:text-lg font-bold text-yellow-400">Â¥5000</span>
          </div>
        </div>

        <!-- Turn Indicator - Centered -->
        <div
          class="hud-panel bg-gray-800/80 text-white px-3 py-1 md:px-6 md:py-2 rounded-full border border-gray-600 pointer-events-auto"
        >
          <span id="turn-indicator" class="font-bold text-xs md:text-lg tracking-widest whitespace-nowrap">ç­‰å¾…...</span>
        </div>
      </div>

      <!-- Left Bottom: Render Stats (FPS, Triangles, Draw Calls) -->
      <div id="render-stats" class="hud-panel absolute bottom-2 left-2 md:bottom-4 md:left-4 bg-black/70 text-green-400 px-2 py-1 rounded text-xs font-mono pointer-events-none z-20">
        <div>FPS: <span id="stats-fps">0</span></div>
        <div>Triangles: <span id="stats-triangles">0</span></div>
        <div>Draw Calls: <span id="stats-drawcalls">0</span></div>
        <div>Chunks: <span id="stats-chunks-visible">0</span>/<span id="stats-chunks-total">0</span></div>
      </div>

      <!-- Left Side: Players List -->
      <div class="absolute top-32 md:top-40 left-2 md:left-4 flex flex-col gap-2 pointer-events-none z-20">
        <!-- P1 Info (Minimal) -->
        <div
          class="hud-panel bg-blue-900/90 text-white px-3 py-2 rounded-lg border-2 border-blue-400 shadow-lg transition-all pointer-events-auto cursor-pointer hover:border-yellow-400 flex items-center gap-2"
          id="p1-panel"
          onclick="game.showPlayerDetail(0)"
        >
          <div class="w-4 h-4 rounded-full bg-blue-400 flex-shrink-0"></div>
          <span class="font-bold text-sm">P1</span>
          <span id="p1-binbougami" class="hidden text-lg binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
          <span class="text-yellow-300 text-sm font-mono ml-1">Â¥<span id="p1-money">0</span></span>
        </div>

        <!-- COM Info (Minimal) -->
        <div
          class="hud-panel bg-red-900/90 text-white px-3 py-2 rounded-lg border-2 border-red-400 shadow-lg transition-all opacity-70 pointer-events-auto cursor-pointer hover:border-yellow-400 flex items-center gap-2"
          id="com-panel"
          onclick="game.showPlayerDetail(1)"
        >
          <div class="w-4 h-4 rounded-full bg-red-500 flex-shrink-0"></div>
          <span class="font-bold text-sm">COM</span>
          <span id="com-binbougami" class="hidden text-lg binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
          <span class="text-yellow-300 text-sm font-mono ml-1">Â¥<span id="com-money">0</span></span>
        </div>
      </div>

      <!-- Airport Button -->
      <button
        onclick="game.toggleMap()"
        class="hud-panel absolute top-2 right-2 md:top-4 md:right-4 bg-blue-600 hover:bg-blue-700 text-white p-2 md:p-3 rounded-full shadow-lg border-2 border-white z-50 pointer-events-auto transition-transform hover:scale-110"
        title="åˆ‡æ¢åŸå¸‚"
      >
        âœˆï¸
      </button>

      <!-- Action Log -->
      <div class="absolute top-40 md:top-24 right-2 md:right-4 w-48 md:w-64 pointer-events-none z-20">
        <div id="game-log" class="flex flex-col gap-1 md:gap-2 items-end text-xs md:text-sm font-bold text-white shadow-black drop-shadow-md">
          <!-- Log entries go here -->
        </div>
      </div>

      <!-- Bottom Controls -->
      <div class="flex flex-col items-center gap-4 mb-4 pointer-events-none">
        <!-- å¡ç‰Œæ‰‹ç‰ŒåŒºåŸŸ -->
        <div id="card-hand-panel" class="hud-panel pointer-events-auto bg-gray-900/80 px-4 py-2 rounded-xl border border-gray-600 hidden">
          <div class="text-xs text-gray-400 mb-1 text-center">ğŸƒ æ‰‹ç‰Œ (ç‚¹å‡»ä½¿ç”¨)</div>
          <div id="card-hand" class="card-panel flex gap-2">
            <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
          </div>
        </div>

        <!-- æŒ‰é’®åŒºåŸŸ -->
        <div class="flex gap-3">
          <button
            id="use-card-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-purple-400 to-purple-600 text-white font-bold text-lg px-6 py-3 rounded-xl shadow-lg border-b-4 border-purple-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸƒ ä½¿ç”¨å¡ç‰Œ
          </button>
          <button
            id="roll-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-yellow-400 to-yellow-600 text-black font-black text-2xl px-12 py-4 rounded-2xl shadow-xl border-b-4 border-yellow-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸ² æ·éª°å­
          </button>
        </div>
      </div>
    </div>

    <!-- Money Change Modal -->
    <div id="money-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100">
        <div id="money-modal-icon" class="text-6xl mb-4">ğŸ’°</div>
        <h3 class="text-2xl font-black text-gray-800 mb-2" id="money-modal-title">ç©å®¶</h3>
        <div class="text-2xl font-bold mb-2" id="money-modal-delta"></div>
        <div class="text-5xl font-mono font-bold my-4 text-gray-800" id="money-modal-amount">Â¥0</div>
        <div class="text-gray-500 text-sm" id="money-modal-desc">èµ„é‡‘å˜åŠ¨</div>
      </div>
    </div>

    <!-- Property Buy Modal -->
    <!-- ç©·ç¥æ•ˆæœå¼¹çª— -->
    <div id="binbougami-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-gray-900 to-purple-900 p-8 rounded-2xl shadow-2xl max-w-md w-full border-4 border-purple-500 relative text-center">
        <div id="binbougami-modal-icon" class="text-8xl mb-4 binbougami-effect">ğŸ‘»</div>
        <h3 class="text-3xl font-black text-purple-300 mb-2" id="binbougami-modal-title">ç©·ç¥æ¥è¢­ï¼</h3>
        <p class="text-xl text-gray-300 mb-4" id="binbougami-modal-desc">ç©·ç¥æ­£åœ¨æ£ä¹±...</p>
        <div class="text-4xl font-mono font-bold text-red-400 mb-4" id="binbougami-modal-effect"></div>
        <div class="text-sm text-gray-400" id="binbougami-modal-hint"></div>
      </div>
    </div>

    <!-- AIè´­ä¹°æˆ¿äº§å¼¹çª— -->
    <div id="ai-purchase-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-red-900 to-orange-900 p-8 rounded-2xl shadow-2xl max-w-md w-full border-4 border-red-500 relative text-center">
        <div class="text-8xl mb-4">ğŸ </div>
        <h3 class="text-3xl font-black text-red-300 mb-2" id="ai-purchase-title">ç”µè„‘è´­ä¹°æˆ¿äº§</h3>
        <p class="text-2xl text-yellow-300 font-bold mb-2" id="ai-purchase-property-name">æˆ¿äº§åç§°</p>
        <p class="text-xl text-gray-300 mb-4" id="ai-purchase-location">ä½ç½®ï¼šXXX</p>
        <div class="text-4xl font-mono font-bold text-red-400 mb-4" id="ai-purchase-price">-Â¥0</div>
        <div class="text-sm text-gray-400">ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...</div>
      </div>
    </div>

    <!-- ç©·ç¥é™„èº«å…¨å±åŠ¨ç”» -->
    <div id="possession-modal" class="fixed inset-0 flex items-center justify-center hidden z-[100] bg-black/90 backdrop-blur-sm transition-opacity duration-500">
      <div class="text-center transform transition-all duration-500 scale-0" id="possession-content">
        <div class="text-9xl mb-8 animate-bounce">ğŸ‘»</div>
        <h1 class="text-6xl font-black text-purple-500 mb-4 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]">ç©·ç¥é™„èº«ï¼</h1>
        <p class="text-4xl text-white font-bold" id="possession-text">ç©å®¶ XX è¢«ç©·ç¥é™„èº«äº†ï¼</p>
      </div>
    </div>

    <!-- 3D éª°å­åŠ¨ç”»å¼¹çª— -->
    <div id="dice-modal" class="dice-modal">
      <div class="flex flex-col items-center">
        <div class="dice-scene">
          <div id="dice-result" class="dice-result">
            æ·å‡ºäº† <span id="dice-result-value" class="dice-result-value">0</span> ç‚¹!
          </div>
          <div class="dice-floor"></div>
          <div id="dice-stage" class="dice-stage">
            <div id="dice-camera" class="dice-camera">
              <!-- Dice will be dynamically injected here -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- å¡ç‰Œè·å–å¼¹çª— -->
    <div id="card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-amber-900 to-yellow-900 p-6 rounded-2xl shadow-2xl max-w-lg w-full border-4 border-yellow-500 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ å¡ç‰‡ç«™</div>
        <h3 class="text-2xl font-bold text-center mt-4 mb-4 text-yellow-300">è·å–å¡ç‰Œ</h3>
        <div id="card-modal-content" class="space-y-3 mb-4">
          <!-- å¡ç‰Œé€‰é¡¹ä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">ç¦»å¼€</button>
        </div>
      </div>
    </div>

    <!-- ä½¿ç”¨å¡ç‰Œé€‰æ‹©å¼¹çª— -->
    <div id="use-card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-indigo-900 to-purple-900 p-6 rounded-2xl shadow-2xl max-w-2xl w-full border-4 border-indigo-400 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-indigo-500 text-white px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ é€‰æ‹©è¦ä½¿ç”¨çš„å¡ç‰Œ</div>
        <div id="use-card-list" class="flex flex-wrap gap-3 justify-center mt-6 mb-4">
          <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeUseCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">å–æ¶ˆ</button>
        </div>
      </div>
    </div>

    <!-- ç©å®¶è¯¦æƒ…å¼¹çª— -->
    <div id="player-detail-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div id="player-detail-content" class="bg-gradient-to-b from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative">
        <button onclick="game.closePlayerDetailModal()" class="absolute top-3 right-3 text-white/70 hover:text-white text-xl">âœ•</button>
        <div class="flex items-center gap-3 mb-4">
          <div id="player-detail-color" class="w-8 h-8 rounded-full"></div>
          <h3 id="player-detail-name" class="text-2xl font-bold text-white"></h3>
          <span id="player-detail-binbougami" class="hidden text-2xl binbougami-indicator">ğŸ‘»</span>
        </div>
        <div class="space-y-3">
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ’° ç°é‡‘</span>
            <span id="player-detail-money" class="text-xl font-bold text-yellow-300">Â¥0</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ  èµ„äº§</span>
            <span id="player-detail-assets" class="text-lg text-green-300">Â¥0</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ“ è·ç›®çš„åœ°</span>
            <span id="player-detail-distance" class="text-lg text-cyan-300">--</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸƒ å¡ç‰Œ</span>
            <span id="player-detail-cards" class="text-lg text-amber-300">0</span>
          </div>
        </div>
        <button onclick="game.closePlayerDetailModal(); game.focusOnPlayer(game.currentDetailPlayer)" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition">
          ğŸ“ å®šä½åˆ°ç©å®¶
        </button>
      </div>
    </div>

    <!-- åŸå¸‚ä¿¡æ¯é¢æ¿ -->
    <div id="city-info-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50 bg-black/70 p-4">
      <div class="bg-white rounded-2xl shadow-2xl w-full h-5/6 max-w-2xl md:max-w-4xl lg:max-w-6xl flex flex-col relative">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-4 md:p-6 rounded-t-2xl flex justify-between items-center gap-4">
          <div class="min-w-0">
            <h2 class="text-2xl md:text-4xl font-bold truncate" id="city-info-title">åŸå¸‚ä¿¡æ¯</h2>
            <p class="text-blue-100 text-xs md:text-sm mt-1 truncate" id="city-info-subtitle"></p>
          </div>
          <button onclick="game.closeCityInfoModal()" class="text-white hover:bg-white/20 rounded-full p-2 text-xl md:text-2xl flex-shrink-0">âœ•</button>
        </div>

        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 bg-gray-50 overflow-x-auto">
          <button class="city-info-tab flex-1 min-w-max py-3 md:py-4 px-4 md:px-6 text-sm md:text-lg font-bold text-center cursor-pointer border-b-4 border-blue-600 text-blue-600 transition whitespace-nowrap" data-tab="properties">
            ğŸ  åœ°äº§ä¸å»ºç­‘
          </button>
          <button class="city-info-tab flex-1 min-w-max py-3 md:py-4 px-4 md:px-6 text-sm md:text-lg font-bold text-center cursor-pointer border-b-4 border-transparent text-gray-600 hover:text-gray-800 transition whitespace-nowrap" data-tab="info">
            ğŸ“– åŸå¸‚ä¿¡æ¯
          </button>
        </div>

        <!-- Content Area -->
        <div class="flex-1 overflow-y-auto">
          <!-- Properties Tab (merged with buildings) -->
          <div id="city-info-properties-tab" class="city-info-tab-content p-4 md:p-8">
            <!-- Player Money Display -->
            <div class="mb-6 bg-gradient-to-r from-yellow-50 to-orange-50 p-4 rounded-lg border-2 border-yellow-200">
              <p class="text-center text-lg md:text-xl font-bold text-gray-800">
                ğŸ’° æŒæœ‰èµ„é‡‘: <span class="text-yellow-600" id="city-info-player-money">0</span> å…ƒ
              </p>
            </div>
            
            <!-- Destination indicator -->
            <div id="city-info-dest-indicator" class="mb-4 bg-yellow-100 text-center py-2 px-4 rounded-full text-sm font-bold text-yellow-700 border-2 border-yellow-400 hidden">
              ğŸ¯ å½“å‰ç›®çš„åœ°ï¼
            </div>
            
            <!-- Combined Properties & Buildings List -->
            <div id="city-info-properties-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
              <!-- Combined property and building cards injected here -->
            </div>
            <div id="city-info-empty-properties" class="text-center text-gray-500 py-12 col-span-full">
              <p class="text-xl md:text-2xl">æš‚æ— åœ°äº§ä¸å»ºç­‘ ğŸœï¸</p>
            </div>
            
            <!-- Monopoly hint -->
            <div class="mt-6 bg-purple-50 p-4 rounded-lg border-2 border-purple-200 text-center">
              <p class="text-sm md:text-base text-purple-700 font-bold">
                <span id="city-info-monopoly-hint">ğŸ’¡ ä¹°é½3ç§ç‰©ä»¶å¯è·å¾—ç‹¬å åŠ æˆ(æ”¶ç›Šx2)</span>
              </p>
            </div>
          </div>

          <!-- Info Tab -->
          <div id="city-info-info-tab" class="city-info-tab-content hidden p-4 md:p-8 overflow-x-hidden">
            <div id="city-llm-content" class="prose prose-sm md:prose-lg max-w-none">
              <div class="flex items-center justify-center py-12">
                <div class="text-center">
                  <div class="animate-spin text-4xl mb-4">â³</div>
                  <p class="text-gray-500 text-lg md:text-xl">æ­£åœ¨åŠ è½½åŸå¸‚ä¿¡æ¯...</p>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Footer -->
        <div class="border-t border-gray-200 bg-gray-50 p-4 md:p-6 rounded-b-2xl flex justify-end gap-2 md:gap-4">
          <button onclick="game.closeCityInfoModal()" class="px-4 md:px-8 py-2 md:py-3 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold rounded-lg transition text-sm md:text-base">
            å…³é—­
          </button>
        </div>
      </div>
    </div>

    <script>
      /**
       * DiceAnimation - 3Déª°å­åŠ¨ç”»ç±»
       * ä» dice_roller_3d.html ç§»æ¤çš„å®Œæ•´éª°å­åŠ¨ç”»
       */
      class DiceAnimation {
        constructor() {
          this.modal = document.getElementById('dice-modal');
          this.stage = document.getElementById('dice-stage');
          this.camera = document.getElementById('dice-camera');
          this.resultEl = document.getElementById('dice-result');
          this.resultValueEl = document.getElementById('dice-result-value');
          
          this.isRolling = false;
          this.duration = 1200; // Animation duration in ms
          
          // Target rotations for each dice face (which face lands up)
          this.targetRotations = {
            1: { x: 90, y: 0, z: 0 },   
            2: { x: 0, y: 0, z: 0 },    
            3: { x: 0, y: 0, z: 90 },   
            4: { x: 0, y: 0, z: -90 },  
            5: { x: 180, y: 0, z: 0 },  
            6: { x: -90, y: 0, z: 0 },  
          };
          
          // Dot positions for each face value (0-8 grid positions)
          this.dotMap = {
            1: [4],
            2: [0, 8],
            3: [0, 4, 8],
            4: [0, 2, 6, 8],
            5: [0, 2, 4, 6, 8],
            6: [0, 2, 3, 5, 6, 8]
          };
        }
        
        /**
         * Create HTML for a single dice face
         * @param {number} number - Face value (1-6)
         * @returns {string} HTML string
         */
        _createFaceHTML(number) {
          const activeDots = this.dotMap[number] || [];
          let dotsHTML = '';
          for (let i = 0; i < 9; i++) {
            if (activeDots.includes(i)) {
              dotsHTML += `<div class="die-dot" style="grid-area: ${Math.floor(i / 3) + 1} / ${(i % 3) + 1}"></div>`;
            }
          }
          return `<div class="die-face die-face-${number}">${dotsHTML}</div>`;
        }
        
        /**
         * Render dice elements
         * @param {number} count - Number of dice
         */
        _renderDice(count) {
          this.camera.innerHTML = '';
          const spacing = 20;
          
          for (let i = 0; i < count; i++) {
            const dieWrapper = document.createElement('div');
            dieWrapper.className = 'die-wrapper';
            dieWrapper.style.transform = `translate3d(${i * spacing}px, 0, ${i * -spacing}px)`;
            
            const die = document.createElement('div');
            die.className = 'die';
            die.dataset.index = i;
            
            // Create all 6 faces
            let facesHTML = '';
            [1, 6, 2, 5, 3, 4].forEach(n => facesHTML += this._createFaceHTML(n));
            die.innerHTML = facesHTML;
            
            dieWrapper.appendChild(die);
            
            // Add shadow
            const shadow = document.createElement('div');
            shadow.className = 'die-shadow';
            dieWrapper.appendChild(shadow);
            
            this.camera.appendChild(dieWrapper);
          }
        }
        
        /**
         * Generate random result for a single die
         * @returns {Object} Result with value and rotation angles
         */
        _generateResult() {
          const val = Math.ceil(Math.random() * 6);
          const base = this.targetRotations[val];
          const spins = 2 + Math.floor(Math.random() * 3);
          
          return {
            value: val,
            x: base.x + (spins * 360),
            y: base.y + (Math.floor(Math.random() * 2) * 360),
            z: base.z + (spins * 360)
          };
        }
        
        /**
         * Roll dice with animation
         * @param {number} diceCount - Number of dice to roll
         * @returns {Promise<{results: number[], total: number}>}
         */
        roll(diceCount = 1) {
          return new Promise((resolve) => {
            if (this.isRolling) {
              resolve({ results: [], total: 0 });
              return;
            }
            
            this.isRolling = true;
            
            // Render dice
            this._renderDice(diceCount);
            
            // Show modal
            this.modal.classList.add('show');
            this.resultEl.classList.remove('show');
            
            // Reset and trigger fly-in animation
            this.stage.classList.remove('entering');
            void this.stage.offsetWidth; // Force reflow
            this.stage.classList.add('entering');
            
            // Generate results
            const results = [];
            let total = 0;
            for (let i = 0; i < diceCount; i++) {
              const res = this._generateResult();
              results.push(res);
              total += res.value;
            }
            
            // Apply rotation animations
            const diceEls = this.camera.querySelectorAll('.die');
            const easing = "cubic-bezier(0.1, 0.9, 0.2, 1)";
            
            diceEls.forEach((die, idx) => {
              const target = results[idx];
              die.style.transition = `transform ${this.duration}ms ${easing}`;
              die.style.transform = `rotateX(${target.x}deg) rotateY(${target.y}deg) rotateZ(${target.z}deg)`;
            });
            
            // Show result after animation
            setTimeout(() => {
              this.resultValueEl.textContent = total;
              this.resultEl.classList.add('show');
            }, this.duration);
            
            // Hide modal and resolve after showing result
            setTimeout(() => {
              this.isRolling = false;
              this.modal.classList.remove('show');
              this.stage.classList.remove('entering');
              
              resolve({ 
                results: results.map(r => r.value), 
                total: total 
              });
            }, this.duration + 800);
          });
        }
        
        /**
         * Set animation duration
         * @param {number} ms - Duration in milliseconds
         */
        setDuration(ms) {
          this.duration = Math.max(500, ms);
        }
      }

      // Create global dice animation instance
      const diceAnimation = new DiceAnimation();

      /**
       * 3D Metro Tycoon Game Engine (Three.js Edition)
       */

      // --- Constants & Config ---
      const TILE_SIZE = 4; // World unit size for a tile
      const TILE_SPACING = 0.2; // Gap between tiles
      const COLORS = {
        bg: 0x87ceeb, // Sky Blue
        ground: 0x1a1a20,

        // Tile Materials
        blue: 0x3b82f6, // Money +
        red: 0xef4444, // Money -
        yellow: 0xeab308, // Event
        green: 0x22c55e, // Station
        start: 0xffffff, // Start

        road: 0x9ca3af, // Plain Road
        env_nature: 0x15803d, // Nature
        env_culture: 0x52525b, // Culture

        // Buildings
        building: [0x60a5fa, 0x818cf8, 0xa78bfa],
      };

      const BUILDING_COSTS = [1000, 5000, 20000];
      const BUILDING_NAMES = ["æ‹‰é¢æ‘Š", "å•†åŠ¡é…’åº—", "æ‘©å¤©å¤§æ¥¼"];
      const BUILDING_INCOME = [200, 800, 4000];

      // ç›®çš„åœ°å¥–åŠ±é‡‘é¢
      const DESTINATION_REWARD = 5000;

      // æˆ¿äº§ç›¸å…³å¸¸é‡
      const PROPERTY_PRICE_RANGE = [3000, 8000]; // æˆ¿äº§ä»·æ ¼èŒƒå›´
      const INITIAL_PLAYER_MONEY = 30000; // ç©å®¶åˆå§‹èµ„é‡‘

      // --- ç©·ç¥ç³»ç»Ÿ ---
      // æ¶ˆæ¯ä¸­çš„ {playerName} ä¼šåœ¨æ˜¾ç¤ºæ—¶æ ¹æ®ç©å®¶ç±»å‹æ›¿æ¢ï¼šç”¨æˆ·æ˜¾ç¤º"ä½ "ï¼ŒAIæ˜¾ç¤ºç©å®¶åå­—
      const BINBOUGAMI_EFFECTS = {
        // æ™®é€šç©·ç¥æ•ˆæœ
        normal: [
          { type: "loseMoney", min: 300, max: 1500, msg: "ç©·ç¥å·èµ°äº†{playerName}çš„é’±ï¼" },
          { type: "loseMoney", min: 500, max: 2000, msg: "ç©·ç¥è¯·å®¢åƒé¥­ï¼Œç”¨çš„æ˜¯{playerName}çš„é’±ï¼" },
          { type: "sellProperty", msg: "ç©·ç¥å¼ºè¡ŒåŠä»·å–æ‰äº†{playerName}çš„ç‰©ä»¶ï¼" },
          { type: "nothing", msg: "ç©·ç¥ä»Šå¤©å¿ƒæƒ…å¥½ï¼Œæ”¾è¿‡{playerName}äº†~" },
          { type: "loseMoney", min: 200, max: 800, msg: "ç©·ç¥æ‰“ç¢äº†{playerName}çš„å­˜é’±ç½ï¼" },
        ],
        // å¤§é­”ç‹ç©·ç¥æ•ˆæœï¼ˆå‡çº§åï¼‰
        king: [
          { type: "loseMoney", min: 2000, max: 5000, msg: "å¤§é­”ç‹ç©·ç¥ç–¯ç‹‚åå™¬{playerName}çš„è´¢äº§ï¼" },
          { type: "sellAllProperty", msg: "å¤§é­”ç‹ç©·ç¥åå™¬äº†{playerName}æ‰€æœ‰çš„ç‰©ä»¶ï¼" },
          { type: "debt", min: 3000, max: 8000, msg: "å¤§é­”ç‹ç©·ç¥è®©{playerName}èƒŒä¸Šå·¨é¢å€ºåŠ¡ï¼" },
          { type: "loseMoney", min: 1500, max: 4000, msg: "å¤§é­”ç‹ç©·ç¥å¬å¼€è±ªåå®´ä¼šï¼Œè´¦å•ç»™{playerName}ï¼" },
        ],
      };
      // ç©·ç¥å‡çº§æ‰€éœ€çš„å›åˆæ•°
      const BINBOUGAMI_UPGRADE_TURNS = 8;

      // --- å¡ç‰Œç³»ç»Ÿ ---
      const CARD_TYPES = {
        // ç§»åŠ¨ç±»å¡ç‰Œ
        express: { name: "æ€¥è¡Œå¡", desc: "æ·2ä¸ªéª°å­", icon: "ğŸšƒ", type: "move", diceCount: 2, rarity: "common", price: 500 },
        superExpress: { name: "ç‰¹æ€¥å¡", desc: "æ·3ä¸ªéª°å­", icon: "ğŸš„", type: "move", diceCount: 3, rarity: "rare", price: 1500 },
        rocket: { name: "ç«ç®­å¡", desc: "æ·4ä¸ªéª°å­", icon: "ğŸš€", type: "move", diceCount: 4, rarity: "epic", price: 3000 },
        backward: { name: "åé€€å¡", desc: "å¯ä»¥å‘åç§»åŠ¨", icon: "âª", type: "special", effect: "backward", rarity: "common", price: 300 },
        teleport: { name: "ä»»æ„é—¨", desc: "ä¼ é€åˆ°ä»»æ„è½¦ç«™", icon: "ğŸšª", type: "special", effect: "teleport", rarity: "legendary", price: 5000 },

        // æ”»å‡»/å¦¨ç¢ç±»å¡ç‰Œ
        hibernate: { name: "å†¬çœ å¡", desc: "è®©å¯¹æ‰‹åœ1å›åˆ", icon: "ğŸ’¤", type: "attack", effect: "skip", rarity: "rare", price: 1200 },
        fart: { name: "æ”¾å±å¡", desc: "å¹é£å¯¹æ‰‹1-3æ ¼", icon: "ğŸ’¨", type: "attack", effect: "blowAway", rarity: "common", price: 600 },
        trap: { name: "é™·é˜±å¡", desc: "åœ¨å½“å‰æ ¼å­è®¾ç½®é™·é˜±", icon: "ğŸ•³ï¸", type: "attack", effect: "trap", rarity: "rare", price: 800 },

        // é˜²å¾¡/ç‰¹æ®Šç±»å¡ç‰Œ
        shield: { name: "æŠ¤èº«ç¬¦", desc: "å…ç–«ä¸€æ¬¡ç©·ç¥æ•ˆæœ", icon: "ğŸ›¡ï¸", type: "defense", effect: "immunity", rarity: "rare", price: 2000 },
        exorcism: { name: "é©±é­”ç¬¦", desc: "ç«‹å³é©±é™¤ç©·ç¥", icon: "ğŸ“¿", type: "special", effect: "exorcise", rarity: "epic", price: 4000 },
        doubleIncome: { name: "å€æ”¶å¡", desc: "ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€", icon: "ğŸ’", type: "buff", effect: "doubleIncome", rarity: "epic", price: 3500 },
      };

      // å¡ç‰ŒæŠ½å–æ± ï¼ˆæŒ‰ç¨€æœ‰åº¦åˆ†ç±»ï¼‰
      const CARD_POOL = {
        common: ["express", "backward", "fart"],
        rare: ["superExpress", "hibernate", "trap", "shield"],
        epic: ["rocket", "exorcism", "doubleIncome"],
        legendary: ["teleport"],
      };

      // æœ€å¤§æ‰‹ç‰Œæ•°
      const MAX_HAND_SIZE = 8;
      // ä¸€å¹´çš„å›åˆæ•°ï¼ˆæ¯æœˆä¸€å›åˆï¼Œ12å›åˆ=1å¹´ï¼Œ3æœˆå†³ç®—ï¼‰
      const TURNS_PER_YEAR = 12;
      const SETTLEMENT_MONTH = 3; // 3æœˆå†³ç®—

      // æˆ¿äº§ç¼“å­˜ç³»ç»Ÿ - è¿½è¸ªæˆ¿äº§çš„è´­ä¹°çŠ¶æ€å’Œå·²è´­ä¹°æˆ¿äº§çš„å›ºå®šæ•°æ®
      const PROPERTIES_CACHE = {};
      function initializePropertiesCache() {
        PROPERTIES_CACHE.homes = {}; // æŒ‰åŸå¸‚å­˜å‚¨æˆ¿äº§: { cityName: [homes...] }
      }
      function getOrCreatePropertyId(cityName, propertyIndex) {
        if (!PROPERTIES_CACHE.homes[cityName]) {
          PROPERTIES_CACHE.homes[cityName] = [];
        }
        const key = `${cityName}_${propertyIndex}`;
        if (!PROPERTIES_CACHE.homes[cityName][propertyIndex]) {
          PROPERTIES_CACHE.homes[cityName][propertyIndex] = {
            id: key,
            cityName: cityName,
            index: propertyIndex,
            purchasedBy: null, // è´­ä¹°è€…çš„ç©å®¶IDï¼Œnullè¡¨ç¤ºæœªè´­ä¹°
            purchasePrice: null,
            // ä»¥ä¸‹å­—æ®µåœ¨è´­ä¹°æ—¶ä¼šè¢«å¡«å……ï¼Œç”¨äºä¿æŒå·²è´­ä¹°æˆ¿äº§çš„æ•°æ®ä¸å˜
            cachedData: null  // { level, price, income, playerId, playerName, avatar, homeName, isOnline }
          };
        }
        return PROPERTIES_CACHE.homes[cityName][propertyIndex];
      }

      // --- Terrain Color Legend (from terrain PNG files) ---
      // Height categories:
      // - flat: same height as road tiles (1 unit) - urban, crops, scrub, wetland
      // - varied: random height variation - forest, snow, barren
      // - grass: slight variation with optional decorations
      const TERRAIN_COLORS = {
        '#000000': { type: 'ocean', height: -1, color: 0x000000, label: 'æµ·æ´‹', heightType: 'water' },
        '#1A5BAB': { type: 'water', height: -1, color: 0x1A5BAB, label: 'æ°´åŸŸ', heightType: 'water' },
        '#358221': { type: 'forest', height: 2, color: 0x358221, label: 'æ£®æ—', heightType: 'varied', minHeight: 2, maxHeight: 5, treeChance: 0.8 },
        '#A7D282': { type: 'grass', height: 1, color: 0xA7D282, label: 'è‰åœ°', heightType: 'varied', minHeight: 1, maxHeight: 1.8, treeChance: 0.15 },
        '#90C090': { type: 'urban', height: 1, color: 0x90C090, label: 'åŸå¸‚', heightType: 'flat', treeChance: 0.15 },
        '#FFDB5C': { type: 'crops', height: 1, color: 0xFFDB5C, label: 'è€•åœ°', heightType: 'varied', minHeight: 1, maxHeight: 1.6, treeChance: 0.08 },
        '#EECFA8': { type: 'scrub', height: 1, color: 0xEECFA8, label: 'çŒæœ¨', heightType: 'varied', minHeight: 1, maxHeight: 1.8, treeChance: 0.12 },
        '#EDE9E4': { type: 'barren', height: 1, color: 0xEDE9E4, label: 'è’æ¼ ', heightType: 'varied', minHeight: 1, maxHeight: 3 },
        '#F2F2F2': { type: 'snow', height: 3, color: 0xF2F2F2, label: 'é›ªå±±', heightType: 'varied', minHeight: 3, maxHeight: 6 },
        '#419BDF': { type: 'wetland', height: 0, color: 0x419BDF, label: 'æ¹¿åœ°', heightType: 'flat', treeChance: 0.15 }
      };

      // Terrain tile constants
      // Each terrain tile is a 2x2 degree PNG file
      // The actual image resolution (e.g., 512x512) doesn't matter for terrain type determination
      // We ray trace into the image at specific lon/lat coordinates to sample terrain colors
      const TERRAIN_TILE_DEGREES = 2; // Each terrain tile covers 2x2 degrees of lon/lat
      const MAX_CACHED_TERRAIN_TILES = 32; // Maximum number of cached terrain tile image data
      const TERRAIN_LOAD_RADIUS = 1; // Load 3x3 = 9 terrain tiles around camera (radius 1 means current + neighbors)
      const TERRAIN_CDN_BASE = 'https://cdn.keepwork.com/worldmap/';

      /**
       * TerrainTileManager - Manages loading, caching, and rendering of terrain tiles
       * 
       * Each terrain tile:
       * - Covers a fixed 2x2 degree area of the Earth (aligned to even degree boundaries)
       * - Is stored as a PNG image on CDN (e.g., terrain_72_74_18_20.png)
       * - Contains 200x200 pixels, each pixel = one terrain block
       * - Is loaded on-demand based on camera position
       * 
       * Typically 9 tiles (3x3 grid) are loaded around the camera view.
       * Up to 32 tiles can be cached in memory using LRU eviction.
       */
      class TerrainTileManager {
        constructor(scene, game) {
          this.scene = scene;
          this.game = game;
          
          // Cache for terrain tiles: key = "lonFrom_lonTo_latFrom_latTo"
          // Each tile contains imageData (pixel colors) and rendered meshGroup
          this.terrainTiles = new Map();
          // LRU order tracking for cache eviction
          this.tileAccessOrder = [];
          
          // Currently visible terrain tile keys (typically 9 tiles)
          this.visibleTiles = new Set();
          
          // Loading promises to prevent duplicate loads
          this.loadingPromises = new Map();
          
          // THREE.js group for terrain meshes
          this.terrainGroup = new THREE.Group();
          this.terrainGroup.name = 'terrainGroup';
          this.scene.add(this.terrainGroup);
          
          // Materials cache for terrain types
          this.terrainMaterials = {};
          this.initTerrainMaterials();
          
          // Block geometry (reused for all terrain blocks)
          this.blockGeometry = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
          
          // Current center position (in lon/lat)
          this.centerLon = 0;
          this.centerLat = 0;
        }

        initTerrainMaterials() {
          for (const [hexColor, data] of Object.entries(TERRAIN_COLORS)) {
            this.terrainMaterials[data.type] = new THREE.MeshLambertMaterial({ 
              color: data.color 
            });
          }
          // Default material for unknown terrain
          this.terrainMaterials['default'] = new THREE.MeshLambertMaterial({ color: 0x808080 });
        }

        /**
         * Get terrain tile key from longitude and latitude
         * Tiles are aligned to 2-degree boundaries
         */
        getTileKey(lon, lat) {
          const lonFrom = Math.floor(lon / TERRAIN_TILE_DEGREES) * TERRAIN_TILE_DEGREES;
          const latFrom = Math.floor(lat / TERRAIN_TILE_DEGREES) * TERRAIN_TILE_DEGREES;
          const lonTo = lonFrom + TERRAIN_TILE_DEGREES;
          const latTo = latFrom + TERRAIN_TILE_DEGREES;
          return `${lonFrom}_${lonTo}_${latFrom}_${latTo}`;
        }

        /**
         * Parse tile key back to bounds
         */
        parseTileKey(key) {
          const [lonFrom, lonTo, latFrom, latTo] = key.split('_').map(Number);
          return { lonFrom, lonTo, latFrom, latTo };
        }

        /**
         * Get the terrain image URL for a tile
         */
        getTileImageUrl(lonFrom, lonTo, latFrom, latTo) {
          return `${TERRAIN_CDN_BASE}terrain_${lonFrom}_${lonTo}_${latFrom}_${latTo}.png`;
        }

        /**
         * Load a terrain tile image and cache its pixel data
         */
        async loadTerrainTile(key) {
          // Check if already loading
          if (this.loadingPromises.has(key)) {
            return this.loadingPromises.get(key);
          }

          // Check if already cached
          if (this.terrainTiles.has(key)) {
            this.updateLRU(key);
            return this.terrainTiles.get(key);
          }

          const { lonFrom, lonTo, latFrom, latTo } = this.parseTileKey(key);
          const imageUrl = this.getTileImageUrl(lonFrom, lonTo, latFrom, latTo);

          const loadPromise = new Promise(async (resolve) => {
            try {
              const img = new Image();
              img.crossOrigin = 'anonymous';
              
              await new Promise((imgResolve, imgReject) => {
                img.onload = imgResolve;
                img.onerror = imgReject;
                img.src = imageUrl;
              });

              // Create canvas to read pixel data
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              
              const imageData = ctx.getImageData(0, 0, img.width, img.height);
              
              // Debug: Log sample pixel colors from the loaded image
              console.log(`Loaded terrain image ${key}: ${img.width}x${img.height}`);
              const samplePixels = [];
              for (let i = 0; i < 5; i++) {
                const px = Math.floor(Math.random() * img.width);
                const py = Math.floor(Math.random() * img.height);
                const idx = (py * img.width + px) * 4;
                const r = imageData.data[idx];
                const g = imageData.data[idx + 1];
                const b = imageData.data[idx + 2];
                const a = imageData.data[idx + 3];
                const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0').toUpperCase()).join('');
                samplePixels.push({ px, py, r, g, b, a, hex });
              }
              // console.log('Sample pixel colors:', samplePixels);
              
              const tileData = {
                key,
                lonFrom, lonTo, latFrom, latTo,
                imageData,
                width: img.width,
                height: img.height,
                meshGroup: null, // Will be created when rendering
                visible: false,
                loaded: true
              };

              // Evict oldest tiles if cache is full
              this.evictOldTiles();
              
              this.terrainTiles.set(key, tileData);
              this.updateLRU(key);
              
              // console.log(`Loaded terrain tile: ${key}`);
              resolve(tileData);
            } catch (error) {
              console.warn(`Failed to load terrain tile ${key}:`, error);
              // Create empty tile data for failed loads
              const emptyTileData = {
                key,
                lonFrom, lonTo, latFrom, latTo,
                imageData: null,
                width: TERRAIN_IMAGE_SIZE,
                height: TERRAIN_IMAGE_SIZE,
                meshGroup: null,
                visible: false,
                loaded: false
              };
              this.terrainTiles.set(key, emptyTileData);
              this.updateLRU(key);
              resolve(emptyTileData);
            } finally {
              this.loadingPromises.delete(key);
            }
          });

          this.loadingPromises.set(key, loadPromise);
          return loadPromise;
        }

        /**
         * Update LRU order
         */
        updateLRU(key) {
          const index = this.tileAccessOrder.indexOf(key);
          if (index > -1) {
            this.tileAccessOrder.splice(index, 1);
          }
          this.tileAccessOrder.push(key);
        }

        /**
         * Evict oldest tiles when cache is full
         */
        evictOldTiles() {
          while (this.terrainTiles.size >= MAX_CACHED_TERRAIN_TILES && this.tileAccessOrder.length > 0) {
            const oldestKey = this.tileAccessOrder.shift();
            const tile = this.terrainTiles.get(oldestKey);
            if (tile) {
              // Remove mesh from scene
              if (tile.meshGroup) {
                this.terrainGroup.remove(tile.meshGroup);
                // Dispose geometries and materials
                tile.meshGroup.traverse((child) => {
                  if (child.geometry) child.geometry.dispose();
                });
                tile.meshGroup = null;
              }
              this.terrainTiles.delete(oldestKey);
              this.visibleTiles.delete(oldestKey);
              console.log(`Evicted terrain tile: ${oldestKey}`);
            }
          }
        }

        /**
         * Get pixel color at specific position in the terrain image
         */
        getPixelColor(tileData, localX, localY) {
          if (!tileData || !tileData.imageData) return null;
          
          const x = Math.floor(localX);
          const y = Math.floor(localY);
          
          if (x < 0 || x >= tileData.width || y < 0 || y >= tileData.height) return null;
          
          const index = (y * tileData.width + x) * 4;
          const r = tileData.imageData.data[index];
          const g = tileData.imageData.data[index + 1];
          const b = tileData.imageData.data[index + 2];
          
          return { r, g, b };
        }

        /**
         * Convert RGB to hex string for lookup
         */
        rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0').toUpperCase()).join('');
        }

        /**
         * Find closest terrain color from the legend
         */
        findClosestTerrainType(r, g, b) {
          const hexColor = this.rgbToHex(r, g, b);
          
          // Direct match
          if (TERRAIN_COLORS[hexColor]) {
            return TERRAIN_COLORS[hexColor];
          }
          
          // Find closest color by distance
          let closestType = null;
          let minDistance = Infinity;
          
          for (const [hex, data] of Object.entries(TERRAIN_COLORS)) {
            const tr = parseInt(hex.slice(1, 3), 16);
            const tg = parseInt(hex.slice(3, 5), 16);
            const tb = parseInt(hex.slice(5, 7), 16);
            
            const distance = Math.sqrt(
              Math.pow(r - tr, 2) + 
              Math.pow(g - tg, 2) + 
              Math.pow(b - tb, 2)
            );
            
            if (distance < minDistance) {
              minDistance = distance;
              closestType = data;
            }
          }
          
          return closestType || { type: 'default', height: 1, color: 0x808080 };
        }

        /**
         * Get terrain data at a specific world coordinate
         * @param worldX - World X coordinate (corresponds to longitude)
         * @param worldZ - World Z coordinate (corresponds to latitude, inverted)
         * @param centerLon - Center longitude of the map
         * @param centerLat - Center latitude of the map
         */
        getTerrainAt(worldX, worldZ, centerLon, centerLat) {
          // Convert world coordinates to lon/lat
          // worldX/Z are grid coordinates * TILE_SIZE, and grid coords = (lon/lat - center) * CONFIG_SCALE
          const configScale = this.game?.configScale || 70;
          const lon = centerLon + (worldX / TILE_SIZE) / configScale;
          const lat = centerLat - (worldZ / TILE_SIZE) / configScale;
          
          const key = this.getTileKey(lon, lat);
          const tileData = this.terrainTiles.get(key);
          
          if (!tileData || !tileData.imageData) return null;
          
          // Calculate local position within the tile (0 to TERRAIN_TILE_DEGREES)
          const localLon = lon - tileData.lonFrom;
          const localLat = tileData.latTo - lat; // Y is inverted in image
          
          // Convert to pixel coordinates using actual image dimensions
          const pixelsPerDegree = tileData.width / TERRAIN_TILE_DEGREES;
          const pixelX = localLon * pixelsPerDegree;
          const pixelY = localLat * pixelsPerDegree;
          
          const color = this.getPixelColor(tileData, pixelX, pixelY);
          if (!color) return null;
          
          return this.findClosestTerrainType(color.r, color.g, color.b);
        }

        /**
         * Create mesh for a terrain tile (called after loading)
         * Ray traces into the image at world grid positions to determine terrain type
         */
        createTerrainMesh(tileData, centerLon, centerLat, CONFIG_SCALE) {
          if (tileData.meshGroup) return; // Already created
          if (!tileData.imageData) return; // No data to render
          
          const meshGroup = new THREE.Group();
          meshGroup.name = `terrain_${tileData.key}`;
          
          // Spatial chunk size for instanced meshes (16x16 grid cells)
          const CHUNK_SIZE = 16;
          
          // Create a water plane for this terrain tile
          // Calculate tile bounds in world coordinates
          const minGridX = Math.floor((tileData.lonFrom - centerLon) * CONFIG_SCALE);
          const maxGridX = Math.ceil((tileData.lonTo - centerLon) * CONFIG_SCALE);
          const minGridZ = Math.floor(-(tileData.latTo - centerLat) * CONFIG_SCALE);
          const maxGridZ = Math.ceil(-(tileData.latFrom - centerLat) * CONFIG_SCALE);
          
          // Calculate water plane size and position
          const tileSizeX = (maxGridX - minGridX) * TILE_SIZE;
          const tileSizeZ = (maxGridZ - minGridZ) * TILE_SIZE;
          const tileCenterX = (minGridX + maxGridX) / 2 * TILE_SIZE;
          const tileCenterZ = (minGridZ + maxGridZ) / 2 * TILE_SIZE;
          
          // Add water plane for this tile
          const waterGeo = new THREE.PlaneGeometry(tileSizeX, tileSizeZ);
          const waterMat = new THREE.MeshLambertMaterial({ color: 0x1e3a8a }); // Deep blue ocean
          const waterMesh = new THREE.Mesh(waterGeo, waterMat);
          waterMesh.rotation.x = -Math.PI / 2;
          waterMesh.position.set(tileCenterX, -0.5, tileCenterZ);
          waterMesh.receiveShadow = false;
          meshGroup.add(waterMesh);
          
          // Calculate pixels per degree from actual image size
          const pixelsPerDegree = tileData.width / TERRAIN_TILE_DEGREES;
          
          // Helper to get chunk key from grid coordinates
          const getChunkKey = (gridX, gridZ) => {
            const chunkX = Math.floor(gridX / CHUNK_SIZE);
            const chunkZ = Math.floor(gridZ / CHUNK_SIZE);
            return `${chunkX},${chunkZ}`;
          };
          
          // Group blocks by chunk AND terrain type for spatially chunked instancing
          // Structure: { chunkKey: { terrainType: Map<posKey, blockData> } }
          const blocksByChunk = {};
          
          // Debug: count terrain types found
          const terrainTypeCounts = {};
          
          // Iterate over game world grid positions that fall within this tile
          // (reusing minGridX, maxGridX, minGridZ, maxGridZ calculated above for water plane)
          
          for (let gridX = minGridX; gridX <= maxGridX; gridX++) {
            for (let gridZ = minGridZ; gridZ <= maxGridZ; gridZ++) {
              const key = `${gridX},${gridZ}`;
              
              // Skip positions that already have road/station tiles
              if (this.tilesMap && this.tilesMap.has(key)) {
                continue;
              }
              
              // Convert grid position to lon/lat
              const lon = centerLon + gridX / CONFIG_SCALE;
              const lat = centerLat - gridZ / CONFIG_SCALE;
              
              // Check if this position is within this tile's bounds
              if (lon < tileData.lonFrom || lon >= tileData.lonTo ||
                  lat < tileData.latFrom || lat >= tileData.latTo) {
                continue;
              }
              
              // Calculate pixel position in image
              const localLon = lon - tileData.lonFrom;
              const localLat = tileData.latTo - lat; // Y is inverted in image
              const px = Math.floor(localLon * pixelsPerDegree);
              const py = Math.floor(localLat * pixelsPerDegree);
              
              const color = this.getPixelColor(tileData, px, py);
              if (!color) continue;
              
              const terrain = this.findClosestTerrainType(color.r, color.g, color.b);
              
              // Count terrain types for debugging
              terrainTypeCounts[terrain.type] = (terrainTypeCounts[terrain.type] || 0) + 1;
              
              // Skip water types (ocean plane handles them)
              if (terrain.type === 'water' || terrain.type === 'ocean') continue;
              
              // Get chunk key for this position
              const chunkKey = getChunkKey(gridX, gridZ);
              
              if (!blocksByChunk[chunkKey]) {
                blocksByChunk[chunkKey] = {};
              }
              if (!blocksByChunk[chunkKey][terrain.type]) {
                blocksByChunk[chunkKey][terrain.type] = new Map();
              }
              
              // Generate random height based on terrain type using position-based seed for consistency
              const seed = (gridX * 73856093) ^ (gridZ * 19349663);
              const pseudoRandom = ((seed % 1000) / 1000);
              
              let blockHeight = 1; // Default flat height (same as road tiles)
              const terrainConfig = Object.values(TERRAIN_COLORS).find(t => t.type === terrain.type);
              
              if (terrainConfig && terrainConfig.heightType === 'varied') {
                const minH = terrainConfig.minHeight || 1;
                const maxH = terrainConfig.maxHeight || 3;
                blockHeight = minH + pseudoRandom * (maxH - minH);
              } else {
                blockHeight = 1;
              }
              
              // Only add if not already occupied
              const posKey = `${gridX},${gridZ}`;
              if (!blocksByChunk[chunkKey][terrain.type].has(posKey)) {
                blocksByChunk[chunkKey][terrain.type].set(posKey, {
                  x: gridX * TILE_SIZE,
                  z: gridZ * TILE_SIZE,
                  height: blockHeight,
                  seed: seed // Store seed for consistent decoration generation
                });
              }
            }
          }
          
          // Create terrain meshes with optimized instanced rendering
          // All terrain types now use instanced meshes with scale for varied heights
          
          // Shared tree/bush geometries for instanced decoration
          const treeGeo = new THREE.ConeGeometry(0.8, 2.5, 6);
          const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
          const tallTreeGeo = new THREE.ConeGeometry(1.2, 4, 6);
          const tallTreeMat = new THREE.MeshLambertMaterial({ color: 0x0d3d1a });
          const bushGeo = new THREE.ConeGeometry(0.6, 1.8, 6);
          const bushMat = new THREE.MeshLambertMaterial({ color: 0x5d6d3a });
          
          // Decoration config per terrain type: { chance, geo, mat, heightOffset, useOffset }
          const decorationConfig = {
            forest: { chance: 0.7, geo: tallTreeGeo, mat: tallTreeMat, heightOffset: 2, useOffset: true },
            grass: { chance: 0.15, geo: treeGeo, mat: treeMat, heightOffset: 1.25, useOffset: false },
            crops: { chance: 0.08, geo: treeGeo, mat: treeMat, heightOffset: 1.25, useOffset: false },
            scrub: { chance: 0.12, geo: bushGeo, mat: bushMat, heightOffset: 0.9, useOffset: true, offsetScale: 0.5 }
          };
          
          // Unit box geometry (1x1x1) - will be scaled per instance
          const unitBoxGeo = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
          
          // Helper matrices for instancing
          const matrix = new THREE.Matrix4();
          const posVec = new THREE.Vector3();
          const scaleVec = new THREE.Vector3();
          const quaternion = new THREE.Quaternion();
          
          // Create meshes by spatial chunk, each chunk containing instanced meshes by terrain type
          let totalBlocks = 0;
          let chunkCount = 0;
          
          for (const [chunkKey, blocksByType] of Object.entries(blocksByChunk)) {
            // Create a group for this spatial chunk
            const chunkGroup = new THREE.Group();
            const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
            chunkGroup.name = `chunk_${chunkKey}`;
            
            // Calculate chunk center for potential frustum culling
            const chunkCenterX = (chunkX + 0.5) * CHUNK_SIZE * TILE_SIZE;
            const chunkCenterZ = (chunkZ + 0.5) * CHUNK_SIZE * TILE_SIZE;
            chunkGroup.userData.chunkCenter = new THREE.Vector3(chunkCenterX, 0, chunkCenterZ);
            chunkGroup.userData.chunkRadius = CHUNK_SIZE * TILE_SIZE * Math.SQRT2 * 0.5;
            
            for (const [type, positions] of Object.entries(blocksByType)) {
              if (positions.size === 0) continue;
              
              const material = this.terrainMaterials[type] || this.terrainMaterials['default'];
              const count = positions.size;
              totalBlocks += count;
              
              // Create instanced mesh for terrain blocks with varied heights via scale
              const instancedMesh = new THREE.InstancedMesh(unitBoxGeo, material, count);
              instancedMesh.receiveShadow = true;
              
              // Collect decoration positions for instanced decoration rendering
              const decoConfig = decorationConfig[type];
              const decoPositions = [];
              
              let index = 0;
              for (const [, pos] of positions) {
                const blockHeight = pos.height;
                // Position: center block vertically, accounting for scale
                const yOffset = blockHeight * 0.5 - 0.5;
                posVec.set(pos.x, yOffset, pos.z);
                scaleVec.set(1, blockHeight, 1);
                matrix.compose(posVec, quaternion, scaleVec);
                instancedMesh.setMatrixAt(index++, matrix);
                
                // Check for decoration
                if (decoConfig) {
                  const treeRandom = ((pos.seed * 7) % 100) / 100;
                  if (treeRandom < decoConfig.chance) {
                    let dx = 0, dz = 0;
                    // Add random offset for natural variation within tile bounds
                    const maxRandomOffset = TILE_SIZE * 0.1;
                    dx = (((pos.seed * 13) % 100) / 100 - 0.5) * 2 * maxRandomOffset;
                    dz = (((pos.seed * 17) % 100) / 100 - 0.5) * 2 * maxRandomOffset;
                    // Random height scale for trees (0.5 to 1.5)
                    const heightScale = 0.8 + ((pos.seed * 19) % 100) / 100 * 0.6;
                    decoPositions.push({
                      x: pos.x + dx,
                      y: blockHeight + decoConfig.heightOffset * heightScale - 0.5,
                      z: pos.z + dz,
                      heightScale: heightScale
                    });
                  }
                }
              }
              
              instancedMesh.instanceMatrix.needsUpdate = true;
              chunkGroup.add(instancedMesh);
              
              // Create instanced mesh for decorations (trees/bushes) if any
              if (decoConfig && decoPositions.length > 0) {
                const decoInstancedMesh = new THREE.InstancedMesh(decoConfig.geo, decoConfig.mat, decoPositions.length);
                decoInstancedMesh.castShadow = true;
                
                for (let i = 0; i < decoPositions.length; i++) {
                  const dp = decoPositions[i];
                  // Apply random uniform scale for natural variation
                  posVec.set(dp.x, dp.y, dp.z);
                  scaleVec.set(dp.heightScale, dp.heightScale, dp.heightScale);
                  matrix.compose(posVec, quaternion, scaleVec);
                  decoInstancedMesh.setMatrixAt(i, matrix);
                }
                
                decoInstancedMesh.instanceMatrix.needsUpdate = true;
                chunkGroup.add(decoInstancedMesh);
              }
            }
            
            meshGroup.add(chunkGroup);
            chunkCount++;
          }
          
          tileData.meshGroup = meshGroup;
          this.terrainGroup.add(meshGroup);
          
          console.log(`Created terrain mesh for ${tileData.key} with ${totalBlocks} blocks in ${chunkCount} chunks (${CHUNK_SIZE}x${CHUNK_SIZE})`);
        }

        /**
         * Perform frustum culling on terrain chunk groups
         * Call this every frame before rendering to hide chunks outside view
         * @param {THREE.Camera} camera - The active camera
         * @returns {Object} Stats about visible/culled chunks
         */
        cullChunks(camera) {
          if (!camera) return { visible: 0, culled: 0 };
          
          // Reuse cached objects to avoid GC pressure
          if (!this._cullFrustum) {
            this._cullFrustum = new THREE.Frustum();
            this._cullMatrix = new THREE.Matrix4();
            this._cullSphere = new THREE.Sphere();
          }
          
          // Update frustum from camera
          this._cullMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._cullFrustum.setFromProjectionMatrix(this._cullMatrix);
          
          let visibleCount = 0;
          let culledCount = 0;
          
          // Iterate through all terrain tiles
          for (const [, tileData] of this.terrainTiles) {
            if (!tileData.meshGroup) continue;
            
            // Iterate through chunk groups within each tile
            for (const child of tileData.meshGroup.children) {
              // Skip non-chunk children (like water plane)
              if (!child.userData.chunkCenter) {
                continue;
              }
              
              // Check if chunk's bounding sphere intersects frustum
              this._cullSphere.center.copy(child.userData.chunkCenter);
              this._cullSphere.radius = child.userData.chunkRadius;
              
              const isVisible = this._cullFrustum.intersectsSphere(this._cullSphere);
              
              child.visible = isVisible;
              
              if (isVisible) {
                visibleCount++;
              } else {
                culledCount++;
              }
            }
          }
          
          return { visible: visibleCount, culled: culledCount };
        }

        /**
         * Update which terrain tiles should be loaded and visible
         * Loads a 3x3 grid of tiles (9 total) centered on the camera position
         * Each tile is a 2x2 degree area containing many terrain blocks
         */
        async updateVisibleTiles(centerLon, centerLat, CONFIG_SCALE) {
          this.centerLon = centerLon;
          this.centerLat = centerLat;
          
          // Calculate which tiles should be visible (3x3 grid = 9 tiles around camera)
          const newVisibleTiles = new Set();
          
          // TERRAIN_LOAD_RADIUS = 1 means: current tile + 1 tile in each direction = 3x3 grid
          for (let dx = -TERRAIN_LOAD_RADIUS; dx <= TERRAIN_LOAD_RADIUS; dx++) {
            for (let dy = -TERRAIN_LOAD_RADIUS; dy <= TERRAIN_LOAD_RADIUS; dy++) {
              const lon = centerLon + dx * TERRAIN_TILE_DEGREES;
              const lat = centerLat + dy * TERRAIN_TILE_DEGREES;
              const key = this.getTileKey(lon, lat);
              newVisibleTiles.add(key);
            }
          }
          
          // Hide tiles that are no longer visible
          for (const key of this.visibleTiles) {
            if (!newVisibleTiles.has(key)) {
              const tile = this.terrainTiles.get(key);
              if (tile && tile.meshGroup) {
                tile.meshGroup.visible = false;
                tile.visible = false;
              }
            }
          }
          
          // Load and show new visible tiles
          for (const key of newVisibleTiles) {
            if (!this.terrainTiles.has(key)) {
              // Load new tile
              const tileData = await this.loadTerrainTile(key);
              if (tileData && tileData.loaded) {
                this.createTerrainMesh(tileData, centerLon, centerLat, CONFIG_SCALE);
              }
            }
            
            const tile = this.terrainTiles.get(key);
            if (tile) {
              if (!tile.meshGroup && tile.loaded) {
                this.createTerrainMesh(tile, centerLon, centerLat, CONFIG_SCALE);
              }
              if (tile.meshGroup) {
                tile.meshGroup.visible = true;
                tile.visible = true;
              }
            }
          }
          
          this.visibleTiles = newVisibleTiles;
        }

        /**
         * Check if a world position is on a road-buildable terrain
         */
        isRoadBuildable(worldX, worldZ, centerLon, centerLat) {
          const terrain = this.getTerrainAt(worldX, worldZ, centerLon, centerLat);
          if (!terrain) return true; // Default to buildable if no terrain data
          return terrain.type !== 'water';
        }

        /**
         * Get terrain type at world position
         */
        getTerrainTypeAt(worldX, worldZ, centerLon, centerLat) {
          const terrain = this.getTerrainAt(worldX, worldZ, centerLon, centerLat);
          return terrain ? terrain.type : 'default';
        }

        /**
         * Cleanup all terrain tiles
         */
        dispose() {
          for (const [key, tile] of this.terrainTiles) {
            if (tile.meshGroup) {
              this.terrainGroup.remove(tile.meshGroup);
              tile.meshGroup.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
              });
            }
          }
          this.terrainTiles.clear();
          this.tileAccessOrder = [];
          this.visibleTiles.clear();
          this.loadingPromises.clear();
          
          if (this.terrainGroup.parent) {
            this.terrainGroup.parent.remove(this.terrainGroup);
          }
        }
      }

      // Station data loaded from world_traveler_map_data (full city info with lat/lng/population)
      let STATION_DATA = [];
      // Station names (extracted from STATION_DATA for backward compatibility)
      let STATION_NAMES = [];

      // --- Utilities ---
      const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const wait = (ms) => new Promise((r) => setTimeout(r, ms));

      // Home city - always shown on map in green
      let homeCity = "æ·±åœ³";

      // Global toast function for notifications
      function showToast(msg, color = "white") {
        const logEl = document.getElementById("game-log");
        const entry = document.createElement("div");
        entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
        logEl.appendChild(entry);
        if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
        setTimeout(() => {
          entry.style.opacity = "0";
          setTimeout(() => entry.remove(), 500);
        }, 4000);
      }

      // --- Load Station Data from External File ---
      async function loadStationData() {
        // Fallback default station data
        const defaultStations = [
          { name: "æ·±åœ³ - ç¦ç”°åŒº", lat: 22.5431, lng: 114.0579, population: 1553200, level: 1 },
          { name: "æ·±åœ³ - å—å±±åŒº", lat: 22.5229, lng: 113.9294, population: 1795800, level: 1 },
          { name: "æ·±åœ³ - ç½—æ¹–åŒº", lat: 22.5478, lng: 114.1316, population: 1143800, level: 2 },
          { name: "å¹¿å· - å¤©æ²³åŒº", lat: 23.1343, lng: 113.3603, population: 2241800, level: 1 },
          { name: "å¹¿å· - è¶Šç§€åŒº", lat: 23.1291, lng: 113.2644, population: 1038600, level: 1 }
        ];

        try {
          const response = await fetch("world_traveler_map_data");
          const text = await response.text();

          // Extract JSON from file (can be array or object with cities property)
          const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
          if (jsonMatch) {
            // Clean up the JSON text: remove comments
            const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, "");
            const parsed = JSON.parse(jsonText);
            
            let cities = [];
            if (Array.isArray(parsed)) {
              cities = parsed;
            } else if (parsed.cities) {
              cities = parsed.cities;
            }

            // Store full city data
            if (cities.length > 0) {
              STATION_DATA = cities;
              STATION_NAMES = cities.map(city => city.name);
              console.log(`Loaded ${STATION_DATA.length} stations from world_traveler_map_data`);
            } else {
              console.error("No cities found in world_traveler_map_data");
              STATION_DATA = defaultStations;
              STATION_NAMES = defaultStations.map(s => s.name);
            }
          } else {
            console.error("Could not parse station data from world_traveler_map_data");
            STATION_DATA = defaultStations;
            STATION_NAMES = defaultStations.map(s => s.name);
          }
        } catch (error) {
          console.error("Error loading station data:", error);
          STATION_DATA = defaultStations;
          STATION_NAMES = defaultStations.map(s => s.name);
        }
      }

      // --- Game Classes ---

      class Tile {
        constructor(id, gridX, gridY, type) {
          this.id = id;
          this.gridX = gridX;
          this.gridY = gridY;
          this.type = type;
          this.buildings = [];
          this.owner = null;

          // Station name is set externally from node data after construction
          // Do NOT use hash-based assignment here as it leads to incorrect names
          this.stationName = "";

          this.neighbors = [];
          this.mesh = null; // Three.js Mesh
          this.labelElement = null; // HTML Element for station name
        }

        get isRoad() {
          return !this.type.startsWith("env");
        }

        get isColored() {
          return ["blue", "red", "yellow", "green", "start"].includes(this.type);
        }

        // Helper to get world position based on grid
        get worldPos() {
          return new THREE.Vector3(this.gridX * TILE_SIZE, 0, this.gridY * TILE_SIZE);
        }
      }

      class Player {
        constructor(id, name, color, isAI) {
          this.id = id;
          this.name = name;
          this.color = color;
          this.isAI = isAI;
          this.money = INITIAL_PLAYER_MONEY;
          this.assets = 0;

          this.currentTile = null;
          this.previousTile = null;

          this.mesh = null; // Three.js Mesh (Group)

          // For smooth movement animation
          this.animating = false;
          this.targetPos = new THREE.Vector3();

          // --- ç©·ç¥ç³»ç»Ÿ ---
          this.hasBinbougami = false; // æ˜¯å¦è¢«ç©·ç¥é™„èº«
          this.binbougamiTurns = 0; // ç©·ç¥é™„èº«å›åˆæ•°
          this.binbougamiLevel = 0; // 0=æ™®é€š, 1=å¤§é­”ç‹
          this.binbougamiMesh = null; // ç©·ç¥3Dæ¨¡å‹
          this.binbougamiJustAttached = false; // åˆšåˆšè¢«é™„èº«ï¼Œæœ¬å›åˆä¸è§¦å‘æ•ˆæœ

          // --- å¡ç‰Œç³»ç»Ÿ ---
          this.cards = []; // æ‰‹ç‰Œ
          this.skipNextTurn = false; // ä¸‹å›åˆæ˜¯å¦è·³è¿‡ï¼ˆå†¬çœ æ•ˆæœï¼‰
          this.doubleIncomeNext = false; // ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€
          this.hasShield = false; // æ˜¯å¦æœ‰æŠ¤èº«ç¬¦ä¿æŠ¤
        }
      }

      class Game {
        constructor() {
          this.container = document.getElementById("game-container");
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // FPS and render stats tracking
          this.lastFrameTime = performance.now();
          this.frameCount = 0;
          this.fps = 0;
          this.lastStatsUpdate = 0;

          // Three.js Components
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;

          this.map = [];
          this.players = [];
          this.turn = 0;
          this.state = "INIT";
          this.cameraLocked = true;
          this.isUserInteracting = false;

          // ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ—¶é—´ç³»ç»Ÿï¼ˆå¹´/æœˆï¼‰
          this.gameYear = 1;
          this.gameMonth = 4; // ä»4æœˆå¼€å§‹
          this.totalTurns = 0;

          this.mode = "GAME"; // 'MAP' or 'GAME' - start in GAME mode (load home city directly)
          this.worldMap = null; // Legacy - no longer used (iframe handles world map)
          this.worldMapIframe = null; // Reference to world map iframe element
          this.pendingCity = null; // City pending selection after travel animation
          this.currentCity = null;

          // åŸå¸‚ä¿¡æ¯ç¼“å­˜
          this.cityInfoCache = {};
          this.currentCityInfoTile = null;
          this.cityInfoPanelMode = "purchase"; // "purchase" for buying, "view-only" for clicking on map
          
          // Sessionçº§åˆ«çš„åœ°äº§æ˜¾ç¤ºç¼“å­˜ - ä¿å­˜ä¸€å±€æ¸¸æˆä¸­çš„åœ°äº§æ˜¾ç¤ºé¡ºåº
          // ç»“æ„: { cityName: { seed: randomSeed, properties: [list of property indices in order] } }
          this.sessionPropertyCache = {};
          // å·²è´­ä¹°çš„åœ°äº§ç¼“å­˜ - åœ¨sessionä¸­ä¿æŒå›ºå®šæ˜¾ç¤ºåœ¨æœ€å‰
          this.purchasedPropertiesInSession = {}; // { cityName: [list of purchased property indices] }
          
          // Game mode raycaster for tile clicking
          this.gameRaycaster = null;
          this.gameMouse = new THREE.Vector2();

          // Terrain tile manager for large-scale terrain
          this.terrainManager = null;
          // Map center coordinates (lon/lat)
          this.mapCenterLon = 0;
          this.mapCenterLat = 0;
          this.configScale = 70; // Scale factor for lat/lon to grid units

          this.initThree();
          // this.initGame(); // Delayed until city selection

          window.addEventListener("resize", () => this.onResize());
          document.getElementById("roll-btn").onclick = () => this.playerRoll();

          this.initWorldMap();

          // Start Loop
          this.animate();
        }

        initThree() {
          // 1. Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
          this.scene.fog = new THREE.Fog(0x87CEEB, 100, 300); // Matching fog

          // 2. Camera (Perspective)
          const fov = 45;
          const aspect = this.width / this.height;
          const near = 0.1;
          const far = 300;
          this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

          // Perspective View Setup: Position and LookAt
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(this.scene.position); // Will be updated to follow player

          // 3. Renderer
          if (!this.renderer) {
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);
          }

          // Controls
          if (this.controls) this.controls.dispose();
          this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 30;
          this.controls.maxDistance = 200;
          this.controls.target.set(0, 0, 0);

          // Lock rotation, enable pan on ground plane
          this.controls.enableRotate = false;
          // Pan on XZ plane (ground) instead of screen space
          // This keeps the camera-to-ground distance constant when panning
          this.controls.screenSpacePanning = false;
          // Lock polar angle to maintain fixed camera height relative to ground
          // Camera is at (0, 60, 60) looking at (0, 0, 0), so polar angle is ~45 degrees (Ï€/4)
          const fixedPolarAngle = Math.PI / 4; // 45 degrees from vertical
          this.controls.minPolarAngle = fixedPolarAngle;
          this.controls.maxPolarAngle = fixedPolarAngle;
          
          this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
          this.controls.touches = {
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };

          // Stop auto-following if user interacts
          this.controls.addEventListener("start", () => {
            this.cameraLocked = false;
            this.isUserInteracting = true;
          });

          this.controls.addEventListener("end", () => {
            this.isUserInteracting = false;
            if (this.state === "MOVING") {
              this.cameraLocked = true;
            }
          });

          // Setup click detection for tiles (raycaster for game mode clicks)
          this.gameRaycaster = new THREE.Raycaster();
          this.gameMouse = new THREE.Vector2();
          let downX = 0, downY = 0;
          
          const canvas = this.renderer.domElement;
          canvas.addEventListener("pointerdown", (e) => {
            downX = e.clientX;
            downY = e.clientY;
          });

          canvas.addEventListener("pointerup", (e) => {
            const moveDist = Math.sqrt(Math.pow(e.clientX - downX, 2) + Math.pow(e.clientY - downY, 2));
            // Allow small movement (jitter) but filter out drags
            if (moveDist < 10 && this.mode === "GAME") {
              this.onGameClick(e);
            }
          });

          // 4. Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(50, 100, 50);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          dirLight.shadow.camera.near = 0.5;
          dirLight.shadow.camera.far = 500;
          const shadowSize = 50;
          dirLight.shadow.camera.left = -shadowSize;
          dirLight.shadow.camera.right = shadowSize;
          dirLight.shadow.camera.top = shadowSize;
          dirLight.shadow.camera.bottom = -shadowSize;
          this.scene.add(dirLight);
        }

        initWorldMap() {
          // Use iframe for world map instead of inline WorldMapManager
          this.worldMapIframe = document.getElementById("world-map-iframe");
          this.worldMap = null; // No longer using WorldMapManager class
          
          // Hide world map iframe initially - game loads directly to home city
          if (this.worldMapIframe) {
            this.worldMapIframe.style.display = "none";
          }
          
          // Hide game UI initially until user starts the game
          document.getElementById("ui-layer").style.display = "none";
          document.getElementById("labels-layer").style.display = "none";

          // Setup message listener for iframe communication
          window.addEventListener("message", (e) => this.handleMapMessage(e));
        }

        handleMapMessage(e) {
          const data = e.data;
          if (!data || !data.type) return;

          switch (data.type) {
            case 'mapLoaded':
              console.log("World map iframe loaded");
              // Send initial config to iframe
              this.sendMapMessage({ 
                type: 'setConfig', 
                homeCity: homeCity,
                currentCity: this.currentCity ? this.currentCity.name : null
              });
              break;

            case 'mapStarted':
              console.log("Map started (user clicked start)");
              document.getElementById("game-title").classList.remove("hidden");
              break;

            case 'citySelected':
              console.log("City selected:", data.city);
              // User clicked on a city in the map - trigger travel animation then enter city
              if (data.city) {
                this.pendingCity = data.city;
                // Send fly command to iframe
                this.sendMapMessage({ 
                  type: 'flyToCity', 
                  cityName: data.city.name, 
                  enterCity: true 
                });
              }
              break;

            case 'travelComplete':
              console.log("Travel complete:", data.city);
              // Plane animation finished, now enter the city
              if (data.city) {
                this.selectCity(data.city);
              }
              break;

            case 'mapClosed':
              console.log("Map closed by user");
              // User closed the map, return to game if we have a city
              if (this.currentCity) {
                this.hideWorldMap();
              }
              break;
          }
        }

        sendMapMessage(message) {
          if (this.worldMapIframe && this.worldMapIframe.contentWindow) {
            this.worldMapIframe.contentWindow.postMessage(message, '*');
          }
        }

        showWorldMap() {
          if (this.worldMapIframe) {
            // Load iframe src on first use (lazy loading)
            if (!this.worldMapIframe.src || this.worldMapIframe.src === 'about:blank' || this.worldMapIframe.src === window.location.href) {
              const currentPath = window.location.pathname;
              const lastSlashIndex = currentPath.lastIndexOf('/');
              const basePath = currentPath.substring(0, lastSlashIndex + 1);
              const filename = currentPath.substring(lastSlashIndex + 1);
              const dotIndex = filename.lastIndexOf('.');
              const extension = dotIndex !== -1 ? filename.substring(dotIndex) : '';
              const newFilename = 'world_map_select' + extension;
              this.worldMapIframe.src = basePath + newFilename + window.location.search;
              
              // Hide login modal when world map is first loaded
              const loginModal = document.getElementById("login-modal");
              if (loginModal) loginModal.classList.add("hidden");
            }
            this.worldMapIframe.style.display = "block";
          }
          this.mode = "MAP";
        }

        hideWorldMap() {
          if (this.worldMapIframe) {
            this.worldMapIframe.style.display = "none";
          }
          this.mode = "GAME";
          if (this.controls) this.controls.enabled = true;
          document.getElementById("ui-layer").style.display = "flex";
          document.getElementById("labels-layer").style.display = "block";
          document.getElementById("game-title").classList.add("hidden");
        }

        startGame() {
          // This is called when the iframe's start button is clicked (via postMessage)
          document.getElementById("game-title").classList.remove("hidden");
        }

        selectCity(city) {
          this.currentCity = city;
          this.mode = "GAME";

          // Hide the world map iframe
          this.hideWorldMap();

          // Dispose terrain manager before clearing scene
          if (this.terrainManager) {
            this.terrainManager.dispose();
            this.terrainManager = null;
          }

          // Reset Game Scene if needed or just init
          // Clear existing map if any?
          while (this.scene.children.length > 0) {
            this.scene.remove(this.scene.children[0]);
          }

          // é‡ç½®ç›®çš„åœ°æ ‡è®°
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ¸…ç©ºæ ‡ç­¾å±‚
          document.getElementById("labels-layer").innerHTML = "";

          this.initThree(); // Re-init scene/camera/lights for Game
          this.initGame(); // Generate city map

          // Update UI
          document.getElementById("ui-layer").style.display = "flex";
          document.getElementById("labels-layer").style.display = "block";
          document.getElementById("game-title").classList.add("hidden");
        }

        // Travel from current city (or homeCity) to the provided city. Will perform plane animation then select City
        travelToCity(cityOrName, enterCity = true) {
          let cityObj = null;
          if (!cityOrName) return;
          if (typeof cityOrName === "string") {
            cityObj = { name: cityOrName }; // Create minimal city object with name
          } else {
            cityObj = cityOrName;
          }
          if (!cityObj || !cityObj.name) {
            console.warn("travelToCity: city not found", cityOrName);
            return;
          }

          // Show world map and send fly command to iframe
          this.showWorldMap();
          this.pendingCity = cityObj;
          
          // Send fly command to iframe (iframe will send travelComplete when done)
          this.sendMapMessage({ 
            type: 'flyToCity', 
            cityName: cityObj.name, 
            enterCity: enterCity 
          });
        }

        toggleMap() {
          if (this.mode === "GAME") {
            this.showWorldMap();
            if (this.controls) this.controls.enabled = false;

            document.getElementById("ui-layer").style.display = "none";
            document.getElementById("labels-layer").style.display = "none";
            document.getElementById("destination-indicator").classList.add("hidden");
            document.getElementById("game-title").classList.remove("hidden");
          } else {
            if (this.currentCity) {
              this.hideWorldMap();
            }
          }
        }


        async initGame() {
          // Initialize properties cache
          initializePropertiesCache();
          
          // åˆå§‹åŒ–sessionçº§åˆ«çš„åœ°äº§æ˜¾ç¤ºç¼“å­˜
          this.sessionPropertyCache = {};
          this.purchasedPropertiesInSession = {};
          
          // Materials Cache
          this.materials = {
            road: new THREE.MeshLambertMaterial({ color: COLORS.road }),
            start: new THREE.MeshLambertMaterial({ color: COLORS.start }),
            blue: new THREE.MeshLambertMaterial({ color: COLORS.blue }),
            red: new THREE.MeshLambertMaterial({ color: COLORS.red }),
            yellow: new THREE.MeshLambertMaterial({ color: COLORS.yellow }),
            green: new THREE.MeshLambertMaterial({ color: COLORS.green }),
            env_nature: new THREE.MeshLambertMaterial({ color: COLORS.env_nature }),
            env_culture: new THREE.MeshLambertMaterial({ color: COLORS.env_culture }),
            rail: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 }),
          };

          this.geometries = {
            tile: new THREE.BoxGeometry(TILE_SIZE - TILE_SPACING, 1, TILE_SIZE - TILE_SPACING),
            envBlock: new THREE.BoxGeometry(TILE_SIZE, 4, TILE_SIZE), // Taller blocks for env
          };

          // Generate Map
          const startTile = this.generateMap();

          // Init Players
          this.players = [new Player("p1", "ç©å®¶", 0x3b82f6, false), new Player("com", "ç”µè„‘", 0xef4444, true)];

          this.players.forEach((p) => {
            this.createPlayerMesh(p);
            p.currentTile = startTile;
            p.mesh.position.copy(startTile.worldPos);
            p.mesh.position.y = 1.5; // Sit on top of tile
          });

          // Initial Camera Setup: Center on P1, looking from South
          const p1Pos = this.players[0].mesh.position;
          this.camera.position.set(p1Pos.x, p1Pos.y + 60, p1Pos.z + 60);
          this.controls.target.copy(p1Pos);
          this.controls.update();

          // åˆå§‹åŒ–ç›®çš„åœ°å’Œæ—¶é—´
          this.gameYear = 1;
          this.gameMonth = 4;
          this.totalTurns = 0;
          await this.setNewDestination();
          document.getElementById("destination-panel").classList.remove("hidden");

          this.updateUI();
          this.startTurn();

          // Debug: Quickly attach binbougami to P1 if 'testBinbougami' query present
          try {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get("testBinbougami") === "1") {
              await wait(500);
              await this.attachBinbougami(this.players[0]);
            }
          } catch (e) {}
        }

        createPlayerMesh(player) {
          const group = new THREE.Group();

          // Body
          const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 16);
          const bodyMat = new THREE.MeshStandardMaterial({ color: player.color });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 1;
          body.castShadow = true;
          group.add(body);

          // Head
          const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
          const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
          const head = new THREE.Mesh(headGeo, headMat);
          head.position.y = 2.2;
          head.castShadow = true;
          group.add(head);
          // expose head reference for attaching UI / effects
          player.headMesh = head;

          // Hat/Indicator (Cone)
          const hatGeo = new THREE.ConeGeometry(0.6, 1, 16);
          const hatMat = new THREE.MeshStandardMaterial({ color: player.color });
          const hat = new THREE.Mesh(hatGeo, hatMat);
          hat.position.y = 3;
          hat.rotation.x = Math.PI; // Point down? No point up like a party hat
          group.add(hat);

          this.scene.add(group);
          player.mesh = group;
        }

        // --- Map Generation Algorithm (from world_traveler_map.html) ---
        // Data Structures for A* Pathfinding and MST
        
        // Priority Queue for A* pathfinding
        _createPriorityQueue() {
          return {
            items: [],
            enqueue(element, priority) {
              const qElement = { element, priority };
              let contain = false;
              for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].priority > qElement.priority) {
                  this.items.splice(i, 0, qElement);
                  contain = true;
                  break;
                }
              }
              if (!contain) this.items.push(qElement);
            },
            dequeue() { return this.items.shift(); },
            isEmpty() { return this.items.length === 0; }
          };
        }

        // Union-Find for Kruskal's MST
        _createUnionFind(elements) {
          const parent = {};
          elements.forEach(e => parent[e] = e);
          return {
            find(id) {
              if (parent[id] === id) return id;
              parent[id] = this.find(parent[id]);
              return parent[id];
            },
            union(id1, id2) {
              const root1 = this.find(id1);
              const root2 = this.find(id2);
              if (root1 !== root2) {
                parent[root1] = root2;
                return true;
              }
              return false;
            },
            connected(id1, id2) { 
              return this.find(id1) === this.find(id2); 
            }
          };
        }

        generateMap() {
          this.map = [];
          
          // Initialize simplex noise for terrain (fallback when terrain tiles not loaded)
          const simplex = new SimplexNoise();
          
          // World map for terrain data
          const worldMap = new Map(); // Key: "x,z", Value: { h: height, obj: objectType }
          const roadSet = new Set(); // Track built roads for dynamic costing
          
          // Cost constants for A* pathfinding
          const COST_EMPTY = 10;     // Expensive to build new
          const COST_EXISTING = 1;   // Cheap to use existing
          
          // Helper functions
          const setCell = (x, z, data) => {
            worldMap.set(`${x},${z}`, data);
          };
          
          const getCell = (x, z) => {
            return worldMap.get(`${x},${z}`);
          };
          
          const getNoiseHeight = (x, z) => {
            let n = simplex.noise2D(x*0.03, z*0.03); 
            let n2 = simplex.noise2D(x*0.1, z*0.1);
            let h = -1;
            if (n > -0.2) h = 1; 
            if (n > 0.5) h = 3; 
            if (h === 1 && n2 > 0.4) h = 2;
            return h;
          };
          
          const getCost = (x, z) => {
            return roadSet.has(`${x},${z}`) ? COST_EXISTING : COST_EMPTY;
          };
          
          // A* Pathfinding
          const findPath = (start, end) => {
            const openSet = this._createPriorityQueue();
            openSet.enqueue(start, 0);
            
            const cameFrom = {};
            const gScore = {};
            const startKey = `${start.x},${start.z}`;
            gScore[startKey] = 0;

            const getKey = (pt) => `${pt.x},${pt.z}`;
            
            while (!openSet.isEmpty()) {
              const current = openSet.dequeue().element;
              const currentKey = getKey(current);

              if (current.x === end.x && current.z === end.z) {
                const path = [];
                let curr = currentKey;
                while (cameFrom[curr]) {
                  const [x, z] = curr.split(',').map(Number);
                  path.push({x, z});
                  curr = cameFrom[curr];
                }
                return { path: path.reverse(), cost: gScore[currentKey] };
              }

              const neighbors = [
                {x: current.x+1, z: current.z}, {x: current.x-1, z: current.z},
                {x: current.x, z: current.z+1}, {x: current.x, z: current.z-1}
              ];

              for (let neighbor of neighbors) {
                const neighborKey = getKey(neighbor);
                const newCost = gScore[currentKey] + getCost(neighbor.x, neighbor.z);

                if (newCost < (gScore[neighborKey] ?? Infinity)) {
                  cameFrom[neighborKey] = currentKey;
                  gScore[neighborKey] = newCost;
                  const h = Math.abs(neighbor.x - end.x) + Math.abs(neighbor.z - end.z);
                  openSet.enqueue(neighbor, newCost + h);
                }
              }
            }
            return { path: [], cost: Infinity };
          };
          
          const addPathToRoadSet = (path) => {
            path.forEach(p => roadSet.add(`${p.x},${p.z}`));
          };
          
          // Builds a simple L-shaped road between two points
          const buildDirectRoad = (start, end) => {
            let x = start.x;
            let z = start.z;
            
            while(x !== end.x) {
              roadSet.add(`${x},${z}`);
              x += (end.x > x ? 1 : -1);
            }
            while(z !== end.z) {
              roadSet.add(`${x},${z}`);
              z += (end.z > z ? 1 : -1);
            }
            roadSet.add(`${end.x},${end.z}`);
          };
          
          // Ensure road exists at position
          const ensureRoad = (x, z) => {
            let cell = getCell(x, z);
            if (!cell) {
              setCell(x, z, { h: 1, obj: 1 });
            } else {
              if (cell.obj === 0) {
                cell.obj = 1;
                cell.h = Math.max(cell.h, 1);
                setCell(x, z, cell);
              }
            }
            
            // Padding around roads
            for(let dx=-1; dx<=1; dx++) {
              for(let dz=-1; dz<=1; dz++) {
                if(dx===0 && dz===0) continue;
                let px = x+dx, pz = z+dz;
                if(!worldMap.has(`${px},${pz}`)) {
                  let h = getNoiseHeight(px, pz);
                  if(h < 1) h = 1; 
                  setCell(px, pz, { h: h, obj: 0 });
                }
              }
            }
          };

          // --- Step 1: Load Station Data from Config ---
          // Use actual lat/lng coordinates from STATION_DATA
          // Scale factor: needs to be large enough that stations don't overlap on even grid
          // With ~277 stations in ~2x3.3 degree area, scale of 200 gives ~400x660 units = 200x330 even grid positions
          const CONFIG_SCALE = this.configScale; // Scale factor for lat/lon to grid units
          const RENDER_RADIUS = 6; // Radius to render terrain around stations
          
          let rawPoints = [];
          let centerLat = 0;
          let centerLng = 0;
          
          if (STATION_DATA.length > 0) {
            // Calculate bounds of all cities
            let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
            STATION_DATA.forEach(d => {
              if (d.lat < minLat) minLat = d.lat;
              if (d.lat > maxLat) maxLat = d.lat;
              if (d.lng < minLng) minLng = d.lng;
              if (d.lng > maxLng) maxLng = d.lng;
            });
            
            centerLat = (minLat + maxLat) / 2;
            centerLng = (minLng + maxLng) / 2;
            
            // Store map center for terrain tile loading
            this.mapCenterLon = centerLng;
            this.mapCenterLat = centerLat;

            // Convert lat/lng to grid coordinates
            rawPoints = STATION_DATA.map(d => ({
              x: (d.lng - centerLng) * CONFIG_SCALE,
              z: -(d.lat - centerLat) * CONFIG_SCALE,
              originalName: d.name,
              population: d.population || 100000,
              level: d.level || 3,
              // Store original coordinates for terrain lookup
              lon: d.lng,
              lat: d.lat
            }));
          } else {
            // Fallback: generate random positions
            for (let i = 0; i < STATION_NAMES.length; i++) {
              rawPoints.push({
                x: (Math.random() - 0.5) * 100,
                z: (Math.random() - 0.5) * 100,
                originalName: STATION_NAMES[i],
                population: 1000000 - i * 10000,
                level: 3
              });
            }
          }
          
          // --- Step 2: Snap to Even Grid and Resolve Collisions ---
          const nodes = [];
          const occupied = new Set();
          
          // Sort by population descending so higher population cities get priority
          rawPoints.sort((a, b) => (b.population || 0) - (a.population || 0));
          
          const snapToEvenGrid = (val) => Math.round(val / 2) * 2;
          
          const findNearestFree = (startGx, startGz) => {
            startGx = snapToEvenGrid(startGx);
            startGz = snapToEvenGrid(startGz);
            
            if (!occupied.has(`${startGx},${startGz}`)) return { x: startGx, z: startGz };
            
            let radius = 2;
            while (radius < 100) {
              for (let x = -radius; x <= radius; x += 2) {
                for (let z = -radius; z <= radius; z += 2) {
                  if (Math.abs(x) !== radius && Math.abs(z) !== radius) continue;
                  
                  let checkX = startGx + x;
                  let checkZ = startGz + z;
                  if (!occupied.has(`${checkX},${checkZ}`)) {
                    return { x: checkX, z: checkZ };
                  }
                }
              }
              radius += 2;
            }
            return null;
          };

          rawPoints.forEach((p, index) => {
            let desiredGx = snapToEvenGrid(Math.round(p.x));
            let desiredGz = snapToEvenGrid(Math.round(p.z));
            
            let pos = findNearestFree(desiredGx, desiredGz);
            
            if (pos) {
              let gx = pos.x;
              let gz = pos.z;
              let key = `${gx},${gz}`;
              
              occupied.add(key);
              // Use level to determine type (level 1-2 are major stations)
              let type = (p.level <= 2) ? 'station' : 'city';
              let node = {
                id: nodes.length,
                x: gx, 
                z: gz,
                type: type,
                name: p.originalName,
                population: p.population,
                level: p.level,
                neighbors: [],
                // Store original lon/lat for terrain lookup
                lon: p.lon,
                lat: p.lat
              };
              nodes.push(node);
              setCell(gx, gz, { h: 1, obj: type === 'station' ? 3 : 2 });
            } else {
              console.warn(`Could not place station: ${p.originalName} (desired: ${desiredGx}, ${desiredGz})`);
            }
          });

          console.log(`Generated ${nodes.length} station nodes from ${STATION_DATA.length} station data entries`);

          // --- Step 3: Generate Terrain Around Stations ---
          // Note: Terrain tiles are loaded asynchronously by TerrainTileManager
          // For road generation, we still use noise-based terrain to determine passability
          // The actual visual terrain will come from PNG tiles
          nodes.forEach(node => {
            for(let dx = -RENDER_RADIUS; dx <= RENDER_RADIUS; dx++) {
              for(let dz = -RENDER_RADIUS; dz <= RENDER_RADIUS; dz++) {
                let wx = node.x + dx;
                let wz = node.z + dz;
                if (!worldMap.has(`${wx},${wz}`)) {
                  // Use noise for now (terrain tiles load async)
                  let h = getNoiseHeight(wx, wz);
                  setCell(wx, wz, { h: h, obj: 0 });
                }
              }
            }
          });

          // --- Step 4: Build Road Network using Kruskal's MST with A* ---
          const solveNetwork = () => {
            if (nodes.length < 2) return;

            roadSet.clear();
            
            const loopVal = 50; // Loop sensitivity (0-100)
            const detourRatio = loopVal === 0 ? 1000 : 5.0 - (loopVal / 25);

            // Prepare edges sorted by Manhattan distance
            let edges = [];
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                const dist = Math.abs(nodes[i].x - nodes[j].x) + Math.abs(nodes[i].z - nodes[j].z);
                edges.push({ u: nodes[i], v: nodes[j], dist: dist });
              }
            }
            edges.sort((a, b) => a.dist - b.dist);

            const uf = this._createUnionFind(nodes.map(n => n.id));
            let rejectedEdges = [];

            // Phase 1: MST Skeleton
            for (let i = 0; i < edges.length; i++) {
              const edge = edges[i];
              
              if (uf.connected(edge.u.id, edge.v.id)) {
                rejectedEdges.push(edge);
                continue;
              }

              const pathRes = findPath(edge.u, edge.v);
              
              if (!uf.connected(edge.u.id, edge.v.id)) {
                uf.union(edge.u.id, edge.v.id);
                addPathToRoadSet(pathRes.path);
                
                // Connect nodes as neighbors
                edge.u.neighbors.push(edge.v);
                edge.v.neighbors.push(edge.u);
              }
            }

            // Phase 2: Loop Injection (Smart Shortcuts)
            if (loopVal > 0) {
              const localEdges = rejectedEdges.filter(e => e.dist < 15);

              for (let edge of localEdges) {
                const currentRailPath = findPath(edge.u, edge.v);
                
                if (currentRailPath.cost - edge.dist > 8) {
                  buildDirectRoad(edge.u, edge.v);
                  edge.u.neighbors.push(edge.v);
                  edge.v.neighbors.push(edge.u);
                }
              }
            }

            // Apply roads to world
            roadSet.forEach(k => {
              const [x, z] = k.split(',').map(Number);
              if(!nodes.some(n => n.x === x && n.z === z)) {
                ensureRoad(x, z);
              }
            });
          };
          
          solveNetwork();

          // --- Step 5: Convert to Tile System ---
          const tileData = new Map();
          
          worldMap.forEach((cell, key) => {
            const [xStr, zStr] = key.split(',');
            const x = parseInt(xStr);
            const z = parseInt(zStr);
            
            let h = cell.h;
            let obj = cell.obj;
            
            if (h === -1) return; // Skip water
            
            let type = 'road';
            
            // Determine tile type based on object
            if (obj === 2 || obj === 3) {
              // Station/City
              type = 'green';
            } else if (obj === 1) {
              // Road - add colored tiles randomly
              type = Math.random() < 0.3 ? this.getRandomColoredType() : 'road';
            } else {
              // Environment based on height
              if (h === 0 || h === -1) type = 'env_nature';
              else if (h === 1) type = Math.random() > 0.3 ? 'env_nature' : 'env_culture';
              else if (h === 2) type = 'env_nature';
              else if (h === 3) type = 'env_culture';
            }
            
            // Find station name and population if this is a station
            let stationName = '';
            let population = 0;
            if (type === 'green') {
              const node = nodes.find(n => n.x === x && n.z === z);
              if (node) {
                stationName = node.name;
                population = node.population || 0;
              }
            }
            
            tileData.set(key, { x, z, type, stationName, population, height: h, obj });
          });

          // --- Step 6: Instantiate Tiles ---
          const mapGroup = new THREE.Group();
          mapGroup.name = 'gameMapGroup';
          this.scene.add(mapGroup);
          this.tilesMap = new Map();
          this.mapGroup = mapGroup; // Store reference for later

          // Note: Ocean planes are now rendered per-terrain-tile in TerrainTileManager.createTerrainMesh()
          // This allows for proper loading/unloading with terrain tiles

          let idCounter = 0;
          tileData.forEach((data) => {
            // Skip pure environment tiles - terrain manager handles environment rendering
            // Only create tiles for roads, stations, and game-relevant tiles
            if (data.obj === 1 || data.obj === 2 || data.obj === 3 || 
                data.type === 'green' || data.type === 'road' || 
                ['blue', 'red', 'yellow'].includes(data.type)) {
              const tile = new Tile(idCounter++, data.x, data.z, data.type);
              if (data.stationName) tile.stationName = data.stationName;
              if (data.population) tile.population = data.population;

              this.map.push(tile);
              this.tilesMap.set(`${data.x},${data.z}`, tile);
              this.createTileVisuals(tile, mapGroup);
            }
            // Note: Environment tiles are now rendered by TerrainTileManager from PNG data
          });

          console.log(`Created ${this.map.length} tiles, ${this.map.filter(t => t.type === 'green').length} stations`);

          // --- Step 6.5: Initialize Terrain Manager (async loading after stations/roads are rendered) ---
          // Initialize or reset terrain manager
          if (this.terrainManager) {
            this.terrainManager.dispose();
          }
          this.terrainManager = new TerrainTileManager(this.scene, this);
          
          // Store reference to tilesMap for terrain manager to check road/station positions
          this.terrainManager.tilesMap = this.tilesMap;
          
          // Start loading terrain tiles for the current area (async - doesn't block map rendering)
          // Terrain loads around camera view and streams in as PNG tiles are fetched from CDN
          this.terrainManager.updateVisibleTiles(centerLng, centerLat, CONFIG_SCALE);

          // --- Step 7: Link Neighbors ---
          this.map.forEach((tile) => {
            if (!tile.isRoad) return;

            const dirs = [
              [0, 1],
              [0, -1],
              [1, 0],
              [-1, 0],
            ];
            dirs.forEach(([dx, dz]) => {
              const nx = tile.gridX + dx;
              const nz = tile.gridY + dz;
              const neighbor = this.tilesMap.get(`${nx},${nz}`);
              if (neighbor && neighbor.isRoad) {
                tile.neighbors.push(neighbor);
              }
            });
          });

          // --- Step 8: Set Start Position (city with largest population) ---
          const stations = this.map.filter((t) => t.type === "green");
          // Sort stations by population descending and pick the one with largest population
          stations.sort((a, b) => (b.population || 0) - (a.population || 0));
          let startTile = stations.length > 0 ? stations[0] : this.map[0];

          if (!startTile) startTile = this.map[0];

          if (startTile) {
            startTile.type = "start";
            startTile.mesh.material = this.materials.start;
            startTile.mesh.position.y = 0.2;
            if (startTile.labelElement) {
              startTile.labelElement.remove();
              startTile.labelElement = null;
            }
          }

          return startTile;
        }

        createTileVisuals(tile, parentGroup) {
          const x = tile.gridX * TILE_SIZE;
          const z = tile.gridY * TILE_SIZE;

          // 1. Base Block
          let geometry = this.geometries.tile;
          let yPos = 0;

          // Environment blocks are taller to create "canyons" for the track
          if (!tile.isRoad) {
            geometry = new THREE.BoxGeometry(TILE_SIZE, rand(2, 6), TILE_SIZE);
            yPos = -1; // Sink them a bit
          }

          const material = this.materials[tile.type] || this.materials.road;
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, yPos, z);
          mesh.receiveShadow = true;

          // 2. Decorations
          if (tile.type === "env_nature") {
            if (Math.random() > 0.5) {
              const treeGeo = new THREE.ConeGeometry(1, 3, 8);
              const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
              const tree = new THREE.Mesh(treeGeo, treeMat);
              // BoxGeometry is centered at origin, so local (0,0,0) is the center of the tile mesh
              // Add random offset within the tile bounds
              const maxOffset = TILE_SIZE * 0.1;
              const randomOffsetX = (Math.random() - 0.5) * 2 * maxOffset;
              const randomOffsetZ = (Math.random() - 0.5) * 2 * maxOffset;
              tree.position.set(randomOffsetX, 2.5, randomOffsetZ);
              tree.castShadow = true;
              mesh.add(tree); // Local coordinate - (0,0,0) is center of tile
            }
          } else if (tile.type === "green") {
            // Station Marker
            const stationGeo = new THREE.BoxGeometry(2.5, 1, 2.5);
            const stationMesh = new THREE.Mesh(stationGeo, new THREE.MeshLambertMaterial({ color: 0xffffff }));
            stationMesh.position.y = 0.6;
            mesh.add(stationMesh);

            // Add HTML Label
            this.createStationLabel(tile);
          }

          tile.mesh = mesh;
          parentGroup.add(mesh);
        }

        createStationLabel(tile) {
          const div = document.createElement("div");
          div.className = "station-label";
          div.innerText = tile.stationName;
          document.getElementById("labels-layer").appendChild(div);
          tile.labelElement = div;

          // Determine best label position: prefer non-road adjacent tiles
          // Check left (-x), right (+x), and top (-z) directions
          const leftKey = `${tile.gridX - 1},${tile.gridY}`;
          const rightKey = `${tile.gridX + 1},${tile.gridY}`;
          const topKey = `${tile.gridX},${tile.gridY - 1}`;

          const leftTile = this.tilesMap.get(leftKey);
          const rightTile = this.tilesMap.get(rightKey);
          const topTile = this.tilesMap.get(topKey);

          // Check if tile is a road/walkable tile (not environment)
          const isRoadTile = (t) => t && t.isRoad;

          // Priority: place label toward non-road areas (top > left > right)
          if (!isRoadTile(topTile)) {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // top (default)
          } else if (!isRoadTile(leftTile)) {
            tile.labelOffset = { x: -50, y: 0, align: "right" }; // left side
          } else if (!isRoadTile(rightTile)) {
            tile.labelOffset = { x: 50, y: 0, align: "left" }; // right side
          } else {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // fallback to top
          }
        }

        getRandomColoredType() {
          // Note: Don't return "green" here - only actual station nodes (from nodes array)
          // should be green. Road tiles converted to green would have no matching node,
          // causing incorrect station names to be assigned.
          const r = Math.random();
          if (r < 0.33) return "red";
          if (r < 0.66) return "yellow";
          return "blue";
        }

        // --- ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ ---

        async setNewDestination() {
          // è·å–æ‰€æœ‰è½¦ç«™ï¼ˆç»¿è‰²æ ¼å­ï¼‰ï¼Œæ’é™¤å½“å‰èµ·å§‹ç‚¹å’Œç©å®¶æ‰€åœ¨ä½ç½®
          const stations = this.map.filter((t) => t.type === "green" && t !== this.destinationTile && !this.players.some((p) => p.currentTile === t));

          if (stations.length === 0) return;

          // ç§»é™¤æ—§ç›®çš„åœ°çš„é«˜äº®æ ·å¼
          if (this.destinationTile && this.destinationTile.labelElement) {
            this.destinationTile.labelElement.classList.remove("destination");
          }

          // éšæœºé€‰æ‹©ä¸€ä¸ªè½¦ç«™ä½œä¸ºç›®çš„åœ°
          let newDest = stations[Math.floor(Math.random() * stations.length)];

          // æ˜¾ç¤ºæŠ½å¥–åŠ¨ç”»
          newDest = await this.showDestinationLottery(stations, newDest);

          this.destinationTile = newDest;

          // æ›´æ–°UIæ˜¾ç¤º
          document.getElementById("destination-name").innerText = newDest.stationName;

          // æ·»åŠ ç›®çš„åœ°æ ‡ç­¾é«˜äº®æ ·å¼
          if (newDest.labelElement) {
            newDest.labelElement.classList.add("destination");
          }

          // ç§»é™¤æ—§çš„ç›®çš„åœ°æ ‡è®°
          if (this.destinationMarker) {
            this.scene.remove(this.destinationMarker);
          }

          // åˆ›å»ºæ–°çš„ç›®çš„åœ°æ ‡è®°ï¼ˆå‘å…‰çš„åœ†æŸ±+æ——å¸œï¼‰
          this.createDestinationMarker(newDest);

          this.log(`ğŸ¯ æ–°ç›®çš„åœ°: ${newDest.stationName}`, "#fbbf24");
          showToast(`ğŸ¯ ç›®çš„åœ°å·²æ›´æ–°: ${newDest.stationName}`, "#fbbf24");

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // ä½¿ç”¨0-1 BFSè®¡ç®—ä»ä¸€ä¸ªæ ¼å­åˆ°ç›®çš„åœ°çš„æœ€çŸ­è·ç¦»ï¼ˆç«™æ•°ï¼‰
        // éå½©è‰²æ ¼å­ä¸æ¶ˆè€—æ­¥æ•°(æƒé‡0)ï¼Œå½©è‰²æ ¼å­æ¶ˆè€—1æ­¥(æƒé‡1)
        calculateDistanceToDestination(fromTile) {
          if (!this.destinationTile || !fromTile) return -1;
          if (fromTile === this.destinationTile) return 0;

          // 0-1 BFS: ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ï¼Œæƒé‡0çš„è¾¹åŠ åˆ°é˜Ÿé¦–ï¼Œæƒé‡1çš„è¾¹åŠ åˆ°é˜Ÿå°¾
          const dist = new Map();
          const deque = []; // åŒç«¯é˜Ÿåˆ—
          
          dist.set(fromTile, 0);
          deque.push({ tile: fromTile, distance: 0 });

          while (deque.length > 0) {
            const { tile, distance } = deque.shift();
            
            // å¦‚æœå½“å‰è·ç¦»å¤§äºå·²è®°å½•çš„æœ€çŸ­è·ç¦»ï¼Œè·³è¿‡
            if (distance > (dist.get(tile) ?? Infinity)) continue;

            for (const neighbor of tile.neighbors) {
              // è®¡ç®—åˆ°é‚»å±…çš„æ–°è·ç¦»ï¼šå½©è‰²æ ¼å­+1ï¼Œéå½©è‰²æ ¼å­+0
              const weight = neighbor.isColored ? 1 : 0;
              const newDist = distance + weight;
              
              // å¦‚æœæ‰¾åˆ°æ›´çŸ­çš„è·¯å¾„
              if (newDist < (dist.get(neighbor) ?? Infinity)) {
                dist.set(neighbor, newDist);
                
                // åˆ°è¾¾ç›®çš„åœ°
                if (neighbor === this.destinationTile) {
                  return newDist;
                }
                
                // 0-1 BFS: æƒé‡0åŠ åˆ°é˜Ÿé¦–ï¼Œæƒé‡1åŠ åˆ°é˜Ÿå°¾
                if (weight === 0) {
                  deque.unshift({ tile: neighbor, distance: newDist });
                } else {
                  deque.push({ tile: neighbor, distance: newDist });
                }
              }
            }
          }

          return -1; // æ— æ³•åˆ°è¾¾
        }

        // AIä½¿ç”¨A*ç®—æ³•è®¡ç®—åˆ°è¾¾ç›®çš„åœ°çš„æœ€ä¼˜è·¯å¾„
        // è€ƒè™‘æ–°çš„ç§»åŠ¨è§„åˆ™ï¼šè¡ŒåŠ¨ç‚¹æ•°åŸºäºè·ç¦»èµ·ç‚¹çš„æ­¥æ•°ï¼Œå¯ä»¥å¾€è¿”
        // è¿”å›: { path: Tile[], totalSteps: number } æˆ– null
        calculateOptimalPathToDestination(fromTile, maxSteps = 100) {
          if (!this.destinationTile || !fromTile) return null;
          if (fromTile === this.destinationTile) return { path: [fromTile], totalSteps: 0 };

          // A* with state = (tile, distanceFromStart)
          // å› ä¸ºå¯ä»¥å¾€è¿”ï¼Œæˆ‘ä»¬éœ€è¦è¿½è¸ª (tile, distance) å¯¹
          // ç›®æ ‡æ˜¯æ‰¾åˆ°ä¸€æ¡è·¯å¾„ä½¿å¾—æœ€ç»ˆè·ç¦»åˆšå¥½ç­‰äºæŸä¸ªå€¼æ—¶åˆ°è¾¾ç›®çš„åœ°
          
          // ä½¿ç”¨BFSæ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„åˆ°è¾¾æ–¹å¼
          // state: { tile, distance, path, visited }
          const queue = [];
          const visited = new Map(); // key: `${tile.id}_${distance}`, value: true
          
          queue.push({
            tile: fromTile,
            distance: 0,
            path: [fromTile],
            visitedTiles: new Map([[fromTile, 0]]) // tile -> min distance when first visited
          });
          
          let bestResult = null;
          let bestTotalSteps = Infinity;
          
          while (queue.length > 0) {
            const state = queue.shift();
            const { tile, distance, path, visitedTiles } = state;
            
            // å¦‚æœè·ç¦»å·²ç»è¶…è¿‡æœ€å¤§æ­¥æ•°ï¼Œè·³è¿‡
            if (distance > maxSteps) continue;
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®çš„åœ°ï¼ˆè·ç¦»åˆšå¥½ç”¨å®Œæ—¶åœ¨ç›®çš„åœ°ï¼‰
            if (tile === this.destinationTile && distance > 0) {
              // æ‰¾åˆ°ä¸€æ¡å¯è¡Œè·¯å¾„ï¼Œè®°å½•éœ€è¦çš„æ­¥æ•°
              if (distance < bestTotalSteps) {
                bestTotalSteps = distance;
                bestResult = { path: [...path], totalSteps: distance };
              }
              continue; // ç»§ç»­æœç´¢å¯èƒ½æ›´çŸ­çš„è·¯å¾„
            }
            
            // é˜²æ­¢çŠ¶æ€çˆ†ç‚¸ï¼šé™åˆ¶æœç´¢æ·±åº¦
            if (path.length > maxSteps * 2) continue;
            
            // é¿å…é‡å¤æ¢ç´¢ç›¸åŒçŠ¶æ€
            const stateKey = `${tile.gridX}_${tile.gridY}_${distance}`;
            if (visited.has(stateKey)) continue;
            visited.set(stateKey, true);
            
            // æ¢ç´¢æ‰€æœ‰é‚»å±…
            for (const neighbor of tile.neighbors) {
              // è®¡ç®—ç§»åŠ¨åˆ°é‚»å±…åçš„æ–°è·ç¦»
              let newDistance;
              const newVisitedTiles = new Map(visitedTiles);
              
              if (neighbor.isColored) {
                if (newVisitedTiles.has(neighbor)) {
                  // å›åˆ°ä¹‹å‰è®¿é—®è¿‡çš„æ ¼å­ï¼Œä½¿ç”¨ä¹‹å‰çš„è·ç¦»
                  newDistance = newVisitedTiles.get(neighbor);
                } else {
                  // æ–°æ ¼å­ï¼Œè·ç¦»+1
                  newDistance = distance + 1;
                  newVisitedTiles.set(neighbor, newDistance);
                }
              } else {
                newDistance = distance;
                if (!newVisitedTiles.has(neighbor)) {
                  newVisitedTiles.set(neighbor, distance);
                }
              }
              
              // å¦‚æœæ–°è·ç¦»å·²ç»è¶…è¿‡æœ€ä½³ç»“æœï¼Œå‰ªæ
              if (bestResult && newDistance >= bestTotalSteps) continue;
              
              queue.push({
                tile: neighbor,
                distance: newDistance,
                path: [...path, neighbor],
                visitedTiles: newVisitedTiles
              });
            }
          }
          
          return bestResult;
        }

        // AIé¢„è®¡ç®—ï¼šç»™å®šå½“å‰ä½ç½®å’Œéª°å­ç‚¹æ•°ï¼Œè®¡ç®—åº”è¯¥èµ°çš„è·¯å¾„
        // è¿”å›æœ€ç»ˆèƒ½åˆ°è¾¾çš„æœ€ä½³ä½ç½®çš„è·¯å¾„
        calculateAIPath(fromTile, steps) {
          if (!this.destinationTile || !fromTile) return null;
          
          // é¦–å…ˆå°è¯•æ‰¾åˆ°èƒ½åˆšå¥½åˆ°è¾¾ç›®çš„åœ°çš„è·¯å¾„
          const optimalPath = this.calculateOptimalPathToDestination(fromTile, steps);
          
          if (optimalPath && optimalPath.totalSteps === steps) {
            // å®Œç¾ï¼åˆšå¥½èƒ½åˆ°è¾¾ç›®çš„åœ°
            return optimalPath.path;
          }
          
          // å¦‚æœä¸èƒ½åˆšå¥½åˆ°è¾¾ç›®çš„åœ°ï¼Œæ‰¾ä¸€æ¡è·¯å¾„è®©æˆ‘ä»¬å°½å¯èƒ½æ¥è¿‘ç›®çš„åœ°
          // ä½¿ç”¨BFSæšä¸¾æ‰€æœ‰å¯èƒ½çš„ç»ˆç‚¹ä½ç½®ï¼Œé€‰æ‹©è·ç¦»ç›®çš„åœ°æœ€è¿‘çš„
          const visited = new Map();
          const queue = [{
            tile: fromTile,
            distance: 0,
            path: [fromTile],
            visitedTiles: new Map([[fromTile, 0]])
          }];
          
          let bestEndTile = fromTile;
          let bestEndPath = [fromTile];
          let bestDistToDest = this.calculateDistanceToDestination(fromTile);
          
          while (queue.length > 0) {
            const state = queue.shift();
            const { tile, distance, path, visitedTiles } = state;
            
            // å¦‚æœè·ç¦»åˆšå¥½ç­‰äºæ­¥æ•°ï¼Œè¿™æ˜¯ä¸€ä¸ªå¯èƒ½çš„ç»ˆç‚¹
            if (distance === steps) {
              const distToDest = this.calculateDistanceToDestination(tile);
              if (distToDest >= 0 && (bestDistToDest < 0 || distToDest < bestDistToDest)) {
                bestDistToDest = distToDest;
                bestEndTile = tile;
                bestEndPath = [...path];
              }
              continue; // ä¸èƒ½å†èµ°äº†
            }
            
            // å¦‚æœè·ç¦»å·²ç»è¶…è¿‡æ­¥æ•°ï¼Œè·³è¿‡
            if (distance > steps) continue;
            
            // é¿å…é‡å¤æ¢ç´¢
            const stateKey = `${tile.gridX}_${tile.gridY}_${distance}`;
            if (visited.has(stateKey)) continue;
            visited.set(stateKey, true);
            
            // é™åˆ¶æœç´¢æ·±åº¦
            if (path.length > steps * 3) continue;
            
            // æ¢ç´¢æ‰€æœ‰é‚»å±…
            for (const neighbor of tile.neighbors) {
              let newDistance;
              const newVisitedTiles = new Map(visitedTiles);
              
              if (neighbor.isColored) {
                if (newVisitedTiles.has(neighbor)) {
                  newDistance = newVisitedTiles.get(neighbor);
                } else {
                  newDistance = distance + 1;
                  newVisitedTiles.set(neighbor, newDistance);
                }
              } else {
                newDistance = distance;
                if (!newVisitedTiles.has(neighbor)) {
                  newVisitedTiles.set(neighbor, distance);
                }
              }
              
              if (newDistance <= steps) {
                queue.push({
                  tile: neighbor,
                  distance: newDistance,
                  path: [...path, neighbor],
                  visitedTiles: newVisitedTiles
                });
              }
            }
          }
          
          return bestEndPath;
        }

        // AIé€‰æ‹©æœ€ä¼˜æ–¹å‘ï¼šé€‰æ‹©è·ç¦»ç›®çš„åœ°æœ€è¿‘çš„è·¯å¾„
        chooseBestDirection(options) {
          if (!this.destinationTile || options.length === 0) {
            return options[Math.floor(Math.random() * options.length)];
          }

          let bestTile = options[0];
          let bestDistance = this.calculateDistanceToDestination(options[0]);

          for (let i = 1; i < options.length; i++) {
            const dist = this.calculateDistanceToDestination(options[i]);
            // é€‰æ‹©è·ç¦»æ›´çŸ­çš„ï¼ˆå¦‚æœè·ç¦»ä¸º-1è¡¨ç¤ºæ— æ³•åˆ°è¾¾ï¼Œè·³è¿‡ï¼‰
            if (dist >= 0 && (bestDistance < 0 || dist < bestDistance)) {
              bestDistance = dist;
              bestTile = options[i];
            }
          }

          return bestTile;
        }

        // æ›´æ–°æ‰€æœ‰ç©å®¶çš„è·ç¦»æ˜¾ç¤ºï¼ˆç°åœ¨åªåœ¨è¯¦æƒ…é¢æ¿ä¸­æ˜¾ç¤ºï¼‰
        updateDistanceDisplay() {
          // è·ç¦»ä¿¡æ¯ç°åœ¨åªåœ¨ç©å®¶è¯¦æƒ…å¼¹çª—ä¸­æ˜¾ç¤º
          // æ­¤å‡½æ•°ä¿ç•™ä»¥ä¾›å…¶ä»–åœ°æ–¹è°ƒç”¨å…¼å®¹
        }

        // æ›´æ–°å±å¹•å¤–ç›®çš„åœ°æŒ‡ç¤ºå™¨
        updateDestinationIndicator() {
          const indicator = document.getElementById("destination-indicator");
          if (!indicator) return;

          // å¦‚æœæ²¡æœ‰ç›®çš„åœ°ï¼Œéšè—æŒ‡ç¤ºå™¨
          if (!this.destinationTile) {
            indicator.classList.add("hidden");
            return;
          }

          // Use relative world position between camera look at and the dest station
          this.camera.updateMatrixWorld();
          const destPosCamera = this.destinationTile.mesh.position.clone().applyMatrix4(this.camera.matrixWorldInverse);
          
          // Check if in front of camera (negative z in camera space)
          const isInFront = destPosCamera.z < 0;

          // è·å–ç›®çš„åœ°åœ¨å±å¹•ä¸Šçš„ä½ç½®
          const destPos = this.getScreenPosition(this.destinationTile.mesh.position);
          const margin = 80; // è¾¹ç¼˜margin

          // æ£€æŸ¥ç›®çš„åœ°æ˜¯å¦åœ¨å±å¹•å¯è§èŒƒå›´å†…
          // Must be in front AND within screen bounds
          let isOnScreen = false;
          if (isInFront) {
             isOnScreen = destPos.x >= margin && destPos.x <= this.width - margin && destPos.y >= margin && destPos.y <= this.height - margin;
          }

          if (isOnScreen) {
            // ç›®çš„åœ°åœ¨å±å¹•å†…ï¼Œéšè—æŒ‡ç¤ºå™¨
            indicator.classList.add("hidden");
            return;
          }

          // ç›®çš„åœ°åœ¨å±å¹•å¤–ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨
          indicator.classList.remove("hidden");

          // æ›´æ–°ç›®çš„åœ°åç§°
          document.getElementById("indicator-name").innerText = this.destinationTile.stationName;

          // è®¡ç®—å±å¹•ä¸­å¿ƒåˆ°ç›®çš„åœ°ä½ç½®çš„æ–¹å‘
          // Use camera space coordinates to determine angle
          // Camera x is right, y is up. Screen x is right, y is down.
          // So angle = atan2(-y, x)
          const angle = Math.atan2(-destPosCamera.y, destPosCamera.x);

          // è®¡ç®—æŒ‡ç¤ºå™¨åœ¨å±å¹•è¾¹ç¼˜çš„ä½ç½®
          const edgeMargin = 60;
          let indicatorX, indicatorY;

          const centerX = this.width / 2;
          const centerY = this.height / 2;

          // æ ¹æ®è§’åº¦ç¡®å®šæŒ‡ç¤ºå™¨ä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
          const maxX = this.width - edgeMargin;
          const maxY = this.height - edgeMargin;
          const minX = edgeMargin;
          const minY = edgeMargin;

          // Use cos/sin to find intersection with box
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          
          // Ray from center: x = centerX + t * cos, y = centerY + t * sin
          // Find t for each edge
          
          let t = Infinity;
          
          // Right edge: x = maxX
          if (cos > 0) {
             const tRight = (maxX - centerX) / cos;
             if (tRight < t) t = tRight;
          }
          // Left edge: x = minX
          if (cos < 0) {
             const tLeft = (minX - centerX) / cos;
             if (tLeft < t) t = tLeft;
          }
          // Bottom edge: y = maxY
          if (sin > 0) {
             const tBottom = (maxY - centerY) / sin;
             if (tBottom < t) t = tBottom;
          }
          // Top edge: y = minY
          if (sin < 0) {
             const tTop = (minY - centerY) / sin;
             if (tTop < t) t = tTop;
          }
          
          indicatorX = centerX + t * cos;
          indicatorY = centerY + t * sin;

          // è®¾ç½®æŒ‡ç¤ºå™¨ä½ç½®ï¼Œæ ¹æ®è¾¹ç¼˜ä½ç½®è°ƒæ•´transformé¿å…è¶…å‡ºå±å¹•
          let finalX = indicatorX;
          let finalY = indicatorY;

          // æ ¹æ®æŒ‡ç¤ºå™¨åœ¨å±å¹•çš„ä½ç½®è°ƒæ•´å¯¹é½æ–¹å¼
          let transformX = "-50%";
          let transformY = "-50%";

          const padding = 10; // è·ç¦»å±å¹•è¾¹ç¼˜çš„padding

          // é è¿‘å³è¾¹ç¼˜æ—¶ï¼Œå‘å·¦å¯¹é½ï¼ˆå…ƒç´ å³è¾¹è´´ç€å±å¹•å³è¾¹ï¼‰
          if (indicatorX >= this.width - edgeMargin) {
            transformX = "-100%";
            finalX = this.width - padding;
          }
          // é è¿‘å·¦è¾¹ç¼˜æ—¶ï¼Œå‘å³å¯¹é½ï¼ˆå…ƒç´ å·¦è¾¹è´´ç€å±å¹•å·¦è¾¹ï¼‰
          else if (indicatorX <= edgeMargin) {
            transformX = "0%";
            finalX = padding;
          }

          // é è¿‘ä¸‹è¾¹ç¼˜æ—¶ï¼Œå‘ä¸Šå¯¹é½ï¼ˆå…ƒç´ ä¸‹è¾¹è´´ç€å±å¹•ä¸‹è¾¹ï¼‰
          if (indicatorY >= this.height - edgeMargin) {
            transformY = "-100%";
            finalY = this.height - padding;
          }
          // é è¿‘ä¸Šè¾¹ç¼˜æ—¶ï¼Œå‘ä¸‹å¯¹é½ï¼ˆå…ƒç´ ä¸Šè¾¹è´´ç€å±å¹•ä¸Šè¾¹ï¼‰
          else if (indicatorY <= edgeMargin) {
            transformY = "0%";
            finalY = padding;
          }

          indicator.style.left = `${finalX}px`;
          indicator.style.top = `${finalY}px`;
          indicator.style.transform = `translate(${transformX}, ${transformY})`;

          // æ›´æ–°ç®­å¤´æ–¹å‘
          const arrowEl = document.getElementById("indicator-arrow");
          if (arrowEl) {
            // æ ¹æ®æ–¹å‘é€‰æ‹©ç®­å¤´
            const degAngle = (angle * 180) / Math.PI;
            let arrow = "â†’";
            if (degAngle > -22.5 && degAngle <= 22.5) arrow = "â†’";
            else if (degAngle > 22.5 && degAngle <= 67.5) arrow = "â†˜";
            else if (degAngle > 67.5 && degAngle <= 112.5) arrow = "â†“";
            else if (degAngle > 112.5 && degAngle <= 157.5) arrow = "â†™";
            else if (degAngle > 157.5 || degAngle <= -157.5) arrow = "â†";
            else if (degAngle > -157.5 && degAngle <= -112.5) arrow = "â†–";
            else if (degAngle > -112.5 && degAngle <= -67.5) arrow = "â†‘";
            else if (degAngle > -67.5 && degAngle <= -22.5) arrow = "â†—";

            arrowEl.innerText = arrow;
          }
        }

        // æ˜¾ç¤ºç›®çš„åœ°æŠ½å¥–åŠ¨ç”»
        async showDestinationLottery(stations, finalDest) {
          // åˆ›å»ºå…¨å±å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "lottery-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.9)";
          overlay.style.backdropFilter = "blur(8px)";

          overlay.innerHTML = `
            <div class="text-center relative">
                <div class="text-2xl text-gray-400 mb-4">ğŸ² æ­£åœ¨é€‰æ‹©ç›®çš„åœ°...</div>
                <div class="relative overflow-hidden h-32 w-80 mx-auto mb-6 rounded-xl border-4 border-yellow-600 bg-gray-900 shadow-2xl">
                    <div class="absolute inset-x-0 top-0 h-8 bg-gradient-to-b from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 bottom-0 h-8 bg-gradient-to-t from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 top-1/2 -translate-y-1/2 h-12 border-y-2 border-yellow-400 bg-yellow-400/10 z-10 box-border"></div>
                    <div id="lottery-scroll" class="absolute inset-x-0 transition-transform" style="top: 50%; transform: translateY(-50%);">
                        <!-- åœ°åä¼šåœ¨è¿™é‡Œæ»šåŠ¨ -->
                    </div>
                </div>
                
                <!-- æ‹‰æ†/ç¡®å®šæŒ‰é’® -->
                <div class="mb-6">
                   <button id="lottery-stop-btn" class="group relative inline-flex items-center justify-center px-8 py-3 text-lg font-black text-white transition-all duration-200 bg-red-600 font-pj rounded-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-600 active:scale-95 shadow-[0_6px_0_rgb(153,27,27)] hover:shadow-[0_4px_0_rgb(153,27,27)] hover:translate-y-1 active:shadow-none active:translate-y-2">
                      <span class="mr-2 text-2xl">ğŸ°</span> ç«‹å³ç¡®å®š
                   </button>
                </div>

                <div id="lottery-result" class="text-5xl font-black text-yellow-400 mb-4 opacity-0 transition-opacity duration-500 transform scale-90"></div>
                <div id="lottery-subtitle" class="text-xl text-gray-300 opacity-0 transition-opacity duration-500">å‡ºå‘å§!</div>
            </div>
        `;

          document.body.appendChild(overlay);

          const scrollContainer = document.getElementById("lottery-scroll");
          const stopBtn = document.getElementById("lottery-stop-btn");

          // åˆ›å»ºæ»šåŠ¨å†…å®¹ï¼ˆæ‰€æœ‰è½¦ç«™åéšæœºæ’åˆ—ï¼Œé‡å¤å¤šæ¬¡ï¼‰
          const allNames = stations.map((s) => s.stationName);
          // æ‰“ä¹±é¡ºåº
          for (let i = allNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allNames[i], allNames[j]] = [allNames[j], allNames[i]];
          }

          // ç¡®ä¿æœ€ç»ˆç›®çš„åœ°åœ¨æœ€å
          const finalIndex = allNames.indexOf(finalDest.stationName);
          if (finalIndex > -1) {
            allNames.splice(finalIndex, 1);
          }

          // åˆ›å»ºæ»šåŠ¨åˆ—è¡¨ï¼ˆé‡å¤å¤šæ¬¡ + æœ€ç»ˆç›®çš„åœ°ï¼‰
          const repeatCount = 4;
          let scrollItems = [];
          for (let i = 0; i < repeatCount; i++) {
            scrollItems = scrollItems.concat([...allNames].sort(() => Math.random() - 0.5));
          }
          scrollItems.push(finalDest.stationName); // æœ€ç»ˆåœåœ¨è¿™é‡Œ

          // æ¸²æŸ“æ»šåŠ¨é¡¹
          const itemHeight = 48;
          scrollContainer.innerHTML = scrollItems
            .map(
              (name, idx) => `
            <div class="h-12 flex items-center justify-center text-2xl font-bold ${name === finalDest.stationName && idx === scrollItems.length - 1 ? "text-yellow-400" : "text-white"}" 
                 style="height: ${itemHeight}px;">${name}</div>
        `
            )
            .join("");

          // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆç¬¬ä¸€ä¸ªé¡¹ç›®åœ¨ä¸­å¿ƒï¼‰
          scrollContainer.style.transform = `translateY(-${itemHeight / 2}px)`;
          scrollContainer.style.transition = "none";

          await wait(100);

          // å¼€å§‹æ»šåŠ¨åŠ¨ç”»
          const totalItems = scrollItems.length;
          const finalOffset = (totalItems - 1) * itemHeight + itemHeight / 2;

          // å…ˆå¿«åæ…¢çš„æ»šåŠ¨æ•ˆæœ
          const duration = 3000;
          scrollContainer.style.transition = `transform ${duration}ms cubic-bezier(0.15, 0.85, 0.35, 1)`;
          scrollContainer.style.transform = `translateY(-${finalOffset}px)`;

          // Promise that resolves when animation should end (either timeout or click)
          let resolveAnimation;
          const animationPromise = new Promise(r => resolveAnimation = r);
          
          let isStopped = false;
          let selectedCity = finalDest; // Default to finalDest

          // Auto stop after duration + buffer
          const autoTimer = setTimeout(() => {
             if(!isStopped) {
                 isStopped = true;
                 resolveAnimation();
             }
          }, duration + 200);

      // Manual stop: pause immediately and wait for second click
      stopBtn.onclick = () => {
        if (!isStopped) {
          isStopped = true;
          clearTimeout(autoTimer);

          // Immediately freeze at the current transform value
          const computed = window.getComputedStyle(scrollContainer).transform;
          let currentY = 0;
          if (computed && computed !== "none") {
            // Handle matrix and matrix3d formats
            const matMatch = computed.match(/matrix.*\((.+)\)/);
            if (matMatch) {
              const values = matMatch[1].split(',');
              if (values.length === 6) {
              // matrix(a, b, c, d, tx, ty)
              currentY = parseFloat(values[5]);
            } else if (values.length === 16) {
              // matrix3d(..., ty at index 13)
              currentY = parseFloat(values[13]);
            }
            }
          } else {
            // Fallback: try to get transform from inline style
            const inlineTransform = scrollContainer.style.transform.match(/translateY\((-?\d+\.?\d*)px\)/);
            if (inlineTransform) currentY = parseFloat(inlineTransform[1]);
          }

          // Snap to nearest item (align to center)
          // currentY is negative. Center of item i is at -(i*h + h/2)
          // i = (-currentY - h/2) / h
          let itemIndex = Math.round((-currentY - itemHeight / 2) / itemHeight);
          // Clamp index
          itemIndex = Math.max(0, Math.min(itemIndex, scrollItems.length - 1));
          
          const snappedY = -(itemIndex * itemHeight + itemHeight / 2);

          // Get the city name at this position
          const cityName = scrollItems[itemIndex];
          selectedCity = stations.find(s => s.stationName === cityName) || finalDest;

          // Freeze at snapped position with smooth transition
          scrollContainer.style.transition = "transform 0.2s ease-out";
          scrollContainer.style.transform = `translateY(${snappedY}px)`;

          // After snap animation, change button text to "ç°åœ¨å‡ºå‘"
          setTimeout(() => {
            stopBtn.innerHTML = '<span class="mr-2 text-2xl">ğŸš€</span> ç°åœ¨å‡ºå‘';
            
            // Wait for second click to continue
            stopBtn.onclick = () => {
              resolveAnimation();
            };
          }, 200);
        }
      };

          // Wait for animation to finish (or be skipped)
          await animationPromise;
          
          // Update finalDest to the selected city
          finalDest = selectedCity;

          // ç›´æ¥æ·¡å‡ºå¹¶è¿”å›æ¸¸æˆ
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();
          
          return finalDest;
        }

        createDestinationMarker(tile) {
          const group = new THREE.Group();

          // å‘å…‰åœ†ç¯
          const ringGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 32);
          const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.y = 0.3;
          group.add(ring);

          // æ——æ†
          const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
          const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
          const pole = new THREE.Mesh(poleGeo, poleMat);
          pole.position.set(1.5, 3, 1.5);
          group.add(pole);

          // æ——å¸œ
          const flagGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
          const flagMat = new THREE.MeshLambertMaterial({ color: 0xff4444, side: THREE.DoubleSide });
          const flag = new THREE.Mesh(flagGeo, flagMat);
          flag.position.set(2.5, 5, 1.5);
          group.add(flag);

          // ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»çš„æ˜Ÿæ˜Ÿ
          const starGeo = new THREE.OctahedronGeometry(0.5, 0);
          const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const star = new THREE.Mesh(starGeo, starMat);
          star.position.y = 3;
          star.userData.baseY = 3;
          star.userData.animate = true;
          group.add(star);

          // å®šä½åˆ°ç›®çš„åœ°æ ¼å­
          group.position.copy(tile.worldPos);
          group.position.y = 1;

          this.scene.add(group);
          this.destinationMarker = group;

          // æ˜Ÿæ˜ŸåŠ¨ç”»
          const animateStar = () => {
            if (!this.destinationMarker) return;
            const star = this.destinationMarker.children.find((c) => c.userData.animate);
            if (star) {
              star.position.y = star.userData.baseY + Math.sin(Date.now() * 0.003) * 0.5;
              star.rotation.y += 0.02;
            }
            requestAnimationFrame(animateStar);
          };
          animateStar();
        }

        // æ˜¾ç¤ºåˆ°è¾¾ç›®çš„åœ°çš„ç»“ç®—åŠ¨ç”»
        async showDestinationArrival(player) {
          if (!this.destinationTile) return;

          const destName = this.destinationTile.stationName;

          // åˆ›å»ºç¤¼èŠ±æ•ˆæœå®¹å™¨
          const fireworksContainer = document.createElement("div");
          fireworksContainer.className = "fireworks-container";
          fireworksContainer.id = "fireworks-container";
          document.body.appendChild(fireworksContainer);

          // å¯åŠ¨ç¤¼èŠ±åŠ¨ç”»
          this.startFireworks(fireworksContainer);

          // åˆ›å»ºç»“ç®—åŠ¨ç”»å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "arrival-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.backdropFilter = "blur(4px)";

          overlay.innerHTML = `
            <div class="text-center transform scale-0 transition-transform duration-500" id="arrival-content">
                <div class="text-8xl mb-6 animate-bounce">ğŸ†</div>
                <div class="text-4xl font-black text-yellow-300 mb-4">${player.name} æœ€å…ˆåˆ°è¾¾ç›®çš„åœ°!</div>
                <div class="text-3xl font-bold text-white mb-6">ğŸ“ ${destName}</div>
                <div class="text-2xl text-gray-300 mb-4">è·å¾—äº†</div>
                <div class="text-6xl font-mono font-black text-green-400 mb-6">Â¥${DESTINATION_REWARD}</div>
                <div class="text-xl text-gray-300 mb-2">çš„æ´åŠ©é‡‘!</div>
                <div class="mt-4 flex justify-center gap-2 mb-8">
                    <span class="text-4xl">ğŸ‰</span>
                    <span class="text-4xl">ğŸŠ</span>
                    <span class="text-4xl">âœ¨</span>
                    <span class="text-4xl">ğŸ†</span>
                    <span class="text-4xl">ğŸ‡</span>
                </div>
                <button id="arrival-confirm-btn" class="arrival-btn">ç¡® å®š</button>
            </div>
        `;

          document.body.appendChild(overlay);

          // å¼¹å‡ºåŠ¨ç”»
          await wait(100);
          document.getElementById("arrival-content").style.transform = "scale(1)";

          // æ’­æ”¾é‡‘å¸éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
          this.log(`ğŸ† ${player.name} åˆ°è¾¾ç›®çš„åœ° ${destName}!`, "#22c55e");
          showToast(`ğŸ† ${player.name} è·å¾—æ´åŠ©é‡‘ Â¥${DESTINATION_REWARD}!`, "#22c55e");

          player.money += DESTINATION_REWARD;

          // --- ç©·ç¥é™„èº«é€»è¾‘ ---
          // å¯»æ‰¾è·ç¦»ç›®çš„åœ°æœ€è¿œçš„ç©å®¶ï¼ˆé™¤äº†åˆ°è¾¾è€…ï¼‰
          let maxDist = -1;
          let victim = null;

          // è®¡ç®—æ‰€æœ‰å…¶ä»–ç©å®¶åˆ°å½“å‰ç›®çš„åœ°çš„è·ç¦»
          for (const p of this.players) {
            if (p === player) continue;

            const dist = this.calculateDistanceToDestination(p.currentTile);
            // å¦‚æœæ— æ³•åˆ°è¾¾(-1)ï¼Œè§†ä¸ºæ— ç©·è¿œ
            const effectiveDist = dist === -1 ? 9999 : dist;

            if (effectiveDist > maxDist) {
              maxDist = effectiveDist;
              victim = p;
            } else if (effectiveDist === maxDist) {
              // è·ç¦»ç›¸åŒæ—¶ï¼Œéšæœºé€‰æ‹©
              if (Math.random() > 0.5) victim = p;
            }
          }

          if (victim) {
            // å¦‚æœç©·ç¥å·²ç»åœ¨æŸäººèº«ä¸Šï¼Œä¸”é‚£ä¸ªäººä¸æ˜¯victimï¼Œåˆ™è½¬ç§»
            // å¦‚æœç©·ç¥è¿˜æ²¡å‡ºç°ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰ï¼Œåˆ™é™„èº«victim
            const currentOwner = this.players.find((p) => p.hasBinbougami);
            if (currentOwner !== victim) {
              await wait(500);
              await this.attachBinbougami(victim);
            }
          }

          this.updateUI();

          // ç­‰å¾…ç”¨æˆ·ç‚¹å‡»ç¡®å®šæŒ‰é’®
          await new Promise((resolve) => {
            const confirmBtn = document.getElementById("arrival-confirm-btn");
            confirmBtn.addEventListener("click", () => {
              resolve();
            }, { once: true });
          });

          // åœæ­¢ç¤¼èŠ±åŠ¨ç”»
          this.stopFireworks();

          // æ·¡å‡ºåŠ¨ç”»
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();
          
          // ç§»é™¤ç¤¼èŠ±å®¹å™¨
          const fwContainer = document.getElementById("fireworks-container");
          if (fwContainer) fwContainer.remove();

          // è®¾ç½®æ–°çš„ç›®çš„åœ°
          await this.setNewDestination();
        }

        // å¯åŠ¨ç¤¼èŠ±åŠ¨ç”»
        startFireworks(container) {
          this.fireworksActive = true;
          this.fireworksInterval = setInterval(() => {
            if (!this.fireworksActive) return;
            this.createFirework(container);
          }, 300);
          
          // ç«‹å³åˆ›å»ºå‡ ä¸ªç¤¼èŠ±
          for (let i = 0; i < 5; i++) {
            setTimeout(() => this.createFirework(container), i * 100);
          }
        }

        // åœæ­¢ç¤¼èŠ±åŠ¨ç”»
        stopFireworks() {
          this.fireworksActive = false;
          if (this.fireworksInterval) {
            clearInterval(this.fireworksInterval);
            this.fireworksInterval = null;
          }
        }

        // åˆ›å»ºå•ä¸ªç¤¼èŠ±æ•ˆæœ
        createFirework(container) {
          if (!this.fireworksActive || !container) return;

          const colors = ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#0066ff', '#ff00ff', '#ff69b4', '#ffd700'];
          const x = Math.random() * window.innerWidth;
          const y = Math.random() * (window.innerHeight * 0.6) + window.innerHeight * 0.1;
          
          // åˆ›å»ºå‘å°„è½¨è¿¹
          const trail = document.createElement("div");
          trail.className = "firework-trail";
          trail.style.left = x + "px";
          trail.style.bottom = "0";
          trail.style.background = colors[Math.floor(Math.random() * colors.length)];
          trail.style.setProperty("--end-y", -y + "px");
          container.appendChild(trail);
          
          // è½¨è¿¹æ¶ˆå¤±ååˆ›å»ºçˆ†ç‚¸æ•ˆæœ
          setTimeout(() => {
            trail.remove();
            
            // åˆ›å»ºçˆ†ç‚¸ç²’å­
            const particleCount = 20 + Math.floor(Math.random() * 15);
            const baseColor = colors[Math.floor(Math.random() * colors.length)];
            
            for (let i = 0; i < particleCount; i++) {
              const particle = document.createElement("div");
              particle.className = "firework";
              particle.style.left = x + "px";
              particle.style.top = y + "px";
              particle.style.background = baseColor;
              particle.style.boxShadow = `0 0 6px ${baseColor}, 0 0 10px ${baseColor}`;
              
              const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.3;
              const distance = 50 + Math.random() * 100;
              const tx = Math.cos(angle) * distance;
              const ty = Math.sin(angle) * distance;
              
              particle.style.setProperty("--tx", tx + "px");
              particle.style.setProperty("--ty", ty + "px");
              
              container.appendChild(particle);
              
              // è‡ªåŠ¨ç§»é™¤ç²’å­
              setTimeout(() => particle.remove(), 1500);
            }
            
            // æ·»åŠ ä¸€äº›é—ªçƒçš„emoji
            const sparkles = ['âœ¨', 'â­', 'ğŸŒŸ', 'ğŸ’«'];
            for (let i = 0; i < 3; i++) {
              const sparkle = document.createElement("div");
              sparkle.className = "sparkle";
              sparkle.textContent = sparkles[Math.floor(Math.random() * sparkles.length)];
              sparkle.style.left = (x + (Math.random() - 0.5) * 100) + "px";
              sparkle.style.top = (y + (Math.random() - 0.5) * 100) + "px";
              container.appendChild(sparkle);
              
              setTimeout(() => sparkle.remove(), 2000);
            }
          }, 800);
        }

        // --- å¹´åº¦å†³ç®—ç³»ç»Ÿ ---

        advanceTime() {
          this.totalTurns++;
          this.gameMonth++;

          if (this.gameMonth > 12) {
            this.gameMonth = 1;
            this.gameYear++;
          }

          // æ›´æ–°æ—¶é—´æ˜¾ç¤º
          document.getElementById("game-year").innerText = this.gameYear;
          document.getElementById("game-month").innerText = this.gameMonth;

          // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å†³ç®—æœˆï¼ˆ3æœˆï¼‰
          if (this.gameMonth === SETTLEMENT_MONTH) {
            return true; // éœ€è¦å†³ç®—
          }
          return false;
        }

        async performSettlement() {
          this.log(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—å¼€å§‹ï¼`, "#fbbf24");
          showToast(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—ï¼`, "#fbbf24");

          await wait(500);

          for (const player of this.players) {
            let totalIncome = 0;
            const ownedStations = new Map(); // stationName -> buildingCount

            // ç»Ÿè®¡æ¯ä¸ªè½¦ç«™çš„ç‰©ä»¶
            this.map.forEach((tile) => {
              if (tile.type === "green" && tile.owner === player.id) {
                const stationBuildings = tile.buildings.length;
                if (stationBuildings > 0) {
                  ownedStations.set(tile.stationName, stationBuildings);

                  // è®¡ç®—è¯¥è½¦ç«™çš„æ”¶ç›Š
                  let stationIncome = 0;
                  tile.buildings.forEach((tierIndex) => {
                    stationIncome += BUILDING_INCOME[tierIndex];
                  });

                  // ç‹¬å å¥–åŠ±ï¼šå¦‚æœæ‹¥æœ‰å…¨éƒ¨3ç§ç‰©ä»¶ï¼Œæ”¶ç›Šç¿»å€
                  const isMonopoly = tile.buildings.length === 3;
                  if (isMonopoly) {
                    stationIncome *= 2;
                    this.log(`ğŸ† ${tile.stationName} ç‹¬å åŠ æˆï¼`, "#a855f7");
                  }

                  totalIncome += stationIncome;
                }
              }
            });

            if (totalIncome > 0) {
              player.money += totalIncome;
              this.log(`ğŸ’° ${player.name} æ”¶åˆ°çº¢åˆ© Â¥${totalIncome}`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
              await this.showMoneyChangeDialog(player, totalIncome);
            } else {
              this.log(`${player.name} æ²¡æœ‰ç‰©ä»¶æ”¶ç›Š`, "#9ca3af");
            }
          }

          this.updateUI();
          await wait(500);
        }

        // --- UI & Interaction ---

        log(msg, color = "white") {
          const logEl = document.getElementById("game-log");
          const entry = document.createElement("div");
          entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
          logEl.appendChild(entry);
          if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
          setTimeout(() => {
            entry.style.opacity = "0";
            setTimeout(() => entry.remove(), 500);
          }, 4000);
        }

        startTurn() {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          const p = this.players[this.turn];
          document.getElementById("turn-indicator").innerText = `${p.name} çš„å›åˆ`;

          // Center camera on the current player
          this.centerCameraOnPlayer(p);

          const p1Panel = document.getElementById("p1-panel");
          const comPanel = document.getElementById("com-panel");

          p1Panel.style.opacity = this.turn === 0 ? "1" : "0.6";
          p1Panel.style.transform = this.turn === 0 ? "scale(1.05)" : "scale(1)";
          p1Panel.classList.toggle("border-yellow-400", this.turn === 0);

          comPanel.style.opacity = this.turn === 1 ? "1" : "0.6";
          comPanel.style.transform = this.turn === 1 ? "scale(1.05)" : "scale(1)";
          comPanel.classList.toggle("border-yellow-400", this.turn === 1);

          this.state = "IDLE";

          // Check for skip turn (Hibernate)
          if (p.skipNextTurn) {
            p.skipNextTurn = false;
            this.log(`ğŸ’¤ ${p.name} æ­£åœ¨å†¬çœ ï¼Œè·³è¿‡å›åˆ`, "#9ca3af");
            setTimeout(() => this.nextTurn(), 1500);
            return;
          }

          if (p.isAI) {
            document.getElementById("roll-btn").classList.add("hidden");
            document.getElementById("use-card-btn").classList.add("hidden");
            setTimeout(() => this.aiAction(), 1000);
          } else {
            document.getElementById("roll-btn").classList.remove("hidden");
            const useCardBtn = document.getElementById("use-card-btn");
            if (p.cards.length > 0) {
              useCardBtn.classList.remove("hidden");
              useCardBtn.onclick = () => this.openUseCardModal();
            } else {
              useCardBtn.classList.add("hidden");
            }
          }
        }

        async playerRoll() {
          if (this.state !== "IDLE") return;
          document.getElementById("roll-btn").classList.add("hidden");
          await this.processMove();
        }

        async aiAction() {
          this.log("ç”µè„‘æ­£åœ¨æ€è€ƒ...", "#fca5a5");
          await wait(1000);
          await this.processMove();
        }

        async processMove(diceCount = 1) {
          this.state = "MOVING";
          
          const player = this.players[this.turn];
          
          // Use dice animation to roll
          const { results: rolls, total: steps } = await diceAnimation.roll(diceCount);
          
          this.log(`${player.name} æ·å‡ºäº† ${rolls.join("+")} = ${steps} ç‚¹!`, "#fbbf24");

          // Allow changing direction at the start of the turn
          player.previousTile = null;

          // è®°å½•èµ·ç‚¹ä½ç½®ï¼Œç”¨äºè®¡ç®—è·ç¦»
          const startTile = player.currentTile;
          // è®°å½•è®¿é—®è¿‡çš„æ ¼å­åŠå…¶ä»èµ·ç‚¹çš„æœ€çŸ­è·ç¦»
          const visitedDistances = new Map();
          visitedDistances.set(startTile, 0);
          
          let currentDistance = 0; // å½“å‰è·ç¦»èµ·ç‚¹çš„æ­¥æ•°
          let reachedDestination = false;

          // AIé¢„è®¡ç®—è·¯å¾„
          let aiPath = null;
          let aiPathIndex = 0;
          if (player.isAI && this.destinationTile) {
            aiPath = this.calculateAIPath(startTile, steps);
            if (aiPath && aiPath.length > 1) {
              aiPathIndex = 1; // ä»ç¬¬äºŒä¸ªæ ¼å­å¼€å§‹ï¼ˆç¬¬ä¸€ä¸ªæ˜¯èµ·ç‚¹ï¼‰
              this.log(`ğŸ¤– AIè§„åˆ’äº†${aiPath.length - 1}æ­¥è·¯å¾„`, "#60a5fa");
            }
          }

          while (currentDistance < steps) {
            const current = player.currentTile;
            const neighbors = current.neighbors;

            let validNext = neighbors.filter((n) => n !== player.previousTile);
            if (validNext.length === 0 && neighbors.length > 0) {
              validNext = neighbors; // Dead end fallback
            }

            let nextTile = null;

            // AIä½¿ç”¨é¢„è®¡ç®—çš„è·¯å¾„
            if (player.isAI && aiPath && aiPathIndex < aiPath.length) {
              nextTile = aiPath[aiPathIndex];
              aiPathIndex++;
            } else if (validNext.length === 1) {
              nextTile = validNext[0];
            } else if (validNext.length > 1) {
              if (player.isAI) {
                // AIå›é€€ï¼šå¦‚æœé¢„è®¡ç®—è·¯å¾„ç”¨å®Œæˆ–æ— æ•ˆï¼Œä½¿ç”¨ç®€å•ç­–ç•¥
                nextTile = this.chooseBestDirection(validNext);
              } else {
                nextTile = await this.askDirection(player, validNext);
              }
            } else {
              break;
            }

            // Physics Move
            player.previousTile = player.currentTile;
            player.currentTile = nextTile;

            await this.animateMove(player, nextTile.worldPos);

            // --- Binbougami Transfer Check ---
            // Check if we passed another player
            for (const other of this.players) {
              if (other !== player && other.currentTile === player.currentTile) {
                // Collision!
                if (player.hasBinbougami) {
                  // Transfer FROM player TO other
                  this.log(`ğŸ‘» ç©·ç¥ä» ${player.name} è½¬ç§»åˆ°äº† ${other.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(other);
                } else if (other.hasBinbougami) {
                  // Transfer FROM other TO player
                  this.log(`ğŸ‘» ç©·ç¥ä» ${other.name} è½¬ç§»åˆ°äº† ${player.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(player);
                }
              }
            }

            // æ›´æ–°è·ç¦»æ˜¾ç¤º
            this.updateDistanceDisplay();

            // è®¡ç®—æ–°çš„è·ç¦»ï¼šåŸºäºè·ç¦»èµ·ç‚¹çš„æ­¥æ•°
            if (nextTile.isColored) {
              // è®¡ç®—åˆ°è¾¾è¿™ä¸ªæ ¼å­æ—¶è·ç¦»èµ·ç‚¹çš„æ­¥æ•°
              let newDistance;
              if (visitedDistances.has(nextTile)) {
                // å¦‚æœå›åˆ°ä¹‹å‰è®¿é—®è¿‡çš„æ ¼å­ï¼Œä½¿ç”¨ä¹‹å‰è®°å½•çš„è·ç¦»
                newDistance = visitedDistances.get(nextTile);
              } else {
                // æ–°æ ¼å­ï¼šè·ç¦»åŠ 1
                newDistance = currentDistance + 1;
                visitedDistances.set(nextTile, newDistance);
              }
              currentDistance = newDistance;
            }
          }

          // åªæœ‰åˆšå¥½è½åœ¨ç›®çš„åœ°æ‰ç®—åˆ°è¾¾ï¼ˆæ­¥æ•°ç”¨å®Œæ—¶æ­£å¥½åœ¨ç›®çš„åœ°ï¼‰
          if (this.destinationTile && player.currentTile === this.destinationTile) {
            reachedDestination = true;
            await this.showDestinationArrival(player);
          }

          await wait(300);
          await this.triggerTileEvent(player, reachedDestination);
        }

        animateMove(player, targetVec3) {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          return new Promise((resolve) => {
            const startPos = player.mesh.position.clone();
            const startTime = Date.now();
            const duration = 300; // ms

            // Simple Hop Animation
            const animateStep = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Linear Interpolation for X/Z
              player.mesh.position.lerpVectors(startPos, targetVec3, progress);

              // Parabolic Arc for Y (Jump)
              // y = 4 * height * x * (1-x) + baseline
              const jumpHeight = 2;
              const baseHeight = 1.5;
              player.mesh.position.y = baseHeight + 4 * jumpHeight * progress * (1 - progress);

              if (progress < 1) {
                requestAnimationFrame(animateStep);
              } else {
                player.mesh.position.copy(targetVec3);
                player.mesh.position.y = baseHeight;
                resolve();
              }
            };
            animateStep();
          });
        }

        async askDirection(player, options) {
          // Center camera on the player before showing direction options
          await this.centerCameraOnPlayer(player, 300);

          // Determine best direction
          let bestTile = null;
          if (this.destinationTile) {
             bestTile = this.chooseBestDirection(options);
          }

          return new Promise((resolve) => {
            const overlay = document.createElement("div");
            overlay.className = "absolute inset-0 pointer-events-auto z-50";
            overlay.id = "direction-overlay";
            document.getElementById("ui-layer").appendChild(overlay);

            options.forEach((tile) => {
              // Lift the icon slightly so it appears on top of the tile
              const targetPos = tile.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
              const screenPos = this.getScreenPosition(targetPos);

              let label = "ğŸ“";
              const dx = tile.gridX - player.currentTile.gridX;
              const dy = tile.gridY - player.currentTile.gridY; // using gridY as Z

                if (dx > 0) label = "â–¶";
                else if (dx < 0) label = "â—€";
                else if (dy > 0) label = "â–¼";
                else if (dy < 0) label = "â–²";

              // Container for positioning (handles centering)
              const container = document.createElement("div");
              container.className = "absolute";
              container.style.left = `${screenPos.x}px`;
              container.style.top = `${screenPos.y}px`;
              container.style.transform = "translate(-50%, -50%)";

              // Button for appearance and interaction (handles animation)
              const btn = document.createElement("button");
              btn.innerText = label;
              
              const isBest = tile === bestTile;
              const baseClass = "w-12 h-12 rounded-full text-2xl shadow-xl border-4 animate-bounce-custom cursor-pointer transition-transform hover:scale-110";
              const colorClass = isBest 
                ? "bg-yellow-400 hover:bg-yellow-300 border-white text-black ring-4 ring-yellow-300 ring-opacity-50" 
                : "bg-blue-300 hover:bg-blue-200 border-white text-black";
              
              btn.className = `${baseClass} ${colorClass}`;
              
              if (isBest) {
                  btn.style.zIndex = "10";
                  // Add a small indicator for "Best"
                  const badge = document.createElement("div");
                  badge.className = "absolute -top-2 -right-2 bg-yellow-300 text-yellow-800 text-xs font-bold px-1 rounded border border-yellow-500";
                  container.appendChild(badge);
              }

              btn.onclick = () => {
                document.getElementById("direction-overlay").remove();
                resolve(tile);
              };

              container.appendChild(btn);

              // Store 3D position on container for frame updates
              container.target3D = targetPos;

              overlay.appendChild(container);
            });
          });
        }

        async showMoneyChangeDialog(player, changeAmount) {
          return new Promise((resolve) => {
            const modal = document.getElementById("money-modal");
            const title = document.getElementById("money-modal-title");
            const amountEl = document.getElementById("money-modal-amount");
            const deltaEl = document.getElementById("money-modal-delta");
            const icon = document.getElementById("money-modal-icon");
            const container = modal.firstElementChild;

            modal.classList.remove("hidden");

            const endMoney = player.money;
            const startMoneyVal = endMoney - changeAmount;

            const isGain = changeAmount > 0;
            const colorClass = isGain ? "text-blue-600" : "text-red-600";
            const borderClass = isGain ? "border-blue-500" : "border-red-500";

            container.className = `bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100 ${borderClass}`;

            title.innerText = player.name;
            icon.innerText = isGain ? "ğŸ¤‘" : "ğŸ’¸";

            deltaEl.className = `text-3xl font-black mb-2 ${colorClass}`;
            deltaEl.innerText = (isGain ? "+" : "") + "Â¥" + changeAmount;

            // Animation
            const duration = 1500;
            const startTime = Date.now();

            const animate = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);
              const ease = 1 - Math.pow(1 - progress, 4); // Ease out

              const currentVal = Math.floor(startMoneyVal + changeAmount * ease);
              amountEl.innerText = "Â¥" + currentVal;

              if (progress < 1) {
                requestAnimationFrame(animate);
              } else {
                amountEl.innerText = "Â¥" + endMoney;
                setTimeout(() => {
                  modal.classList.add("hidden");
                  resolve();
                }, 800);
              }
            };

            animate();
          });
        }

        // --- ç©·ç¥ç³»ç»Ÿæ–¹æ³• ---

        async attachBinbougami(player) {
          // Remove from current owner
          const currentOwner = this.players.find((p) => p.hasBinbougami);
          if (currentOwner) {
            currentOwner.hasBinbougami = false;
            // Remove visual from current owner
            if (currentOwner.binbougamiMesh) {
              // Remove from whichever parent it was attached to
              try {
                if (typeof currentOwner.binbougamiMesh.removeFromParent === "function") currentOwner.binbougamiMesh.removeFromParent();
                else if (currentOwner.binbougamiMesh.parent) currentOwner.binbougamiMesh.parent.remove(currentOwner.binbougamiMesh);
              } catch (e) {
                // swallow
              }
              currentOwner.binbougamiMesh = null;
            }
          }

          // Attach to new player
          player.hasBinbougami = true;
          player.binbougamiTurns = 0;
          player.binbougamiLevel = 0; // Reset to normal
          player.binbougamiJustAttached = true; // æ ‡è®°åˆšåˆšé™„èº«ï¼Œæœ¬å›åˆä¸è§¦å‘æ•ˆæœ

          this.log(`ğŸ‘» ç©·ç¥é™„èº«åœ¨äº† ${player.name} èº«ä¸Šï¼`, "#a855f7");

          // Play possession sequence
          await this.showBinbougamiPossessionSequence(player);

          this.updateUI();
        }

        async showBinbougamiPossessionSequence(player) {
          // 1. Show Fullscreen UI
          const modal = document.getElementById("possession-modal");
          const content = document.getElementById("possession-content");
          const text = document.getElementById("possession-text");

          if (modal && content && text) {
            text.innerText = `${player.name} è¢«ç©·ç¥é™„èº«äº†ï¼`;
            modal.classList.remove("hidden");

            // Trigger animation
            // Force reflow
            void modal.offsetWidth;

            content.classList.remove("scale-0");
            content.classList.add("scale-100");

            // Wait for UI
            await new Promise((resolve) => setTimeout(resolve, 2500));

            // Hide UI
            content.classList.remove("scale-100");
            content.classList.add("scale-0");
            setTimeout(() => {
              modal.classList.add("hidden");
            }, 500);
          }

          // 2. Move Camera to Player
          this.cameraLocked = false;
          await this.centerCameraOnPlayer(player, 800);

          // 3. Create Falling Binbougami
          this.createBinbougamiMesh(player, true);

          // Wait for fall animation (approx 1s)
          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Shake effect (simple camera shake)
          const originalPos = this.camera.position.clone();
          for (let i = 0; i < 10; i++) {
            this.camera.position.x = originalPos.x + (Math.random() - 0.5) * 2;
            this.camera.position.y = originalPos.y + (Math.random() - 0.5) * 2;
            this.camera.position.z = originalPos.z + (Math.random() - 0.5) * 2;
            await new Promise((r) => setTimeout(r, 30));
          }
          this.camera.position.copy(originalPos);

          // Restore camera lock if in game mode
          if (this.mode === "GAME") {
            this.cameraLocked = true;
          }
        }

        createBinbougamiMesh(player, animateFalling = false) {
          if (player.binbougamiMesh) return;

          const group = new THREE.Group();
          // Use a modest world scale so the ghost matches character size
          const scale = 1.2; // slightly bigger than player head

          // Simple Ghost Shape
          const bodyGeo = new THREE.SphereGeometry(0.4, 16, 16);
          const bodyMat = new THREE.MeshLambertMaterial({ color: 0xa855f7 }); // Purple
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 0.5;
          group.add(body);

          // Tail
          const tailGeo = new THREE.ConeGeometry(0.2, 0.6, 16);
          const tail = new THREE.Mesh(tailGeo, bodyMat);
          tail.position.y = 0.1;
          tail.rotation.x = Math.PI;
          group.add(tail);

          // Eyes
          const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
          const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.position.set(-0.15, 0.55, 0.3);
          group.add(leftEye);

          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.position.set(0.15, 0.55, 0.3);
          group.add(rightEye);

          // Apply scale
          group.scale.set(scale, scale, scale);

          // ç®€åŒ–ä½ç½®ç®—æ³•ï¼šç›´æ¥æŒ‚åœ¨ player.mesh ä¸Šï¼Œä½¿ç”¨å›ºå®šé«˜åº¦
          // ç©å®¶æ¨¡å‹é«˜åº¦çº¦ä¸º 3 å•ä½ï¼ˆå¤´é¡¶ hat åœ¨ y=3ï¼‰ï¼Œç©·ç¥æ˜¾ç¤ºåœ¨ y=4.5 çš„ä½ç½®
          const fixedHeight = 4.5;

          // å…ˆé™„åŠ åˆ°ç©å®¶meshå¹¶è®¾ç½®å¼•ç”¨ï¼Œè¿™æ ·åŠ¨ç”»å›è°ƒå¯ä»¥æ­£å¸¸å·¥ä½œ
          player.mesh.add(group);
          player.binbougamiMesh = group;

          if (animateFalling) {
            const startHeight = fixedHeight + 10; // ä»ä¸Šæ–¹10å•ä½è½ä¸‹
            group.position.set(0, startHeight, 0);

            const startTime = Date.now();
            const duration = 600; // 0.6 second fall

            const animateFall = () => {
              if (!player.binbougamiMesh || !group.parent) return;

              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Quadratic ease in (accelerate)
              const currentY = startHeight - (startHeight - fixedHeight) * (progress * progress);
              group.position.y = currentY;

              if (progress < 1) {
                requestAnimationFrame(animateFall);
              } else {
                group.position.y = fixedHeight;
                this.animateBinbougamiHover(group, fixedHeight);
              }
            };
            animateFall();
          } else {
            group.position.set(0, fixedHeight, 0);
            this.animateBinbougamiHover(group, fixedHeight);
          }
        }

        animateBinbougamiHover(group, baseY) {
          const animate = () => {
            if (!group.parent) return; // Removed from scene

            const time = Date.now() * 0.002;
            group.position.y = baseY + Math.sin(time) * 0.5;
            group.rotation.y = Math.sin(time * 0.5) * 0.2; // Slight rotation

            requestAnimationFrame(animate);
          };
          animate();
        }

        async handleBinbougamiAction(player) {
          if (!player.hasBinbougami) return;

          player.binbougamiTurns++;

          // æ£€æŸ¥æ˜¯å¦å‡çº§ä¸ºå¤§é­”ç‹ (ä¾‹å¦‚8å›åˆå)
          if (player.binbougamiLevel === 0 && player.binbougamiTurns >= BINBOUGAMI_UPGRADE_TURNS) {
            player.binbougamiLevel = 1;
            this.log(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            showToast(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            // Update visual to look scarier (scale up, turn red)
            if (player.binbougamiMesh) {
              player.binbougamiMesh.children[0].material.color.setHex(0xef4444); // Red body
              // Scale up modestly for 'king' mode rather than huge value
              player.binbougamiMesh.scale.set(2.4, 2.4, 2.4);
            }
            await wait(1000);
          }

          // å†³å®šæ•ˆæœ
          const effects = player.binbougamiLevel === 1 ? BINBOUGAMI_EFFECTS.king : BINBOUGAMI_EFFECTS.normal;
          const effect = effects[Math.floor(Math.random() * effects.length)];

          // æ˜¾ç¤ºå¼¹çª—
          await this.showBinbougamiDialog(player, effect);

          // æ‰§è¡Œæ•ˆæœ
          switch (effect.type) {
            case "loseMoney":
              const amount = rand(effect.min, effect.max);
              player.money -= amount;
              this.log(`${player.name} æŸå¤±äº† Â¥${amount}`, "#ef4444");
              break;
            case "debt":
              const debt = rand(effect.min, effect.max);
              player.money -= debt;
              this.log(`${player.name} èƒŒè´Ÿäº† Â¥${debt} å€ºåŠ¡`, "#ef4444");
              break;
            case "sellProperty":
              await this.sellRandomProperty(player);
              break;
            case "sellAllProperty":
              // Sell multiple properties
              let count = 0;
              while ((await this.sellRandomProperty(player, false)) && count < 5) {
                count++;
              }
              break;
            case "nothing":
              this.log("ç©·ç¥ä»€ä¹ˆä¹Ÿæ²¡åš", "#9ca3af");
              break;
          }

          this.updateUI();
        }

        async sellRandomProperty(player, showLog = true) {
          // Find owned properties
          const ownedTiles = this.map.filter((t) => t.owner === player.id && t.buildings.length > 0);
          if (ownedTiles.length === 0) {
            if (showLog) this.log("ç©·ç¥æƒ³å–åœ°ï¼Œä½†ä½ ä¸€æ— æ‰€æœ‰...", "#9ca3af");
            return false;
          }

          const tile = ownedTiles[Math.floor(Math.random() * ownedTiles.length)];
          // Sell the most expensive building on this tile
          const buildingIdx = tile.buildings.pop(); // Remove last added

          const sellPrice = Math.floor(BUILDING_COSTS[buildingIdx] / 2);
          player.money += sellPrice;
          player.assets -= BUILDING_COSTS[buildingIdx];

          // If no buildings left, clear owner
          if (tile.buildings.length === 0) {
            tile.owner = null;
          }

          this.removeBuildingVisually(tile);

          if (showLog) this.log(`ç©·ç¥å–æ‰äº† ${tile.stationName} çš„ç‰©ä»¶ï¼Œè·å¾— Â¥${sellPrice}`, "#ef4444");
          return true;
        }

        removeBuildingVisually(stationTile) {
          // Find environment tiles around station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              if (t && !t.isRoad && t.mesh.children.length > 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            // Pick one and remove a child
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            if (target.mesh.children.length > 0) {
              target.mesh.remove(target.mesh.children[target.mesh.children.length - 1]);
            }
          }
        }

        async showBinbougamiDialog(player, effect) {
          return new Promise((resolve) => {
            const modal = document.getElementById("binbougami-modal");
            const title = document.getElementById("binbougami-modal-title");
            const desc = document.getElementById("binbougami-modal-desc");
            const effectEl = document.getElementById("binbougami-modal-effect");
            const hint = document.getElementById("binbougami-modal-hint");

            modal.classList.remove("hidden");

            title.innerText = player.binbougamiLevel === 1 ? "å¤§é­”ç‹é™ä¸´ï¼" : "ç©·ç¥æ¥è¢­ï¼";
            // æ›¿æ¢å ä½ç¬¦ï¼šç”¨æˆ·æ˜¾ç¤º"ä½ "ï¼ŒAIæ˜¾ç¤ºç©å®¶åå­—
            const displayName = player.isAI ? player.name : "ä½ ";
            desc.innerText = effect.msg.replace(/{playerName}/g, displayName);
            effectEl.innerText = "";
            hint.innerText = "ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...";

            // Auto close after delay
            setTimeout(() => {
              modal.classList.add("hidden");
              resolve();
            }, 2500);
          });
        }

        // æ˜¾ç¤ºAIè´­ä¹°æˆ¿äº§å¼¹çª—
        async showAIPurchaseDialog(player, property, location) {
          return new Promise((resolve) => {
            const modal = document.getElementById("ai-purchase-modal");
            const title = document.getElementById("ai-purchase-title");
            const propertyName = document.getElementById("ai-purchase-property-name");
            const locationEl = document.getElementById("ai-purchase-location");
            const priceEl = document.getElementById("ai-purchase-price");

            modal.classList.remove("hidden");

            title.innerText = `${player.name} è´­ä¹°æˆ¿äº§`;
            propertyName.innerText = property.homeName;
            locationEl.innerText = `ğŸ“ ${location}`;
            priceEl.innerText = `-Â¥${property.price.toLocaleString()}`;

            // Auto close after delay
            setTimeout(() => {
              modal.classList.add("hidden");
              resolve();
            }, 2000);
          });
        }

        // --- å¡ç‰Œç³»ç»Ÿæ–¹æ³• ---

        async handleCardStation(player) {
          // Randomly pick a card from pool based on rarity weights
          const r = Math.random();
          let pool = CARD_POOL.common;
          if (r > 0.7) pool = CARD_POOL.rare;
          if (r > 0.95) pool = CARD_POOL.epic;

          const cardKey = pool[Math.floor(Math.random() * pool.length)];
          const card = CARD_TYPES[cardKey];

          // Add to player hand
          if (player.cards.length < MAX_HAND_SIZE) {
            player.cards.push(cardKey);
            this.log(`ğŸ´ ${player.name} è·å¾—äº† [${card.name}]`, "#fbbf24");
            await this.showCardGetDialog(player, card);
          } else {
            this.log(`ğŸ´ ${player.name} æ‰¾åˆ°äº† [${card.name}]ï¼Œä½†æ˜¯æ‰‹ç‰Œæ»¡äº†...`, "#9ca3af");
            showToast("æ‰‹ç‰Œå·²æ»¡ï¼Œæ— æ³•è·å–æ–°å¡ç‰‡", "gray");
          }
        }

        async showCardGetDialog(player, card) {
          return new Promise((resolve) => {
            const modal = document.getElementById("card-modal");
            const content = document.getElementById("card-modal-content");

            modal.classList.remove("hidden");
            content.innerHTML = `
                <div class="text-center">
                    <div class="text-6xl mb-4">${card.icon}</div>
                    <div class="text-3xl font-bold text-gray-800 mb-2">${card.name}</div>
                    <div class="text-gray-600">${card.desc}</div>
                    <div class="mt-4 text-sm text-yellow-600 font-bold">ç¨€æœ‰åº¦: ${card.rarity.toUpperCase()}</div>
                </div>
            `;

            if (player.isAI) {
              setTimeout(() => {
                this.closeCardModal();
                resolve();
              }, 1500);
            } else {
              this._resolveCardModal = resolve;
            }
          });
        }

        closeCardModal() {
          document.getElementById("card-modal").classList.add("hidden");
          if (this._resolveCardModal) {
            this._resolveCardModal();
            this._resolveCardModal = null;
          }
        }

        openUseCardModal() {
          const player = this.players[0]; // Human player
          if (player.cards.length === 0) return;

          const modal = document.getElementById("use-card-modal");
          const list = document.getElementById("use-card-list");
          list.innerHTML = "";

          player.cards.forEach((cardKey, index) => {
            const card = CARD_TYPES[cardKey];
            const div = document.createElement("div");
            div.className = `card-item w-32 p-3 rounded-xl border-2 flex flex-col items-center gap-2 bg-white shadow-md card-rarity-${card.rarity}`;
            div.onclick = () => this.useCard(index);

            div.innerHTML = `
                <div class="text-3xl">${card.icon}</div>
                <div class="font-bold text-sm text-center">${card.name}</div>
                <div class="text-xs text-gray-600 text-center leading-tight">${card.desc}</div>
            `;
            list.appendChild(div);
          });

          modal.classList.remove("hidden");
        }

        closeUseCardModal() {
          document.getElementById("use-card-modal").classList.add("hidden");
        }

        async useCard(cardIndex) {
          this.closeUseCardModal();
          const player = this.players[0];
          const cardKey = player.cards[cardIndex];
          const card = CARD_TYPES[cardKey];

          // Remove card from hand
          player.cards.splice(cardIndex, 1);
          this.updateUI();

          this.log(`ğŸƒ ${player.name} ä½¿ç”¨äº† [${card.name}]`, "#a855f7");

          // Hide buttons
          document.getElementById("roll-btn").classList.add("hidden");
          document.getElementById("use-card-btn").classList.add("hidden");

          // Execute Effect
          if (card.type === "move") {
            await this.processMove(card.diceCount);
          } else if (card.type === "attack") {
            await this.handleAttackCard(player, card);
            this.nextTurn();
          } else if (card.type === "special") {
            await this.handleSpecialCard(player, card);
            this.nextTurn();
          }
        }

        async handleAttackCard(player, card) {
          const target = this.players.find((p) => p !== player); // Simple 1v1 logic

          if (card.effect === "skip") {
            target.skipNextTurn = true;
            this.log(`ğŸ’¤ ${target.name} ä¸‹å›åˆå°†æ— æ³•è¡ŒåŠ¨ï¼`, "#3b82f6");
            showToast(`${target.name} è¿›å…¥å†¬çœ ï¼`, "#3b82f6");
          } else if (card.effect === "blowAway") {
            // åªé€‰æ‹©stationæ ¼å­(type === "green")
            const stations = this.map.filter((t) => t.type === "green");
            const randomStation = stations[Math.floor(Math.random() * stations.length)];
            target.currentTile = randomStation;
            target.mesh.position.copy(randomStation.worldPos);
            target.mesh.position.y = 1.5;
            this.log(`ğŸ’¨ ${target.name} è¢«å¹é£åˆ°äº† ${randomStation.stationName}ï¼`, "#3b82f6");
            this.updateDistanceDisplay();
          } else if (card.effect === "trap") {
            this.log("é™·é˜±å¡å°šæœªå®è£…", "gray");
          }
          await wait(1000);
        }

        async handleSpecialCard(player, card) {
          if (card.effect === "backward") {
            this.log("åé€€å¡å°šæœªå®è£…", "gray");
          } else if (card.effect === "teleport") {
            const stations = this.map.filter((t) => t.type === "green");
            const target = stations[Math.floor(Math.random() * stations.length)];
            player.currentTile = target;
            player.mesh.position.copy(target.worldPos);
            player.mesh.position.y = 1.5;
            this.log(`ğŸšª ${player.name} ä½¿ç”¨ä»»æ„é—¨ä¼ é€åˆ°äº† ${target.stationName}`, "#a855f7");
            this.updateDistanceDisplay();
          } else if (card.effect === "exorcise") {
            if (player.hasBinbougami) {
              player.hasBinbougami = false;
              if (player.binbougamiMesh) {
                try {
                  if (typeof player.binbougamiMesh.removeFromParent === "function") player.binbougamiMesh.removeFromParent();
                  else if (player.binbougamiMesh.parent) player.binbougamiMesh.parent.remove(player.binbougamiMesh);
                } catch (e) {}
                player.binbougamiMesh = null;
              }
              this.log(`ğŸ“¿ ç©·ç¥è¢«é©±æ•£äº†ï¼`, "#fbbf24");
            } else {
              this.log("ä½ èº«ä¸Šæ²¡æœ‰ç©·ç¥...", "gray");
            }
          }
          await wait(1000);
        }

        async triggerTileEvent(player, alreadyReachedDestination = false) {
          this.state = "EVENT";
          const tile = player.currentTile;
          let endTurn = true;

          // ç›®çš„åœ°åˆ°è¾¾å·²åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­å¤„ç†ï¼Œä¸å†é‡å¤æ£€æŸ¥

          switch (tile.type) {
            case "blue":
              const bonus = rand(500, 2000);
              player.money += bonus;
              this.log(`å¹¸è¿ï¼è·å¾—èµ„é‡‘ Â¥${bonus}`, "#60a5a5");
              await this.showMoneyChangeDialog(player, bonus);
              break;
            case "red":
              const loss = rand(500, 1500);
              player.money -= loss;
              this.log(`å€’éœ‰ï¼æŸå¤± Â¥${loss}`, "#f87171");
              await this.showMoneyChangeDialog(player, -loss);
              break;
            case "yellow":
              await this.handleCardStation(player);
              break;
            case "green":
              endTurn = false;
              await this.handleStation(player, tile);
              break;
          }

          // Handle Binbougami at end of turn
          if (player.hasBinbougami) {
            // å¦‚æœæ˜¯åˆšåˆšé™„èº«çš„ï¼Œæœ¬å›åˆä¸è§¦å‘æ•ˆæœï¼ˆä¸‹å›åˆå¼€å§‹æ‰è§¦å‘ï¼‰
            if (player.binbougamiJustAttached) {
              player.binbougamiJustAttached = false;
            } else {
              await wait(500);
              await this.handleBinbougamiAction(player);
            }
          }

          this.updateUI();
          if (endTurn) this.nextTurn();
        }

        spawnFloatingText(pos, text, color) {
          const div = document.createElement("div");
          div.innerText = text;
          div.style.color = color;
          div.className = "absolute text-2xl font-black shadow-white drop-shadow-md pointer-events-none transition-all duration-1000 ease-out";

          const screenPos = this.getScreenPosition(pos);
          div.style.left = screenPos.x + "px";
          div.style.top = screenPos.y + "px";

          document.getElementById("ui-layer").appendChild(div);

          // Animate via CSS
          requestAnimationFrame(() => {
            div.style.transform = "translateY(-50px)";
            div.style.opacity = "0";
          });

          setTimeout(() => div.remove(), 1000);
        }

        async handleStation(player, tile) {
          if (player.isAI) {
            // AIç­–ç•¥ï¼šå°è¯•è´­ä¹°æˆ¿äº§
            const playerProperties = this.generatePlayerProperties(tile);
            
            // ç­›é€‰å¯è´­ä¹°çš„æˆ¿äº§ï¼ˆæœªè´­ä¹° + èƒ½æ”¯ä»˜ï¼‰
            const affordableProperties = playerProperties.filter(
              p => !p.isPurchased && player.money >= p.price * 1.2
            );
            
            if (affordableProperties.length > 0) {
              // é€‰æ‹©æœ€ä¾¿å®œçš„æˆ¿äº§
              const property = affordableProperties.sort((a, b) => a.price - b.price)[0];
              
              // æ›´æ–°ç¼“å­˜ - ä½¿ç”¨property.indexï¼ˆåŸå§‹ç´¢å¼•ï¼‰è€Œä¸æ˜¯æ’åºåçš„ç´¢å¼•
              const propertyRecord = getOrCreatePropertyId(tile.stationName, property.index);
              propertyRecord.purchasedBy = player.id;
              propertyRecord.purchasePrice = property.price;
              // ç¼“å­˜å·²è´­ä¹°æˆ¿äº§çš„å®Œæ•´æ•°æ®ï¼Œç¡®ä¿æ•°æ®ä¸å†å˜åŠ¨
              propertyRecord.cachedData = {
                level: property.level,
                price: property.price,
                income: property.income,
                playerId: property.playerId,
                playerName: property.playerName,
                avatar: property.avatar,
                homeName: property.homeName,
                isOnline: property.isOnline
              };
              
              // æ‰§è¡Œè´­ä¹°
              player.money -= property.price;
              player.assets += property.price;
              
              // å…¨å±å¼¹çª—å±•ç¤ºAIè´­ä¹°ä¿¡æ¯
              await this.showAIPurchaseDialog(player, property, tile.stationName);
              
              this.log(`ğŸ  ${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, "#fca5a5");
            } else {
              this.log(`${player.name} æ²¡æœ‰è´­ä¹°æ„å‘`, "#9ca3af");
            }
            this.nextTurn();
          } else {
            this.state = "BUYING";
            this.showCityInfoModal(tile);
          }
        }

        playerBuy(tierIndex) {
          // This method is deprecated - use purchaseProperty instead
          // Kept for backward compatibility
          const player = this.players[0];
          const tile = player.currentTile;
          if (tile.buildings.includes(tierIndex) || player.money < BUILDING_COSTS[tierIndex]) return;

          this.doBuy(player, tile, tierIndex);
          this.populatePropertiesAndBuildingsTab(tile);
          this.updateUI();
        }

        doBuy(player, tile, tierIndex) {
          player.money -= BUILDING_COSTS[tierIndex];
          player.assets += BUILDING_COSTS[tierIndex];
          tile.buildings.push(tierIndex);
          tile.buildings.sort();
          tile.owner = player.id;

          this.placeBuildingVisually(tile, tierIndex);
          this.log(`${player.name} è´­ä¹°äº† ${BUILDING_NAMES[tierIndex]}!`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
        }

        placeBuildingVisually(stationTile, tierIndex) {
          // Find a spot near the station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              // Must be environment (not road) and empty
              if (t && !t.isRoad && t.mesh.children.length === 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            const target = candidates[Math.floor(Math.random() * candidates.length)];

            const bColor = COLORS.building[tierIndex];
            const h = (tierIndex + 1) * 3; // Height varies by tier

            const bGeo = new THREE.BoxGeometry(2.5, h, 2.5);
            const bMat = new THREE.MeshLambertMaterial({ color: bColor });
            const bMesh = new THREE.Mesh(bGeo, bMat);
            bMesh.position.y = h / 2 + 1; // Adjust for height
            bMesh.castShadow = true;
            bMesh.receiveShadow = true;

            // Add windows texture logic (simplified as black boxes)
            const winGeo = new THREE.BoxGeometry(2.6, h * 0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x334155 });
            const wins = new THREE.Mesh(winGeo, winMat);
            bMesh.add(wins);

            target.mesh.add(bMesh);

            // Juice effect
            const scaleUp = () => {
              bMesh.scale.set(0.1, 0.1, 0.1);
              let s = 0.1;
              const grow = setInterval(() => {
                s += 0.1;
                bMesh.scale.set(s, s, s);
                if (s >= 1) clearInterval(grow);
              }, 16);
            };
            scaleUp();
          }
        }

        onGameClick(event) {
          // Perform raycasting to detect clicked tiles
          const rect = this.renderer.domElement.getBoundingClientRect();
          this.gameMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.gameMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          this.gameRaycaster.setFromCamera(this.gameMouse, this.camera);
          
          // Get all tile meshes
          const tileMeshes = this.map.map((tile) => tile.mesh);
          const intersects = this.gameRaycaster.intersectObjects(tileMeshes);

          if (intersects.length > 0) {
            // Find which tile was clicked
            const clickedMesh = intersects[0].object;
            const clickedTile = this.map.find((tile) => tile.mesh === clickedMesh);
            
            if (clickedTile && clickedTile.type === "green") {
              // Open city info panel in "view-only" mode (no purchase)
              this.showCityInfoModalViewOnly(clickedTile);
            }
          }
        }

        showCityInfoModal(tile) {
          const modal = document.getElementById("city-info-modal");
          this.currentCityInfoTile = tile;
          this.cityInfoPanelMode = "purchase"; // Mark as purchase mode (when stopped at city)
          
          // Update header
          document.getElementById("city-info-title").innerText = tile.stationName;
          document.getElementById("city-info-subtitle").innerText = `äººå£: ${tile.population?.toLocaleString() || 'æœªçŸ¥'} | çº§åˆ«: ${tile.level || 'N/A'}`;
          
          // Show modal
          modal.classList.remove("hidden");
          
          // In purchase mode, show properties tab (merged with buildings)
          this.switchCityInfoTab("properties");
          
          // Populate merged properties & buildings tab
          this.populatePropertiesAndBuildingsTab(tile);
          
          // Also populate info tab for reference
          this.populateCityInfoTab(tile);
          
          // Setup tab switching
          this.setupCityInfoTabs();
        }

        showCityInfoModalViewOnly(tile) {
          // Open city info panel in view-only mode (when clicking from map, not stopped)
          const modal = document.getElementById("city-info-modal");
          this.currentCityInfoTile = tile;
          this.cityInfoPanelMode = "view-only"; // Mark as view-only mode
          
          // Update header
          document.getElementById("city-info-title").innerText = tile.stationName;
          document.getElementById("city-info-subtitle").innerText = `äººå£: ${tile.population?.toLocaleString() || 'æœªçŸ¥'} | çº§åˆ«: ${tile.level || 'N/A'}`;
          
          // Show modal
          modal.classList.remove("hidden");
          
          // Reset to properties tab (merged)
          this.switchCityInfoTab("properties");
          
          // Populate merged properties & buildings tab
          this.populatePropertiesAndBuildingsTab(tile);
          
          // Load city info from LLM (async, no await needed for UI responsiveness)
          this.populateCityInfoTab(tile);
          
          // Setup tab switching
          this.setupCityInfoTabs();
        }

        closeCityInfoModal() {
          document.getElementById("city-info-modal").classList.add("hidden");
          
          // Only proceed to next turn if in purchase mode (stopped at city)
          // In view-only mode (clicked from map), just close the panel
          if (this.cityInfoPanelMode === "purchase") {
            this.nextTurn();
          }
        }

        switchCityInfoTab(tabName) {
          // Hide all tabs
          document.querySelectorAll(".city-info-tab-content").forEach(el => {
            el.classList.add("hidden");
          });
          
          // Remove active border from all buttons
          document.querySelectorAll(".city-info-tab").forEach(btn => {
            btn.classList.remove("border-blue-600", "text-blue-600");
            btn.classList.add("border-transparent", "text-gray-600");
          });
          
          // Show selected tab
          const tabEl = document.getElementById(`city-info-${tabName}-tab`);
          if (tabEl) {
            tabEl.classList.remove("hidden");
          }
          
          // Highlight selected button
          const btnEl = document.querySelector(`.city-info-tab[data-tab="${tabName}"]`);
          if (btnEl) {
            btnEl.classList.remove("border-transparent", "text-gray-600");
            btnEl.classList.add("border-blue-600", "text-blue-600");
          }
        }

        setupCityInfoTabs() {
          document.querySelectorAll(".city-info-tab").forEach(btn => {
            btn.onclick = () => {
              const tabName = btn.dataset.tab;
              this.switchCityInfoTab(tabName);
            };
          });
        }

        populatePropertiesAndBuildingsTab(tile) {
          // Update player money display
          const player = this.players[0];
          document.getElementById("city-info-player-money").innerText = player.money.toLocaleString();
          
          // Show/hide destination indicator
          const destIndicator = document.getElementById("city-info-dest-indicator");
          const isDestination = tile === this.destinationTile;
          if (isDestination) {
            destIndicator.classList.remove("hidden");
          } else {
            destIndicator.classList.add("hidden");
          }
          
          // Get player properties (these are homes available for purchase)
          const container = document.getElementById("city-info-properties-list");
          const emptyDiv = document.getElementById("city-info-empty-properties");
          
          container.innerHTML = "";
          
          // Get player properties (homes from other players)
          const playerProperties = this.generatePlayerProperties(tile);
          
          if (playerProperties.length === 0) {
            container.style.display = "none";
            emptyDiv.style.display = "block";
            return;
          }
          
          emptyDiv.style.display = "none";
          container.style.display = "grid";
          
          // Render all property cards
          playerProperties.forEach((property, index) => {
            const card = document.createElement("div");
            card.className = "bg-white rounded-lg border-2 border-blue-300 overflow-hidden shadow-md hover:shadow-lg transition flex flex-col";
            
            // Check if already purchased
            const isPurchased = property.isPurchased;
            
            // Top section: Home name, price, income, and action button
            const headerBg = isPurchased ? "from-purple-100 to-pink-100" : "from-blue-100 to-cyan-100";
            const borderColor = isPurchased ? "border-purple-400" : "border-blue-400";
            
            let actionBtn = "";
            if (isPurchased) {
              actionBtn = `<span class="text-purple-600 font-bold text-xs whitespace-nowrap">âœ“ è¢« ${property.purchasedByName} è´­ä¹°</span>`;
            } else {
              // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å½“å‰åŸå¸‚ï¼ˆåªæœ‰åœ¨è´­ä¹°æ¨¡å¼ä¸‹ä¸”ç©å®¶åœ¨æ­£ç¡®ä½ç½®æ‰èƒ½è´­ä¹°ï¼‰
              const isPlayerHere = tile.stationName === player.currentTile.stationName && this.cityInfoPanelMode === "purchase";
              const canAfford = player.money >= property.price;
              
              if (isPlayerHere && canAfford) {
                actionBtn = `<button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-xs font-bold shadow transition" onclick="game.purchaseProperty(${index})">è´­ä¹°</button>`;
              } else if (!isPlayerHere) {
                actionBtn = `<span class="text-gray-400 text-xs font-bold"></span>`;
              } else {
                actionBtn = `<span class="text-red-400 text-xs font-bold">ğŸ’¸ ç¼ºé’±</span>`;
              }
            }
            
            const incomeRate = property.price > 0 ? Math.round((property.income || 0) / property.price * 100) : 0;
            card.className = `bg-white rounded-lg border-2 ${borderColor} overflow-hidden shadow-md hover:shadow-lg transition flex flex-col`;
            card.innerHTML = `
              <!-- Header: Home name, price, income, action button -->
              <div class="bg-gradient-to-br ${headerBg} p-3 flex justify-between items-start gap-2">
                <div class="flex-1 min-w-0">
                  <p class="font-bold text-gray-800 text-base truncate">${property.homeName}</p>
                  <p class="text-sm text-gray-700 mt-1">ğŸ’°:<span class="font-bold">Â¥${property.price.toLocaleString()}</span>  ğŸ“ˆ å¹´æ”¶ç›Š:<span class="font-bold text-green-600">Â¥${property.income || 0}</span> <span class="font-bold ${incomeRate >= 50 ? 'text-red-500' : incomeRate >= 30 ? 'text-orange-500' : 'text-gray-500'}">(${incomeRate}%)</span></p>
                </div>
                <div class="flex-shrink-0 text-center">
                  ${actionBtn}
                </div>
              </div>
              
              <!-- Footer: Player info (avatar, name, level) -->
              <div class="p-3 flex items-center justify-between bg-gray-50 border-t border-gray-200">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                  <img src="${property.avatar}" alt="å¤´åƒ" class="w-10 h-10 rounded-full border-2 border-blue-400 flex-shrink-0">
                  <div class="min-w-0">
                    <p class="font-bold text-gray-800 text-sm truncate">${property.playerName}</p>
                    <p class="text-xs text-gray-600">ç­‰çº§: ${property.level} â­</p>
                  </div>
                </div>
                <div class="flex-shrink-0">
                  <div class="${property.isOnline ? 'bg-green-500' : 'bg-gray-400'} text-white px-2 py-0.5 rounded-full text-xs font-bold">
                    ${property.isOnline ? 'ğŸŸ¢' : 'âš«'}
                  </div>
                </div>
              </div>
            `;
            
            container.appendChild(card);
          });
          
          // Hide monopoly hint (not applicable for home purchases)
          const monopolyContainer = document.getElementById("city-info-properties-tab").querySelector(".bg-purple-50");
          if (monopolyContainer) {
            monopolyContainer.style.display = "none";
          }
        }

        generatePlayerProperties(tile) {
          // Generate player property data for display
          // éœ€æ±‚: 
          // 1. å·²è´­ä¹°çš„åœ°äº§å§‹ç»ˆç½®é¡¶æ˜¾ç¤ºï¼Œä¸”æ•°æ®ä¿æŒä¸å˜ï¼ˆä»ç¼“å­˜è¯»å–ï¼‰
          // 2. æœªè´­ä¹°çš„åœ°äº§æ¯æ¬¡å¯ä»¥æœ‰éšæœºæ€§
          // 3. åŸå¸‚çš„æˆ¿äº§æ•°é‡åœ¨sessionä¸­ä¿æŒä¸€è‡´
          
          const playerNames = ["å°æ˜", "å°çº¢", "è€ç‹", "å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­", "å­™ä¸ƒ", "å‘¨å…«", "å´ä¹"];
          const homeNames = ["æ¢¦å¹»åº„å›­", "ç»¿æ´²å®¶å›­", "å¤©ç©ºä¹‹åŸ", "æ£®æ—å°å±‹", "äº‘ç«¯åˆ«å¢…", "æµ·æ»¨åº¦å‡", "å±±é¡¶åˆ«å¢…", "å¤é•‡æ°‘å®¿", "æ¹–è¾¹å°å±‹", "èŠ±å›­æ´‹æˆ¿"];
          
          const cityName = tile.stationName;
          
          // ç¡®ä¿cityçš„sessionç¼“å­˜å­˜åœ¨ï¼ˆåªä¿å­˜æˆ¿äº§æ•°é‡ï¼Œä¸ä¿å­˜å…·ä½“æ•°æ®ï¼‰
          if (!this.sessionPropertyCache[cityName]) {
            // é¦–æ¬¡è®¿é—®æ­¤åŸå¸‚ - ç”Ÿæˆéšæœºå±æ€§æ•°é‡
            const minProperties = 5;
            const maxProperties = 8;
            const count = Math.floor(Math.random() * (maxProperties - minProperties + 1)) + minProperties;
            
            // ä¿å­˜åˆ°sessionç¼“å­˜ - åªä¿å­˜æ•°é‡
            this.sessionPropertyCache[cityName] = {
              totalCount: count
            };
          }
          
          const totalCount = this.sessionPropertyCache[cityName].totalCount;
          
          // ä¸ºæ‰€æœ‰å±æ€§ç”Ÿæˆæ•°æ®
          const allProperties = [];
          for (let i = 0; i < totalCount; i++) {
            const propertyData = getOrCreatePropertyId(cityName, i);
            
            // Determine if purchased and by whom
            const isPurchased = propertyData.purchasedBy !== null;
            let ownerName = "";
            
            if (isPurchased) {
              const purchaser = this.players.find((p) => p.id === propertyData.purchasedBy);
              ownerName = purchaser ? purchaser.name : "æœªçŸ¥ç©å®¶";
            }
            
            let propInfo;
            if (isPurchased && propertyData.cachedData) {
              // å·²è´­ä¹°çš„æˆ¿äº§ï¼šä½¿ç”¨ç¼“å­˜çš„å›ºå®šæ•°æ®
              propInfo = propertyData.cachedData;
            } else {
              // æœªè´­ä¹°çš„æˆ¿äº§ï¼šæ¯æ¬¡éšæœºç”Ÿæˆ
              const level = Math.floor(Math.random() * 5) + 1;
              const price = PROPERTY_PRICE_RANGE[0] + Math.floor(Math.random() * (PROPERTY_PRICE_RANGE[1] - PROPERTY_PRICE_RANGE[0]));
              const income = Math.floor((Math.random() * 2000) + 500 * level);
              propInfo = {
                level: level,
                price: price,
                income: income,
                playerId: `P${Math.floor(Math.random() * 10000)}`,
                playerName: playerNames[i % playerNames.length],
                avatar: `https://i.pravatar.cc/150?img=${Math.floor(Math.random() * 70)}`,
                homeName: homeNames[i % homeNames.length],
                isOnline: Math.random() > 0.3
              };
            }
            
            allProperties.push({
              type: "property",
              id: propertyData.id,
              index: i,
              playerId: propInfo.playerId,
              playerName: propInfo.playerName,
              avatar: propInfo.avatar,
              homeName: propInfo.homeName,
              level: propInfo.level,
              price: propInfo.price,
              income: propInfo.income,
              isOnline: propInfo.isOnline,
              isPurchased: isPurchased,
              purchasedBy: propertyData.purchasedBy,
              purchasedByName: ownerName
            });
          }
          
          // åˆ†ç¦»å·²è´­ä¹°å’Œæœªè´­ä¹°çš„å±æ€§
          const purchasedProps = allProperties.filter(p => p.isPurchased);
          const unpurchasedProps = allProperties.filter(p => !p.isPurchased);
          
          // å·²è´­ä¹°çš„å§‹ç»ˆåœ¨å‰ï¼Œæœªè´­ä¹°çš„æŒ‰ç…§sessionä¸­ä¿å­˜çš„é¡ºåºæ˜¾ç¤º
          const result = [...purchasedProps, ...unpurchasedProps];
          
          return result;
        }

        purchaseProperty(propertyIndex) {
          const player = this.players[0];
          const tile = player.currentTile;
          
          // éªŒè¯ç©å®¶æ˜¯å¦åœ¨æ­£ç¡®çš„åŸå¸‚
          // ç¡®ä¿ç©å®¶åªèƒ½è´­ä¹°å½“å‰æ‰€åœ¨åŸå¸‚çš„åœ°äº§
          if (!this.currentCityInfoTile || tile.stationName !== this.currentCityInfoTile.stationName) {
            this.log("åªèƒ½è´­ä¹°å½“å‰æ‰€åœ¨åŸå¸‚çš„åœ°äº§ï¼", "#ef4444");
            return;
          }
          
          // Get the properties list
          const playerProperties = this.generatePlayerProperties(tile);
          if (propertyIndex >= playerProperties.length) return;
          
          const property = playerProperties[propertyIndex];
          
          // Check if already purchased
          if (property.isPurchased) {
            this.log("è¯¥å®¶å›­å·²è¢«è´­ä¹°", "#9ca3af");
            return;
          }
          
          // Check if player has enough money
          if (player.money < property.price) {
            this.log("èµ„é‡‘ä¸è¶³ï¼Œæ— æ³•è´­ä¹°", "#ef4444");
            return;
          }
          
          // Update cache to mark as purchased - ä½¿ç”¨property.indexï¼ˆåŸå§‹ç´¢å¼•ï¼‰è€Œä¸æ˜¯æ’åºåçš„propertyIndex
          const propertyRecord = getOrCreatePropertyId(tile.stationName, property.index);
          propertyRecord.purchasedBy = player.id;
          propertyRecord.purchasePrice = property.price;
          // ç¼“å­˜å·²è´­ä¹°æˆ¿äº§çš„å®Œæ•´æ•°æ®ï¼Œç¡®ä¿æ•°æ®ä¸å†å˜åŠ¨
          propertyRecord.cachedData = {
            level: property.level,
            price: property.price,
            income: property.income,
            playerId: property.playerId,
            playerName: property.playerName,
            avatar: property.avatar,
            homeName: property.homeName,
            isOnline: property.isOnline
          };
          
          // Purchase the property
          player.money -= property.price;
          player.assets += property.price;
          
          this.log(`${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
          showToast(`ğŸ  ${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, "#22c55e");
          
          // Refresh the UI
          this.populatePropertiesAndBuildingsTab(tile);
          this.updateUI();
        }

        async populateCityInfoTab(tile) {
          const container = document.getElementById("city-llm-content");
          
          // Check cache first
          if (this.cityInfoCache && this.cityInfoCache[tile.stationName]) {
            container.innerHTML = this.cityInfoCache[tile.stationName];
            return;
          }
          
          // Check if already loading this city to prevent duplicate requests
          if (!this.cityInfoLoadingPromises) {
            this.cityInfoLoadingPromises = {};
          }
          
          if (this.cityInfoLoadingPromises[tile.stationName]) {
            // Already loading, wait for it to complete
            await this.cityInfoLoadingPromises[tile.stationName];
            // After loading completes, render from cache
            if (this.cityInfoCache && this.cityInfoCache[tile.stationName]) {
              container.innerHTML = this.cityInfoCache[tile.stationName];
            }
            return;
          }
          
          try {
            // Show loading state
            container.innerHTML = `
              <div class="text-center py-8">
                <div class="inline-block animate-spin">â³</div>
                <p class="text-gray-600 mt-2">åŠ è½½åŸå¸‚ä¿¡æ¯ä¸­...</p>
              </div>
            `;
            
            // Create a promise for this request and track it
            const loadPromise = this.generateCityInfoFromLLM(tile.stationName, tile.population, tile.level, container);
            this.cityInfoLoadingPromises[tile.stationName] = loadPromise;
            
            // Generate city info using LLM with streaming
            await loadPromise;
            
            // Clean up the loading promise
            delete this.cityInfoLoadingPromises[tile.stationName];
          } catch (error) {
            console.error("Error loading city info:", error);
            container.innerHTML = `
              <div class="text-center py-12">
                <p class="text-red-500 text-xl">åŠ è½½åŸå¸‚ä¿¡æ¯å¤±è´¥</p>
                <p class="text-gray-500 mt-2">${error.message}</p>
              </div>
            `;
            // Clean up the loading promise
            delete this.cityInfoLoadingPromises[tile.stationName];
          }
        }

        async generateCityInfoFromLLM(cityName, population, level, container) {
          // Initialize Keepwork SDK if not already done
          if (!window.sdk) {
            window.sdk = new KeepworkSDK({
              timeout: 30000
            });
            console.log(`Keepwork SDK initialized token: ${window.sdk.token}`);
          }

          const prompt = `è¯·ç”¨ä¸­æ–‡ä¸ºæˆ‘ç”Ÿæˆå…³äºåŸå¸‚"${cityName}"çš„æœ‰è¶£ä¿¡æ¯ã€‚å†…å®¹åº”è¯¥åŒ…æ‹¬ï¼š
1. åŸå¸‚çš„åœ°ç†ä½ç½®å’Œç‰¹ç‚¹ï¼ˆ2-3å¥ï¼‰
2. å†å²èƒŒæ™¯æˆ–æ–‡åŒ–ç‰¹è‰²ï¼ˆ2-3å¥ï¼‰
3. ä¸»è¦æ™¯ç‚¹æˆ–ç‰¹è‰²ï¼ˆ3-4ä¸ªç‚¹ï¼‰
4. ç¾é£Ÿæ–‡åŒ–ï¼ˆ2-3å¥ï¼‰
5. æ—…æ¸¸å»ºè®®ï¼ˆ2-3å¥ï¼‰

è¯·ä½¿ç”¨markdownæ ¼å¼ï¼ŒåŒ…å«æ ‡é¢˜ã€åˆ—è¡¨ç­‰ã€‚å†…å®¹åº”è¯¥é€šä¿—æ˜“æ‡‚ï¼Œæœ‰è¶£ä¸”å‡†ç¡®ã€‚`;

          try {
            // Reuse a single session for all city info requests
            if (!window.sdk || !window.sdk.aiChat) {
              throw new Error("AI chat not available");
            }
            
            // Create session only once and reuse it
            if (!window.cityInfoChatSession) {
              window.cityInfoChatSession = window.sdk.aiChat.createSession({
                stream: true,
              });
            }
            
            const aiChatSession = window.cityInfoChatSession;

            // Use SDK aiChat session to send message and stream response
            let fullResponse = "";
            let lastRenderedResponse = "";
            
            const shouldRenderUpdate = (text) => {
              // Only render if we have at least one complete paragraph or line
              // Look for complete sentences ending with Chinese punctuation or newline
              const lastNewlineIdx = text.lastIndexOf('\n');
              const lastSentenceEnd = Math.max(
                text.lastIndexOf('ã€‚'),
                text.lastIndexOf('ï¼'),
                text.lastIndexOf('ï¼Ÿ'),
                text.lastIndexOf('\n')
              );
              
              // Render if we have meaningful content since last render
              // and either have a complete sentence or significant new content
              const newContent = text.substring(lastRenderedResponse.length);
              const hasCompleteSentence = newContent.includes('ã€‚') || 
                                         newContent.includes('ï¼') || 
                                         newContent.includes('ï¼Ÿ') ||
                                         newContent.includes('\n');
              const significantContent = newContent.length > 50;
              
              return hasCompleteSentence || significantContent;
            };
            
            const renderStreamingContent = (text) => {
              const htmlContent = this.markdownToHtml(text);
              container.innerHTML = htmlContent;
              lastRenderedResponse = text;
            };

            await aiChatSession.send(prompt, {
              onMessage: (partialText, fullResponse) => {
                if (partialText !== undefined && partialText !== null) {
                  fullResponse = partialText;
                  // Only render when we have complete sentences to avoid flickering
                  if (shouldRenderUpdate(fullResponse)) {
                    renderStreamingContent(fullResponse);
                  }
                }
              },
              onComplete: (finalText, fullResponse) => {
                // Final render - always render complete content
                fullResponse = finalText || "";
                if (fullResponse) {
                  renderStreamingContent(fullResponse);
                  
                  // Cache the final result
                  if (!this.cityInfoCache) this.cityInfoCache = {};
                  this.cityInfoCache[cityName] = this.markdownToHtml(fullResponse);
                }
              },
              onError: (error) => {
                throw error;
              },
            });
          } catch (error) {
            console.error("LLM Error:", error);
            // Fallback: render formatted HTML with generic info
            const fallbackContent = this.generateFallbackCityInfo(cityName);
            container.innerHTML = fallbackContent;
            
            // Cache the fallback result
            if (!this.cityInfoCache) this.cityInfoCache = {};
            this.cityInfoCache[cityName] = fallbackContent;
          }
        }

        markdownToHtml(markdown) {
          // Simple markdown to HTML converter
          let html = markdown;
          
          // Headers
          html = html.replace(/^### (.*?)$/gm, '<h3 class="text-2xl font-bold mt-4 mb-2 text-gray-800">$1</h3>');
          html = html.replace(/^## (.*?)$/gm, '<h2 class="text-3xl font-bold mt-6 mb-3 text-gray-900">$1</h2>');
          html = html.replace(/^# (.*?)$/gm, '<h1 class="text-4xl font-bold mt-8 mb-4 text-gray-900">$1</h1>');
          
          // Bold
          html = html.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
          html = html.replace(/__(.*?)__/g, '<strong class="font-bold text-gray-900">$1</strong>');
          
          // Italic
          html = html.replace(/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>');
          html = html.replace(/_(.*?)_/g, '<em class="italic text-gray-700">$1</em>');
          
          // Lists
          html = html.replace(/^\* (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          html = html.replace(/^- (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          html = html.replace(/^\d+\. (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          
          // Wrap consecutive lists
          html = html.replace(/(<li[^>]*>.*?<\/li>)/gs, (match) => {
            if (!match.includes('<ul') && !match.includes('<ol')) {
              return '<ul class="list-disc">' + match + '</ul>';
            }
            return match;
          });
          
          // Line breaks
          html = html.replace(/\n\n/g, '</p><p class="mb-4 text-gray-700">');
          html = html.replace(/\n/g, '<br>');
          
          // Wrap in paragraph tags if not already wrapped
          if (!html.includes('<p') && !html.includes('<h') && !html.includes('<ul')) {
            html = '<p class="mb-4 text-gray-700">' + html + '</p>';
          }
          
          return `<div class="prose prose-lg max-w-none">${html}</div>`;
        }

        generateFallbackCityInfo(cityName) {
          return `
            <div class="bg-blue-50 rounded-lg p-6">
              <h2 class="text-3xl font-bold mb-4 text-gray-900">ğŸŒ ${cityName}</h2>
              <div class="space-y-4 text-gray-700">
                <p class="text-lg"><strong>ğŸ“ åœ°ç†ä½ç½®ï¼š</strong>è¿™æ˜¯ä¸€ä¸ªå……æ»¡æ´»åŠ›çš„åŸå¸‚ï¼Œæ‹¥æœ‰æ‚ ä¹…çš„å†å²å’Œç°ä»£çš„é­…åŠ›ã€‚</p>
                <p class="text-lg"><strong>ğŸ›ï¸ å†å²æ–‡åŒ–ï¼š</strong>åŸå¸‚èåˆäº†ä¼ ç»Ÿä¸ç°ä»£ï¼Œå±•ç°äº†ç‹¬ç‰¹çš„æ–‡åŒ–ç‰¹è‰²ã€‚</p>
                <p class="text-lg"><strong>ğŸ¯ ä¸»è¦æ™¯ç‚¹ï¼š</strong></p>
                <ul class="list-disc ml-8 space-y-2">
                  <li>å†å²é—è¿¹å’Œå¤å»ºç­‘</li>
                  <li>ç°ä»£è‰ºæœ¯å’Œæ–‡åŒ–ä¸­å¿ƒ</li>
                  <li>è‡ªç„¶é£æ™¯å’Œå…¬å›­</li>
                  <li>ç¹åçš„å•†ä¸šè¡—åŒº</li>
                </ul>
                <p class="text-lg"><strong>ğŸœ ç¾é£Ÿæ–‡åŒ–ï¼š</strong>åŸå¸‚æ‹¥æœ‰ä¸°å¯Œçš„ç¾é£Ÿæ–‡åŒ–ï¼Œèåˆäº†ä¼ ç»Ÿå’Œå›½é™…é£å‘³ã€‚</p>
                <p class="text-lg"><strong>âœˆï¸ æ—…æ¸¸å»ºè®®ï¼š</strong>æœ€ä½³è®¿é—®å­£èŠ‚æ˜¯æ˜¥å­£å’Œç§‹å­£ï¼Œå»ºè®®åœç•™3-5å¤©ä»¥å……åˆ†ä½“éªŒåŸå¸‚çš„é­…åŠ›ã€‚</p>
              </div>
            </div>
          `;
        }

        async nextTurn() {
          // æ—¶é—´æ¨è¿›ï¼ˆæ¯ä¸¤ä¸ªå›åˆï¼ˆP1+COMå„èµ°ä¸€æ¬¡ï¼‰ç®—ä¸€ä¸ªæœˆï¼‰
          // è¿™é‡Œæ¯ä¸ªç©å®¶å›åˆç»“æŸåï¼Œå¦‚æœæ˜¯COMå›åˆç»“æŸï¼Œåˆ™æ¨è¿›ä¸€ä¸ªæœˆ
          if (this.turn === 1) {
            // COMåˆšç»“æŸå›åˆ
            const needSettlement = this.advanceTime();
            if (needSettlement) {
              await this.performSettlement();
            }
          }

          this.turn = (this.turn + 1) % 2;
          this.startTurn();
        }

        updateUI() {
          const p1 = this.players[0];
          const com = this.players[1];
          document.getElementById("p1-money").innerText = p1.money.toLocaleString();
          document.getElementById("com-money").innerText = com.money.toLocaleString();

          // Update Binbougami Indicators
          const p1Binbougami = document.getElementById("p1-binbougami");
          const comBinbougami = document.getElementById("com-binbougami");

          if (this.players[0].hasBinbougami) p1Binbougami.classList.remove("hidden");
          else p1Binbougami.classList.add("hidden");

          if (this.players[1].hasBinbougami) comBinbougami.classList.remove("hidden");
          else comBinbougami.classList.add("hidden");

          // Update Hand Panel (for P1) - åªåœ¨ç©å®¶å›åˆä¸”çŠ¶æ€ä¸ºIDLEæ—¶æ˜¾ç¤ºï¼ˆæŠ•æ·éª°å­å‰ï¼‰
          const handPanel = document.getElementById("card-hand-panel");
          const handContainer = document.getElementById("card-hand");

          if (this.turn === 0 && !this.players[0].isAI && this.players[0].cards.length > 0 && this.state === "IDLE") {
            handPanel.classList.remove("hidden");
            handContainer.innerHTML = "";
            this.players[0].cards.forEach((cardKey, index) => {
              const card = CARD_TYPES[cardKey];
              const div = document.createElement("div");
              div.className = `flex-shrink-0 w-16 h-20 bg-white rounded border-2 flex flex-col items-center justify-center cursor-pointer hover:scale-110 transition-transform card-rarity-${card.rarity}`;
              div.title = `${card.name}: ${card.desc}`;
              div.onclick = () => this.useCard(index);
              div.innerHTML = `<div class="text-2xl">${card.icon}</div><div class="text-[10px] font-bold truncate w-full text-center">${card.name}</div>`;
              handContainer.appendChild(div);
            });
          } else {
            handPanel.classList.add("hidden");
          }

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // --- Rendering Loop ---

        getScreenPosition(vec3) {
          const v = vec3.clone();
          v.project(this.camera);
          const x = (v.x * 0.5 + 0.5) * this.width;
          const y = (-(v.y * 0.5) + 0.5) * this.height;
          return { x, y };
        }

        centerCameraOnPlayer(player, duration = 500) {
          return new Promise((resolve) => {
            if (!player || !player.mesh) {
              resolve();
              return;
            }

            const targetPos = player.mesh.position.clone();
            const startTarget = this.controls.target.clone();
            const startCamPos = this.camera.position.clone();

            // Calculate camera offset from current target
            const offset = startCamPos.clone().sub(startTarget);
            const endCamPos = targetPos.clone().add(offset);

            const startTime = Date.now();

            const animateCamera = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(elapsed / duration, 1);

              // Ease out cubic for smooth deceleration
              const eased = 1 - Math.pow(1 - progress, 3);

              this.controls.target.lerpVectors(startTarget, targetPos, eased);
              this.camera.position.lerpVectors(startCamPos, endCamPos, eased);

              if (progress < 1) {
                requestAnimationFrame(animateCamera);
              } else {
                resolve();
              }
            };

            animateCamera();
          });
        }

        // Focus camera on a specific player by index (0 = P1, 1 = COM)
        focusOnPlayer(playerIndex) {
          if (this.mode !== "GAME") return;
          if (playerIndex < 0 || playerIndex >= this.players.length) return;

          const player = this.players[playerIndex];
          if (!player || !player.mesh) return;

          // Temporarily disable camera lock to allow manual focus
          this.cameraLocked = false;

          // Center camera on the selected player
          this.centerCameraOnPlayer(player, 400);
        }

        // æ˜¾ç¤ºç©å®¶è¯¦æƒ…å¼¹çª—
        showPlayerDetail(playerIndex) {
          if (playerIndex < 0 || playerIndex >= this.players.length) return;
          
          const player = this.players[playerIndex];
          this.currentDetailPlayer = playerIndex;
          
          const modal = document.getElementById("player-detail-modal");
          const content = document.getElementById("player-detail-content");
          const colorDiv = document.getElementById("player-detail-color");
          const nameEl = document.getElementById("player-detail-name");
          const binbougamiEl = document.getElementById("player-detail-binbougami");
          const moneyEl = document.getElementById("player-detail-money");
          const assetsEl = document.getElementById("player-detail-assets");
          const distanceEl = document.getElementById("player-detail-distance");
          const cardsEl = document.getElementById("player-detail-cards");
          
          // è®¾ç½®è¾¹æ¡†é¢œè‰²
          const borderColor = playerIndex === 0 ? "border-blue-400" : "border-red-400";
          content.className = `bg-gradient-to-b from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl max-w-sm w-full border-4 ${borderColor} relative`;
          
          // è®¾ç½®é¢œè‰²åœ†ç‚¹
          colorDiv.style.backgroundColor = playerIndex === 0 ? "#60a5fa" : "#ef4444";
          
          // è®¾ç½®åå­—
          nameEl.textContent = player.name;
          
          // ç©·ç¥çŠ¶æ€
          if (player.hasBinbougami) {
            binbougamiEl.classList.remove("hidden");
          } else {
            binbougamiEl.classList.add("hidden");
          }
          
          // è®¾ç½®æ•°æ®
          moneyEl.textContent = "Â¥" + player.money.toLocaleString();
          assetsEl.textContent = "Â¥" + player.assets.toLocaleString();
          cardsEl.textContent = player.cards.length;
          
          // è·ç¦»
          if (this.destinationTile && player.currentTile) {
            const distance = this.calculateDistanceToDestination(player.currentTile);
            distanceEl.textContent = distance >= 0 ? distance + " æ ¼" : "--";
          } else {
            distanceEl.textContent = "--";
          }
          
          modal.classList.remove("hidden");
        }
        
        // å…³é—­ç©å®¶è¯¦æƒ…å¼¹çª—
        closePlayerDetailModal() {
          document.getElementById("player-detail-modal").classList.add("hidden");
        }

        onResize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // Update Game Camera
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();

          // Note: World map iframe handles its own resize events

          this.renderer.setSize(this.width, this.height);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          // When in MAP mode, the iframe handles rendering - just skip
          if (this.mode === "MAP") {
            return;
          }

          // Camera Follow Logic
          if (this.cameraLocked) {
            const activePlayer = this.players[this.turn];
            if (activePlayer && activePlayer.mesh) {
              const targetPos = activePlayer.mesh.position;

              // Smoothly move both target and camera to maintain angle
              const currentTarget = this.controls.target.clone();
              const newTarget = currentTarget.clone().lerp(targetPos, 0.1);
              const delta = new THREE.Vector3().subVectors(newTarget, currentTarget);

              this.camera.position.add(delta);
              this.controls.target.copy(newTarget);
            }
          }

          if (this.controls) this.controls.update();

          // Update Station Labels
          this.map.forEach((tile) => {
            if (tile.labelElement) {
              // Only update if visible (optional optimization)
              const pos = this.getScreenPosition(tile.mesh.position);
              const offset = tile.labelOffset || { x: 0, y: -30, align: "center" };

              // Apply position based on label alignment
              let transform;
              if (offset.align === "left") {
                // Label on right side of station, align left edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(0%, -50%)`;
              } else if (offset.align === "right") {
                // Label on left side of station, align right edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-100%, -50%)`;
              } else {
                // Label on top (default), center aligned
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-50%, -100%)`;
              }
              tile.labelElement.style.transform = transform;

              // Hide if offscreen
              if (pos.x < 0 || pos.x > this.width || pos.y < 0 || pos.y > this.height) {
                tile.labelElement.style.opacity = "0";
              } else {
                tile.labelElement.style.opacity = "1";
              }
            }
          });

          // Update off-screen destination indicator
          this.updateDestinationIndicator();

          // Update Overlay Buttons if active
          const overlay = document.getElementById("direction-overlay");
          if (overlay) {
            Array.from(overlay.children).forEach((btn) => {
              if (btn.target3D) {
                const screenPos = this.getScreenPosition(btn.target3D);
                btn.style.left = `${screenPos.x}px`;
                btn.style.top = `${screenPos.y}px`;
              }
            });
          }

          // Update terrain tiles based on camera position (throttled)
          this.updateTerrainTiles();

          // Perform frustum culling on terrain chunks before rendering
          if (this.terrainManager) {
            this.chunkCullStats = this.terrainManager.cullChunks(this.camera);
          }

          this.renderer.render(this.scene, this.camera);

          // Update render stats (FPS, triangles, draw calls)
          this.updateRenderStats();
        }

        updateRenderStats() {
          this.frameCount++;
          const now = performance.now();
          
          // Update stats every 500ms
          if (now - this.lastStatsUpdate >= 500) {
            const elapsed = now - this.lastFrameTime;
            this.fps = Math.round((this.frameCount * 1000) / elapsed);
            this.frameCount = 0;
            this.lastFrameTime = now;
            this.lastStatsUpdate = now;
            
            // Get renderer info
            const info = this.renderer.info;
            const triangles = info.render.triangles;
            const drawCalls = info.render.calls;
            
            // Update DOM
            document.getElementById('stats-fps').textContent = this.fps;
            document.getElementById('stats-triangles').textContent = triangles.toLocaleString();
            document.getElementById('stats-drawcalls').textContent = drawCalls;
            
            // Update chunk culling stats
            if (this.chunkCullStats) {
              const total = this.chunkCullStats.visible + this.chunkCullStats.culled;
              document.getElementById('stats-chunks-visible').textContent = this.chunkCullStats.visible;
              document.getElementById('stats-chunks-total').textContent = total;
            }
          }
        }

        // Throttled terrain tile update
        updateTerrainTiles() {
          if (!this.terrainManager || this.mode !== "GAME") return;
          
          // Throttle updates to avoid excessive loading
          const now = Date.now();
          if (this._lastTerrainUpdate && now - this._lastTerrainUpdate < 1000) return;
          this._lastTerrainUpdate = now;
          
          // Calculate camera center in lon/lat
          const target = this.controls.target;
          
          // Convert world position back to lon/lat
         const gridX = target.x / TILE_SIZE;
          const gridZ = target.z / TILE_SIZE;
          
          const centerLon = this.mapCenterLon + gridX / this.configScale;
          const centerLat = this.mapCenterLat - gridZ / this.configScale;
          
          // Update visible terrain tiles
          this.terrainManager.updateVisibleTiles(centerLon, centerLat, this.configScale);
        }
      }

      // Boot
      window.onload = async () => {
        // Initialize game first (starts rendering loop)
        window.game = new Game();

        // Load station data for game map (full city info with lat/lng/population)
        await loadStationData();

        // Setup start button click handler
        const loginModal = document.getElementById("login-modal");
        const loginBtn = document.getElementById("login-btn");
        
        loginBtn.onclick = () => {
          // Hide login modal
          loginModal.classList.add("hidden");
          
          // Auto-load home city immediately
          const homeCityData = STATION_DATA.find(city => city.name.includes(homeCity) || homeCity.includes(city.name.split(' - ')[0]));
          if (homeCityData) {
            window.game.selectCity(homeCityData);
          } else {
            // Fallback: use first city or create minimal home city object
            const fallbackCity = STATION_DATA[0] || { name: homeCity };
            window.game.selectCity(fallbackCity);
          }
        };

        // Note: World map is now hidden by default, user can open it via toggleMap
      };
    </script>
  </body>
</html>
