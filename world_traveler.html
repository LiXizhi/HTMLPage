<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åœ°é“å¤§äº¨ - Three.js é‡åˆ¶ç‰ˆ</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #202025; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; outline: none; }
        
        /* UI Overlay - ä¿æŒåŸæ ·ï¼Œä½†å¢åŠ ç©¿é€æ€§ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        .hud-panel { pointer-events: auto; }
        
        /* Animations */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-custom { animation: bounce 1s infinite; }
        
        .modal {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            transition: opacity 0.3s;
        }

        /* Station Labels floating in 3D space */
        .station-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            transform: translate(-50%, -150%);
            white-space: nowrap;
            text-shadow: 0 1px 2px black;
            z-index: 10;
        }
        
        /* Destination label highlight */
        .station-label.destination {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: #000;
            font-size: 16px;
            padding: 6px 16px;
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
            animation: destination-pulse 1.5s ease-in-out infinite;
            z-index: 15;
        }
        
        @keyframes destination-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 30px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.6); }
        }
        
        /* Off-screen destination indicator */
        .destination-indicator {
            position: fixed;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: #000;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            white-space: nowrap;
            border: 2px solid #fff;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: indicator-pulse 1s ease-in-out infinite;
        }
        
        @keyframes indicator-pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(251, 191, 36, 0.8); }
            50% { opacity: 0.9; box-shadow: 0 0 25px rgba(251, 191, 36, 1); }
        }
    </style>
</head>
<body>

    <!-- Game Container -->
    <div id="game-container" class="w-full h-full relative"></div>

    <!-- Labels Layer (Dynamic HTML for 3D objects) -->
    <div id="labels-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>
    
    <!-- Off-screen Destination Indicator -->
    <div id="destination-indicator" class="destination-indicator hidden">
        <span>ğŸ¯</span>
        <span>ç›®çš„åœ°: </span>
        <span id="indicator-name">---</span>
        <span id="indicator-arrow">â†’</span>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- Airport Button -->
        <button onclick="game.toggleMap()" class="hud-panel absolute top-4 right-4 bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg border-2 border-white z-50 pointer-events-auto transition-transform hover:scale-110" title="åˆ‡æ¢åŸå¸‚">
            âœˆï¸
        </button>
        
        <!-- Top Info Bar -->
        <div class="flex justify-between w-full max-w-4xl mx-auto pointer-events-none">
            <!-- P1 Info -->
            <div class="hud-panel bg-blue-900/90 text-white p-4 rounded-xl border-2 border-blue-400 shadow-lg w-48 transition-all pointer-events-auto cursor-pointer hover:border-yellow-400" id="p1-panel" onclick="game.focusOnPlayer(0)">
                <h2 class="text-xl font-bold flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-blue-400"></div> ç©å®¶ (P1)
                </h2>
                <p class="text-yellow-300 text-2xl font-mono mt-1">Â¥<span id="p1-money">0</span></p>
                <p class="text-xs text-gray-300 mt-1">èµ„äº§: Â¥<span id="p1-assets">0</span></p>
                <p class="text-xs text-cyan-300 mt-1">ğŸ“ è·ç›®çš„åœ°: <span id="p1-distance">--</span> ç«™</p>
            </div>

            <!-- Turn Indicator -->
            <div class="hud-panel bg-gray-800/80 text-white px-6 py-2 rounded-full border border-gray-600 h-fit mt-2 pointer-events-auto">
                <span id="turn-indicator" class="font-bold text-lg tracking-widest">ç­‰å¾…å¼€å§‹...</span>
            </div>
            
            <!-- Destination & Time Info -->
            <div class="hud-panel absolute top-20 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-purple-900/90 to-pink-900/90 text-white px-6 py-3 rounded-xl border-2 border-yellow-400 shadow-lg pointer-events-auto hidden" id="destination-panel">
                <div class="flex items-center gap-4">
                    <div class="text-center">
                        <div class="text-xs text-gray-300">ğŸ“… å½“å‰æ—¶é—´</div>
                        <div class="text-lg font-bold text-yellow-300"><span id="game-year">1</span>å¹´<span id="game-month">4</span>æœˆ</div>
                    </div>
                    <div class="w-px h-10 bg-gray-500"></div>
                    <div class="text-center">
                        <div class="text-xs text-gray-300">ğŸ¯ ç›®çš„åœ°</div>
                        <div class="text-lg font-bold text-green-300" id="destination-name">---</div>
                    </div>
                    <div class="w-px h-10 bg-gray-500"></div>
                    <div class="text-center">
                        <div class="text-xs text-gray-300">ğŸ’° æ´åŠ©é‡‘</div>
                        <div class="text-lg font-bold text-yellow-400">Â¥5000</div>
                    </div>
                </div>
            </div>

            <!-- COM Info -->
            <div class="hud-panel bg-red-900/90 text-white p-4 rounded-xl border-2 border-red-400 shadow-lg w-48 transition-all opacity-70 pointer-events-auto cursor-pointer hover:border-yellow-400" id="com-panel" onclick="game.focusOnPlayer(1)">
                <h2 class="text-xl font-bold flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-red-500"></div> ç”µè„‘ (COM)
                </h2>
                <p class="text-yellow-300 text-2xl font-mono mt-1">Â¥<span id="com-money">0</span></p>
                <p class="text-xs text-gray-300 mt-1">èµ„äº§: Â¥<span id="com-assets">0</span></p>
                <p class="text-xs text-cyan-300 mt-1">ğŸ“ è·ç›®çš„åœ°: <span id="com-distance">--</span> ç«™</p>
            </div>
        </div>

        <!-- Action Log -->
        <div class="absolute top-24 right-4 w-64 pointer-events-none z-20">
            <div id="game-log" class="flex flex-col gap-2 items-end text-sm font-bold text-white shadow-black drop-shadow-md">
                <!-- Log entries go here -->
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-center items-end mb-8 pointer-events-none">
            <button id="roll-btn" class="hud-panel pointer-events-auto bg-gradient-to-b from-yellow-400 to-yellow-600 text-black font-black text-2xl px-12 py-4 rounded-2xl shadow-xl border-b-4 border-yellow-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden">
                ğŸ² æ·éª°å­
            </button>
        </div>
    </div>

    <!-- Money Change Modal -->
    <div id="money-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
        <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100">
            <div id="money-modal-icon" class="text-6xl mb-4">ğŸ’°</div>
            <h3 class="text-2xl font-black text-gray-800 mb-2" id="money-modal-title">ç©å®¶</h3>
            <div class="text-2xl font-bold mb-2" id="money-modal-delta"></div>
            <div class="text-5xl font-mono font-bold my-4 text-gray-800" id="money-modal-amount">Â¥0</div>
            <div class="text-gray-500 text-sm" id="money-modal-desc">èµ„é‡‘å˜åŠ¨</div>
        </div>
    </div>

    <!-- Property Buy Modal -->
    <div id="buy-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full border-4 border-green-600 relative">
            <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-1 rounded-full font-bold shadow-lg">
                åˆ°è¾¾è½¦ç«™
            </div>
            <h3 class="text-2xl font-bold text-center mt-4 mb-2 text-gray-800" id="station-name">ä¸œäº¬ç«™</h3>
            <div class="text-center text-yellow-600 font-bold text-xl mb-2">æŒæœ‰èµ„é‡‘: Â¥<span id="buy-modal-money">0</span></div>
            <p class="text-center text-gray-500 mb-4">è¿™å—åœ°çš®çœ‹èµ·æ¥å¾ˆæœ‰æ½œåŠ›ï¼è¦æŠ•èµ„å—ï¼Ÿ</p>
            
            <div id="building-list" class="space-y-3 mb-6">
                <!-- Buildings injected here -->
            </div>

            <div class="flex gap-3">
                <button onclick="game.closeBuyModal()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 rounded-lg transition">
                    ç¦»å¼€
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * 3D Metro Tycoon Game Engine (Three.js Edition)
 */

// --- Constants & Config ---
const TILE_SIZE = 4; // World unit size for a tile
const TILE_SPACING = 0.2; // Gap between tiles
const COLORS = {
    bg: 0x87CEEB, // Sky Blue
    ground: 0x1a1a20,
    
    // Tile Materials
    blue: 0x3b82f6,    // Money +
    red: 0xef4444,     // Money -
    yellow: 0xeab308,  // Event
    green: 0x22c55e,   // Station
    start: 0xffffff,   // Start
    
    road: 0x9ca3af,    // Plain Road
    env_nature: 0x15803d, // Nature
    env_culture: 0x52525b, // Culture

    // Buildings
    building: [0x60a5fa, 0x818cf8, 0xa78bfa] 
};

const BUILDING_COSTS = [1000, 5000, 20000];
const BUILDING_NAMES = ["æ‹‰é¢æ‘Š", "å•†åŠ¡é…’åº—", "æ‘©å¤©å¤§æ¥¼"];
const BUILDING_INCOME = [200, 800, 4000];

// ç›®çš„åœ°å¥–åŠ±é‡‘é¢
const DESTINATION_REWARD = 5000;
// ä¸€å¹´çš„å›åˆæ•°ï¼ˆæ¯æœˆä¸€å›åˆï¼Œ12å›åˆ=1å¹´ï¼Œ3æœˆå†³ç®—ï¼‰
const TURNS_PER_YEAR = 12;
const SETTLEMENT_MONTH = 3; // 3æœˆå†³ç®—

const STATION_NAMES = [
    "ç½—æ¹–å£å²¸", "å›½è´¸", "è€è¡—", "å¤§å‰§é™¢", "ç§‘å­¦é¦†", "åå¼ºè·¯", "å²—å¦", 
    "ä¼šå±•ä¸­å¿ƒ", "è´­ç‰©å…¬å›­", "é¦™èœœæ¹–", "è½¦å…¬åº™", "ç«¹å­æ—", "ä¾¨åŸä¸œ", 
    "åä¾¨åŸ", "ä¸–ç•Œä¹‹çª—", "ç™½çŸ³æ´²", "é«˜æ–°å›­", "æ·±å¤§", "æ¡ƒå›­", "å¤§æ–°", 
    "å‰æµ·æ¹¾", "å®å®‰ä¸­å¿ƒ", "æ·±åœ³åŒ—ç«™", "å¸‚æ°‘ä¸­å¿ƒ", "å°‘å¹´å®«", "è²èŠ±åŒ—", 
    "ä¸Šæ¢…æ—", "ç¦æ°‘", "ç¦ç”°å£å²¸", "åæµ·", "ç§‘è‹‘", "çº¢æ ‘æ¹¾", "é£æœºåœº"
];

// --- Utilities ---
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const wait = (ms) => new Promise(r => setTimeout(r, ms));

// Home city - always shown on map in green
let homeCity = "æ·±åœ³";

// Global toast function for notifications
function showToast(msg, color = 'white') {
    const logEl = document.getElementById('game-log');
    const entry = document.createElement('div');
    entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
    logEl.appendChild(entry);
    if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
    setTimeout(() => {
        entry.style.opacity = '0';
        setTimeout(() => entry.remove(), 500);
    }, 4000);
}

// --- Load World Map Data from External File ---
let CITIES = [];
let CONTINENTS = {}; // continents loaded from data file (if any)

async function loadCitiesData() {
    // Fallback default cities
    const defaultCities = [
        { name: "æ·±åœ³", lat: 22.5431, lon: 114.0579, population: 12590000, level: 1 },
        { name: "ä¸œäº¬", lat: 35.6762, lon: 139.6503, population: 13960000, level: 1 }
    ];

    try {
        const response = await fetch('world_traveler_data.md');
        const text = await response.text();
        
        // Extract JSON array from markdown (between [ and ])
        // The data file may either be a JSON array (legacy) or a JSON object with { cities: [], continents: {} }
        const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                // Clean up the JSON text: remove comments
                const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, '');
                const parsed = JSON.parse(jsonText);
                if (Array.isArray(parsed)) {
                    CITIES = parsed;
                    CONTINENTS = {};
                } else {
                    CITIES = parsed.cities || defaultCities;
                    CONTINENTS = parsed.continents || {};
                }
            console.log(`Loaded ${CITIES.length} cities from world_traveler_data.md`);
        } else {
            console.error('Could not parse cities data from world_traveler_data.md');
            CITIES = defaultCities;
        }
    } catch (error) {
        console.error('Error loading cities data:', error);
        CITIES = defaultCities;
    }
}

// --- World Map Class ---
class WorldMapManager {
    constructor(game) {
        this.game = game;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Center camera on initial location with zoom to show level 1 and 2
        const initialLat = 25;
        const initialLon = 105;
        const cameraDistance = 28; // Close enough to show level 2 (threshold is 35)
        const phi = (90 - initialLat) * (Math.PI / 180);
        const theta = (initialLon + 180) * (Math.PI / 180);
        const camX = -(cameraDistance * Math.sin(phi) * Math.cos(theta));
        const camZ = (cameraDistance * Math.sin(phi) * Math.sin(theta));
        const camY = (cameraDistance * Math.cos(phi));
        this.camera.position.set(camX, camY, camZ);
        
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        this.cities = [];
        this.controls = new THREE.OrbitControls(this.camera, this.game.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 15;
        this.controls.maxDistance = 60;
        this.controls.enablePan = false;

        this.init();
    }

    init() {
        // Earth Sphere
        const geometry = new THREE.SphereGeometry(10, 64, 64);
        const material = new THREE.MeshPhongMaterial({ 
            color: 0x1a237e,
            emissive: 0x112244,
            specular: 0x111111,
            shininess: 10
        });
        this.earth = new THREE.Mesh(geometry, material);
        this.group.add(this.earth);

        // Atmosphere glow
        const atmGeo = new THREE.SphereGeometry(10.2, 64, 64);
        const atmMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide });
        this.group.add(new THREE.Mesh(atmGeo, atmMat));

        // Continent outlines
        this.createContinentOutlines();

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 30, 50);
        this.scene.add(dirLight);

        // Cities
        this.createCities();
        
        // Event Listeners
        window.addEventListener('click', (e) => this.onClick(e));
    }

    // Create continent outline curves on globe
    createContinentOutlines() {
        const radius = 10.05; // Slightly above earth surface
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x44ff88, linewidth: 2, transparent: true, opacity: 0.8 });

    // Continent outline data (simplified lat/lon coordinates)
    const defaultContinents = {
            // äºšæ´² (Asia) - simplified outline
            asia: [
                [66, 170], [70, 140], [75, 100], [70, 70], [55, 60], [45, 35], [35, 35],
                [25, 55], [10, 75], [8, 80], [20, 90], [22, 90], [25, 95], [10, 100],
                [5, 105], [1, 104], [-8, 110], [-8, 115], [-5, 120], [5, 120], [10, 125],
                [20, 120], [25, 122], [35, 130], [40, 130], [45, 140], [50, 140], [55, 160],
                [60, 170], [66, 170]
            ],
    };
    const continents = (typeof CONTINENTS !== 'undefined' && Object.keys(CONTINENTS).length > 0) ? CONTINENTS : defaultContinents;

        // Draw each continent outline
        Object.values(continents).forEach(coords => {
            const points = [];
            // Create points for each coordinate, with interpolation along sphere surface
            for (let i = 0; i < coords.length; i++) {
                const [lat1, lon1] = coords[i];
                const [lat2, lon2] = coords[(i + 1) % coords.length]; // Wrap to first point for closure
                
                // Add start point
                points.push(this.latLonToVector3(lat1, lon1, radius));
                
                // Interpolate points along the great circle to keep lines on sphere surface
                const segments = 5; // Number of intermediate points between each pair
                for (let j = 1; j < segments; j++) {
                    const t = j / segments;
                    const latInterp = lat1 + (lat2 - lat1) * t;
                    const lonInterp = lon1 + (lon2 - lon1) * t;
                    points.push(this.latLonToVector3(latInterp, lonInterp, radius));
                }
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, lineMaterial);
            this.group.add(line);
        });
    }

    latLonToVector3(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const z = (radius * Math.sin(phi) * Math.sin(theta));
        const y = (radius * Math.cos(phi));
        return new THREE.Vector3(x, y, z);
    }

    createCities() {
        // Sort cities by population (descending) - higher population has priority
        const sortedCities = [...CITIES].sort((a, b) => b.population - a.population);
        
        // Initialize city positions
        const cityData = sortedCities.map(city => ({
            city,
            pos: this.latLonToVector3(city.lat, city.lon, 10),
            mass: city.population // Use population as mass
        }));
        
        const minMarkerDistance = 0.5; // Minimum distance between markers on sphere
        const maxIterations = 50; // Max iterations for separation
        
        // Iteratively separate overlapping markers using mass-based repulsion
        for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;
            
            for (let i = 0; i < cityData.length; i++) {
                for (let j = i + 1; j < cityData.length; j++) {
                    const a = cityData[i];
                    const b = cityData[j];
                    const dist = a.pos.distanceTo(b.pos);
                    
                    if (dist < minMarkerDistance && dist > 0.001) {
                        hasOverlap = true;
                        
                        // Calculate repulsion direction (from a to b)
                        const direction = new THREE.Vector3().subVectors(b.pos, a.pos).normalize();
                        
                        // Calculate displacement based on mass ratio
                        // Heavier (more population) moves less
                        const totalMass = a.mass + b.mass;
                        const overlap = minMarkerDistance - dist;
                        const moveA = overlap * (b.mass / totalMass); // Lighter moves more
                        const moveB = overlap * (a.mass / totalMass);
                        
                        // Move positions apart along sphere surface
                        a.pos.addScaledVector(direction, -moveA);
                        b.pos.addScaledVector(direction, moveB);
                        
                        // Re-project onto sphere surface (radius = 10)
                        a.pos.normalize().multiplyScalar(10);
                        b.pos.normalize().multiplyScalar(10);
                    }
                }
            }
            
            if (!hasOverlap) break;
        }
        
        // Create markers and labels
        cityData.forEach(({ city, pos }) => {
            // Marker size based on level
            const markerSize = city.level === 1 ? 0.25 : (city.level === 2 ? 0.18 : 0.12);
            const markerGeo = new THREE.SphereGeometry(markerSize, 16, 16);
            
            // Color based on level and home city
            let color;
            if (city.name === homeCity) {
                color = 0x00ff00; // Green for home city
            } else if (city.level === 1) {
                color = 0xffaa00; // Orange for level 1
            } else if (city.level === 2) {
                color = 0x88aaff; // Light blue for level 2
            } else {
                color = 0xaaaaaa; // Gray for level 3
            }
            
            const markerMat = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(pos);
            marker.userData = { city: city };
            this.group.add(marker);
            
            // Simple Label (using Sprite) - size based on population/level
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const fontSize = city.level === 1 ? 28 : (city.level === 2 ? 22 : 18);
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = city.level === 1 ? '#ffffff' : (city.level === 2 ? '#ccddff' : '#999999');
            context.textAlign = 'center';
            context.fillText(city.name, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            
            // Position label above marker
            const labelPos = pos.clone().normalize().multiplyScalar(10.5);
            sprite.position.copy(labelPos);
            
            // Scale based on level
            const spriteScale = city.level === 1 ? 2.5 : (city.level === 2 ? 2.0 : 1.5);
            sprite.scale.set(spriteScale, spriteScale * 0.25, 1);
            
            this.group.add(sprite);

            this.cities.push({ marker, sprite, data: city, basePos: pos.clone() });
        });
    }

    onClick(event) {
        if (this.game.mode !== 'MAP') return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const markers = this.cities.map(c => c.marker);
        const intersects = this.raycaster.intersectObjects(markers);

        if (intersects.length > 0) {
            const city = intersects[0].object.userData.city;
            this.game.selectCity(city);
        }
    }

    update() {
        this.controls.update();
        
        // Level of Detail logic based on zoom distance
        const dist = this.camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
        
        // Zoom thresholds for showing different levels
        const showLevel2 = dist < 35; // Show level 2 when closer
        const showLevel3 = dist < 22; // Show level 3 when even closer
        
        // Collect visible labels for overlap detection
        const visibleLabels = [];
        
        // First pass: determine visibility based on level
        this.cities.forEach(c => {
            const level = c.data.level || 1;
            const isHomeCity = c.data.name === homeCity;
            let shouldShowByLevel = false;
            
            if (isHomeCity || level === 1) {
                shouldShowByLevel = true; // Always show home city and level 1
            } else if (level === 2) {
                shouldShowByLevel = showLevel2;
            } else if (level === 3) {
                shouldShowByLevel = showLevel3;
            }
            
            // Check if in front of camera using dot product (more stable than screenZ)
            const cameraPos = this.camera.position.clone().normalize();
            const markerDir = c.marker.position.clone().normalize();
            const dotProduct = markerDir.dot(cameraPos);
            const isFrontFacing = dotProduct > -0.1; // Visible if on front hemisphere
            
            const shouldShow = shouldShowByLevel && isFrontFacing;
            
            c.marker.visible = shouldShow;
            c.sprite.visible = false; // Default to hidden, will be shown in overlap pass
            c.potentiallyVisible = shouldShow;
            
            if (shouldShow) {
                // Calculate screen position for overlap detection
                const screenPos = c.marker.position.clone().project(this.camera);
                c.screenX = (screenPos.x + 1) / 2 * window.innerWidth;
                c.screenY = (-screenPos.y + 1) / 2 * window.innerHeight;
                
                visibleLabels.push(c);
            }
        });
        
        // Sort by population (higher population has priority for label display)
        visibleLabels.sort((a, b) => b.data.population - a.data.population);
        
        // Second pass: show non-overlapping labels (keep higher population visible)
        const labelRadius = 50; // Approximate label radius in screen pixels
        const shownLabels = [];
        
        visibleLabels.forEach(c => {
            let hasOverlap = false;
            
            for (const shown of shownLabels) {
                const dx = c.screenX - shown.screenX;
                const dy = c.screenY - shown.screenY;
                const screenDist = Math.sqrt(dx * dx + dy * dy);
                
                // Smaller overlap threshold for higher level cities
                const minDist = labelRadius * (c.data.level === 1 ? 1.2 : (c.data.level === 2 ? 1.0 : 0.8));
                
                if (screenDist < minDist) {
                    hasOverlap = true;
                    break;
                }
            }
            
            if (!hasOverlap) {
                c.sprite.visible = true;
                shownLabels.push(c);
            }
        });
    }
}

// --- Game Classes ---

class Tile {
    constructor(id, gridX, gridY, type) {
        this.id = id;
        this.gridX = gridX;
        this.gridY = gridY;
        this.type = type; 
        this.buildings = []; 
        this.owner = null; 
        
        this.stationName = '';
        if (type === 'green') {
             const rawIdx = (gridX * 13 + gridY * 7) % STATION_NAMES.length;
             const idx = (rawIdx + STATION_NAMES.length) % STATION_NAMES.length;
             this.stationName = STATION_NAMES[idx];
        }

        this.neighbors = []; 
        this.mesh = null; // Three.js Mesh
        this.labelElement = null; // HTML Element for station name
    }

    get isRoad() {
        return !this.type.startsWith('env');
    }

    get isColored() {
        return ['blue', 'red', 'yellow', 'green', 'start'].includes(this.type);
    }

    // Helper to get world position based on grid
    get worldPos() {
        return new THREE.Vector3(this.gridX * TILE_SIZE, 0, this.gridY * TILE_SIZE);
    }
}

class Player {
    constructor(id, name, color, isAI) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.isAI = isAI;
        this.money = 10000;
        this.assets = 0;
        
        this.currentTile = null;
        this.previousTile = null;
        
        this.mesh = null; // Three.js Mesh (Group)
        
        // For smooth movement animation
        this.animating = false;
        this.targetPos = new THREE.Vector3();
    }
}

class Game {
    constructor() {
        this.container = document.getElementById('game-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // Three.js Components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;

        this.map = []; 
        this.players = [];
        this.turn = 0;
        this.state = 'INIT'; 
        this.cameraLocked = true;
        this.isUserInteracting = false;
        
        // ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ
        this.destinationTile = null;
        this.destinationMarker = null;
        
        // æ—¶é—´ç³»ç»Ÿï¼ˆå¹´/æœˆï¼‰
        this.gameYear = 1;
        this.gameMonth = 4; // ä»4æœˆå¼€å§‹
        this.totalTurns = 0;
        
        this.mode = 'MAP'; // 'MAP' or 'GAME'
        this.worldMap = null;
        this.currentCity = null;

        this.initThree();
        // this.initGame(); // Delayed until city selection

        window.addEventListener('resize', () => this.onResize());
        document.getElementById('roll-btn').onclick = () => this.playerRoll();
        
        this.initWorldMap();
        
        // Start Loop
        this.animate();
    }

    initThree() {
        // 1. Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x202025);
        this.scene.fog = new THREE.Fog(0x202025, 90, 180);

        // 2. Camera (Perspective)
        const fov = 45;
        const aspect = this.width / this.height;
        const near = 0.1;
        const far = 1000;
        this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        
        // Perspective View Setup: Position and LookAt
        this.camera.position.set(0, 60, 60); 
        this.camera.lookAt(this.scene.position); // Will be updated to follow player

        // 3. Renderer
        if (!this.renderer) {
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);
        }

        // Controls
        if (this.controls) this.controls.dispose();
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 130;
        this.controls.target.set(0, 0, 0);
        
        // Lock rotation, enable pan
        this.controls.enableRotate = false;
        this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };
        this.controls.touches = {
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN
        };
        
        // Stop auto-following if user interacts
        this.controls.addEventListener('start', () => {
            this.cameraLocked = false;
            this.isUserInteracting = true;
        });

        this.controls.addEventListener('end', () => {
            this.isUserInteracting = false;
            if (this.state === 'MOVING') {
                this.cameraLocked = true;
            }
        });

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        const shadowSize = 50;
        dirLight.shadow.camera.left = -shadowSize;
        dirLight.shadow.camera.right = shadowSize;
        dirLight.shadow.camera.top = shadowSize;
        dirLight.shadow.camera.bottom = -shadowSize;
        this.scene.add(dirLight);
    }

    initWorldMap() {
        this.worldMap = new WorldMapManager(this);
        if (this.controls) this.controls.enabled = false;
        
        // Hide Game UI initially
        document.getElementById('ui-layer').style.display = 'none';
        document.getElementById('labels-layer').style.display = 'none';
    }

    selectCity(city) {
        this.currentCity = city;
        this.mode = 'GAME';
        
        if (this.worldMap) this.worldMap.controls.enabled = false;

        // Reset Game Scene if needed or just init
        // Clear existing map if any?
        while(this.scene.children.length > 0){ 
            this.scene.remove(this.scene.children[0]); 
        }
        
        // é‡ç½®ç›®çš„åœ°æ ‡è®°
        this.destinationTile = null;
        this.destinationMarker = null;
        
        // æ¸…ç©ºæ ‡ç­¾å±‚
        document.getElementById('labels-layer').innerHTML = '';
        
        this.initThree(); // Re-init scene/camera/lights for Game
        this.initGame(); // Generate city map
        
        // Update UI
        document.getElementById('ui-layer').style.display = 'flex';
        document.getElementById('labels-layer').style.display = 'block';
    }

    toggleMap() {
        if (this.mode === 'GAME') {
            this.mode = 'MAP';
            if (this.controls) this.controls.enabled = false;
            if (this.worldMap) this.worldMap.controls.enabled = true;
            
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('labels-layer').style.display = 'none';
            document.getElementById('destination-indicator').classList.add('hidden');
        } else {
            if (this.currentCity) {
                this.mode = 'GAME';
                if (this.worldMap) this.worldMap.controls.enabled = false;
                if (this.controls) this.controls.enabled = true;

                document.getElementById('ui-layer').style.display = 'flex';
                document.getElementById('labels-layer').style.display = 'block';
            }
        }
    }

    async initGame() {
        // Materials Cache
        this.materials = {
            road: new THREE.MeshLambertMaterial({ color: COLORS.road }),
            start: new THREE.MeshLambertMaterial({ color: COLORS.start }),
            blue: new THREE.MeshLambertMaterial({ color: COLORS.blue }),
            red: new THREE.MeshLambertMaterial({ color: COLORS.red }),
            yellow: new THREE.MeshLambertMaterial({ color: COLORS.yellow }),
            green: new THREE.MeshLambertMaterial({ color: COLORS.green }),
            env_nature: new THREE.MeshLambertMaterial({ color: COLORS.env_nature }),
            env_culture: new THREE.MeshLambertMaterial({ color: COLORS.env_culture }),
            rail: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 })
        };
        
        this.geometries = {
            tile: new THREE.BoxGeometry(TILE_SIZE - TILE_SPACING, 1, TILE_SIZE - TILE_SPACING),
            envBlock: new THREE.BoxGeometry(TILE_SIZE, 4, TILE_SIZE) // Taller blocks for env
        };

        // Generate Map
        const startTile = this.generateMap();

        // Init Players
        this.players = [
            new Player('p1', 'ç©å®¶', 0x3b82f6, false),
            new Player('com', 'ç”µè„‘', 0xef4444, true)
        ];
        
        this.players.forEach(p => {
            this.createPlayerMesh(p);
            p.currentTile = startTile;
            p.mesh.position.copy(startTile.worldPos);
            p.mesh.position.y = 1.5; // Sit on top of tile
        });

        // Initial Camera Setup: Center on P1, looking from South
        const p1Pos = this.players[0].mesh.position;
        this.camera.position.set(p1Pos.x, p1Pos.y + 60, p1Pos.z + 60);
        this.controls.target.copy(p1Pos);
        this.controls.update();
        
        // åˆå§‹åŒ–ç›®çš„åœ°å’Œæ—¶é—´
        this.gameYear = 1;
        this.gameMonth = 4;
        this.totalTurns = 0;
        await this.setNewDestination();
        document.getElementById('destination-panel').classList.remove('hidden');
        
        this.updateUI();
        this.startTurn();
    }

    createPlayerMesh(player) {
        const group = new THREE.Group();

        // Body
        const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 16);
        const bodyMat = new THREE.MeshStandardMaterial({ color: player.color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1;
        body.castShadow = true;
        group.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 2.2;
        head.castShadow = true;
        group.add(head);

        // Hat/Indicator (Cone)
        const hatGeo = new THREE.ConeGeometry(0.6, 1, 16);
        const hatMat = new THREE.MeshStandardMaterial({ color: player.color });
        const hat = new THREE.Mesh(hatGeo, hatMat);
        hat.position.y = 3;
        hat.rotation.x = Math.PI; // Point down? No point up like a party hat
        group.add(hat);

        this.scene.add(group);
        player.mesh = group;
    }

    generateMap() {
        this.map = [];
        
        // 0. Prepare Station Names
        const availableNames = [...STATION_NAMES];
        // Shuffle
        for (let i = availableNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableNames[i], availableNames[j]] = [availableNames[j], availableNames[i]];
        }
        
        const totalStations = availableNames.length;
        
        // 1. Calculate Grid Dimensions to fit all stations
        const ratio = 4/3;
        let cols = Math.ceil(Math.sqrt(totalStations * ratio));
        let rows = Math.ceil(totalStations / cols);
        while (cols * rows < totalStations) rows++;

        // 2. Generate Coordinates (Centered around 0)
        const xCoords = [];
        let cx = -Math.floor(cols * 2.5); 
        for(let i=0; i<cols; i++) {
            xCoords.push(cx);
            cx += rand(2, 5);
        }

        const zCoords = [];
        let cz = -Math.floor(rows * 2.5);
        for(let i=0; i<rows; i++) {
            zCoords.push(cz);
            cz += rand(2, 5);
        }
        
        // 3. Build Graph Nodes (Intersections)
        const nodes = []; 
        for(let i=0; i<xCoords.length; i++) {
            const row = [];
            for(let j=0; j<zCoords.length; j++) {
                row.push({ x: xCoords[i], z: zCoords[j], id: `${i},${j}` });
            }
            nodes.push(row);
        }

        // 4. Build All Potential Edges
        const allEdges = [];
        for(let i=0; i<xCoords.length-1; i++) {
            for(let j=0; j<zCoords.length; j++) {
                allEdges.push({ u: nodes[i][j], v: nodes[i+1][j], type: 'h' });
            }
        }
        for(let i=0; i<xCoords.length; i++) {
            for(let j=0; j<zCoords.length-1; j++) {
                allEdges.push({ u: nodes[i][j], v: nodes[i][j+1], type: 'v' });
            }
        }

        // MST Logic
        for (let i = allEdges.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allEdges[i], allEdges[j]] = [allEdges[j], allEdges[i]];
        }

        const parent = new Map();
        const find = (id) => {
            if (!parent.has(id)) parent.set(id, id);
            if (parent.get(id) !== id) parent.set(id, find(parent.get(id)));
            return parent.get(id);
        };
        const union = (id1, id2) => {
            const root1 = find(id1);
            const root2 = find(id2);
            if (root1 !== root2) {
                parent.set(root1, root2);
                return true;
            }
            return false;
        };

        const activeEdges = new Set();
        const rejectedEdges = [];

        for(const edge of allEdges) {
            if (union(edge.u.id, edge.v.id)) {
                activeEdges.add(edge);
            } else {
                rejectedEdges.push(edge);
            }
        }

        for(const edge of rejectedEdges) {
            if (Math.random() < 0.4) {
                activeEdges.add(edge);
            }
        }

        const degrees = new Map();
        const incDeg = (id) => degrees.set(id, (degrees.get(id) || 0) + 1);
        activeEdges.forEach(e => { incDeg(e.u.id); incDeg(e.v.id); });

        for(const edge of rejectedEdges) {
            if (activeEdges.has(edge)) continue;
            if ((degrees.get(edge.u.id)||0) < 2 || (degrees.get(edge.v.id)||0) < 2) {
                activeEdges.add(edge);
                incDeg(edge.u.id);
                incDeg(edge.v.id);
            }
        }

        // 5. Sparse Map Generation
        const tileData = new Map(); // "x,z" -> { type, stationName? }
        const setTile = (x, z, type, props={}) => {
            const key = `${x},${z}`;
            // Don't overwrite road/station with env
            if (!tileData.has(key) || (tileData.get(key).type === 'env' && type !== 'env')) { 
                tileData.set(key, { x, z, type, ...props });
            }
        };

        // Place Stations
        let nameIndex = 0;
        nodes.forEach(row => row.forEach(node => {
            let stationName = "";
            if (nameIndex < availableNames.length) {
                stationName = availableNames[nameIndex++];
            } else {
                stationName = `éƒŠåŒº ${nameIndex++ - availableNames.length + 1}`;
            }
            setTile(node.x, node.z, 'green', { stationName });
        }));

        // Place Roads
        activeEdges.forEach(edge => {
            const u = edge.u;
            const v = edge.v;
            if (edge.type === 'h') { // Varying X
                const minX = Math.min(u.x, v.x);
                const maxX = Math.max(u.x, v.x);
                for(let x = minX + 1; x < maxX; x++) {
                    const type = (Math.random() < 0.3) ? this.getRandomColoredType() : 'road';
                    setTile(x, u.z, type);
                }
            } else { // Varying Z
                const minZ = Math.min(u.z, v.z);
                const maxZ = Math.max(u.z, v.z);
                for(let z = minZ + 1; z < maxZ; z++) {
                    const type = (Math.random() < 0.3) ? this.getRandomColoredType() : 'road';
                    setTile(u.x, z, type);
                }
            }
        });

        // Grow Environment around roads/stations
        const roadTiles = Array.from(tileData.values());
        roadTiles.forEach(t => {
            // Random range 3-8
            const range = rand(3, 8);
            for(let dx = -range; dx <= range; dx++) {
                for(let dz = -range; dz <= range; dz++) {
                    // Organic shape (Diamond/Circle hybrid)
                    if (Math.abs(dx) + Math.abs(dz) <= range * 1.4) {
                         const nx = t.x + dx;
                         const nz = t.z + dz;
                         const key = `${nx},${nz}`;
                         if (!tileData.has(key)) {
                             const envType = Math.random() > 0.7 ? 'env_culture' : 'env_nature';
                             setTile(nx, nz, envType); // Default to env
                         }
                    }
                }
            }
        });

        // 6. Instantiate Tiles
        const mapGroup = new THREE.Group();
        this.scene.add(mapGroup);
        this.tilesMap = new Map();
        
        let idCounter = 0;
        tileData.forEach(data => {
            const tile = new Tile(idCounter++, data.x, data.z, data.type);
            if (data.stationName) tile.stationName = data.stationName;
            
            this.map.push(tile);
            this.tilesMap.set(`${data.x},${data.z}`, tile);
            this.createTileVisuals(tile, mapGroup);
        });
        
        // 7. Link Neighbors
        this.map.forEach(tile => {
            if (!tile.isRoad) return;
            
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            dirs.forEach(([dx, dz]) => {
                const nx = tile.gridX + dx;
                const nz = tile.gridY + dz;
                const neighbor = this.tilesMap.get(`${nx},${nz}`);
                if (neighbor && neighbor.isRoad) {
                    tile.neighbors.push(neighbor);
                }
            });
        });
        
        // Set Start Position
        const stations = this.map.filter(t => t.type === 'green');
        let startTile = stations.length > 0 ? stations[Math.floor(Math.random() * stations.length)] : this.map[0];
        
        if (!startTile) startTile = this.map[0];

        if (startTile) {
            startTile.type = 'start';
            startTile.mesh.material = this.materials.start;
            startTile.mesh.position.y = 0.2; 
            if (startTile.labelElement) {
                startTile.labelElement.remove();
                startTile.labelElement = null;
            }
        }
        
        return startTile;
    }

    createTileVisuals(tile, parentGroup) {
        const x = tile.gridX * TILE_SIZE;
        const z = tile.gridY * TILE_SIZE;

        // 1. Base Block
        let geometry = this.geometries.tile;
        let yPos = 0;

        // Environment blocks are taller to create "canyons" for the track
        if (!tile.isRoad) {
            geometry = new THREE.BoxGeometry(TILE_SIZE, rand(2, 6), TILE_SIZE);
            yPos = -1; // Sink them a bit
        }

        const material = this.materials[tile.type] || this.materials.road;
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, yPos, z);
        mesh.receiveShadow = true;
        
        // 2. Decorations
        if (tile.type === 'env_nature') {
            if (Math.random() > 0.5) {
                const treeGeo = new THREE.ConeGeometry(1, 3, 8);
                const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
                const tree = new THREE.Mesh(treeGeo, treeMat);
                tree.position.set(0, 2.5, 0);
                tree.castShadow = true;
                mesh.add(tree); // Local coordinate
            }
        } else if (tile.type === 'green') {
            // Station Marker
            const stationGeo = new THREE.BoxGeometry(2.5, 1, 2.5);
            const stationMesh = new THREE.Mesh(stationGeo, new THREE.MeshLambertMaterial({color: 0xffffff}));
            stationMesh.position.y = 0.6;
            mesh.add(stationMesh);

            // Add HTML Label
            this.createStationLabel(tile);
        }

        tile.mesh = mesh;
        parentGroup.add(mesh);
    }

    createStationLabel(tile) {
        const div = document.createElement('div');
        div.className = 'station-label';
        div.innerText = tile.stationName;
        document.getElementById('labels-layer').appendChild(div);
        tile.labelElement = div;
        
        // Determine best label position: prefer non-road adjacent tiles
        // Check left (-x), right (+x), and top (-z) directions
        const leftKey = `${tile.gridX - 1},${tile.gridY}`;
        const rightKey = `${tile.gridX + 1},${tile.gridY}`;
        const topKey = `${tile.gridX},${tile.gridY - 1}`;
        
        const leftTile = this.tilesMap.get(leftKey);
        const rightTile = this.tilesMap.get(rightKey);
        const topTile = this.tilesMap.get(topKey);
        
        // Check if tile is a road/walkable tile (not environment)
        const isRoadTile = (t) => t && t.isRoad;
        
        // Priority: place label toward non-road areas (top > left > right)
        if (!isRoadTile(topTile)) {
            tile.labelOffset = { x: 0, y: -30, align: 'center' }; // top (default)
        } else if (!isRoadTile(leftTile)) {
            tile.labelOffset = { x: -50, y: 0, align: 'right' }; // left side
        } else if (!isRoadTile(rightTile)) {
            tile.labelOffset = { x: 50, y: 0, align: 'left' }; // right side
        } else {
            tile.labelOffset = { x: 0, y: -30, align: 'center' }; // fallback to top
        }
    }

    getRandomColoredType() {
        const r = Math.random();
        if (r < 0.25) return 'green';
        if (r < 0.5) return 'red';
        if (r < 0.75) return 'yellow';
        return 'blue';
    }
    
    // --- ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ ---
    
    async setNewDestination() {
        // è·å–æ‰€æœ‰è½¦ç«™ï¼ˆç»¿è‰²æ ¼å­ï¼‰ï¼Œæ’é™¤å½“å‰èµ·å§‹ç‚¹å’Œç©å®¶æ‰€åœ¨ä½ç½®
        const stations = this.map.filter(t => t.type === 'green' && 
            t !== this.destinationTile &&
            !this.players.some(p => p.currentTile === t));
        
        if (stations.length === 0) return;
        
        // ç§»é™¤æ—§ç›®çš„åœ°çš„é«˜äº®æ ·å¼
        if (this.destinationTile && this.destinationTile.labelElement) {
            this.destinationTile.labelElement.classList.remove('destination');
        }
        
        // éšæœºé€‰æ‹©ä¸€ä¸ªè½¦ç«™ä½œä¸ºç›®çš„åœ°
        const newDest = stations[Math.floor(Math.random() * stations.length)];
        
        // æ˜¾ç¤ºæŠ½å¥–åŠ¨ç”»
        await this.showDestinationLottery(stations, newDest);
        
        this.destinationTile = newDest;
        
        // æ›´æ–°UIæ˜¾ç¤º
        document.getElementById('destination-name').innerText = newDest.stationName;
        
        // æ·»åŠ ç›®çš„åœ°æ ‡ç­¾é«˜äº®æ ·å¼
        if (newDest.labelElement) {
            newDest.labelElement.classList.add('destination');
        }
        
        // ç§»é™¤æ—§çš„ç›®çš„åœ°æ ‡è®°
        if (this.destinationMarker) {
            this.scene.remove(this.destinationMarker);
        }
        
        // åˆ›å»ºæ–°çš„ç›®çš„åœ°æ ‡è®°ï¼ˆå‘å…‰çš„åœ†æŸ±+æ——å¸œï¼‰
        this.createDestinationMarker(newDest);
        
        this.log(`ğŸ¯ æ–°ç›®çš„åœ°: ${newDest.stationName}`, "#fbbf24");
        showToast(`ğŸ¯ ç›®çš„åœ°å·²æ›´æ–°: ${newDest.stationName}`, '#fbbf24');
        
        // æ›´æ–°è·ç¦»æ˜¾ç¤º
        this.updateDistanceDisplay();
    }
    
    // ä½¿ç”¨BFSè®¡ç®—ä»ä¸€ä¸ªæ ¼å­åˆ°ç›®çš„åœ°çš„æœ€çŸ­è·ç¦»ï¼ˆç«™æ•°ï¼‰
    calculateDistanceToDestination(fromTile) {
        if (!this.destinationTile || !fromTile) return -1;
        if (fromTile === this.destinationTile) return 0;
        
        // BFSæœç´¢æœ€çŸ­è·¯å¾„
        const visited = new Set();
        const queue = [{ tile: fromTile, distance: 0 }];
        visited.add(fromTile);
        
        while (queue.length > 0) {
            const { tile, distance } = queue.shift();
            
            for (const neighbor of tile.neighbors) {
                if (neighbor === this.destinationTile) {
                    // åªè®¡ç®—å½©è‰²æ ¼å­ï¼ˆæœ‰æ•ˆæ­¥æ•°ï¼‰
                    return distance + (neighbor.isColored ? 1 : 0);
                }
                
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    // åªæœ‰å½©è‰²æ ¼å­æ‰ç®—ä¸€æ­¥
                    const newDist = distance + (neighbor.isColored ? 1 : 0);
                    queue.push({ tile: neighbor, distance: newDist });
                }
            }
        }
        
        return -1; // æ— æ³•åˆ°è¾¾
    }
    
    // AIé€‰æ‹©æœ€ä¼˜æ–¹å‘ï¼šé€‰æ‹©è·ç¦»ç›®çš„åœ°æœ€è¿‘çš„è·¯å¾„
    chooseBestDirection(options) {
        if (!this.destinationTile || options.length === 0) {
            return options[Math.floor(Math.random() * options.length)];
        }
        
        let bestTile = options[0];
        let bestDistance = this.calculateDistanceToDestination(options[0]);
        
        for (let i = 1; i < options.length; i++) {
            const dist = this.calculateDistanceToDestination(options[i]);
            // é€‰æ‹©è·ç¦»æ›´çŸ­çš„ï¼ˆå¦‚æœè·ç¦»ä¸º-1è¡¨ç¤ºæ— æ³•åˆ°è¾¾ï¼Œè·³è¿‡ï¼‰
            if (dist >= 0 && (bestDistance < 0 || dist < bestDistance)) {
                bestDistance = dist;
                bestTile = options[i];
            }
        }
        
        return bestTile;
    }
    
    // æ›´æ–°æ‰€æœ‰ç©å®¶çš„è·ç¦»æ˜¾ç¤º
    updateDistanceDisplay() {
        if (!this.destinationTile || this.players.length === 0) return;
        
        // ç©å®¶1è·ç¦»
        const p1Dist = this.calculateDistanceToDestination(this.players[0].currentTile);
        document.getElementById('p1-distance').innerText = p1Dist >= 0 ? p1Dist : '--';
        
        // ç”µè„‘è·ç¦»
        if (this.players.length > 1) {
            const comDist = this.calculateDistanceToDestination(this.players[1].currentTile);
            document.getElementById('com-distance').innerText = comDist >= 0 ? comDist : '--';
        }
    }
    
    // æ›´æ–°å±å¹•å¤–ç›®çš„åœ°æŒ‡ç¤ºå™¨
    updateDestinationIndicator() {
        const indicator = document.getElementById('destination-indicator');
        if (!indicator) return;
        
        // å¦‚æœæ²¡æœ‰ç›®çš„åœ°ï¼Œéšè—æŒ‡ç¤ºå™¨
        if (!this.destinationTile) {
            indicator.classList.add('hidden');
            return;
        }
        
        // è·å–ç›®çš„åœ°åœ¨å±å¹•ä¸Šçš„ä½ç½®
        const destPos = this.getScreenPosition(this.destinationTile.mesh.position);
        const margin = 80; // è¾¹ç¼˜margin
        
        // æ£€æŸ¥ç›®çš„åœ°æ˜¯å¦åœ¨å±å¹•å¯è§èŒƒå›´å†…
        const isOnScreen = destPos.x >= margin && destPos.x <= this.width - margin &&
                           destPos.y >= margin && destPos.y <= this.height - margin;
        
        if (isOnScreen) {
            // ç›®çš„åœ°åœ¨å±å¹•å†…ï¼Œéšè—æŒ‡ç¤ºå™¨
            indicator.classList.add('hidden');
            return;
        }
        
        // ç›®çš„åœ°åœ¨å±å¹•å¤–ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨
        indicator.classList.remove('hidden');
        
        // æ›´æ–°ç›®çš„åœ°åç§°
        document.getElementById('indicator-name').innerText = this.destinationTile.stationName;
        
        // è®¡ç®—å±å¹•ä¸­å¿ƒåˆ°ç›®çš„åœ°ä½ç½®çš„æ–¹å‘
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const dx = destPos.x - centerX;
        const dy = destPos.y - centerY;
        const angle = Math.atan2(dy, dx);
        
        // è®¡ç®—æŒ‡ç¤ºå™¨åœ¨å±å¹•è¾¹ç¼˜çš„ä½ç½®
        const edgeMargin = 60;
        let indicatorX, indicatorY;
        
        // æ ¹æ®è§’åº¦ç¡®å®šæŒ‡ç¤ºå™¨ä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
        const maxX = this.width - edgeMargin;
        const maxY = this.height - edgeMargin;
        const minX = edgeMargin;
        const minY = edgeMargin;
        
        // è®¡ç®—ä¸å±å¹•è¾¹ç¼˜çš„äº¤ç‚¹
        const tanAngle = Math.tan(angle);
        
        // æ£€æŸ¥å³è¾¹ç¼˜
        if (dx > 0) {
            const y = centerY + (maxX - centerX) * tanAngle;
            if (y >= minY && y <= maxY) {
                indicatorX = maxX;
                indicatorY = y;
            }
        }
        // æ£€æŸ¥å·¦è¾¹ç¼˜
        if (dx < 0) {
            const y = centerY + (minX - centerX) * tanAngle;
            if (y >= minY && y <= maxY) {
                indicatorX = minX;
                indicatorY = y;
            }
        }
        // æ£€æŸ¥ä¸‹è¾¹ç¼˜
        if (dy > 0 && (indicatorX === undefined)) {
            const x = centerX + (maxY - centerY) / tanAngle;
            if (x >= minX && x <= maxX) {
                indicatorX = x;
                indicatorY = maxY;
            }
        }
        // æ£€æŸ¥ä¸Šè¾¹ç¼˜
        if (dy < 0 && (indicatorX === undefined)) {
            const x = centerX + (minY - centerY) / tanAngle;
            if (x >= minX && x <= maxX) {
                indicatorX = x;
                indicatorY = minY;
            }
        }
        
        // å¦‚æœè¿˜æ²¡æœ‰ç¡®å®šä½ç½®ï¼Œä½¿ç”¨ç®€å•çš„clamping
        if (indicatorX === undefined) {
            indicatorX = Math.max(minX, Math.min(maxX, destPos.x));
            indicatorY = Math.max(minY, Math.min(maxY, destPos.y));
        }
        
        // è®¾ç½®æŒ‡ç¤ºå™¨ä½ç½®ï¼Œæ ¹æ®è¾¹ç¼˜ä½ç½®è°ƒæ•´transformé¿å…è¶…å‡ºå±å¹•
        let finalX = indicatorX;
        let finalY = indicatorY;
        
        // æ ¹æ®æŒ‡ç¤ºå™¨åœ¨å±å¹•çš„ä½ç½®è°ƒæ•´å¯¹é½æ–¹å¼
        let transformX = '-50%';
        let transformY = '-50%';
        
        const padding = 10; // è·ç¦»å±å¹•è¾¹ç¼˜çš„padding
        
        // é è¿‘å³è¾¹ç¼˜æ—¶ï¼Œå‘å·¦å¯¹é½ï¼ˆå…ƒç´ å³è¾¹è´´ç€å±å¹•å³è¾¹ï¼‰
        if (indicatorX >= this.width - edgeMargin) {
            transformX = '-100%';
            finalX = this.width - padding;
        }
        // é è¿‘å·¦è¾¹ç¼˜æ—¶ï¼Œå‘å³å¯¹é½ï¼ˆå…ƒç´ å·¦è¾¹è´´ç€å±å¹•å·¦è¾¹ï¼‰
        else if (indicatorX <= edgeMargin) {
            transformX = '0%';
            finalX = padding;
        }
        
        // é è¿‘ä¸‹è¾¹ç¼˜æ—¶ï¼Œå‘ä¸Šå¯¹é½ï¼ˆå…ƒç´ ä¸‹è¾¹è´´ç€å±å¹•ä¸‹è¾¹ï¼‰
        if (indicatorY >= this.height - edgeMargin) {
            transformY = '-100%';
            finalY = this.height - padding;
        }
        // é è¿‘ä¸Šè¾¹ç¼˜æ—¶ï¼Œå‘ä¸‹å¯¹é½ï¼ˆå…ƒç´ ä¸Šè¾¹è´´ç€å±å¹•ä¸Šè¾¹ï¼‰
        else if (indicatorY <= edgeMargin) {
            transformY = '0%';
            finalY = padding;
        }
        
        indicator.style.left = `${finalX}px`;
        indicator.style.top = `${finalY}px`;
        indicator.style.transform = `translate(${transformX}, ${transformY})`;
        
        // æ›´æ–°ç®­å¤´æ–¹å‘
        const arrowEl = document.getElementById('indicator-arrow');
        if (arrowEl) {
            // æ ¹æ®æ–¹å‘é€‰æ‹©ç®­å¤´
            const degAngle = angle * 180 / Math.PI;
            let arrow = 'â†’';
            if (degAngle > -22.5 && degAngle <= 22.5) arrow = 'â†’';
            else if (degAngle > 22.5 && degAngle <= 67.5) arrow = 'â†˜';
            else if (degAngle > 67.5 && degAngle <= 112.5) arrow = 'â†“';
            else if (degAngle > 112.5 && degAngle <= 157.5) arrow = 'â†™';
            else if (degAngle > 157.5 || degAngle <= -157.5) arrow = 'â†';
            else if (degAngle > -157.5 && degAngle <= -112.5) arrow = 'â†–';
            else if (degAngle > -112.5 && degAngle <= -67.5) arrow = 'â†‘';
            else if (degAngle > -67.5 && degAngle <= -22.5) arrow = 'â†—';
            
            arrowEl.innerText = arrow;
        }
    }
    
    // æ˜¾ç¤ºç›®çš„åœ°æŠ½å¥–åŠ¨ç”»
    async showDestinationLottery(stations, finalDest) {
        // åˆ›å»ºå…¨å±å¼¹çª—
        const overlay = document.createElement('div');
        overlay.id = 'lottery-overlay';
        overlay.className = 'fixed inset-0 flex items-center justify-center z-50';
        overlay.style.background = 'rgba(0,0,0,0.9)';
        overlay.style.backdropFilter = 'blur(8px)';
        
        overlay.innerHTML = `
            <div class="text-center">
                <div class="text-2xl text-gray-400 mb-4">ğŸ² æ­£åœ¨é€‰æ‹©ç›®çš„åœ°...</div>
                <div class="relative overflow-hidden h-32 w-80 mx-auto mb-6 rounded-xl" style="background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(30,30,50,0.9) 50%, rgba(0,0,0,0.8) 100%);">
                    <div class="absolute inset-x-0 top-0 h-8 bg-gradient-to-b from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 bottom-0 h-8 bg-gradient-to-t from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 top-1/2 -translate-y-1/2 h-12 border-y-2 border-yellow-400 bg-yellow-400/10 z-10"></div>
                    <div id="lottery-scroll" class="absolute inset-x-0 transition-transform" style="top: 50%; transform: translateY(-50%);">
                        <!-- åœ°åä¼šåœ¨è¿™é‡Œæ»šåŠ¨ -->
                    </div>
                </div>
                <div id="lottery-result" class="text-5xl font-black text-yellow-400 mb-4 opacity-0 transition-opacity duration-500"></div>
                <div id="lottery-subtitle" class="text-xl text-gray-300 opacity-0 transition-opacity duration-500">å‡ºå‘å§!</div>
            </div>
        `;
        
        document.body.appendChild(overlay);
        
        const scrollContainer = document.getElementById('lottery-scroll');
        
        // åˆ›å»ºæ»šåŠ¨å†…å®¹ï¼ˆæ‰€æœ‰è½¦ç«™åéšæœºæ’åˆ—ï¼Œé‡å¤å¤šæ¬¡ï¼‰
        const allNames = stations.map(s => s.stationName);
        // æ‰“ä¹±é¡ºåº
        for (let i = allNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allNames[i], allNames[j]] = [allNames[j], allNames[i]];
        }
        
        // ç¡®ä¿æœ€ç»ˆç›®çš„åœ°åœ¨æœ€å
        const finalIndex = allNames.indexOf(finalDest.stationName);
        if (finalIndex > -1) {
            allNames.splice(finalIndex, 1);
        }
        
        // åˆ›å»ºæ»šåŠ¨åˆ—è¡¨ï¼ˆé‡å¤å¤šæ¬¡ + æœ€ç»ˆç›®çš„åœ°ï¼‰
        const repeatCount = 4;
        let scrollItems = [];
        for (let i = 0; i < repeatCount; i++) {
            scrollItems = scrollItems.concat([...allNames].sort(() => Math.random() - 0.5));
        }
        scrollItems.push(finalDest.stationName); // æœ€ç»ˆåœåœ¨è¿™é‡Œ
        
        // æ¸²æŸ“æ»šåŠ¨é¡¹
        const itemHeight = 48;
        scrollContainer.innerHTML = scrollItems.map((name, idx) => `
            <div class="h-12 flex items-center justify-center text-2xl font-bold ${name === finalDest.stationName && idx === scrollItems.length - 1 ? 'text-yellow-400' : 'text-white'}" 
                 style="height: ${itemHeight}px;">${name}</div>
        `).join('');
        
        // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆä»ç¬¬ä¸€ä¸ªå¼€å§‹ï¼‰
        scrollContainer.style.transform = `translateY(-${itemHeight / 2}px)`;
        scrollContainer.style.transition = 'none';
        
        await wait(100);
        
        // å¼€å§‹æ»šåŠ¨åŠ¨ç”»
        const totalItems = scrollItems.length;
        const finalOffset = (totalItems - 1) * itemHeight + itemHeight / 2;
        
        // å…ˆå¿«åæ…¢çš„æ»šåŠ¨æ•ˆæœ
        scrollContainer.style.transition = 'transform 3s cubic-bezier(0.15, 0.85, 0.35, 1)';
        scrollContainer.style.transform = `translateY(-${finalOffset}px)`;
        
        // ç­‰å¾…æ»šåŠ¨å®Œæˆ
        await wait(3200);
        
        // æ˜¾ç¤ºç»“æœ
        document.getElementById('lottery-result').innerText = `ğŸ¯ ${finalDest.stationName}`;
        document.getElementById('lottery-result').style.opacity = '1';
        document.getElementById('lottery-subtitle').style.opacity = '1';
        
        // ç­‰å¾…å±•ç¤º
        await wait(1500);
        
        // æ·¡å‡º
        overlay.style.opacity = '0';
        overlay.style.transition = 'opacity 0.5s';
        await wait(500);
        overlay.remove();
    }
    
    createDestinationMarker(tile) {
        const group = new THREE.Group();
        
        // å‘å…‰åœ†ç¯
        const ringGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.3;
        group.add(ring);
        
        // æ——æ†
        const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.set(1.5, 3, 1.5);
        group.add(pole);
        
        // æ——å¸œ
        const flagGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
        const flagMat = new THREE.MeshLambertMaterial({ color: 0xff4444, side: THREE.DoubleSide });
        const flag = new THREE.Mesh(flagGeo, flagMat);
        flag.position.set(2.5, 5, 1.5);
        group.add(flag);
        
        // ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»çš„æ˜Ÿæ˜Ÿ
        const starGeo = new THREE.OctahedronGeometry(0.5, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 3;
        star.userData.baseY = 3;
        star.userData.animate = true;
        group.add(star);
        
        // å®šä½åˆ°ç›®çš„åœ°æ ¼å­
        group.position.copy(tile.worldPos);
        group.position.y = 1;
        
        this.scene.add(group);
        this.destinationMarker = group;
        
        // æ˜Ÿæ˜ŸåŠ¨ç”»
        const animateStar = () => {
            if (!this.destinationMarker) return;
            const star = this.destinationMarker.children.find(c => c.userData.animate);
            if (star) {
                star.position.y = star.userData.baseY + Math.sin(Date.now() * 0.003) * 0.5;
                star.rotation.y += 0.02;
            }
            requestAnimationFrame(animateStar);
        };
        animateStar();
    }
    
    // æ˜¾ç¤ºåˆ°è¾¾ç›®çš„åœ°çš„ç»“ç®—åŠ¨ç”»
    async showDestinationArrival(player) {
        if (!this.destinationTile) return;
        
        const destName = this.destinationTile.stationName;
        
        // åˆ›å»ºç»“ç®—åŠ¨ç”»å¼¹çª—
        const overlay = document.createElement('div');
        overlay.id = 'arrival-overlay';
        overlay.className = 'fixed inset-0 flex items-center justify-center z-50';
        overlay.style.background = 'rgba(0,0,0,0.8)';
        overlay.style.backdropFilter = 'blur(4px)';
        
        overlay.innerHTML = `
            <div class="text-center transform scale-0 transition-transform duration-500" id="arrival-content">
                <div class="text-8xl mb-6 animate-bounce">ğŸ†</div>
                <div class="text-4xl font-black text-white mb-4">åˆ°è¾¾ç›®çš„åœ°!</div>
                <div class="text-3xl font-bold text-yellow-400 mb-6">${destName}</div>
                <div class="text-6xl font-mono font-black text-green-400 mb-4">+Â¥${DESTINATION_REWARD}</div>
                <div class="text-xl text-gray-300">${player.name} è·å¾—æ´åŠ©é‡‘!</div>
                <div class="mt-6 flex justify-center gap-2">
                    <span class="text-4xl">ğŸ‰</span>
                    <span class="text-4xl">ğŸŠ</span>
                    <span class="text-4xl">âœ¨</span>
                </div>
            </div>
        `;
        
        document.body.appendChild(overlay);
        
        // å¼¹å‡ºåŠ¨ç”»
        await wait(100);
        document.getElementById('arrival-content').style.transform = 'scale(1)';
        
        // æ’­æ”¾é‡‘å¸éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
        this.log(`ğŸ† ${player.name} åˆ°è¾¾ç›®çš„åœ° ${destName}!`, "#22c55e");
        showToast(`ğŸ† ${player.name} è·å¾—æ´åŠ©é‡‘ Â¥${DESTINATION_REWARD}!`, '#22c55e');
        
        player.money += DESTINATION_REWARD;
        this.updateUI();
        
        // ç­‰å¾…åŠ¨ç”»å±•ç¤º
        await wait(2500);
        
        // æ·¡å‡ºåŠ¨ç”»
        overlay.style.opacity = '0';
        overlay.style.transition = 'opacity 0.5s';
        await wait(500);
        overlay.remove();
        
        // è®¾ç½®æ–°çš„ç›®çš„åœ°
        await this.setNewDestination();
    }
    
    // --- å¹´åº¦å†³ç®—ç³»ç»Ÿ ---
    
    advanceTime() {
        this.totalTurns++;
        this.gameMonth++;
        
        if (this.gameMonth > 12) {
            this.gameMonth = 1;
            this.gameYear++;
        }
        
        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
        document.getElementById('game-year').innerText = this.gameYear;
        document.getElementById('game-month').innerText = this.gameMonth;
        
        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å†³ç®—æœˆï¼ˆ3æœˆï¼‰
        if (this.gameMonth === SETTLEMENT_MONTH) {
            return true; // éœ€è¦å†³ç®—
        }
        return false;
    }
    
    async performSettlement() {
        this.log(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—å¼€å§‹ï¼`, "#fbbf24");
        showToast(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—ï¼`, '#fbbf24');
        
        await wait(500);
        
        for (const player of this.players) {
            let totalIncome = 0;
            const ownedStations = new Map(); // stationName -> buildingCount
            
            // ç»Ÿè®¡æ¯ä¸ªè½¦ç«™çš„ç‰©ä»¶
            this.map.forEach(tile => {
                if (tile.type === 'green' && tile.owner === player.id) {
                    const stationBuildings = tile.buildings.length;
                    if (stationBuildings > 0) {
                        ownedStations.set(tile.stationName, stationBuildings);
                        
                        // è®¡ç®—è¯¥è½¦ç«™çš„æ”¶ç›Š
                        let stationIncome = 0;
                        tile.buildings.forEach(tierIndex => {
                            stationIncome += BUILDING_INCOME[tierIndex];
                        });
                        
                        // ç‹¬å å¥–åŠ±ï¼šå¦‚æœæ‹¥æœ‰å…¨éƒ¨3ç§ç‰©ä»¶ï¼Œæ”¶ç›Šç¿»å€
                        const isMonopoly = tile.buildings.length === 3;
                        if (isMonopoly) {
                            stationIncome *= 2;
                            this.log(`ğŸ† ${tile.stationName} ç‹¬å åŠ æˆï¼`, "#a855f7");
                        }
                        
                        totalIncome += stationIncome;
                    }
                }
            });
            
            if (totalIncome > 0) {
                player.money += totalIncome;
                this.log(`ğŸ’° ${player.name} æ”¶åˆ°çº¢åˆ© Â¥${totalIncome}`, player.color === 0x3b82f6 ? '#60a5fa' : '#f87171');
                await this.showMoneyChangeDialog(player, totalIncome);
            } else {
                this.log(`${player.name} æ²¡æœ‰ç‰©ä»¶æ”¶ç›Š`, "#9ca3af");
            }
        }
        
        this.updateUI();
        await wait(500);
    }

    // --- UI & Interaction ---

    log(msg, color = 'white') {
        const logEl = document.getElementById('game-log');
        const entry = document.createElement('div');
        entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
        logEl.appendChild(entry);
        if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
        setTimeout(() => {
            entry.style.opacity = '0';
            setTimeout(() => entry.remove(), 500);
        }, 4000);
    }

    startTurn() {
        if (!this.isUserInteracting) {
            this.cameraLocked = true;
        }
        const p = this.players[this.turn];
        document.getElementById('turn-indicator').innerText = `${p.name} çš„å›åˆ`;
        
        // Center camera on the current player
        this.centerCameraOnPlayer(p);
        
        const p1Panel = document.getElementById('p1-panel');
        const comPanel = document.getElementById('com-panel');
        
        p1Panel.style.opacity = this.turn === 0 ? '1' : '0.6';
        p1Panel.style.transform = this.turn === 0 ? 'scale(1.05)' : 'scale(1)';
        p1Panel.classList.toggle('border-yellow-400', this.turn === 0);
        
        comPanel.style.opacity = this.turn === 1 ? '1' : '0.6';
        comPanel.style.transform = this.turn === 1 ? 'scale(1.05)' : 'scale(1)';
        comPanel.classList.toggle('border-yellow-400', this.turn === 1);

        this.state = 'IDLE';

        if (p.isAI) {
            document.getElementById('roll-btn').classList.add('hidden');
            setTimeout(() => this.aiAction(), 1000);
        } else {
            document.getElementById('roll-btn').classList.remove('hidden');
        }
    }

    async playerRoll() {
        if (this.state !== 'IDLE') return;
        document.getElementById('roll-btn').classList.add('hidden');
        await this.processMove();
    }

    async aiAction() {
        this.log("ç”µè„‘æ­£åœ¨æ€è€ƒ...", "#fca5a5");
        await wait(1000);
        await this.processMove();
    }

    async processMove() {
        this.state = 'MOVING';
        const steps = rand(1, 6);
        const player = this.players[this.turn];
        
        this.log(`${player.name} æ·å‡ºäº† ${steps} ç‚¹!`, "#fbbf24");

        let remainingSteps = steps;
        let reachedDestination = false;
        
        while (remainingSteps > 0) {
            const current = player.currentTile;
            const neighbors = current.neighbors;
            
            let validNext = neighbors.filter(n => n !== player.previousTile);
            if (validNext.length === 0 && neighbors.length > 0) {
                validNext = neighbors; // Dead end fallback
            }

            let nextTile = null;

            if (validNext.length === 1) {
                nextTile = validNext[0];
            } else if (validNext.length > 1) {
                if (player.isAI) {
                    nextTile = this.chooseBestDirection(validNext);
                } else {
                    nextTile = await this.askDirection(player, validNext);
                }
            } else {
                break;
            }

            // Physics Move
            player.previousTile = player.currentTile;
            player.currentTile = nextTile;
            
            await this.animateMove(player, nextTile.worldPos);
            
            // æ›´æ–°è·ç¦»æ˜¾ç¤º
            this.updateDistanceDisplay();
            
            // æ£€æŸ¥æ˜¯å¦è·¯è¿‡ç›®çš„åœ°ï¼ˆå³ä½¿è¿˜æœ‰æ­¥æ•°ä¹Ÿç®—åˆ°è¾¾ï¼‰
            if (!reachedDestination && this.destinationTile && nextTile === this.destinationTile) {
                reachedDestination = true;
                await this.showDestinationArrival(player);
            }

            if (nextTile.isColored) {
                remainingSteps--;
            }
        }

        await wait(300);
        await this.triggerTileEvent(player, reachedDestination);
    }

    animateMove(player, targetVec3) {
        if (!this.isUserInteracting) {
            this.cameraLocked = true;
        }
        return new Promise(resolve => {
            const startPos = player.mesh.position.clone();
            const startTime = Date.now();
            const duration = 300; // ms
            
            // Simple Hop Animation
            const animateStep = () => {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                
                // Linear Interpolation for X/Z
                player.mesh.position.lerpVectors(startPos, targetVec3, progress);
                
                // Parabolic Arc for Y (Jump)
                // y = 4 * height * x * (1-x) + baseline
                const jumpHeight = 2;
                const baseHeight = 1.5;
                player.mesh.position.y = baseHeight + (4 * jumpHeight * progress * (1 - progress));

                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    player.mesh.position.copy(targetVec3);
                    player.mesh.position.y = baseHeight;
                    resolve();
                }
            };
            animateStep();
        });
    }

    async askDirection(player, options) {
        // Center camera on the player before showing direction options
        await this.centerCameraOnPlayer(player, 300);
        
        return new Promise(resolve => {
            const overlay = document.createElement('div');
            overlay.className = 'absolute inset-0 pointer-events-auto z-50';
            overlay.id = 'direction-overlay';
            document.getElementById('ui-layer').appendChild(overlay);

            options.forEach(tile => {
                // Lift the icon slightly so it appears on top of the tile
                const targetPos = tile.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                const screenPos = this.getScreenPosition(targetPos);
                
                let label = 'ğŸ“';
                const dx = tile.gridX - player.currentTile.gridX;
                const dy = tile.gridY - player.currentTile.gridY; // using gridY as Z
                
                if (dx > 0) label = 'â¡ï¸';
                else if (dx < 0) label = 'â¬…ï¸';
                else if (dy > 0) label = 'â¬‡ï¸'; // Z+ is down on screen roughly
                else if (dy < 0) label = 'â¬†ï¸';

                // Container for positioning (handles centering)
                const container = document.createElement('div');
                container.className = 'absolute';
                container.style.left = `${screenPos.x}px`;
                container.style.top = `${screenPos.y}px`;
                container.style.transform = 'translate(-50%, -50%)';

                // Button for appearance and interaction (handles animation)
                const btn = document.createElement('button');
                btn.innerText = label; 
                btn.className = 'w-12 h-12 bg-yellow-400 hover:bg-white rounded-full text-2xl shadow-xl border-4 border-yellow-600 animate-bounce-custom cursor-pointer';
                
                btn.onclick = () => {
                    document.getElementById('direction-overlay').remove();
                    resolve(tile);
                };

                container.appendChild(btn);

                // Store 3D position on container for frame updates
                container.target3D = targetPos;
                
                overlay.appendChild(container);
            });
        });
    }

    async showMoneyChangeDialog(player, changeAmount) {
        return new Promise(resolve => {
            const modal = document.getElementById('money-modal');
            const title = document.getElementById('money-modal-title');
            const amountEl = document.getElementById('money-modal-amount');
            const deltaEl = document.getElementById('money-modal-delta');
            const icon = document.getElementById('money-modal-icon');
            const container = modal.firstElementChild;

            modal.classList.remove('hidden');
            
            const endMoney = player.money;
            const startMoneyVal = endMoney - changeAmount;

            const isGain = changeAmount > 0;
            const colorClass = isGain ? 'text-blue-600' : 'text-red-600';
            const borderClass = isGain ? 'border-blue-500' : 'border-red-500';
            
            container.className = `bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100 ${borderClass}`;
            
            title.innerText = player.name;
            icon.innerText = isGain ? 'ğŸ¤‘' : 'ğŸ’¸';
            
            deltaEl.className = `text-3xl font-black mb-2 ${colorClass}`;
            deltaEl.innerText = (isGain ? '+' : '') + 'Â¥' + changeAmount;
            
            // Animation
            const duration = 1500;
            const startTime = Date.now();
            
            const animate = () => {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4); // Ease out
                
                const currentVal = Math.floor(startMoneyVal + (changeAmount * ease));
                amountEl.innerText = 'Â¥' + currentVal;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    amountEl.innerText = 'Â¥' + endMoney;
                    setTimeout(() => {
                        modal.classList.add('hidden');
                        resolve();
                    }, 800); 
                }
            };
            
            animate();
        });
    }

    async triggerTileEvent(player, alreadyReachedDestination = false) {
        this.state = 'EVENT';
        const tile = player.currentTile;
        let endTurn = true;
        
        // ç›®çš„åœ°åˆ°è¾¾å·²åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­å¤„ç†ï¼Œä¸å†é‡å¤æ£€æŸ¥

        switch (tile.type) {
            case 'blue':
                const bonus = rand(500, 2000);
                player.money += bonus;
                this.log(`å¹¸è¿ï¼è·å¾—èµ„é‡‘ Â¥${bonus}`, "#60a5a5");
                await this.showMoneyChangeDialog(player, bonus);
                break;
            case 'red':
                const loss = rand(500, 1500);
                player.money -= loss;
                this.log(`å€’éœ‰ï¼æŸå¤± Â¥${loss}`, "#f87171");
                await this.showMoneyChangeDialog(player, -loss);
                break;
            case 'yellow':
                this.log(`å¡ç‰Œäº‹ä»¶ (æœªå®è£…)`, "#fbbf24");
                break;
            case 'green':
                endTurn = false;
                await this.handleStation(player, tile);
                break;
        }

        this.updateUI();
        if (endTurn) this.nextTurn();
    }

    spawnFloatingText(pos, text, color) {
        const div = document.createElement('div');
        div.innerText = text;
        div.style.color = color;
        div.className = 'absolute text-2xl font-black shadow-white drop-shadow-md pointer-events-none transition-all duration-1000 ease-out';
        
        const screenPos = this.getScreenPosition(pos);
        div.style.left = screenPos.x + 'px';
        div.style.top = screenPos.y + 'px';
        
        document.getElementById('ui-layer').appendChild(div);
        
        // Animate via CSS
        requestAnimationFrame(() => {
            div.style.transform = 'translateY(-50px)';
            div.style.opacity = '0';
        });
        
        setTimeout(() => div.remove(), 1000);
    }

    async handleStation(player, tile) {
        if (player.isAI) {
            // AIç­–ç•¥ï¼šä¼˜å…ˆè€ƒè™‘æ˜¯å¦è¦è´­ä¹°
            let bought = false;
            for (let i = 2; i >= 0; i--) { // ä»é«˜çº§ç‰©ä»¶å¼€å§‹è€ƒè™‘
                if (!tile.buildings.includes(i) && player.money >= BUILDING_COSTS[i] * 1.2) {
                     this.doBuy(player, tile, i);
                     bought = true;
                     await wait(800);
                     // AIä¸è´ªå©ªï¼Œä¸€æ¬¡åªä¹°ä¸€ä¸ª
                     break;
                }
            }
            if(!bought) this.log("ç”µè„‘æ²¡æœ‰è´­ä¹°æ„å‘", "#fca5a5");
            this.nextTurn();
        } else {
            this.state = 'BUYING';
            this.showBuyModal(tile);
        }
    }

    showBuyModal(tile) {
        const modal = document.getElementById('buy-modal');
        const list = document.getElementById('building-list');
        document.getElementById('station-name').innerText = tile.stationName;
        document.getElementById('buy-modal-money').innerText = this.players[0].money;
        list.innerHTML = '';
        
        // æ˜¾ç¤ºæ˜¯å¦ä¸ºç›®çš„åœ°
        const isDestination = tile === this.destinationTile;
        if (isDestination) {
            const destBadge = document.createElement('div');
            destBadge.className = 'bg-yellow-500 text-black text-center py-1 px-3 rounded-full text-sm font-bold mb-3';
            destBadge.innerText = 'ğŸ¯ å½“å‰ç›®çš„åœ°ï¼';
            list.appendChild(destBadge);
        }

        BUILDING_NAMES.forEach((name, index) => {
            const cost = BUILDING_COSTS[index];
            const income = BUILDING_INCOME[index];
            const isOwned = tile.buildings.includes(index);
            const canAfford = this.players[0].money >= cost;
            
            const div = document.createElement('div');
            div.className = `flex justify-between items-center p-3 rounded border ${isOwned ? 'bg-blue-100 border-blue-500' : 'bg-gray-50 border-gray-200'}`;
            
            let btnHtml = '';
            if (isOwned) {
                let ownerName = 'æœªçŸ¥';
                if (tile.owner) {
                    const owner = this.players.find(p => p.id === tile.owner);
                    if (owner) {
                        ownerName = (owner.id === this.players[0].id) ? 'æˆ‘' : owner.name;
                    }
                }
                btnHtml = `<span class="text-blue-600 font-bold text-sm">å·²æ‹¥æœ‰ (${ownerName})</span>`;
            } else {
                btnHtml = canAfford ? `<button onclick="game.playerBuy(${index})" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm shadow">è´­ä¹°</button>` : `<span class="text-red-400 text-sm">ç¼ºé’±</span>`;
            }

            div.innerHTML = `
                <div>
                    <div class="font-bold text-gray-800">${name}</div>
                    <div class="text-xs text-gray-500">Â¥${cost} Â· <span class="text-green-600">å¹´æ”¶ç›Š Â¥${income}</span></div>
                </div>
                <div>${btnHtml}</div>
            `;
            list.appendChild(div);
        });
        
        // æ˜¾ç¤ºç‹¬å å¥–åŠ±æç¤º
        const monopolyHint = document.createElement('div');
        monopolyHint.className = 'text-xs text-center text-purple-600 mt-2';
        monopolyHint.innerText = tile.buildings.length === 3 ? 'ğŸ† å·²ç‹¬å ï¼æ”¶ç›Šç¿»å€ï¼' : 'ğŸ’¡ ä¹°é½3ç§ç‰©ä»¶å¯è·å¾—ç‹¬å åŠ æˆ(æ”¶ç›Šx2)';
        list.appendChild(monopolyHint);

        modal.classList.remove('hidden');
    }

    playerBuy(tierIndex) {
        const player = this.players[0];
        const tile = player.currentTile;
        if (tile.buildings.includes(tierIndex) || player.money < BUILDING_COSTS[tierIndex]) return;

        this.doBuy(player, tile, tierIndex);
        this.showBuyModal(tile); 
        this.updateUI();
    }

    doBuy(player, tile, tierIndex) {
        player.money -= BUILDING_COSTS[tierIndex];
        player.assets += BUILDING_COSTS[tierIndex];
        tile.buildings.push(tierIndex);
        tile.buildings.sort();
        tile.owner = player.id;
        
        this.placeBuildingVisually(tile, tierIndex);
        this.log(`${player.name} è´­ä¹°äº† ${BUILDING_NAMES[tierIndex]}!`, player.color === 0x3b82f6 ? '#60a5fa' : '#f87171');
    }

    placeBuildingVisually(stationTile, tierIndex) {
        // Find a spot near the station
        const range = 2;
        const candidates = [];
        for(let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for(let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
                const t = this.tilesMap.get(`${x},${z}`);
                // Must be environment (not road) and empty
                if (t && !t.isRoad && t.mesh.children.length === 0) {
                    candidates.push(t);
                }
            }
        }

        if (candidates.length > 0) {
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            
            const bColor = COLORS.building[tierIndex];
            const h = (tierIndex + 1) * 3; // Height varies by tier
            
            const bGeo = new THREE.BoxGeometry(2.5, h, 2.5);
            const bMat = new THREE.MeshLambertMaterial({ color: bColor });
            const bMesh = new THREE.Mesh(bGeo, bMat);
            bMesh.position.y = h / 2 + 1; // Adjust for height
            bMesh.castShadow = true;
            bMesh.receiveShadow = true;
            
            // Add windows texture logic (simplified as black boxes)
            const winGeo = new THREE.BoxGeometry(2.6, h*0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x334155 });
            const wins = new THREE.Mesh(winGeo, winMat);
            bMesh.add(wins);

            target.mesh.add(bMesh);
            
            // Juice effect
            const scaleUp = () => {
                bMesh.scale.set(0.1, 0.1, 0.1);
                let s = 0.1;
                const grow = setInterval(() => {
                    s += 0.1;
                    bMesh.scale.set(s, s, s);
                    if (s >= 1) clearInterval(grow);
                }, 16);
            };
            scaleUp();
        }
    }

    closeBuyModal() {
        document.getElementById('buy-modal').classList.add('hidden');
        this.nextTurn();
    }

    async nextTurn() {
        // æ—¶é—´æ¨è¿›ï¼ˆæ¯ä¸¤ä¸ªå›åˆï¼ˆP1+COMå„èµ°ä¸€æ¬¡ï¼‰ç®—ä¸€ä¸ªæœˆï¼‰
        // è¿™é‡Œæ¯ä¸ªç©å®¶å›åˆç»“æŸåï¼Œå¦‚æœæ˜¯COMå›åˆç»“æŸï¼Œåˆ™æ¨è¿›ä¸€ä¸ªæœˆ
        if (this.turn === 1) { // COMåˆšç»“æŸå›åˆ
            const needSettlement = this.advanceTime();
            if (needSettlement) {
                await this.performSettlement();
            }
        }
        
        this.turn = (this.turn + 1) % 2;
        this.startTurn();
    }

    updateUI() {
        const p1 = this.players[0];
        const com = this.players[1];
        document.getElementById('p1-money').innerText = p1.money.toLocaleString();
        document.getElementById('p1-assets').innerText = p1.assets.toLocaleString();
        document.getElementById('com-money').innerText = com.money.toLocaleString();
        document.getElementById('com-assets').innerText = com.assets.toLocaleString();
        
        // æ›´æ–°è·ç¦»æ˜¾ç¤º
        this.updateDistanceDisplay();
    }

    // --- Rendering Loop ---

    getScreenPosition(vec3) {
        const v = vec3.clone();
        v.project(this.camera);
        const x = (v.x * .5 + .5) * this.width;
        const y = (-(v.y * .5) + .5) * this.height;
        return { x, y };
    }

    centerCameraOnPlayer(player, duration = 500) {
        return new Promise(resolve => {
            if (!player || !player.mesh) {
                resolve();
                return;
            }
            
            const targetPos = player.mesh.position.clone();
            const startTarget = this.controls.target.clone();
            const startCamPos = this.camera.position.clone();
            
            // Calculate camera offset from current target
            const offset = startCamPos.clone().sub(startTarget);
            const endCamPos = targetPos.clone().add(offset);
            
            const startTime = Date.now();
            
            const animateCamera = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic for smooth deceleration
                const eased = 1 - Math.pow(1 - progress, 3);
                
                this.controls.target.lerpVectors(startTarget, targetPos, eased);
                this.camera.position.lerpVectors(startCamPos, endCamPos, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    resolve();
                }
            };
            
            animateCamera();
        });
    }
    
    // Focus camera on a specific player by index (0 = P1, 1 = COM)
    focusOnPlayer(playerIndex) {
        if (this.mode !== 'GAME') return;
        if (playerIndex < 0 || playerIndex >= this.players.length) return;
        
        const player = this.players[playerIndex];
        if (!player || !player.mesh) return;
        
        // Temporarily disable camera lock to allow manual focus
        this.cameraLocked = false;
        
        // Center camera on the selected player
        this.centerCameraOnPlayer(player, 400);
    }

    onResize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // Update Game Camera
        this.camera.aspect = this.width / this.height;
        this.camera.updateProjectionMatrix();
        
        // Update Map Camera
        if (this.worldMap) {
            this.worldMap.camera.aspect = this.width / this.height;
            this.worldMap.camera.updateProjectionMatrix();
        }

        this.renderer.setSize(this.width, this.height);
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        if (this.mode === 'MAP') {
            if (this.worldMap) {
                this.worldMap.update();
                this.renderer.render(this.worldMap.scene, this.worldMap.camera);
            }
            return;
        }

        // Camera Follow Logic
        if (this.cameraLocked) {
            const activePlayer = this.players[this.turn];
            if (activePlayer && activePlayer.mesh) {
                const targetPos = activePlayer.mesh.position;
                
                // Smoothly move both target and camera to maintain angle
                const currentTarget = this.controls.target.clone();
                const newTarget = currentTarget.clone().lerp(targetPos, 0.1);
                const delta = new THREE.Vector3().subVectors(newTarget, currentTarget);
                
                this.camera.position.add(delta);
                this.controls.target.copy(newTarget);
            }
        }

        if (this.controls) this.controls.update();

        // Update Station Labels
        this.map.forEach(tile => {
            if (tile.labelElement) {
                // Only update if visible (optional optimization)
                const pos = this.getScreenPosition(tile.mesh.position);
                const offset = tile.labelOffset || { x: 0, y: -30, align: 'center' };
                
                // Apply position based on label alignment
                let transform;
                if (offset.align === 'left') {
                    // Label on right side of station, align left edge
                    transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(0%, -50%)`;
                } else if (offset.align === 'right') {
                    // Label on left side of station, align right edge
                    transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-100%, -50%)`;
                } else {
                    // Label on top (default), center aligned
                    transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-50%, -100%)`;
                }
                tile.labelElement.style.transform = transform;
                
                // Hide if offscreen
                if (pos.x < 0 || pos.x > this.width || pos.y < 0 || pos.y > this.height) {
                    tile.labelElement.style.opacity = '0';
                } else {
                    tile.labelElement.style.opacity = '1';
                }
            }
        });
        
        // Update off-screen destination indicator
        this.updateDestinationIndicator();

        // Update Overlay Buttons if active
        const overlay = document.getElementById('direction-overlay');
        if (overlay) {
            Array.from(overlay.children).forEach(btn => {
                if (btn.target3D) {
                    const screenPos = this.getScreenPosition(btn.target3D);
                    btn.style.left = `${screenPos.x}px`;
                    btn.style.top = `${screenPos.y}px`;
                }
            });
        }

        this.renderer.render(this.scene, this.camera);
    }
}

// Boot
window.onload = async () => {
    // Load cities data first
    await loadCitiesData();
    // Then initialize the game
    window.game = new Game();
};

</script>
</body>
</html>
