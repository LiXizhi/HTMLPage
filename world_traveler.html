<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello World - Travel, Build, Talk</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.keepwork.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.16"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #202025;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
        outline: none;
        touch-action: none;
      }

      /* UI Overlay - ä¿æŒåŸæ ·ï¼Œä½†å¢åŠ ç©¿é€æ€§ */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 20;
      }
      .hud-panel {
        pointer-events: auto;
      }

      /* Animations */
      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }
      .animate-bounce-custom {
        animation: bounce 1s infinite;
      }

      .modal {
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        transition: opacity 0.3s;
      }

      /* Station Labels floating in 3D space */
      .station-label {
        position: absolute;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        transform: translate(-50%, -150%);
        white-space: nowrap;
        text-shadow: 0 1px 2px black;
        z-index: 10;
        user-select: none;
        -webkit-user-select: none;
      }

      /* Destination label highlight */
      .station-label.destination {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        font-size: 16px;
        padding: 6px 16px;
        border: 2px solid #fff;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        animation: destination-pulse 1.5s ease-in-out infinite;
        z-index: 15;
      }

      @keyframes destination-pulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.6);
        }
      }

      /* Off-screen destination indicator */
      .destination-indicator {
        position: fixed;
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        white-space: nowrap;
        border: 2px solid #fff;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        z-index: 1;
        display: flex;
        align-items: center;
        gap: 6px;
        animation: indicator-pulse 1s ease-in-out infinite;
      }

      @keyframes indicator-pulse {
        0%,
        100% {
          opacity: 1;
          box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        }
        50% {
          opacity: 0.9;
          box-shadow: 0 0 25px rgba(251, 191, 36, 1);
        }
      }

      /* ç©·ç¥ç›¸å…³æ ·å¼ */
      .binbougami-indicator {
        animation: binbougami-shake 0.5s ease-in-out infinite;
      }

      @keyframes binbougami-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-2px) rotate(-1deg);
        }
        75% {
          transform: translateX(2px) rotate(1deg);
        }
      }

      .binbougami-effect {
        animation: binbougami-appear 0.5s ease-out;
      }

      @keyframes binbougami-appear {
        0% {
          transform: scale(0) rotate(-180deg);
          opacity: 0;
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* ç©·ç¥å¤§é­”ç‹æ¨¡å¼ */
      .binbougami-king {
        animation: king-pulse 1s ease-in-out infinite;
        filter: drop-shadow(0 0 10px #ff0000);
      }

      @keyframes king-pulse {
        0%,
        100% {
          transform: scale(1);
          filter: drop-shadow(0 0 10px #ff0000);
        }
        50% {
          transform: scale(1.1);
          filter: drop-shadow(0 0 20px #ff4444);
        }
      }

      /* å¡ç‰Œæ ·å¼ */
      .card-item {
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .card-item:hover {
        transform: translateY(-8px) scale(1.05);
        z-index: 100;
      }

      .card-rarity-common {
        border-color: #9ca3af;
        background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
      }
      .card-rarity-rare {
        border-color: #3b82f6;
        background: linear-gradient(135deg, #dbeafe, #bfdbfe);
      }
      .card-rarity-epic {
        border-color: #8b5cf6;
        background: linear-gradient(135deg, #ede9fe, #ddd6fe);
      }
      .card-rarity-legendary {
        border-color: #f59e0b;
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
      }

      .card-panel {
        max-height: 120px;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .card-panel::-webkit-scrollbar {
        height: 4px;
      }

      .card-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }

      /* --- 3D Dice Animation Styles --- */
      :root {
        --die-size: 80px;
        --die-half: 40px;
        --dot-size: 10px;
      }

      .dice-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .dice-modal.show {
        opacity: 1;
        pointer-events: auto;
      }

      .dice-scene {
        position: relative;
        width: 400px;
        height: 300px;
        perspective: 2000px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: visible;
      }

      .dice-floor {
        position: absolute;
        width: 500px;
        height: 500px;
        background-image: radial-gradient(rgba(255,255,255,0.3) 1px, transparent 1px);
        background-size: 20px 20px;
        opacity: 0.5;
        transform: rotateX(60deg) scale(1.5);
        pointer-events: none;
      }

      .dice-stage {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-style: preserve-3d;
        opacity: 0;
      }

      @keyframes diceStageEnter {
        0% {
          opacity: 0;
          transform: translate(300px, 200px) scale(0.2);
        }
        60% {
          opacity: 1;
          transform: translate(-20px, -20px) scale(1.05);
        }
        100% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
      }

      .dice-stage.entering {
        animation: diceStageEnter 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }

      .dice-camera {
        position: relative;
        transform-style: preserve-3d;
        transform: rotateX(-35deg) rotateY(45deg);
        display: flex;
        gap: 30px;
        transition: transform 0.5s;
      }

      .die-wrapper {
        position: relative;
        width: var(--die-size);
        height: var(--die-size);
        transform-style: preserve-3d;
      }

      .die {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transform: rotateX(-90deg);
      }

      .die-shadow {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        filter: blur(15px);
        transform: translateY(50px) rotateX(90deg) scale(1.2);
        border-radius: 50%;
        z-index: -1;
      }

      .die-face {
        position: absolute;
        width: var(--die-size);
        height: var(--die-size);
        background: white;
        border: 2px solid #cbd5e1;
        border-radius: 10px;
        box-sizing: border-box;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        padding: 10px;
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);
        backface-visibility: visible;
      }

      .die-dot {
        width: var(--dot-size);
        height: var(--dot-size);
        background: #1e293b;
        border-radius: 50%;
        align-self: center;
        justify-self: center;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      }

      .die-face-1 { transform: translateZ(var(--die-half)); }
      .die-face-2 { transform: rotateX(90deg) translateZ(var(--die-half)); }
      .die-face-3 { transform: rotateY(-90deg) translateZ(var(--die-half)); }
      .die-face-4 { transform: rotateY(90deg) translateZ(var(--die-half)); }
      .die-face-5 { transform: rotateX(-90deg) translateZ(var(--die-half)); }
      .die-face-6 { transform: rotateY(180deg) translateZ(var(--die-half)); }

      .dice-result {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: 900;
        color: white;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        opacity: 0;
        transition: opacity 0.3s;
      }

      .dice-result.show {
        opacity: 1;
      }

      .dice-result-value {
        color: #fbbf24;
      }
    </style>
  </head>
  <body>
    <!-- Game Container -->
    <div id="game-container" class="w-full h-full relative"></div>

    <!-- Labels Layer (Dynamic HTML for 3D objects) -->
    <div id="labels-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>

    <!-- Off-screen Destination Indicator -->
    <div id="destination-indicator" class="destination-indicator hidden">
      <span id="indicator-arrow">â†’</span>
      <span id="indicator-name">---</span>
    </div>

    <!-- Title and Subtitle (Outside UI Layer) -->
    <div id="game-title" class="absolute top-4 left-4 z-50 pointer-events-auto hidden">
      <h1
        class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg"
        style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
      >
        HelloWorld
      </h1>
      <p class="text-sm text-white font-semibold tracking-wider drop-shadow-md mt-1 ml-1">powered by paracraft</p>
    </div>

    <!-- Login Window -->
    <div id="login-modal" class="fixed inset-0 flex items-center justify-center z-[60] bg-black/40 backdrop-blur-sm">
      <div class="text-center">
        <h1
          class="text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg mb-2"
          style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
        >
          Hello World
        </h1>
        <p class="text-2xl text-white font-semibold tracking-wider drop-shadow-md mb-8">Travel the World, Build Your Home, Talk With People</p>
        <button
          id="login-btn"
          class="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-4 px-12 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 border-2 border-white/50"
        >
          ç«‹å³å‡ºå‘
        </button>
      </div>
      <div class="absolute bottom-8 text-white/90 text-sm font-bold tracking-widest drop-shadow-lg">powered by Paracraft (c) copy right 2025</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-2 md:p-4 pointer-events-none">
      <!-- Top Bar Container -->
      <div class="flex flex-col w-full items-center gap-2 pointer-events-none">
        <!-- Row 1: Destination & Time (Always visible at top, compact on mobile) -->
        <div
          class="hud-panel pointer-events-auto bg-gradient-to-r from-purple-900/90 to-pink-900/90 text-white px-3 py-2 pr-12 md:pr-3 rounded-xl border-2 border-yellow-400 shadow-lg hidden w-full max-w-2xl flex justify-between items-center gap-2 z-50"
          id="destination-panel"
        >
          <div class="flex items-center gap-2">
            <span class="text-xs text-gray-300">ğŸ“…</span>
            <span class="text-sm md:text-lg font-bold text-yellow-300 whitespace-nowrap"><span id="game-year">1</span>å¹´<span id="game-month">4</span>æœˆ</span>
          </div>
          <div class="w-px h-6 bg-gray-500"></div>
          <div class="flex items-center gap-2 overflow-hidden flex-1 justify-center">
            <span class="text-xs text-gray-300">ğŸ¯</span>
            <span class="text-sm md:text-lg font-bold text-green-300 truncate" id="destination-name">---</span>
          </div>
          <div class="w-px h-6 bg-gray-500 hidden md:block"></div>
          <div class="flex items-center gap-2 hidden md:flex">
            <span class="text-xs text-gray-300">ğŸ’°</span>
            <span class="text-sm md:text-lg font-bold text-yellow-400">Â¥5000</span>
          </div>
        </div>

        <!-- Turn Indicator - Centered -->
        <div
          class="hud-panel bg-gray-800/80 text-white px-3 py-1 md:px-6 md:py-2 rounded-full border border-gray-600 pointer-events-auto"
        >
          <span id="turn-indicator" class="font-bold text-xs md:text-lg tracking-widest whitespace-nowrap">ç­‰å¾…...</span>
        </div>
      </div>

      <!-- Left Side: Players List -->
      <div class="absolute top-32 md:top-40 left-2 md:left-4 flex flex-col gap-2 pointer-events-none z-20">
        <!-- P1 Info (Minimal) -->
        <div
          class="hud-panel bg-blue-900/90 text-white px-3 py-2 rounded-lg border-2 border-blue-400 shadow-lg transition-all pointer-events-auto cursor-pointer hover:border-yellow-400 flex items-center gap-2"
          id="p1-panel"
          onclick="game.showPlayerDetail(0)"
        >
          <div class="w-4 h-4 rounded-full bg-blue-400 flex-shrink-0"></div>
          <span class="font-bold text-sm">P1</span>
          <span id="p1-binbougami" class="hidden text-lg binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
          <span class="text-yellow-300 text-sm font-mono ml-1">Â¥<span id="p1-money">0</span></span>
        </div>

        <!-- COM Info (Minimal) -->
        <div
          class="hud-panel bg-red-900/90 text-white px-3 py-2 rounded-lg border-2 border-red-400 shadow-lg transition-all opacity-70 pointer-events-auto cursor-pointer hover:border-yellow-400 flex items-center gap-2"
          id="com-panel"
          onclick="game.showPlayerDetail(1)"
        >
          <div class="w-4 h-4 rounded-full bg-red-500 flex-shrink-0"></div>
          <span class="font-bold text-sm">COM</span>
          <span id="com-binbougami" class="hidden text-lg binbougami-indicator" title="ç©·ç¥é™„èº«ä¸­">ğŸ‘»</span>
          <span class="text-yellow-300 text-sm font-mono ml-1">Â¥<span id="com-money">0</span></span>
        </div>
      </div>

      <!-- Airport Button -->
      <button
        onclick="game.toggleMap()"
        class="hud-panel absolute top-2 right-2 md:top-4 md:right-4 bg-blue-600 hover:bg-blue-700 text-white p-2 md:p-3 rounded-full shadow-lg border-2 border-white z-50 pointer-events-auto transition-transform hover:scale-110"
        title="åˆ‡æ¢åŸå¸‚"
      >
        âœˆï¸
      </button>

      <!-- Action Log -->
      <div class="absolute top-40 md:top-24 right-2 md:right-4 w-48 md:w-64 pointer-events-none z-20">
        <div id="game-log" class="flex flex-col gap-1 md:gap-2 items-end text-xs md:text-sm font-bold text-white shadow-black drop-shadow-md">
          <!-- Log entries go here -->
        </div>
      </div>

      <!-- Bottom Controls -->
      <div class="flex flex-col items-center gap-4 mb-4 pointer-events-none">
        <!-- å¡ç‰Œæ‰‹ç‰ŒåŒºåŸŸ -->
        <div id="card-hand-panel" class="hud-panel pointer-events-auto bg-gray-900/80 px-4 py-2 rounded-xl border border-gray-600 hidden">
          <div class="text-xs text-gray-400 mb-1 text-center">ğŸƒ æ‰‹ç‰Œ (ç‚¹å‡»ä½¿ç”¨)</div>
          <div id="card-hand" class="card-panel flex gap-2">
            <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
          </div>
        </div>

        <!-- æŒ‰é’®åŒºåŸŸ -->
        <div class="flex gap-3">
          <button
            id="use-card-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-purple-400 to-purple-600 text-white font-bold text-lg px-6 py-3 rounded-xl shadow-lg border-b-4 border-purple-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸƒ ä½¿ç”¨å¡ç‰Œ
          </button>
          <button
            id="roll-btn"
            class="hud-panel pointer-events-auto bg-gradient-to-b from-yellow-400 to-yellow-600 text-black font-black text-2xl px-12 py-4 rounded-2xl shadow-xl border-b-4 border-yellow-800 hover:translate-y-1 hover:border-b-0 active:scale-95 transition-all hidden"
          >
            ğŸ² æ·éª°å­
          </button>
        </div>
      </div>
    </div>

    <!-- Money Change Modal -->
    <div id="money-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100">
        <div id="money-modal-icon" class="text-6xl mb-4">ğŸ’°</div>
        <h3 class="text-2xl font-black text-gray-800 mb-2" id="money-modal-title">ç©å®¶</h3>
        <div class="text-2xl font-bold mb-2" id="money-modal-delta"></div>
        <div class="text-5xl font-mono font-bold my-4 text-gray-800" id="money-modal-amount">Â¥0</div>
        <div class="text-gray-500 text-sm" id="money-modal-desc">èµ„é‡‘å˜åŠ¨</div>
      </div>
    </div>

    <!-- Property Buy Modal -->
    <!-- ç©·ç¥æ•ˆæœå¼¹çª— -->
    <div id="binbougami-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-gray-900 to-purple-900 p-8 rounded-2xl shadow-2xl max-w-md w-full border-4 border-purple-500 relative text-center">
        <div id="binbougami-modal-icon" class="text-8xl mb-4 binbougami-effect">ğŸ‘»</div>
        <h3 class="text-3xl font-black text-purple-300 mb-2" id="binbougami-modal-title">ç©·ç¥æ¥è¢­ï¼</h3>
        <p class="text-xl text-gray-300 mb-4" id="binbougami-modal-desc">ç©·ç¥æ­£åœ¨æ£ä¹±...</p>
        <div class="text-4xl font-mono font-bold text-red-400 mb-4" id="binbougami-modal-effect"></div>
        <div class="text-sm text-gray-400" id="binbougami-modal-hint"></div>
      </div>
    </div>

    <!-- ç©·ç¥é™„èº«å…¨å±åŠ¨ç”» -->
    <div id="possession-modal" class="fixed inset-0 flex items-center justify-center hidden z-[100] bg-black/90 backdrop-blur-sm transition-opacity duration-500">
      <div class="text-center transform transition-all duration-500 scale-0" id="possession-content">
        <div class="text-9xl mb-8 animate-bounce">ğŸ‘»</div>
        <h1 class="text-6xl font-black text-purple-500 mb-4 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]">ç©·ç¥é™„èº«ï¼</h1>
        <p class="text-4xl text-white font-bold" id="possession-text">ç©å®¶ XX è¢«ç©·ç¥é™„èº«äº†ï¼</p>
      </div>
    </div>

    <!-- 3D éª°å­åŠ¨ç”»å¼¹çª— -->
    <div id="dice-modal" class="dice-modal">
      <div class="flex flex-col items-center">
        <div class="dice-scene">
          <div class="dice-floor"></div>
          <div id="dice-stage" class="dice-stage">
            <div id="dice-camera" class="dice-camera">
              <!-- Dice will be dynamically injected here -->
            </div>
          </div>
        </div>
        <div id="dice-result" class="dice-result">
          æ·å‡ºäº† <span id="dice-result-value" class="dice-result-value">0</span> ç‚¹!
        </div>
      </div>
    </div>

    <!-- å¡ç‰Œè·å–å¼¹çª— -->
    <div id="card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-amber-900 to-yellow-900 p-6 rounded-2xl shadow-2xl max-w-lg w-full border-4 border-yellow-500 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ å¡ç‰‡ç«™</div>
        <h3 class="text-2xl font-bold text-center mt-4 mb-4 text-yellow-300">è·å–å¡ç‰Œ</h3>
        <div id="card-modal-content" class="space-y-3 mb-4">
          <!-- å¡ç‰Œé€‰é¡¹ä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">ç¦»å¼€</button>
        </div>
      </div>
    </div>

    <!-- ä½¿ç”¨å¡ç‰Œé€‰æ‹©å¼¹çª— -->
    <div id="use-card-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div class="bg-gradient-to-b from-indigo-900 to-purple-900 p-6 rounded-2xl shadow-2xl max-w-2xl w-full border-4 border-indigo-400 relative">
        <div class="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-indigo-500 text-white px-6 py-1 rounded-full font-bold shadow-lg">ğŸƒ é€‰æ‹©è¦ä½¿ç”¨çš„å¡ç‰Œ</div>
        <div id="use-card-list" class="flex flex-wrap gap-3 justify-center mt-6 mb-4">
          <!-- å¡ç‰Œä¼šåŠ¨æ€æ’å…¥ -->
        </div>
        <div class="flex gap-3">
          <button onclick="game.closeUseCardModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg transition">å–æ¶ˆ</button>
        </div>
      </div>
    </div>

    <!-- ç©å®¶è¯¦æƒ…å¼¹çª— -->
    <div id="player-detail-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50">
      <div id="player-detail-content" class="bg-gradient-to-b from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative">
        <button onclick="game.closePlayerDetailModal()" class="absolute top-3 right-3 text-white/70 hover:text-white text-xl">âœ•</button>
        <div class="flex items-center gap-3 mb-4">
          <div id="player-detail-color" class="w-8 h-8 rounded-full"></div>
          <h3 id="player-detail-name" class="text-2xl font-bold text-white"></h3>
          <span id="player-detail-binbougami" class="hidden text-2xl binbougami-indicator">ğŸ‘»</span>
        </div>
        <div class="space-y-3">
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ’° ç°é‡‘</span>
            <span id="player-detail-money" class="text-xl font-bold text-yellow-300">Â¥0</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ  èµ„äº§</span>
            <span id="player-detail-assets" class="text-lg text-green-300">Â¥0</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸ“ è·ç›®çš„åœ°</span>
            <span id="player-detail-distance" class="text-lg text-cyan-300">--</span>
          </div>
          <div class="flex justify-between items-center text-white">
            <span class="text-gray-400">ğŸƒ å¡ç‰Œ</span>
            <span id="player-detail-cards" class="text-lg text-amber-300">0</span>
          </div>
        </div>
        <button onclick="game.closePlayerDetailModal(); game.focusOnPlayer(game.currentDetailPlayer)" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition">
          ğŸ“ å®šä½åˆ°ç©å®¶
        </button>
      </div>
    </div>

    <!-- åŸå¸‚ä¿¡æ¯é¢æ¿ -->
    <div id="city-info-modal" class="modal fixed inset-0 flex items-center justify-center hidden z-50 bg-black/70 p-4">
      <div class="bg-white rounded-2xl shadow-2xl w-full h-5/6 max-w-2xl md:max-w-4xl lg:max-w-6xl flex flex-col relative">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-4 md:p-6 rounded-t-2xl flex justify-between items-center gap-4">
          <div class="min-w-0">
            <h2 class="text-2xl md:text-4xl font-bold truncate" id="city-info-title">åŸå¸‚ä¿¡æ¯</h2>
            <p class="text-blue-100 text-xs md:text-sm mt-1 truncate" id="city-info-subtitle"></p>
          </div>
          <button onclick="game.closeCityInfoModal()" class="text-white hover:bg-white/20 rounded-full p-2 text-xl md:text-2xl flex-shrink-0">âœ•</button>
        </div>

        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 bg-gray-50 overflow-x-auto">
          <button class="city-info-tab flex-1 min-w-max py-3 md:py-4 px-4 md:px-6 text-sm md:text-lg font-bold text-center cursor-pointer border-b-4 border-blue-600 text-blue-600 transition whitespace-nowrap" data-tab="properties">
            ğŸ  åœ°äº§ä¸å»ºç­‘
          </button>
          <button class="city-info-tab flex-1 min-w-max py-3 md:py-4 px-4 md:px-6 text-sm md:text-lg font-bold text-center cursor-pointer border-b-4 border-transparent text-gray-600 hover:text-gray-800 transition whitespace-nowrap" data-tab="info">
            ğŸ“– åŸå¸‚ä¿¡æ¯
          </button>
        </div>

        <!-- Content Area -->
        <div class="flex-1 overflow-y-auto">
          <!-- Properties Tab (merged with buildings) -->
          <div id="city-info-properties-tab" class="city-info-tab-content p-4 md:p-8">
            <!-- Player Money Display -->
            <div class="mb-6 bg-gradient-to-r from-yellow-50 to-orange-50 p-4 rounded-lg border-2 border-yellow-200">
              <p class="text-center text-lg md:text-xl font-bold text-gray-800">
                ğŸ’° æŒæœ‰èµ„é‡‘: <span class="text-yellow-600" id="city-info-player-money">0</span> å…ƒ
              </p>
            </div>
            
            <!-- Destination indicator -->
            <div id="city-info-dest-indicator" class="mb-4 bg-yellow-100 text-center py-2 px-4 rounded-full text-sm font-bold text-yellow-700 border-2 border-yellow-400 hidden">
              ğŸ¯ å½“å‰ç›®çš„åœ°ï¼
            </div>
            
            <!-- Combined Properties & Buildings List -->
            <div id="city-info-properties-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
              <!-- Combined property and building cards injected here -->
            </div>
            <div id="city-info-empty-properties" class="text-center text-gray-500 py-12 col-span-full">
              <p class="text-xl md:text-2xl">æš‚æ— åœ°äº§ä¸å»ºç­‘ ğŸœï¸</p>
            </div>
            
            <!-- Monopoly hint -->
            <div class="mt-6 bg-purple-50 p-4 rounded-lg border-2 border-purple-200 text-center">
              <p class="text-sm md:text-base text-purple-700 font-bold">
                <span id="city-info-monopoly-hint">ğŸ’¡ ä¹°é½3ç§ç‰©ä»¶å¯è·å¾—ç‹¬å åŠ æˆ(æ”¶ç›Šx2)</span>
              </p>
            </div>
          </div>

          <!-- Info Tab -->
          <div id="city-info-info-tab" class="city-info-tab-content hidden p-4 md:p-8 overflow-x-hidden">
            <div id="city-llm-content" class="prose prose-sm md:prose-lg max-w-none">
              <div class="flex items-center justify-center py-12">
                <div class="text-center">
                  <div class="animate-spin text-4xl mb-4">â³</div>
                  <p class="text-gray-500 text-lg md:text-xl">æ­£åœ¨åŠ è½½åŸå¸‚ä¿¡æ¯...</p>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Footer -->
        <div class="border-t border-gray-200 bg-gray-50 p-4 md:p-6 rounded-b-2xl flex justify-end gap-2 md:gap-4">
          <button onclick="game.closeCityInfoModal()" class="px-4 md:px-8 py-2 md:py-3 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold rounded-lg transition text-sm md:text-base">
            å…³é—­
          </button>
        </div>
      </div>
    </div>

    <script>
      /**
       * DiceAnimation - 3Déª°å­åŠ¨ç”»ç±»
       * ä» dice_roller_3d.html ç§»æ¤çš„å®Œæ•´éª°å­åŠ¨ç”»
       */
      class DiceAnimation {
        constructor() {
          this.modal = document.getElementById('dice-modal');
          this.stage = document.getElementById('dice-stage');
          this.camera = document.getElementById('dice-camera');
          this.resultEl = document.getElementById('dice-result');
          this.resultValueEl = document.getElementById('dice-result-value');
          
          this.isRolling = false;
          this.duration = 1200; // Animation duration in ms
          
          // Target rotations for each dice face (which face lands up)
          this.targetRotations = {
            1: { x: -90, y: 0, z: 0 },
            2: { x: 0, y: 0, z: 0 },
            3: { x: 0, y: 0, z: -90 },
            4: { x: 0, y: 0, z: 90 },
            5: { x: 180, y: 0, z: 0 },
            6: { x: 90, y: 0, z: 0 },
          };
          
          // Dot positions for each face value (0-8 grid positions)
          this.dotMap = {
            1: [4],
            2: [0, 8],
            3: [0, 4, 8],
            4: [0, 2, 6, 8],
            5: [0, 2, 4, 6, 8],
            6: [0, 2, 3, 5, 6, 8]
          };
        }
        
        /**
         * Create HTML for a single dice face
         * @param {number} number - Face value (1-6)
         * @returns {string} HTML string
         */
        _createFaceHTML(number) {
          const activeDots = this.dotMap[number] || [];
          let dotsHTML = '';
          for (let i = 0; i < 9; i++) {
            if (activeDots.includes(i)) {
              dotsHTML += `<div class="die-dot" style="grid-area: ${Math.floor(i / 3) + 1} / ${(i % 3) + 1}"></div>`;
            }
          }
          return `<div class="die-face die-face-${number}">${dotsHTML}</div>`;
        }
        
        /**
         * Render dice elements
         * @param {number} count - Number of dice
         */
        _renderDice(count) {
          this.camera.innerHTML = '';
          const spacing = 20;
          
          for (let i = 0; i < count; i++) {
            const dieWrapper = document.createElement('div');
            dieWrapper.className = 'die-wrapper';
            dieWrapper.style.transform = `translate3d(${i * spacing}px, 0, ${i * -spacing}px)`;
            
            const die = document.createElement('div');
            die.className = 'die';
            die.dataset.index = i;
            
            // Create all 6 faces
            let facesHTML = '';
            [1, 6, 2, 5, 3, 4].forEach(n => facesHTML += this._createFaceHTML(n));
            die.innerHTML = facesHTML;
            
            dieWrapper.appendChild(die);
            
            // Add shadow
            const shadow = document.createElement('div');
            shadow.className = 'die-shadow';
            dieWrapper.appendChild(shadow);
            
            this.camera.appendChild(dieWrapper);
          }
        }
        
        /**
         * Generate random result for a single die
         * @returns {Object} Result with value and rotation angles
         */
        _generateResult() {
          const val = Math.ceil(Math.random() * 6);
          const base = this.targetRotations[val];
          const spins = 2 + Math.floor(Math.random() * 3);
          
          return {
            value: val,
            x: base.x + (spins * 360),
            y: base.y + (Math.floor(Math.random() * 2) * 360),
            z: base.z + (spins * 360)
          };
        }
        
        /**
         * Roll dice with animation
         * @param {number} diceCount - Number of dice to roll
         * @returns {Promise<{results: number[], total: number}>}
         */
        roll(diceCount = 1) {
          return new Promise((resolve) => {
            if (this.isRolling) {
              resolve({ results: [], total: 0 });
              return;
            }
            
            this.isRolling = true;
            
            // Render dice
            this._renderDice(diceCount);
            
            // Show modal
            this.modal.classList.add('show');
            this.resultEl.classList.remove('show');
            
            // Reset and trigger fly-in animation
            this.stage.classList.remove('entering');
            void this.stage.offsetWidth; // Force reflow
            this.stage.classList.add('entering');
            
            // Generate results
            const results = [];
            let total = 0;
            for (let i = 0; i < diceCount; i++) {
              const res = this._generateResult();
              results.push(res);
              total += res.value;
            }
            
            // Apply rotation animations
            const diceEls = this.camera.querySelectorAll('.die');
            const easing = "cubic-bezier(0.1, 0.9, 0.2, 1)";
            
            diceEls.forEach((die, idx) => {
              const target = results[idx];
              die.style.transition = `transform ${this.duration}ms ${easing}`;
              die.style.transform = `rotateX(${target.x}deg) rotateY(${target.y}deg) rotateZ(${target.z}deg)`;
            });
            
            // Show result after animation
            setTimeout(() => {
              this.resultValueEl.textContent = total;
              this.resultEl.classList.add('show');
            }, this.duration);
            
            // Hide modal and resolve after showing result
            setTimeout(() => {
              this.isRolling = false;
              this.modal.classList.remove('show');
              this.stage.classList.remove('entering');
              
              resolve({ 
                results: results.map(r => r.value), 
                total: total 
              });
            }, this.duration + 800);
          });
        }
        
        /**
         * Set animation duration
         * @param {number} ms - Duration in milliseconds
         */
        setDuration(ms) {
          this.duration = Math.max(500, ms);
        }
      }

      // Create global dice animation instance
      const diceAnimation = new DiceAnimation();

      /**
       * 3D Metro Tycoon Game Engine (Three.js Edition)
       */

      // --- Constants & Config ---
      const TILE_SIZE = 4; // World unit size for a tile
      const TILE_SPACING = 0.2; // Gap between tiles
      const COLORS = {
        bg: 0x87ceeb, // Sky Blue
        ground: 0x1a1a20,

        // Tile Materials
        blue: 0x3b82f6, // Money +
        red: 0xef4444, // Money -
        yellow: 0xeab308, // Event
        green: 0x22c55e, // Station
        start: 0xffffff, // Start

        road: 0x9ca3af, // Plain Road
        env_nature: 0x15803d, // Nature
        env_culture: 0x52525b, // Culture

        // Buildings
        building: [0x60a5fa, 0x818cf8, 0xa78bfa],
      };

      const BUILDING_COSTS = [1000, 5000, 20000];
      const BUILDING_NAMES = ["æ‹‰é¢æ‘Š", "å•†åŠ¡é…’åº—", "æ‘©å¤©å¤§æ¥¼"];
      const BUILDING_INCOME = [200, 800, 4000];

      // ç›®çš„åœ°å¥–åŠ±é‡‘é¢
      const DESTINATION_REWARD = 5000;

      // æˆ¿äº§ç›¸å…³å¸¸é‡
      const PROPERTY_PRICE_RANGE = [3000, 8000]; // æˆ¿äº§ä»·æ ¼èŒƒå›´
      const INITIAL_PLAYER_MONEY = 30000; // ç©å®¶åˆå§‹èµ„é‡‘

      // --- ç©·ç¥ç³»ç»Ÿ ---
      const BINBOUGAMI_EFFECTS = {
        // æ™®é€šç©·ç¥æ•ˆæœ
        normal: [
          { type: "loseMoney", min: 300, max: 1500, msg: "ç©·ç¥å·èµ°äº†ä½ çš„é’±ï¼" },
          { type: "loseMoney", min: 500, max: 2000, msg: "ç©·ç¥è¯·å®¢åƒé¥­ï¼Œç”¨çš„æ˜¯ä½ çš„é’±ï¼" },
          { type: "sellProperty", msg: "ç©·ç¥å¼ºè¡ŒåŠä»·å–æ‰äº†ä½ çš„ç‰©ä»¶ï¼" },
          { type: "nothing", msg: "ç©·ç¥ä»Šå¤©å¿ƒæƒ…å¥½ï¼Œæ”¾è¿‡ä½ äº†~" },
          { type: "loseMoney", min: 200, max: 800, msg: "ç©·ç¥æ‰“ç¢äº†ä½ çš„å­˜é’±ç½ï¼" },
        ],
        // å¤§é­”ç‹ç©·ç¥æ•ˆæœï¼ˆå‡çº§åï¼‰
        king: [
          { type: "loseMoney", min: 2000, max: 5000, msg: "å¤§é­”ç‹ç©·ç¥ç–¯ç‹‚åå™¬ä½ çš„è´¢äº§ï¼" },
          { type: "sellAllProperty", msg: "å¤§é­”ç‹ç©·ç¥åå™¬äº†ä½ æ‰€æœ‰çš„ç‰©ä»¶ï¼" },
          { type: "debt", min: 3000, max: 8000, msg: "å¤§é­”ç‹ç©·ç¥è®©ä½ èƒŒä¸Šå·¨é¢å€ºåŠ¡ï¼" },
          { type: "loseMoney", min: 1500, max: 4000, msg: "å¤§é­”ç‹ç©·ç¥å¬å¼€è±ªåå®´ä¼šï¼Œè´¦å•ç»™ä½ ï¼" },
        ],
      };
      // ç©·ç¥å‡çº§æ‰€éœ€çš„å›åˆæ•°
      const BINBOUGAMI_UPGRADE_TURNS = 8;

      // --- å¡ç‰Œç³»ç»Ÿ ---
      const CARD_TYPES = {
        // ç§»åŠ¨ç±»å¡ç‰Œ
        express: { name: "æ€¥è¡Œå¡", desc: "æ·2ä¸ªéª°å­", icon: "ğŸšƒ", type: "move", diceCount: 2, rarity: "common", price: 500 },
        superExpress: { name: "ç‰¹æ€¥å¡", desc: "æ·3ä¸ªéª°å­", icon: "ğŸš„", type: "move", diceCount: 3, rarity: "rare", price: 1500 },
        rocket: { name: "ç«ç®­å¡", desc: "æ·4ä¸ªéª°å­", icon: "ğŸš€", type: "move", diceCount: 4, rarity: "epic", price: 3000 },
        backward: { name: "åé€€å¡", desc: "å¯ä»¥å‘åç§»åŠ¨", icon: "âª", type: "special", effect: "backward", rarity: "common", price: 300 },
        teleport: { name: "ä»»æ„é—¨", desc: "ä¼ é€åˆ°ä»»æ„è½¦ç«™", icon: "ğŸšª", type: "special", effect: "teleport", rarity: "legendary", price: 5000 },

        // æ”»å‡»/å¦¨ç¢ç±»å¡ç‰Œ
        hibernate: { name: "å†¬çœ å¡", desc: "è®©å¯¹æ‰‹åœ1å›åˆ", icon: "ğŸ’¤", type: "attack", effect: "skip", rarity: "rare", price: 1200 },
        fart: { name: "æ”¾å±å¡", desc: "å¹é£å¯¹æ‰‹1-3æ ¼", icon: "ğŸ’¨", type: "attack", effect: "blowAway", rarity: "common", price: 600 },
        trap: { name: "é™·é˜±å¡", desc: "åœ¨å½“å‰æ ¼å­è®¾ç½®é™·é˜±", icon: "ğŸ•³ï¸", type: "attack", effect: "trap", rarity: "rare", price: 800 },

        // é˜²å¾¡/ç‰¹æ®Šç±»å¡ç‰Œ
        shield: { name: "æŠ¤èº«ç¬¦", desc: "å…ç–«ä¸€æ¬¡ç©·ç¥æ•ˆæœ", icon: "ğŸ›¡ï¸", type: "defense", effect: "immunity", rarity: "rare", price: 2000 },
        exorcism: { name: "é©±é­”ç¬¦", desc: "ç«‹å³é©±é™¤ç©·ç¥", icon: "ğŸ“¿", type: "special", effect: "exorcise", rarity: "epic", price: 4000 },
        doubleIncome: { name: "å€æ”¶å¡", desc: "ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€", icon: "ğŸ’", type: "buff", effect: "doubleIncome", rarity: "epic", price: 3500 },
      };

      // å¡ç‰ŒæŠ½å–æ± ï¼ˆæŒ‰ç¨€æœ‰åº¦åˆ†ç±»ï¼‰
      const CARD_POOL = {
        common: ["express", "backward", "fart"],
        rare: ["superExpress", "hibernate", "trap", "shield"],
        epic: ["rocket", "exorcism", "doubleIncome"],
        legendary: ["teleport"],
      };

      // æœ€å¤§æ‰‹ç‰Œæ•°
      const MAX_HAND_SIZE = 8;
      // ä¸€å¹´çš„å›åˆæ•°ï¼ˆæ¯æœˆä¸€å›åˆï¼Œ12å›åˆ=1å¹´ï¼Œ3æœˆå†³ç®—ï¼‰
      const TURNS_PER_YEAR = 12;
      const SETTLEMENT_MONTH = 3; // 3æœˆå†³ç®—

      // æˆ¿äº§ç¼“å­˜ç³»ç»Ÿ - è¿½è¸ªæˆ¿äº§çš„è´­ä¹°çŠ¶æ€
      const PROPERTIES_CACHE = {};
      function initializePropertiesCache() {
        PROPERTIES_CACHE.homes = {}; // æŒ‰åŸå¸‚å­˜å‚¨æˆ¿äº§: { cityName: [homes...] }
      }
      function getOrCreatePropertyId(cityName, propertyIndex) {
        if (!PROPERTIES_CACHE.homes[cityName]) {
          PROPERTIES_CACHE.homes[cityName] = [];
        }
        const key = `${cityName}_${propertyIndex}`;
        if (!PROPERTIES_CACHE.homes[cityName][propertyIndex]) {
          PROPERTIES_CACHE.homes[cityName][propertyIndex] = {
            id: key,
            cityName: cityName,
            index: propertyIndex,
            purchasedBy: null, // è´­ä¹°è€…çš„ç©å®¶IDï¼Œnullè¡¨ç¤ºæœªè´­ä¹°
            purchasePrice: null
          };
        }
        return PROPERTIES_CACHE.homes[cityName][propertyIndex];
      }

      // Station data loaded from world_traveler_map_data (full city info with lat/lng/population)
      let STATION_DATA = [];
      // Station names (extracted from STATION_DATA for backward compatibility)
      let STATION_NAMES = [];

      // --- Utilities ---
      const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const wait = (ms) => new Promise((r) => setTimeout(r, ms));

      // Home city - always shown on map in green
      let homeCity = "æ·±åœ³";

      // Global toast function for notifications
      function showToast(msg, color = "white") {
        const logEl = document.getElementById("game-log");
        const entry = document.createElement("div");
        entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
        logEl.appendChild(entry);
        if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
        setTimeout(() => {
          entry.style.opacity = "0";
          setTimeout(() => entry.remove(), 500);
        }, 4000);
      }

      // --- Load World Map Data from External File ---
      let CITIES = [];
      let CONTINENTS = {}; // continents loaded from data file (if any)

      async function loadCitiesData() {
        // Fallback default cities
        const defaultCities = [
          { name: "æ·±åœ³", lat: 22.5431, lon: 114.0579, population: 12590000, level: 1 },
          { name: "ä¸œäº¬", lat: 35.6762, lon: 139.6503, population: 13960000, level: 1 },
        ];

        try {
          const response = await fetch("world_traveler_data");
          const text = await response.text();

          // Extract JSON array from markdown (between [ and ])
          // The data file may either be a JSON array (legacy) or a JSON object with { cities: [], continents: {} }
          const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
          if (jsonMatch) {
            // Clean up the JSON text: remove comments
            const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, "");
            const parsed = JSON.parse(jsonText);
            if (Array.isArray(parsed)) {
              CITIES = parsed;
              CONTINENTS = {};
            } else {
              CITIES = parsed.cities || defaultCities;
              CONTINENTS = parsed.continents || {};
            }
            console.log(`Loaded ${CITIES.length} cities from world_traveler_data.md`);
          } else {
            console.error("Could not parse cities data from world_traveler_data.md");
            CITIES = defaultCities;
          }
        } catch (error) {
          console.error("Error loading cities data:", error);
          CITIES = defaultCities;
        }
      }

      // --- Load Station Data from External File ---
      async function loadStationData() {
        // Fallback default station data
        const defaultStations = [
          { name: "æ·±åœ³ - ç¦ç”°åŒº", lat: 22.5431, lng: 114.0579, population: 1553200, level: 1 },
          { name: "æ·±åœ³ - å—å±±åŒº", lat: 22.5229, lng: 113.9294, population: 1795800, level: 1 },
          { name: "æ·±åœ³ - ç½—æ¹–åŒº", lat: 22.5478, lng: 114.1316, population: 1143800, level: 2 },
          { name: "å¹¿å· - å¤©æ²³åŒº", lat: 23.1343, lng: 113.3603, population: 2241800, level: 1 },
          { name: "å¹¿å· - è¶Šç§€åŒº", lat: 23.1291, lng: 113.2644, population: 1038600, level: 1 }
        ];

        try {
          const response = await fetch("world_traveler_map_data");
          const text = await response.text();

          // Extract JSON from file (can be array or object with cities property)
          const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
          if (jsonMatch) {
            // Clean up the JSON text: remove comments
            const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, "");
            const parsed = JSON.parse(jsonText);
            
            let cities = [];
            if (Array.isArray(parsed)) {
              cities = parsed;
            } else if (parsed.cities) {
              cities = parsed.cities;
            }

            // Store full city data
            if (cities.length > 0) {
              STATION_DATA = cities;
              STATION_NAMES = cities.map(city => city.name);
              console.log(`Loaded ${STATION_DATA.length} stations from world_traveler_map_data`);
            } else {
              console.error("No cities found in world_traveler_map_data");
              STATION_DATA = defaultStations;
              STATION_NAMES = defaultStations.map(s => s.name);
            }
          } else {
            console.error("Could not parse station data from world_traveler_map_data");
            STATION_DATA = defaultStations;
            STATION_NAMES = defaultStations.map(s => s.name);
          }
        } catch (error) {
          console.error("Error loading station data:", error);
          STATION_DATA = defaultStations;
          STATION_NAMES = defaultStations.map(s => s.name);
        }
      }

      // --- World Map Class ---
      class WorldMapManager {
        constructor(game) {
          this.game = game;
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x000000);
          this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

          // Center camera on initial location with zoom to show level 1 and 2
          const initialLat = 25;
          const initialLon = 105;
          const cameraDistance = 28; // Close enough to show level 2 (threshold is 35)
          const phi = (90 - initialLat) * (Math.PI / 180);
          const theta = (initialLon + 180) * (Math.PI / 180);
          const camX = -(cameraDistance * Math.sin(phi) * Math.cos(theta));
          const camZ = cameraDistance * Math.sin(phi) * Math.sin(theta);
          const camY = cameraDistance * Math.cos(phi);
          this.camera.position.set(camX, camY, camZ);

          this.group = new THREE.Group();
          this.scene.add(this.group);

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();

          this.cities = [];
          this.planes = []; // active plane animations
          this.controls = new THREE.OrbitControls(this.camera, this.game.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 15;
          this.controls.maxDistance = 60;
          this.controls.enablePan = false;

          this.autoRotate = true;
          this.clock = new THREE.Clock();
          this.cameraRestoreAnim = null; // {fromPos, toPos, fromTarget, toTarget, t, duration}
          this.init();
        }

        init() {
          // Earth Sphere
          const geometry = new THREE.SphereGeometry(10, 64, 64);
          const material = new THREE.MeshPhongMaterial({
            color: 0x1a237e,
            emissive: 0x112244,
            specular: 0x111111,
            shininess: 10,
          });
          this.earth = new THREE.Mesh(geometry, material);
          this.group.add(this.earth);

          // Atmosphere glow
          const atmGeo = new THREE.SphereGeometry(10.2, 64, 64);
          const atmMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide });
          this.group.add(new THREE.Mesh(atmGeo, atmMat));

          // Lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          this.scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 1);
          dirLight.position.set(50, 30, 50);
          this.scene.add(dirLight);

          // Event Listeners
          // Use pointer events for better mobile support
          const canvas = this.game.renderer.domElement;
          let downX = 0;
          let downY = 0;

          canvas.addEventListener("pointerdown", (e) => {
            downX = e.clientX;
            downY = e.clientY;
            // Stop auto-rotation when user starts interacting
            this.autoRotate = false;
          });

          canvas.addEventListener("pointerup", (e) => {
            const moveDist = Math.sqrt(Math.pow(e.clientX - downX, 2) + Math.pow(e.clientY - downY, 2));
            // Allow small movement (jitter) but filter out drags
            if (moveDist < 10) {
              this.onClick(e);
            }
          });

          // Also stop auto-rotation when OrbitControls detects drag start
          this.controls.addEventListener("start", () => {
            this.autoRotate = false;
          });
        }

        renderMapObjects() {
          this.createContinentOutlines();
          this.createCities();
        }

        // Create continent outline curves on globe
        createContinentOutlines() {
          const radius = 10.05; // Slightly above earth surface
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x44ff88, linewidth: 2, transparent: true, opacity: 0.8 });

          // Continent outline data (simplified lat/lon coordinates)
          const defaultContinents = {
            // äºšæ´² (Asia) - simplified outline
            asia: [
              [66, 170],
              [70, 140],
              [75, 100],
              [70, 70],
              [55, 60],
              [45, 35],
              [35, 35],
              [25, 55],
              [10, 75],
              [8, 80],
              [20, 90],
              [22, 90],
              [25, 95],
              [10, 100],
              [5, 105],
              [1, 104],
              [-8, 110],
              [-8, 115],
              [-5, 120],
              [5, 120],
              [10, 125],
              [20, 120],
              [25, 122],
              [35, 130],
              [40, 130],
              [45, 140],
              [50, 140],
              [55, 160],
              [60, 170],
              [66, 170],
            ],
          };
          const continents = typeof CONTINENTS !== "undefined" && Object.keys(CONTINENTS).length > 0 ? CONTINENTS : defaultContinents;

          // Draw each continent outline
          Object.values(continents).forEach((coords) => {
            const points = [];
            // Create points for each coordinate, with interpolation along sphere surface
            for (let i = 0; i < coords.length; i++) {
              const [lat1, lon1] = coords[i];
              const [lat2, lon2] = coords[(i + 1) % coords.length]; // Wrap to first point for closure

              // Add start point
              points.push(this.latLonToVector3(lat1, lon1, radius));

              // Interpolate points along the great circle to keep lines on sphere surface
              const segments = 5; // Number of intermediate points between each pair
              for (let j = 1; j < segments; j++) {
                const t = j / segments;
                const latInterp = lat1 + (lat2 - lat1) * t;
                const lonInterp = lon1 + (lon2 - lon1) * t;
                points.push(this.latLonToVector3(latInterp, lonInterp, radius));
              }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, lineMaterial);
            this.group.add(line);
          });
        }

        latLonToVector3(lat, lon, radius) {
          const phi = (90 - lat) * (Math.PI / 180);
          const theta = (lon + 180) * (Math.PI / 180);
          const x = -(radius * Math.sin(phi) * Math.cos(theta));
          const z = radius * Math.sin(phi) * Math.sin(theta);
          const y = radius * Math.cos(phi);
          return new THREE.Vector3(x, y, z);
        }

        createCities() {
          // Sort cities by population (descending) - higher population has priority
          const sortedCities = [...CITIES].sort((a, b) => b.population - a.population);

          // Initialize city positions
          const cityData = sortedCities.map((city) => ({
            city,
            pos: this.latLonToVector3(city.lat, city.lon, 10),
            mass: city.population, // Use population as mass
          }));

          const minMarkerDistance = 0.5; // Minimum distance between markers on sphere
          const maxIterations = 50; // Max iterations for separation

          // Iteratively separate overlapping markers using mass-based repulsion
          for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;

            for (let i = 0; i < cityData.length; i++) {
              for (let j = i + 1; j < cityData.length; j++) {
                const a = cityData[i];
                const b = cityData[j];
                const dist = a.pos.distanceTo(b.pos);

                if (dist < minMarkerDistance && dist > 0.001) {
                  hasOverlap = true;

                  // Calculate repulsion direction (from a to b)
                  const direction = new THREE.Vector3().subVectors(b.pos, a.pos).normalize();

                  // Calculate displacement based on mass ratio
                  // Heavier (more population) moves less
                  const totalMass = a.mass + b.mass;
                  const overlap = minMarkerDistance - dist;
                  const moveA = overlap * (b.mass / totalMass); // Lighter moves more
                  const moveB = overlap * (a.mass / totalMass);

                  // Move positions apart along sphere surface
                  a.pos.addScaledVector(direction, -moveA);
                  b.pos.addScaledVector(direction, moveB);

                  // Re-project onto sphere surface (radius = 10)
                  a.pos.normalize().multiplyScalar(10);
                  b.pos.normalize().multiplyScalar(10);
                }
              }
            }

            if (!hasOverlap) break;
          }

          // Create markers and labels
          cityData.forEach(({ city, pos }) => {
            // Marker size based on level
            const markerSize = city.level === 1 ? 0.25 : city.level === 2 ? 0.18 : 0.12;
            const markerGeo = new THREE.SphereGeometry(markerSize, 16, 16);

            // Color based on level and home city
            let color;
            if (city.name === homeCity) {
              color = 0x00ff00; // Green for home city
            } else if (city.level === 1) {
              color = 0xffaa00; // Orange for level 1
            } else if (city.level === 2) {
              color = 0x88aaff; // Light blue for level 2
            } else {
              color = 0xaaaaaa; // Gray for level 3
            }

            const markerMat = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(pos);
            marker.userData = { city: city };
            this.group.add(marker);

            // Simple Label (using Sprite) - size based on population/level
            const canvas = document.createElement("canvas");
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext("2d");
            const fontSize = city.level === 1 ? 28 : city.level === 2 ? 22 : 18;
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = city.level === 1 ? "#ffffff" : city.level === 2 ? "#ccddff" : "#999999";
            context.textAlign = "center";
            context.fillText(city.name, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);

            // Position label above marker
            const labelPos = pos.clone().normalize().multiplyScalar(10.5);
            sprite.position.copy(labelPos);

            // Scale based on level
            const spriteScale = city.level === 1 ? 2.5 : city.level === 2 ? 2.0 : 1.5;
            sprite.scale.set(spriteScale, spriteScale * 0.25, 1);

            this.group.add(sprite);

            this.cities.push({ marker, sprite, data: city, basePos: pos.clone() });
          });
        }

        onClick(event) {
          if (this.game.mode !== "MAP") return;
          // ignore clicks while a plane is animating so user cannot start multiple flights
          if (this.planes && this.planes.length > 0) return;

          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          // Filter out undefined/null markers and only include visible ones
          const markers = this.cities
            .map((c) => c.marker)
            .filter((marker) => marker && marker.visible);
          
          // Add safety check to prevent hanging on empty or invalid marker list
          if (!markers || markers.length === 0) return;

          try {
            const intersects = this.raycaster.intersectObjects(markers);

            if (intersects.length > 0) {
              const city = intersects[0].object.userData.city;
              this.game.travelToCity(city);
            }
          } catch (e) {
            console.error("Error during raycasting:", e);
          }
        }

        update() {
          this.controls.update();

          if (this.autoRotate) {
            this.group.rotation.y += 0.001;
          }

          // Level of Detail logic based on zoom distance
          const dist = this.camera.position.distanceTo(new THREE.Vector3(0, 0, 0));

          // Zoom thresholds for showing different levels
          const showLevel2 = dist < 35; // Show level 2 when closer
          const showLevel3 = dist < 22; // Show level 3 when even closer

          // Collect visible labels for overlap detection
          const visibleLabels = [];

          // First pass: determine visibility based on level
          this.cities.forEach((c) => {
            const level = c.data.level || 1;
            const isHomeCity = c.data.name === homeCity;
            let shouldShowByLevel = false;

            if (isHomeCity || level === 1) {
              shouldShowByLevel = true; // Always show home city and level 1
            } else if (level === 2) {
              shouldShowByLevel = showLevel2;
            } else if (level === 3) {
              shouldShowByLevel = showLevel3;
            }

            // Check if in front of camera using dot product (more stable than screenZ)
            const cameraPos = this.camera.position.clone().normalize();
            const markerDir = c.marker.position.clone().normalize();
            const dotProduct = markerDir.dot(cameraPos);
            const isFrontFacing = dotProduct > -0.1; // Visible if on front hemisphere

            const shouldShow = shouldShowByLevel && isFrontFacing;

            c.marker.visible = shouldShow;
            c.sprite.visible = false; // Default to hidden, will be shown in overlap pass
            c.potentiallyVisible = shouldShow;

            if (shouldShow) {
              // Calculate screen position for overlap detection
              const screenPos = c.marker.position.clone().project(this.camera);
              c.screenX = ((screenPos.x + 1) / 2) * window.innerWidth;
              c.screenY = ((-screenPos.y + 1) / 2) * window.innerHeight;

              visibleLabels.push(c);
            }
          });

          // Sort by population (higher population has priority for label display)
          visibleLabels.sort((a, b) => b.data.population - a.data.population);

          // Second pass: show non-overlapping labels (keep higher population visible)
          const labelRadius = 50; // Approximate label radius in screen pixels
          const shownLabels = [];

          visibleLabels.forEach((c) => {
            let hasOverlap = false;

            for (const shown of shownLabels) {
              const dx = c.screenX - shown.screenX;
              const dy = c.screenY - shown.screenY;
              const screenDist = Math.sqrt(dx * dx + dy * dy);

              // Smaller overlap threshold for higher level cities
              const minDist = labelRadius * (c.data.level === 1 ? 1.2 : c.data.level === 2 ? 1.0 : 0.8);

              if (screenDist < minDist) {
                hasOverlap = true;
                break;
              }
            }

            if (!hasOverlap) {
              c.sprite.visible = true;
              shownLabels.push(c);
            }
          });

          // Update plane animations
          if (this.planes && this.planes.length > 0) {
            const toRemove = [];
            for (let i = 0; i < this.planes.length; i++) {
              const anim = this.planes[i];
              const mesh = anim.mesh;
              // Basic speed factor based on distance
              const angleBetween = anim.start.clone().normalize().dot(anim.end.clone().normalize());
              const dtheta = Math.acos(THREE.MathUtils.clamp(angleBetween, -1, 1));
              const baseSpeed = 0.002 + 0.01 / (dtheta + 1.0);

              if (anim.state === "takeoff") {
                // scale up and start moving forward slightly
                anim.t += 0.005;
                const s = THREE.MathUtils.lerp(0.01, 0.9, Math.min(1, anim.t / 0.15));
                mesh.scale.set(s, s, s);
                // lift up a bit
                const pos = this.computeGreatCirclePoint(anim.start, anim.end, 0, anim.radius, anim.altitude * 0.2);
                mesh.position.copy(pos);
                mesh.lookAt(this.computeGreatCirclePoint(anim.start, anim.end, 0.05, anim.radius, anim.altitude * 0.2));
                if (anim.t >= 0.15) {
                  anim.state = "cruise";
                  anim.t = 0;
                }
              } else if (anim.state === "cruise") {
                anim.t += baseSpeed;
                const t = Math.min(1, anim.t);
                const pos = this.computeGreatCirclePoint(anim.start, anim.end, t, anim.radius, anim.altitude);
                mesh.position.copy(pos);
                // bigger plane in cruise
                mesh.scale.set(1.4, 1.4, 1.4);
                const lookAheadT = Math.min(1, t + 0.02);
                const aheadPos = this.computeGreatCirclePoint(anim.start, anim.end, lookAheadT, anim.radius, anim.altitude);
                mesh.lookAt(aheadPos);
                if (t >= 1) {
                  // Arrived at destination; skip circling if loopRounds is 0
                  if (anim.circleRoundsLeft <= 0) {
                    // Skip directly to landing
                    anim.state = "landing";
                    anim.t = 0;
                  } else {
                    // Start circling for specified rounds
                    anim.state = "circle";
                    anim.circleAngle = 0;
                    // Save circle orientation basis
                    anim.center = anim.end.clone().setLength(anim.radius + anim.altitude);
                    // Choose circle radius based on city size (small around 0.8)
                    anim.circleRadius = Math.max(0.6, 0.6);
                    // Orthonormal basis u, v perpendicular to center normal
                    const normal = anim.center.clone().normalize();
                    const arbitrary = new THREE.Vector3(0, 1, 0);
                    if (Math.abs(normal.dot(arbitrary)) > 0.95) arbitrary.set(1, 0, 0);
                    anim.u = new THREE.Vector3().crossVectors(normal, arbitrary).normalize();
                    anim.v = new THREE.Vector3().crossVectors(normal, anim.u).normalize();
                  }
                }
              } else if (anim.state === "circle") {
                // Rotate around destination center
                anim.circleAngle += 0.04; // rotation speed
                const a = anim.circleAngle;
                const pos = anim.center
                  .clone()
                  .add(anim.u.clone().multiplyScalar(Math.cos(a) * anim.circleRadius))
                  .add(anim.v.clone().multiplyScalar(Math.sin(a) * anim.circleRadius));
                mesh.position.copy(pos);
                // point in tangent direction
                const tangent = anim.u
                  .clone()
                  .multiplyScalar(-Math.sin(a) * anim.circleRadius)
                  .add(anim.v.clone().multiplyScalar(Math.cos(a) * anim.circleRadius));
                const lookAt = pos.clone().add(tangent);
                mesh.lookAt(lookAt);
                // When one round complete, start landing
                if (anim.circleAngle >= Math.PI * 2 * anim.circleRoundsLeft) {
                  anim.state = "landing";
                  anim.t = 0;
                }
              } else if (anim.state === "landing") {
                // shrink and move down to surface
                anim.t += 0.03;
                const s = THREE.MathUtils.lerp(mesh.scale.x, 0.02, 0.2);
                mesh.scale.set(s, s, s);
                // move towards end surface
                const current = mesh.position.clone();
                const dirToEnd = anim.end.clone().sub(current).multiplyScalar(0.15);
                mesh.position.add(dirToEnd);
                mesh.lookAt(anim.end);
                // When close to end, remove
                if (mesh.position.distanceTo(anim.end) < 0.08 || mesh.scale.x <= 0.03) {
                  // Trigger completion callback if any
                  if (typeof anim.onComplete === "function") {
                    try {
                      anim.onComplete();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                  // Remove mesh
                  // Remove trail
                  if (anim.trailMesh) {
                    try {
                      this.group.remove(anim.trailMesh);
                    } catch (e) {}
                  }
                  this.group.remove(mesh);
                  // Restore control state but keep the camera at the destination
                  if (this.controls && typeof anim.prevControlsEnabled !== "undefined") {
                    this.controls.enabled = anim.prevControlsEnabled;
                  }
                  // Instead of restoring the previous camera position, honor the desired camera distance
                  // and center the map on the destination (anim.end). This keeps the camera distance
                  // consistent while focusing on the new map location.
                  try {
                    // Determine camera distance to preserve (fallback to current camera length)
                    const preservedDistance = anim.prevCameraLen || this.camera.position.length();
                    // Direction from origin to destination (for final camera radial position)
                    const toDir = anim.end ? anim.end.clone().normalize() : this.camera.position.clone().normalize();
                    const toPos = toDir.clone().multiplyScalar(preservedDistance);

                    // Queue a smooth camera restore animation instead of snapping the camera.
                    this.cameraRestoreAnim = {
                      fromPos: this.camera.position.clone(),
                      toPos: toPos,
                      fromTarget: this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0),
                      toTarget: new THREE.Vector3(0, 0, 0),
                      t: 0,
                      duration: 0.35, // seconds for smooth transition
                    };
                  } catch (e) {}
                  // Hide destination UI indicator
                  try {
                    const indicator = document.getElementById("destination-indicator");
                    if (indicator) indicator.classList.add("hidden");
                  } catch (e) {}
                  toRemove.push(i);
                }
              }
              // Camera follow & trail updates
              if (anim.followCamera && mesh) {
                // Camera zoom during takeoff
                if (anim.state === "takeoff") {
                  anim.zoomInT = Math.min(1, anim.zoomInT + anim.zoomSpeed);
                  const camLen = THREE.MathUtils.lerp(anim.prevCameraLen, anim.zoomInDistance, anim.zoomInT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.25);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.25);
                  if (this.controls) this.controls.update();
                } else if (anim.state === "cruise") {
                  // Zoom out smoothly to cruise distance
                  anim.zoomOutT = Math.min(1, anim.zoomOutT + anim.zoomSpeed * 0.25);
                  const camLen = THREE.MathUtils.lerp(anim.zoomInDistance, anim.zoomOutDistance, anim.zoomOutT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.12);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.12);
                  if (this.controls) this.controls.update();
                  // Update trail when cruising
                  if (anim.trailMesh) {
                    anim.trailPoints.push(mesh.position.clone());
                    if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                    anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                    try {
                      anim.trailMesh.computeLineDistances();
                    } catch (e) {}
                    anim.trailMesh.visible = true;
                  }
                } else if (anim.state === "circle") {
                  // As the plane circles before landing, start zooming in to landing distance
                  const shouldZoomIn = anim.circleRoundsLeft <= 1;
                  if (shouldZoomIn) {
                    anim.zoomLandingT = Math.min(1, anim.zoomLandingT + anim.zoomLandingSpeed);
                  } else {
                    // slowly decay to avoid abrupt camera jumps if there are multiple circles
                    anim.zoomLandingT = Math.max(0, anim.zoomLandingT - anim.zoomLandingSpeed * 0.5);
                  }
                  const camLen = THREE.MathUtils.lerp(anim.zoomOutDistance, anim.zoomLandingDistance, anim.zoomLandingT);
                  const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                  this.camera.position.lerp(targetCamPos, 0.18);
                  if (this.controls) this.controls.target.lerp(mesh.position, 0.18);
                  if (this.controls) this.controls.update();
                  // Update trail when circling
                  if (anim.trailMesh) {
                    anim.trailPoints.push(mesh.position.clone());
                    if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                    anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                    try {
                      anim.trailMesh.computeLineDistances();
                    } catch (e) {}
                    anim.trailMesh.visible = true;
                  }
                }
              }
            }
            // Remove finished planes from array in reverse order
            for (let r = toRemove.length - 1; r >= 0; r--) {
              this.planes.splice(toRemove[r], 1);
            }
          }

          // Smooth camera restore animation (if queued)
          try {
            const dt = this.clock.getDelta();
            if (this.cameraRestoreAnim) {
              const a = this.cameraRestoreAnim;
              a.t = Math.min(a.duration, a.t + dt);
              const u = Math.min(1, a.t / a.duration);
              // Interpolate camera world position and controls target
              if (a.fromPos && a.toPos) {
                this.camera.position.lerpVectors(a.fromPos, a.toPos, u);
              }
              if (this.controls && a.fromTarget && a.toTarget) {
                this.controls.target.lerpVectors(a.fromTarget, a.toTarget, u);
                this.controls.update();
              }
              if (u >= 1) {
                this.cameraRestoreAnim = null;
              }
            }
          } catch (e) {}
        }

        // --- Plane animation helpers ---
        createPlaneMesh() {
          // Simple stylized plane mesh: a small group with body and wings
          const group = new THREE.Group();

          const body = new THREE.BoxGeometry(0.5, 0.12, 0.8);
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffee88 });
          const bodyMesh = new THREE.Mesh(body, bodyMat);
          group.add(bodyMesh);

          const wingGeo = new THREE.BoxGeometry(0.9, 0.02, 0.08);
          const wingMat = new THREE.MeshStandardMaterial({ color: 0xdd3333 });
          const wing = new THREE.Mesh(wingGeo, wingMat);
          wing.position.set(0, 0, 0);
          group.add(wing);

          const tailGeo = new THREE.BoxGeometry(0.16, 0.2, 0.02);
          const tailMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
          const tail = new THREE.Mesh(tailGeo, tailMat);
          tail.position.set(-0.28, 0.08, 0);
          group.add(tail);

          // Small shadows and low lighting
          group.scale.set(0.001, 0.001, 0.001); // start from very small
          group.castShadow = true;
          group.receiveShadow = false;
          return group;
        }

        // Compute a point along a great circle between two vectors; r is radius and altitude added
        computeGreatCirclePoint(startVec, endVec, t, radius, altitude) {
          // startVec and endVec are THREE.Vector3 on surface (radius length), we slerp and then lift
          const v0 = startVec.clone().normalize();
          const v1 = endVec.clone().normalize();
          const dot = THREE.MathUtils.clamp(v0.dot(v1), -1, 1);
          const theta = Math.acos(dot);
          if (theta === 0) {
            // Same point
            const final = v0.clone().multiplyScalar(radius + altitude);
            return final;
          }
          const sinTheta = Math.sin(theta);
          const s0 = Math.sin((1 - t) * theta) / sinTheta;
          const s1 = Math.sin(t * theta) / sinTheta;
          const interpolated = v0.multiplyScalar(s0).add(v1.multiplyScalar(s1)).normalize();
          const lift = Math.sin(Math.PI * t) * altitude; // arc-shaped altitude
          return interpolated.multiplyScalar(radius + lift);
        }

        // Main method to play a plane animation from cityAName to cityBName
        flyPlane(
          cityAName,
          cityBName,
          {
            loopRounds = 0,
            altitude = 2.0,
            onComplete = null,
            followCamera = true,
            zoomInDistance = 18,
            zoomOutDistance = 25,
            zoomSpeed = 0.08,
            trailMaxPoints = 64,
            trailColor = 0xffffff,
            zoomLandingDistance = 14,
            zoomLandingSpeed = 0.06,
          } = {}
        ) {
          if (!this.cities || this.cities.length === 0) return;

          const cityA = this.cities.find((c) => c.data.name === cityAName) || this.cities.find((c) => c.data.name === homeCity);
          const cityB = this.cities.find((c) => c.data.name === cityBName) || this.cities.find((c) => c.data.name === homeCity);
          if (!cityA || !cityB) return;

          const startPosSurface = cityA.basePos.clone();
          const endPosSurface = cityB.basePos.clone();

          // Spawn plane
          const plane = this.createPlaneMesh();
          this.group.add(plane);

          const anim = {
            mesh: plane,
            start: startPosSurface
              .clone()
              .normalize()
              .multiplyScalar(10 + 0.01), // just above surface
            end: endPosSurface
              .clone()
              .normalize()
              .multiplyScalar(10 + 0.01),
            t: 0,
            state: "takeoff", // takeoff, cruise, circle, landing
            radius: 10,
            altitude: altitude,
            circleAngle: 0,
            circleRoundsLeft: loopRounds,
            onComplete: onComplete,
          };

          // camera follow options
          anim.followCamera = followCamera;
          anim.zoomInDistance = zoomInDistance;
          anim.zoomOutDistance = zoomOutDistance;
          anim.zoomSpeed = zoomSpeed;
          anim.zoomInT = 0;
          anim.zoomOutT = 0;
          // Landing / circling zoom
          anim.zoomLandingDistance = zoomLandingDistance;
          anim.zoomLandingSpeed = zoomLandingSpeed;
          anim.zoomLandingT = 0;
          anim.prevCameraPos = this.camera.position.clone();
          anim.prevControlsTarget = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
          anim.prevCameraLen = this.camera.position.length();

          // trail initialization (dashed line)
          anim.trailPoints = [];
          anim.trailMaxPoints = trailMaxPoints;
          const trailMat = new THREE.LineDashedMaterial({ color: trailColor, dashSize: 0.25, gapSize: 0.15, scale: 1 });
          const trailGeo = new THREE.BufferGeometry().setFromPoints(anim.trailPoints);
          const trailLine = new THREE.Line(trailGeo, trailMat);
          trailLine.computeLineDistances();
          trailLine.visible = false; // show when cruise begins
          this.group.add(trailLine);
          anim.trailMesh = trailLine;

          // Initialize position at start (tiny -> grow)
          const startWorld = anim.start.clone().setLength(anim.radius + 0.1);
          plane.position.copy(startWorld);
          plane.lookAt(anim.end);
          plane.scale.set(0.01, 0.01, 0.01);

          // Add to active planes
          this.planes.push(anim);
          // Show destination indicator
          try {
            const indicator = document.getElementById("destination-indicator");
            if (indicator) {
              indicator.classList.remove("hidden");
              const nameElem = document.getElementById("indicator-name");
              if (nameElem) nameElem.textContent = cityBName;
            }
          } catch (e) {}
          // Disable interaction while plane is active
          if (this.controls) {
            anim.prevControlsEnabled = this.controls.enabled;
            this.controls.enabled = false;
          }

          // Add a small flag to avoid clicking multiple times
          anim.isAnimating = true;
        }
      }

      // --- Game Classes ---

      class Tile {
        constructor(id, gridX, gridY, type) {
          this.id = id;
          this.gridX = gridX;
          this.gridY = gridY;
          this.type = type;
          this.buildings = [];
          this.owner = null;

          // Station name is set externally from node data after construction
          // Do NOT use hash-based assignment here as it leads to incorrect names
          this.stationName = "";

          this.neighbors = [];
          this.mesh = null; // Three.js Mesh
          this.labelElement = null; // HTML Element for station name
        }

        get isRoad() {
          return !this.type.startsWith("env");
        }

        get isColored() {
          return ["blue", "red", "yellow", "green", "start"].includes(this.type);
        }

        // Helper to get world position based on grid
        get worldPos() {
          return new THREE.Vector3(this.gridX * TILE_SIZE, 0, this.gridY * TILE_SIZE);
        }
      }

      class Player {
        constructor(id, name, color, isAI) {
          this.id = id;
          this.name = name;
          this.color = color;
          this.isAI = isAI;
          this.money = INITIAL_PLAYER_MONEY;
          this.assets = 0;

          this.currentTile = null;
          this.previousTile = null;

          this.mesh = null; // Three.js Mesh (Group)

          // For smooth movement animation
          this.animating = false;
          this.targetPos = new THREE.Vector3();

          // --- ç©·ç¥ç³»ç»Ÿ ---
          this.hasBinbougami = false; // æ˜¯å¦è¢«ç©·ç¥é™„èº«
          this.binbougamiTurns = 0; // ç©·ç¥é™„èº«å›åˆæ•°
          this.binbougamiLevel = 0; // 0=æ™®é€š, 1=å¤§é­”ç‹
          this.binbougamiMesh = null; // ç©·ç¥3Dæ¨¡å‹

          // --- å¡ç‰Œç³»ç»Ÿ ---
          this.cards = []; // æ‰‹ç‰Œ
          this.skipNextTurn = false; // ä¸‹å›åˆæ˜¯å¦è·³è¿‡ï¼ˆå†¬çœ æ•ˆæœï¼‰
          this.doubleIncomeNext = false; // ä¸‹æ¬¡å†³ç®—æ”¶ç›Šç¿»å€
          this.hasShield = false; // æ˜¯å¦æœ‰æŠ¤èº«ç¬¦ä¿æŠ¤
        }
      }

      class Game {
        constructor() {
          this.container = document.getElementById("game-container");
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // Three.js Components
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;

          this.map = [];
          this.players = [];
          this.turn = 0;
          this.state = "INIT";
          this.cameraLocked = true;
          this.isUserInteracting = false;

          // ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ—¶é—´ç³»ç»Ÿï¼ˆå¹´/æœˆï¼‰
          this.gameYear = 1;
          this.gameMonth = 4; // ä»4æœˆå¼€å§‹
          this.totalTurns = 0;

          this.mode = "MAP"; // 'MAP' or 'GAME'
          this.worldMap = null;
          this.currentCity = null;

          // åŸå¸‚ä¿¡æ¯ç¼“å­˜
          this.cityInfoCache = {};
          this.currentCityInfoTile = null;
          this.cityInfoPanelMode = "purchase"; // "purchase" for buying, "view-only" for clicking on map
          
          // Sessionçº§åˆ«çš„åœ°äº§æ˜¾ç¤ºç¼“å­˜ - ä¿å­˜ä¸€å±€æ¸¸æˆä¸­çš„åœ°äº§æ˜¾ç¤ºé¡ºåº
          // ç»“æ„: { cityName: { seed: randomSeed, properties: [list of property indices in order] } }
          this.sessionPropertyCache = {};
          // å·²è´­ä¹°çš„åœ°äº§ç¼“å­˜ - åœ¨sessionä¸­ä¿æŒå›ºå®šæ˜¾ç¤ºåœ¨æœ€å‰
          this.purchasedPropertiesInSession = {}; // { cityName: [list of purchased property indices] }
          
          // Game mode raycaster for tile clicking
          this.gameRaycaster = null;
          this.gameMouse = new THREE.Vector2();

          this.initThree();
          // this.initGame(); // Delayed until city selection

          window.addEventListener("resize", () => this.onResize());
          document.getElementById("roll-btn").onclick = () => this.playerRoll();

          this.initWorldMap();

          // Start Loop
          this.animate();
        }

        initThree() {
          // 1. Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
          this.scene.fog = new THREE.Fog(0x87CEEB, 100, 300); // Matching fog

          // 2. Camera (Perspective)
          const fov = 45;
          const aspect = this.width / this.height;
          const near = 0.1;
          const far = 2000;
          this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

          // Perspective View Setup: Position and LookAt
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(this.scene.position); // Will be updated to follow player

          // 3. Renderer
          if (!this.renderer) {
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);
          }

          // Controls
          if (this.controls) this.controls.dispose();
          this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 30;
          this.controls.maxDistance = 500;
          this.controls.target.set(0, 0, 0);

          // Lock rotation, enable pan on ground plane
          this.controls.enableRotate = false;
          // Pan on XZ plane (ground) instead of screen space
          // This keeps the camera-to-ground distance constant when panning
          this.controls.screenSpacePanning = false;
          // Lock polar angle to maintain fixed camera height relative to ground
          // Camera is at (0, 60, 60) looking at (0, 0, 0), so polar angle is ~45 degrees (Ï€/4)
          const fixedPolarAngle = Math.PI / 4; // 45 degrees from vertical
          this.controls.minPolarAngle = fixedPolarAngle;
          this.controls.maxPolarAngle = fixedPolarAngle;
          
          this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
          this.controls.touches = {
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };

          // Stop auto-following if user interacts
          this.controls.addEventListener("start", () => {
            this.cameraLocked = false;
            this.isUserInteracting = true;
          });

          this.controls.addEventListener("end", () => {
            this.isUserInteracting = false;
            if (this.state === "MOVING") {
              this.cameraLocked = true;
            }
          });

          // Setup click detection for tiles (raycaster for game mode clicks)
          this.gameRaycaster = new THREE.Raycaster();
          this.gameMouse = new THREE.Vector2();
          let downX = 0, downY = 0;
          
          const canvas = this.renderer.domElement;
          canvas.addEventListener("pointerdown", (e) => {
            downX = e.clientX;
            downY = e.clientY;
          });

          canvas.addEventListener("pointerup", (e) => {
            const moveDist = Math.sqrt(Math.pow(e.clientX - downX, 2) + Math.pow(e.clientY - downY, 2));
            // Allow small movement (jitter) but filter out drags
            if (moveDist < 10 && this.mode === "GAME") {
              this.onGameClick(e);
            }
          });

          // 4. Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(50, 100, 50);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          dirLight.shadow.camera.near = 0.5;
          dirLight.shadow.camera.far = 500;
          const shadowSize = 50;
          dirLight.shadow.camera.left = -shadowSize;
          dirLight.shadow.camera.right = shadowSize;
          dirLight.shadow.camera.top = shadowSize;
          dirLight.shadow.camera.bottom = -shadowSize;
          this.scene.add(dirLight);
        }

        initWorldMap() {
          this.worldMap = new WorldMapManager(this);
          if (this.controls) this.controls.enabled = false;

          // Hide Game UI initially
          document.getElementById("ui-layer").style.display = "none";
          document.getElementById("labels-layer").style.display = "none";
          document.getElementById("game-title").classList.add("hidden");

          // Setup Login
          const loginModal = document.getElementById("login-modal");
          if (loginModal) {
            loginModal.classList.remove("hidden");
            document.getElementById("login-btn").onclick = () => this.startGame();
          }
        }

        startGame() {
          const loginModal = document.getElementById("login-modal");
          if (loginModal) loginModal.classList.add("hidden");

          document.getElementById("game-title").classList.remove("hidden");

          if (this.worldMap) {
            // this.worldMap.autoRotate = false;
          }
        }

        selectCity(city) {
          this.currentCity = city;
          // If we're in MAP mode, we should ensure worldMap is visible during travel
          this.mode = "GAME";

          if (this.worldMap) this.worldMap.controls.enabled = false;

          // Reset Game Scene if needed or just init
          // Clear existing map if any?
          while (this.scene.children.length > 0) {
            this.scene.remove(this.scene.children[0]);
          }

          // é‡ç½®ç›®çš„åœ°æ ‡è®°
          this.destinationTile = null;
          this.destinationMarker = null;

          // æ¸…ç©ºæ ‡ç­¾å±‚
          document.getElementById("labels-layer").innerHTML = "";

          this.initThree(); // Re-init scene/camera/lights for Game
          this.initGame(); // Generate city map

          // Update UI
          document.getElementById("ui-layer").style.display = "flex";
          document.getElementById("labels-layer").style.display = "block";
          document.getElementById("game-title").classList.add("hidden");
        }

        // Travel from current city (or homeCity) to the provided city. Will perform plane animation then select City
        travelToCity(cityOrName, enterCity = true) {
          let cityObj = null;
          if (!cityOrName) return;
          if (typeof cityOrName === "string") {
            // find by name
            cityObj = (CITIES || []).find((c) => c.name === cityOrName);
          } else {
            cityObj = cityOrName;
          }
          if (!cityObj) {
            console.warn("travelToCity: city not found", cityOrName);
            return this.selectCity(cityOrName);
          }

          const fromName = this.currentCity && this.currentCity.name ? this.currentCity.name : homeCity;
          // If no worldMap, just switch immediately
          if (!this.worldMap || typeof this.worldMap.flyPlane !== "function") {
            return this.selectCity(cityObj);
          }

          // When the plane finishes flying to cityObj, we call selectCity
          this.worldMap.flyPlane(fromName, cityObj.name, {
            altitude: 2.2,
            followCamera: true,
            zoomInDistance: 18,
            zoomOutDistance: 30,
            zoomSpeed: 0.08,
            trailMaxPoints: 96,
            trailColor: 0xffee88,
            onComplete: () => {
              if (enterCity) {
                this.selectCity(cityObj);
              }
            },
          });
        }

        toggleMap() {
          if (this.mode === "GAME") {
            this.mode = "MAP";
            if (this.controls) this.controls.enabled = false;
            if (this.worldMap) this.worldMap.controls.enabled = true;

            document.getElementById("ui-layer").style.display = "none";
            document.getElementById("labels-layer").style.display = "none";
            document.getElementById("destination-indicator").classList.add("hidden");
            document.getElementById("game-title").classList.remove("hidden");
          } else {
            if (this.currentCity) {
              this.mode = "GAME";
              if (this.worldMap) this.worldMap.controls.enabled = false;
              if (this.controls) this.controls.enabled = true;

              document.getElementById("ui-layer").style.display = "flex";
              document.getElementById("labels-layer").style.display = "block";
              document.getElementById("game-title").classList.add("hidden");
            }
          }
        }

        async initGame() {
          // Initialize properties cache
          initializePropertiesCache();
          
          // åˆå§‹åŒ–sessionçº§åˆ«çš„åœ°äº§æ˜¾ç¤ºç¼“å­˜
          this.sessionPropertyCache = {};
          this.purchasedPropertiesInSession = {};
          
          // Materials Cache
          this.materials = {
            road: new THREE.MeshLambertMaterial({ color: COLORS.road }),
            start: new THREE.MeshLambertMaterial({ color: COLORS.start }),
            blue: new THREE.MeshLambertMaterial({ color: COLORS.blue }),
            red: new THREE.MeshLambertMaterial({ color: COLORS.red }),
            yellow: new THREE.MeshLambertMaterial({ color: COLORS.yellow }),
            green: new THREE.MeshLambertMaterial({ color: COLORS.green }),
            env_nature: new THREE.MeshLambertMaterial({ color: COLORS.env_nature }),
            env_culture: new THREE.MeshLambertMaterial({ color: COLORS.env_culture }),
            rail: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 }),
          };

          this.geometries = {
            tile: new THREE.BoxGeometry(TILE_SIZE - TILE_SPACING, 1, TILE_SIZE - TILE_SPACING),
            envBlock: new THREE.BoxGeometry(TILE_SIZE, 4, TILE_SIZE), // Taller blocks for env
          };

          // Generate Map
          const startTile = this.generateMap();

          // Init Players
          this.players = [new Player("p1", "ç©å®¶", 0x3b82f6, false), new Player("com", "ç”µè„‘", 0xef4444, true)];

          this.players.forEach((p) => {
            this.createPlayerMesh(p);
            p.currentTile = startTile;
            p.mesh.position.copy(startTile.worldPos);
            p.mesh.position.y = 1.5; // Sit on top of tile
          });

          // Initial Camera Setup: Center on P1, looking from South
          const p1Pos = this.players[0].mesh.position;
          this.camera.position.set(p1Pos.x, p1Pos.y + 60, p1Pos.z + 60);
          this.controls.target.copy(p1Pos);
          this.controls.update();

          // åˆå§‹åŒ–ç›®çš„åœ°å’Œæ—¶é—´
          this.gameYear = 1;
          this.gameMonth = 4;
          this.totalTurns = 0;
          await this.setNewDestination();
          document.getElementById("destination-panel").classList.remove("hidden");

          this.updateUI();
          this.startTurn();

          // Debug: Quickly attach binbougami to P1 if 'testBinbougami' query present
          try {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get("testBinbougami") === "1") {
              await wait(500);
              await this.attachBinbougami(this.players[0]);
            }
          } catch (e) {}
        }

        createPlayerMesh(player) {
          const group = new THREE.Group();

          // Body
          const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 16);
          const bodyMat = new THREE.MeshStandardMaterial({ color: player.color });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 1;
          body.castShadow = true;
          group.add(body);

          // Head
          const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
          const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
          const head = new THREE.Mesh(headGeo, headMat);
          head.position.y = 2.2;
          head.castShadow = true;
          group.add(head);
          // expose head reference for attaching UI / effects
          player.headMesh = head;

          // Hat/Indicator (Cone)
          const hatGeo = new THREE.ConeGeometry(0.6, 1, 16);
          const hatMat = new THREE.MeshStandardMaterial({ color: player.color });
          const hat = new THREE.Mesh(hatGeo, hatMat);
          hat.position.y = 3;
          hat.rotation.x = Math.PI; // Point down? No point up like a party hat
          group.add(hat);

          this.scene.add(group);
          player.mesh = group;
        }

        // --- Map Generation Algorithm (from world_traveler_map.html) ---
        // Data Structures for A* Pathfinding and MST
        
        // Priority Queue for A* pathfinding
        _createPriorityQueue() {
          return {
            items: [],
            enqueue(element, priority) {
              const qElement = { element, priority };
              let contain = false;
              for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].priority > qElement.priority) {
                  this.items.splice(i, 0, qElement);
                  contain = true;
                  break;
                }
              }
              if (!contain) this.items.push(qElement);
            },
            dequeue() { return this.items.shift(); },
            isEmpty() { return this.items.length === 0; }
          };
        }

        // Union-Find for Kruskal's MST
        _createUnionFind(elements) {
          const parent = {};
          elements.forEach(e => parent[e] = e);
          return {
            find(id) {
              if (parent[id] === id) return id;
              parent[id] = this.find(parent[id]);
              return parent[id];
            },
            union(id1, id2) {
              const root1 = this.find(id1);
              const root2 = this.find(id2);
              if (root1 !== root2) {
                parent[root1] = root2;
                return true;
              }
              return false;
            },
            connected(id1, id2) { 
              return this.find(id1) === this.find(id2); 
            }
          };
        }

        generateMap() {
          this.map = [];
          
          // Initialize simplex noise for terrain
          const simplex = new SimplexNoise();
          
          // World map for terrain data
          const worldMap = new Map(); // Key: "x,z", Value: { h: height, obj: objectType }
          const roadSet = new Set(); // Track built roads for dynamic costing
          
          // Cost constants for A* pathfinding
          const COST_EMPTY = 10;     // Expensive to build new
          const COST_EXISTING = 1;   // Cheap to use existing
          
          // Helper functions
          const setCell = (x, z, data) => {
            worldMap.set(`${x},${z}`, data);
          };
          
          const getCell = (x, z) => {
            return worldMap.get(`${x},${z}`);
          };
          
          const getNoiseHeight = (x, z) => {
            let n = simplex.noise2D(x*0.03, z*0.03); 
            let n2 = simplex.noise2D(x*0.1, z*0.1);
            let h = -1;
            if (n > -0.2) h = 1; 
            if (n > 0.5) h = 3; 
            if (h === 1 && n2 > 0.4) h = 2;
            return h;
          };
          
          const getCost = (x, z) => {
            return roadSet.has(`${x},${z}`) ? COST_EXISTING : COST_EMPTY;
          };
          
          // A* Pathfinding
          const findPath = (start, end) => {
            const openSet = this._createPriorityQueue();
            openSet.enqueue(start, 0);
            
            const cameFrom = {};
            const gScore = {};
            const startKey = `${start.x},${start.z}`;
            gScore[startKey] = 0;

            const getKey = (pt) => `${pt.x},${pt.z}`;
            
            while (!openSet.isEmpty()) {
              const current = openSet.dequeue().element;
              const currentKey = getKey(current);

              if (current.x === end.x && current.z === end.z) {
                const path = [];
                let curr = currentKey;
                while (cameFrom[curr]) {
                  const [x, z] = curr.split(',').map(Number);
                  path.push({x, z});
                  curr = cameFrom[curr];
                }
                return { path: path.reverse(), cost: gScore[currentKey] };
              }

              const neighbors = [
                {x: current.x+1, z: current.z}, {x: current.x-1, z: current.z},
                {x: current.x, z: current.z+1}, {x: current.x, z: current.z-1}
              ];

              for (let neighbor of neighbors) {
                const neighborKey = getKey(neighbor);
                const newCost = gScore[currentKey] + getCost(neighbor.x, neighbor.z);

                if (newCost < (gScore[neighborKey] ?? Infinity)) {
                  cameFrom[neighborKey] = currentKey;
                  gScore[neighborKey] = newCost;
                  const h = Math.abs(neighbor.x - end.x) + Math.abs(neighbor.z - end.z);
                  openSet.enqueue(neighbor, newCost + h);
                }
              }
            }
            return { path: [], cost: Infinity };
          };
          
          const addPathToRoadSet = (path) => {
            path.forEach(p => roadSet.add(`${p.x},${p.z}`));
          };
          
          // Builds a simple L-shaped road between two points
          const buildDirectRoad = (start, end) => {
            let x = start.x;
            let z = start.z;
            
            while(x !== end.x) {
              roadSet.add(`${x},${z}`);
              x += (end.x > x ? 1 : -1);
            }
            while(z !== end.z) {
              roadSet.add(`${x},${z}`);
              z += (end.z > z ? 1 : -1);
            }
            roadSet.add(`${end.x},${end.z}`);
          };
          
          // Ensure road exists at position
          const ensureRoad = (x, z) => {
            let cell = getCell(x, z);
            if (!cell) {
              setCell(x, z, { h: 1, obj: 1 });
            } else {
              if (cell.obj === 0) {
                cell.obj = 1;
                cell.h = Math.max(cell.h, 1);
                setCell(x, z, cell);
              }
            }
            
            // Padding around roads
            for(let dx=-1; dx<=1; dx++) {
              for(let dz=-1; dz<=1; dz++) {
                if(dx===0 && dz===0) continue;
                let px = x+dx, pz = z+dz;
                if(!worldMap.has(`${px},${pz}`)) {
                  let h = getNoiseHeight(px, pz);
                  if(h < 1) h = 1; 
                  setCell(px, pz, { h: h, obj: 0 });
                }
              }
            }
          };

          // --- Step 1: Load Station Data from Config ---
          // Use actual lat/lng coordinates from STATION_DATA
          // Scale factor: needs to be large enough that stations don't overlap on even grid
          // With ~277 stations in ~2x3.3 degree area, scale of 200 gives ~400x660 units = 200x330 even grid positions
          const CONFIG_SCALE = 70; // Scale factor for lat/lon to grid units
          const RENDER_RADIUS = 6; // Radius to render terrain around stations
          
          let rawPoints = [];
          
          if (STATION_DATA.length > 0) {
            // Calculate bounds of all cities
            let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
            STATION_DATA.forEach(d => {
              if (d.lat < minLat) minLat = d.lat;
              if (d.lat > maxLat) maxLat = d.lat;
              if (d.lng < minLng) minLng = d.lng;
              if (d.lng > maxLng) maxLng = d.lng;
            });
            
            const centerLat = (minLat + maxLat) / 2;
            const centerLng = (minLng + maxLng) / 2;

            // Convert lat/lng to grid coordinates
            rawPoints = STATION_DATA.map(d => ({
              x: (d.lng - centerLng) * CONFIG_SCALE,
              z: -(d.lat - centerLat) * CONFIG_SCALE,
              originalName: d.name,
              population: d.population || 100000,
              level: d.level || 3
            }));
          } else {
            // Fallback: generate random positions
            for (let i = 0; i < STATION_NAMES.length; i++) {
              rawPoints.push({
                x: (Math.random() - 0.5) * 100,
                z: (Math.random() - 0.5) * 100,
                originalName: STATION_NAMES[i],
                population: 1000000 - i * 10000,
                level: 3
              });
            }
          }
          
          // --- Step 2: Snap to Even Grid and Resolve Collisions ---
          const nodes = [];
          const occupied = new Set();
          
          // Sort by population descending so higher population cities get priority
          rawPoints.sort((a, b) => (b.population || 0) - (a.population || 0));
          
          const snapToEvenGrid = (val) => Math.round(val / 2) * 2;
          
          const findNearestFree = (startGx, startGz) => {
            startGx = snapToEvenGrid(startGx);
            startGz = snapToEvenGrid(startGz);
            
            if (!occupied.has(`${startGx},${startGz}`)) return { x: startGx, z: startGz };
            
            let radius = 2;
            while (radius < 100) {
              for (let x = -radius; x <= radius; x += 2) {
                for (let z = -radius; z <= radius; z += 2) {
                  if (Math.abs(x) !== radius && Math.abs(z) !== radius) continue;
                  
                  let checkX = startGx + x;
                  let checkZ = startGz + z;
                  if (!occupied.has(`${checkX},${checkZ}`)) {
                    return { x: checkX, z: checkZ };
                  }
                }
              }
              radius += 2;
            }
            return null;
          };

          rawPoints.forEach((p, index) => {
            let desiredGx = snapToEvenGrid(Math.round(p.x));
            let desiredGz = snapToEvenGrid(Math.round(p.z));
            
            let pos = findNearestFree(desiredGx, desiredGz);
            
            if (pos) {
              let gx = pos.x;
              let gz = pos.z;
              let key = `${gx},${gz}`;
              
              occupied.add(key);
              // Use level to determine type (level 1-2 are major stations)
              let type = (p.level <= 2) ? 'station' : 'city';
              let node = {
                id: nodes.length,
                x: gx, 
                z: gz,
                type: type,
                name: p.originalName,
                population: p.population,
                level: p.level,
                neighbors: []
              };
              nodes.push(node);
              setCell(gx, gz, { h: 1, obj: type === 'station' ? 3 : 2 });
            } else {
              console.warn(`Could not place station: ${p.originalName} (desired: ${desiredGx}, ${desiredGz})`);
            }
          });

          console.log(`Generated ${nodes.length} station nodes from ${STATION_DATA.length} station data entries`);

          // --- Step 3: Generate Terrain Around Stations ---
          nodes.forEach(node => {
            for(let dx = -RENDER_RADIUS; dx <= RENDER_RADIUS; dx++) {
              for(let dz = -RENDER_RADIUS; dz <= RENDER_RADIUS; dz++) {
                let wx = node.x + dx;
                let wz = node.z + dz;
                if (!worldMap.has(`${wx},${wz}`)) {
                  let h = getNoiseHeight(wx, wz);
                  setCell(wx, wz, { h: h, obj: 0 });
                }
              }
            }
          });

          // --- Step 4: Build Road Network using Kruskal's MST with A* ---
          const solveNetwork = () => {
            if (nodes.length < 2) return;

            roadSet.clear();
            
            const loopVal = 50; // Loop sensitivity (0-100)
            const detourRatio = loopVal === 0 ? 1000 : 5.0 - (loopVal / 25);

            // Prepare edges sorted by Manhattan distance
            let edges = [];
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                const dist = Math.abs(nodes[i].x - nodes[j].x) + Math.abs(nodes[i].z - nodes[j].z);
                edges.push({ u: nodes[i], v: nodes[j], dist: dist });
              }
            }
            edges.sort((a, b) => a.dist - b.dist);

            const uf = this._createUnionFind(nodes.map(n => n.id));
            let rejectedEdges = [];

            // Phase 1: MST Skeleton
            for (let i = 0; i < edges.length; i++) {
              const edge = edges[i];
              
              if (uf.connected(edge.u.id, edge.v.id)) {
                rejectedEdges.push(edge);
                continue;
              }

              const pathRes = findPath(edge.u, edge.v);
              
              if (!uf.connected(edge.u.id, edge.v.id)) {
                uf.union(edge.u.id, edge.v.id);
                addPathToRoadSet(pathRes.path);
                
                // Connect nodes as neighbors
                edge.u.neighbors.push(edge.v);
                edge.v.neighbors.push(edge.u);
              }
            }

            // Phase 2: Loop Injection (Smart Shortcuts)
            if (loopVal > 0) {
              const localEdges = rejectedEdges.filter(e => e.dist < 15);

              for (let edge of localEdges) {
                const currentRailPath = findPath(edge.u, edge.v);
                
                if (currentRailPath.cost - edge.dist > 8) {
                  buildDirectRoad(edge.u, edge.v);
                  edge.u.neighbors.push(edge.v);
                  edge.v.neighbors.push(edge.u);
                }
              }
            }

            // Apply roads to world
            roadSet.forEach(k => {
              const [x, z] = k.split(',').map(Number);
              if(!nodes.some(n => n.x === x && n.z === z)) {
                ensureRoad(x, z);
              }
            });
          };
          
          solveNetwork();

          // --- Step 5: Convert to Tile System ---
          const tileData = new Map();
          
          worldMap.forEach((cell, key) => {
            const [xStr, zStr] = key.split(',');
            const x = parseInt(xStr);
            const z = parseInt(zStr);
            
            let h = cell.h;
            let obj = cell.obj;
            
            if (h === -1) return; // Skip water
            
            let type = 'road';
            
            // Determine tile type based on object
            if (obj === 2 || obj === 3) {
              // Station/City
              type = 'green';
            } else if (obj === 1) {
              // Road - add colored tiles randomly
              type = Math.random() < 0.3 ? this.getRandomColoredType() : 'road';
            } else {
              // Environment based on height
              if (h === 0 || h === -1) type = 'env_nature';
              else if (h === 1) type = Math.random() > 0.3 ? 'env_nature' : 'env_culture';
              else if (h === 2) type = 'env_nature';
              else if (h === 3) type = 'env_culture';
            }
            
            // Find station name and population if this is a station
            let stationName = '';
            let population = 0;
            if (type === 'green') {
              const node = nodes.find(n => n.x === x && n.z === z);
              if (node) {
                stationName = node.name;
                population = node.population || 0;
              }
            }
            
            tileData.set(key, { x, z, type, stationName, population, height: h, obj });
          });

          // --- Step 6: Instantiate Tiles ---
          const mapGroup = new THREE.Group();
          this.scene.add(mapGroup);
          this.tilesMap = new Map();

          // Add infinite ocean plane
          const waterGeo = new THREE.PlaneGeometry(10000, 10000);
          const waterMat = new THREE.MeshLambertMaterial({ color: 0x1e3a8a }); // Deep blue ocean
          const waterMesh = new THREE.Mesh(waterGeo, waterMat);
          waterMesh.rotation.x = -Math.PI / 2;
          waterMesh.position.set(0, -0.5, 0);
          waterMesh.receiveShadow = false;
          mapGroup.add(waterMesh);

          let idCounter = 0;
          tileData.forEach((data) => {
            // Skip pure environment tiles far from roads for performance
            if (!data.type.includes('env') || data.obj === 1 || data.obj === 2 || data.obj === 3 || data.type === 'green' || data.type === 'road' || 
                ['blue', 'red', 'yellow'].includes(data.type)) {
              const tile = new Tile(idCounter++, data.x, data.z, data.type);
              if (data.stationName) tile.stationName = data.stationName;
              if (data.population) tile.population = data.population;

              this.map.push(tile);
              this.tilesMap.set(`${data.x},${data.z}`, tile);
              this.createTileVisuals(tile, mapGroup);
            } else {
              // Still add environment tiles but with simpler visuals
              const tile = new Tile(idCounter++, data.x, data.z, data.type);
              this.map.push(tile);
              this.tilesMap.set(`${data.x},${data.z}`, tile);
              this.createTileVisuals(tile, mapGroup);
            }
          });

          console.log(`Created ${this.map.length} tiles, ${this.map.filter(t => t.type === 'green').length} stations`);

          // --- Step 7: Link Neighbors ---
          this.map.forEach((tile) => {
            if (!tile.isRoad) return;

            const dirs = [
              [0, 1],
              [0, -1],
              [1, 0],
              [-1, 0],
            ];
            dirs.forEach(([dx, dz]) => {
              const nx = tile.gridX + dx;
              const nz = tile.gridY + dz;
              const neighbor = this.tilesMap.get(`${nx},${nz}`);
              if (neighbor && neighbor.isRoad) {
                tile.neighbors.push(neighbor);
              }
            });
          });

          // --- Step 8: Set Start Position (city with largest population) ---
          const stations = this.map.filter((t) => t.type === "green");
          // Sort stations by population descending and pick the one with largest population
          stations.sort((a, b) => (b.population || 0) - (a.population || 0));
          let startTile = stations.length > 0 ? stations[0] : this.map[0];

          if (!startTile) startTile = this.map[0];

          if (startTile) {
            startTile.type = "start";
            startTile.mesh.material = this.materials.start;
            startTile.mesh.position.y = 0.2;
            if (startTile.labelElement) {
              startTile.labelElement.remove();
              startTile.labelElement = null;
            }
          }

          return startTile;
        }

        createTileVisuals(tile, parentGroup) {
          const x = tile.gridX * TILE_SIZE;
          const z = tile.gridY * TILE_SIZE;

          // 1. Base Block
          let geometry = this.geometries.tile;
          let yPos = 0;

          // Environment blocks are taller to create "canyons" for the track
          if (!tile.isRoad) {
            geometry = new THREE.BoxGeometry(TILE_SIZE, rand(2, 6), TILE_SIZE);
            yPos = -1; // Sink them a bit
          }

          const material = this.materials[tile.type] || this.materials.road;
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, yPos, z);
          mesh.receiveShadow = true;

          // 2. Decorations
          if (tile.type === "env_nature") {
            if (Math.random() > 0.5) {
              const treeGeo = new THREE.ConeGeometry(1, 3, 8);
              const treeMat = new THREE.MeshLambertMaterial({ color: 0x14532d });
              const tree = new THREE.Mesh(treeGeo, treeMat);
              tree.position.set(0, 2.5, 0);
              tree.castShadow = true;
              mesh.add(tree); // Local coordinate
            }
          } else if (tile.type === "green") {
            // Station Marker
            const stationGeo = new THREE.BoxGeometry(2.5, 1, 2.5);
            const stationMesh = new THREE.Mesh(stationGeo, new THREE.MeshLambertMaterial({ color: 0xffffff }));
            stationMesh.position.y = 0.6;
            mesh.add(stationMesh);

            // Add HTML Label
            this.createStationLabel(tile);
          }

          tile.mesh = mesh;
          parentGroup.add(mesh);
        }

        createStationLabel(tile) {
          const div = document.createElement("div");
          div.className = "station-label";
          div.innerText = tile.stationName;
          document.getElementById("labels-layer").appendChild(div);
          tile.labelElement = div;

          // Determine best label position: prefer non-road adjacent tiles
          // Check left (-x), right (+x), and top (-z) directions
          const leftKey = `${tile.gridX - 1},${tile.gridY}`;
          const rightKey = `${tile.gridX + 1},${tile.gridY}`;
          const topKey = `${tile.gridX},${tile.gridY - 1}`;

          const leftTile = this.tilesMap.get(leftKey);
          const rightTile = this.tilesMap.get(rightKey);
          const topTile = this.tilesMap.get(topKey);

          // Check if tile is a road/walkable tile (not environment)
          const isRoadTile = (t) => t && t.isRoad;

          // Priority: place label toward non-road areas (top > left > right)
          if (!isRoadTile(topTile)) {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // top (default)
          } else if (!isRoadTile(leftTile)) {
            tile.labelOffset = { x: -50, y: 0, align: "right" }; // left side
          } else if (!isRoadTile(rightTile)) {
            tile.labelOffset = { x: 50, y: 0, align: "left" }; // right side
          } else {
            tile.labelOffset = { x: 0, y: -30, align: "center" }; // fallback to top
          }
        }

        getRandomColoredType() {
          // Note: Don't return "green" here - only actual station nodes (from nodes array)
          // should be green. Road tiles converted to green would have no matching node,
          // causing incorrect station names to be assigned.
          const r = Math.random();
          if (r < 0.33) return "red";
          if (r < 0.66) return "yellow";
          return "blue";
        }

        // --- ç›®çš„åœ°ç«é€Ÿç³»ç»Ÿ ---

        async setNewDestination() {
          // è·å–æ‰€æœ‰è½¦ç«™ï¼ˆç»¿è‰²æ ¼å­ï¼‰ï¼Œæ’é™¤å½“å‰èµ·å§‹ç‚¹å’Œç©å®¶æ‰€åœ¨ä½ç½®
          const stations = this.map.filter((t) => t.type === "green" && t !== this.destinationTile && !this.players.some((p) => p.currentTile === t));

          if (stations.length === 0) return;

          // ç§»é™¤æ—§ç›®çš„åœ°çš„é«˜äº®æ ·å¼
          if (this.destinationTile && this.destinationTile.labelElement) {
            this.destinationTile.labelElement.classList.remove("destination");
          }

          // éšæœºé€‰æ‹©ä¸€ä¸ªè½¦ç«™ä½œä¸ºç›®çš„åœ°
          let newDest = stations[Math.floor(Math.random() * stations.length)];

          // æ˜¾ç¤ºæŠ½å¥–åŠ¨ç”»
          newDest = await this.showDestinationLottery(stations, newDest);

          this.destinationTile = newDest;

          // æ›´æ–°UIæ˜¾ç¤º
          document.getElementById("destination-name").innerText = newDest.stationName;

          // æ·»åŠ ç›®çš„åœ°æ ‡ç­¾é«˜äº®æ ·å¼
          if (newDest.labelElement) {
            newDest.labelElement.classList.add("destination");
          }

          // ç§»é™¤æ—§çš„ç›®çš„åœ°æ ‡è®°
          if (this.destinationMarker) {
            this.scene.remove(this.destinationMarker);
          }

          // åˆ›å»ºæ–°çš„ç›®çš„åœ°æ ‡è®°ï¼ˆå‘å…‰çš„åœ†æŸ±+æ——å¸œï¼‰
          this.createDestinationMarker(newDest);

          this.log(`ğŸ¯ æ–°ç›®çš„åœ°: ${newDest.stationName}`, "#fbbf24");
          showToast(`ğŸ¯ ç›®çš„åœ°å·²æ›´æ–°: ${newDest.stationName}`, "#fbbf24");

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // ä½¿ç”¨BFSè®¡ç®—ä»ä¸€ä¸ªæ ¼å­åˆ°ç›®çš„åœ°çš„æœ€çŸ­è·ç¦»ï¼ˆç«™æ•°ï¼‰
        calculateDistanceToDestination(fromTile) {
          if (!this.destinationTile || !fromTile) return -1;
          if (fromTile === this.destinationTile) return 0;

          // BFSæœç´¢æœ€çŸ­è·¯å¾„
          const visited = new Set();
          const queue = [{ tile: fromTile, distance: 0 }];
          visited.add(fromTile);

          while (queue.length > 0) {
            const { tile, distance } = queue.shift();

            for (const neighbor of tile.neighbors) {
              if (neighbor === this.destinationTile) {
                // åªè®¡ç®—å½©è‰²æ ¼å­ï¼ˆæœ‰æ•ˆæ­¥æ•°ï¼‰
                return distance + (neighbor.isColored ? 1 : 0);
              }

              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                // åªæœ‰å½©è‰²æ ¼å­æ‰ç®—ä¸€æ­¥
                const newDist = distance + (neighbor.isColored ? 1 : 0);
                queue.push({ tile: neighbor, distance: newDist });
              }
            }
          }

          return -1; // æ— æ³•åˆ°è¾¾
        }

        // AIé€‰æ‹©æœ€ä¼˜æ–¹å‘ï¼šé€‰æ‹©è·ç¦»ç›®çš„åœ°æœ€è¿‘çš„è·¯å¾„
        chooseBestDirection(options) {
          if (!this.destinationTile || options.length === 0) {
            return options[Math.floor(Math.random() * options.length)];
          }

          let bestTile = options[0];
          let bestDistance = this.calculateDistanceToDestination(options[0]);

          for (let i = 1; i < options.length; i++) {
            const dist = this.calculateDistanceToDestination(options[i]);
            // é€‰æ‹©è·ç¦»æ›´çŸ­çš„ï¼ˆå¦‚æœè·ç¦»ä¸º-1è¡¨ç¤ºæ— æ³•åˆ°è¾¾ï¼Œè·³è¿‡ï¼‰
            if (dist >= 0 && (bestDistance < 0 || dist < bestDistance)) {
              bestDistance = dist;
              bestTile = options[i];
            }
          }

          return bestTile;
        }

        // æ›´æ–°æ‰€æœ‰ç©å®¶çš„è·ç¦»æ˜¾ç¤ºï¼ˆç°åœ¨åªåœ¨è¯¦æƒ…é¢æ¿ä¸­æ˜¾ç¤ºï¼‰
        updateDistanceDisplay() {
          // è·ç¦»ä¿¡æ¯ç°åœ¨åªåœ¨ç©å®¶è¯¦æƒ…å¼¹çª—ä¸­æ˜¾ç¤º
          // æ­¤å‡½æ•°ä¿ç•™ä»¥ä¾›å…¶ä»–åœ°æ–¹è°ƒç”¨å…¼å®¹
        }

        // æ›´æ–°å±å¹•å¤–ç›®çš„åœ°æŒ‡ç¤ºå™¨
        updateDestinationIndicator() {
          const indicator = document.getElementById("destination-indicator");
          if (!indicator) return;

          // å¦‚æœæ²¡æœ‰ç›®çš„åœ°ï¼Œéšè—æŒ‡ç¤ºå™¨
          if (!this.destinationTile) {
            indicator.classList.add("hidden");
            return;
          }

          // Use relative world position between camera look at and the dest station
          this.camera.updateMatrixWorld();
          const destPosCamera = this.destinationTile.mesh.position.clone().applyMatrix4(this.camera.matrixWorldInverse);
          
          // Check if in front of camera (negative z in camera space)
          const isInFront = destPosCamera.z < 0;

          // è·å–ç›®çš„åœ°åœ¨å±å¹•ä¸Šçš„ä½ç½®
          const destPos = this.getScreenPosition(this.destinationTile.mesh.position);
          const margin = 80; // è¾¹ç¼˜margin

          // æ£€æŸ¥ç›®çš„åœ°æ˜¯å¦åœ¨å±å¹•å¯è§èŒƒå›´å†…
          // Must be in front AND within screen bounds
          let isOnScreen = false;
          if (isInFront) {
             isOnScreen = destPos.x >= margin && destPos.x <= this.width - margin && destPos.y >= margin && destPos.y <= this.height - margin;
          }

          if (isOnScreen) {
            // ç›®çš„åœ°åœ¨å±å¹•å†…ï¼Œéšè—æŒ‡ç¤ºå™¨
            indicator.classList.add("hidden");
            return;
          }

          // ç›®çš„åœ°åœ¨å±å¹•å¤–ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨
          indicator.classList.remove("hidden");

          // æ›´æ–°ç›®çš„åœ°åç§°
          document.getElementById("indicator-name").innerText = this.destinationTile.stationName;

          // è®¡ç®—å±å¹•ä¸­å¿ƒåˆ°ç›®çš„åœ°ä½ç½®çš„æ–¹å‘
          // Use camera space coordinates to determine angle
          // Camera x is right, y is up. Screen x is right, y is down.
          // So angle = atan2(-y, x)
          const angle = Math.atan2(-destPosCamera.y, destPosCamera.x);

          // è®¡ç®—æŒ‡ç¤ºå™¨åœ¨å±å¹•è¾¹ç¼˜çš„ä½ç½®
          const edgeMargin = 60;
          let indicatorX, indicatorY;

          const centerX = this.width / 2;
          const centerY = this.height / 2;

          // æ ¹æ®è§’åº¦ç¡®å®šæŒ‡ç¤ºå™¨ä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
          const maxX = this.width - edgeMargin;
          const maxY = this.height - edgeMargin;
          const minX = edgeMargin;
          const minY = edgeMargin;

          // Use cos/sin to find intersection with box
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          
          // Ray from center: x = centerX + t * cos, y = centerY + t * sin
          // Find t for each edge
          
          let t = Infinity;
          
          // Right edge: x = maxX
          if (cos > 0) {
             const tRight = (maxX - centerX) / cos;
             if (tRight < t) t = tRight;
          }
          // Left edge: x = minX
          if (cos < 0) {
             const tLeft = (minX - centerX) / cos;
             if (tLeft < t) t = tLeft;
          }
          // Bottom edge: y = maxY
          if (sin > 0) {
             const tBottom = (maxY - centerY) / sin;
             if (tBottom < t) t = tBottom;
          }
          // Top edge: y = minY
          if (sin < 0) {
             const tTop = (minY - centerY) / sin;
             if (tTop < t) t = tTop;
          }
          
          indicatorX = centerX + t * cos;
          indicatorY = centerY + t * sin;

          // è®¾ç½®æŒ‡ç¤ºå™¨ä½ç½®ï¼Œæ ¹æ®è¾¹ç¼˜ä½ç½®è°ƒæ•´transformé¿å…è¶…å‡ºå±å¹•
          let finalX = indicatorX;
          let finalY = indicatorY;

          // æ ¹æ®æŒ‡ç¤ºå™¨åœ¨å±å¹•çš„ä½ç½®è°ƒæ•´å¯¹é½æ–¹å¼
          let transformX = "-50%";
          let transformY = "-50%";

          const padding = 10; // è·ç¦»å±å¹•è¾¹ç¼˜çš„padding

          // é è¿‘å³è¾¹ç¼˜æ—¶ï¼Œå‘å·¦å¯¹é½ï¼ˆå…ƒç´ å³è¾¹è´´ç€å±å¹•å³è¾¹ï¼‰
          if (indicatorX >= this.width - edgeMargin) {
            transformX = "-100%";
            finalX = this.width - padding;
          }
          // é è¿‘å·¦è¾¹ç¼˜æ—¶ï¼Œå‘å³å¯¹é½ï¼ˆå…ƒç´ å·¦è¾¹è´´ç€å±å¹•å·¦è¾¹ï¼‰
          else if (indicatorX <= edgeMargin) {
            transformX = "0%";
            finalX = padding;
          }

          // é è¿‘ä¸‹è¾¹ç¼˜æ—¶ï¼Œå‘ä¸Šå¯¹é½ï¼ˆå…ƒç´ ä¸‹è¾¹è´´ç€å±å¹•ä¸‹è¾¹ï¼‰
          if (indicatorY >= this.height - edgeMargin) {
            transformY = "-100%";
            finalY = this.height - padding;
          }
          // é è¿‘ä¸Šè¾¹ç¼˜æ—¶ï¼Œå‘ä¸‹å¯¹é½ï¼ˆå…ƒç´ ä¸Šè¾¹è´´ç€å±å¹•ä¸Šè¾¹ï¼‰
          else if (indicatorY <= edgeMargin) {
            transformY = "0%";
            finalY = padding;
          }

          indicator.style.left = `${finalX}px`;
          indicator.style.top = `${finalY}px`;
          indicator.style.transform = `translate(${transformX}, ${transformY})`;

          // æ›´æ–°ç®­å¤´æ–¹å‘
          const arrowEl = document.getElementById("indicator-arrow");
          if (arrowEl) {
            // æ ¹æ®æ–¹å‘é€‰æ‹©ç®­å¤´
            const degAngle = (angle * 180) / Math.PI;
            let arrow = "â†’";
            if (degAngle > -22.5 && degAngle <= 22.5) arrow = "â†’";
            else if (degAngle > 22.5 && degAngle <= 67.5) arrow = "â†˜";
            else if (degAngle > 67.5 && degAngle <= 112.5) arrow = "â†“";
            else if (degAngle > 112.5 && degAngle <= 157.5) arrow = "â†™";
            else if (degAngle > 157.5 || degAngle <= -157.5) arrow = "â†";
            else if (degAngle > -157.5 && degAngle <= -112.5) arrow = "â†–";
            else if (degAngle > -112.5 && degAngle <= -67.5) arrow = "â†‘";
            else if (degAngle > -67.5 && degAngle <= -22.5) arrow = "â†—";

            arrowEl.innerText = arrow;
          }
        }

        // æ˜¾ç¤ºç›®çš„åœ°æŠ½å¥–åŠ¨ç”»
        async showDestinationLottery(stations, finalDest) {
          // åˆ›å»ºå…¨å±å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "lottery-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.9)";
          overlay.style.backdropFilter = "blur(8px)";

          overlay.innerHTML = `
            <div class="text-center relative">
                <div class="text-2xl text-gray-400 mb-4">ğŸ² æ­£åœ¨é€‰æ‹©ç›®çš„åœ°...</div>
                <div class="relative overflow-hidden h-32 w-80 mx-auto mb-6 rounded-xl border-4 border-yellow-600 bg-gray-900 shadow-2xl">
                    <div class="absolute inset-x-0 top-0 h-8 bg-gradient-to-b from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 bottom-0 h-8 bg-gradient-to-t from-black to-transparent z-10"></div>
                    <div class="absolute inset-x-0 top-1/2 -translate-y-1/2 h-12 border-y-2 border-yellow-400 bg-yellow-400/10 z-10 box-border"></div>
                    <div id="lottery-scroll" class="absolute inset-x-0 transition-transform" style="top: 50%; transform: translateY(-50%);">
                        <!-- åœ°åä¼šåœ¨è¿™é‡Œæ»šåŠ¨ -->
                    </div>
                </div>
                
                <!-- æ‹‰æ†/ç¡®å®šæŒ‰é’® -->
                <div class="mb-6">
                   <button id="lottery-stop-btn" class="group relative inline-flex items-center justify-center px-8 py-3 text-lg font-black text-white transition-all duration-200 bg-red-600 font-pj rounded-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-600 active:scale-95 shadow-[0_6px_0_rgb(153,27,27)] hover:shadow-[0_4px_0_rgb(153,27,27)] hover:translate-y-1 active:shadow-none active:translate-y-2">
                      <span class="mr-2 text-2xl">ğŸ°</span> ç«‹å³ç¡®å®š
                   </button>
                </div>

                <div id="lottery-result" class="text-5xl font-black text-yellow-400 mb-4 opacity-0 transition-opacity duration-500 transform scale-90"></div>
                <div id="lottery-subtitle" class="text-xl text-gray-300 opacity-0 transition-opacity duration-500">å‡ºå‘å§!</div>
            </div>
        `;

          document.body.appendChild(overlay);

          const scrollContainer = document.getElementById("lottery-scroll");
          const stopBtn = document.getElementById("lottery-stop-btn");

          // åˆ›å»ºæ»šåŠ¨å†…å®¹ï¼ˆæ‰€æœ‰è½¦ç«™åéšæœºæ’åˆ—ï¼Œé‡å¤å¤šæ¬¡ï¼‰
          const allNames = stations.map((s) => s.stationName);
          // æ‰“ä¹±é¡ºåº
          for (let i = allNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allNames[i], allNames[j]] = [allNames[j], allNames[i]];
          }

          // ç¡®ä¿æœ€ç»ˆç›®çš„åœ°åœ¨æœ€å
          const finalIndex = allNames.indexOf(finalDest.stationName);
          if (finalIndex > -1) {
            allNames.splice(finalIndex, 1);
          }

          // åˆ›å»ºæ»šåŠ¨åˆ—è¡¨ï¼ˆé‡å¤å¤šæ¬¡ + æœ€ç»ˆç›®çš„åœ°ï¼‰
          const repeatCount = 4;
          let scrollItems = [];
          for (let i = 0; i < repeatCount; i++) {
            scrollItems = scrollItems.concat([...allNames].sort(() => Math.random() - 0.5));
          }
          scrollItems.push(finalDest.stationName); // æœ€ç»ˆåœåœ¨è¿™é‡Œ

          // æ¸²æŸ“æ»šåŠ¨é¡¹
          const itemHeight = 48;
          scrollContainer.innerHTML = scrollItems
            .map(
              (name, idx) => `
            <div class="h-12 flex items-center justify-center text-2xl font-bold ${name === finalDest.stationName && idx === scrollItems.length - 1 ? "text-yellow-400" : "text-white"}" 
                 style="height: ${itemHeight}px;">${name}</div>
        `
            )
            .join("");

          // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆç¬¬ä¸€ä¸ªé¡¹ç›®åœ¨ä¸­å¿ƒï¼‰
          scrollContainer.style.transform = `translateY(-${itemHeight / 2}px)`;
          scrollContainer.style.transition = "none";

          await wait(100);

          // å¼€å§‹æ»šåŠ¨åŠ¨ç”»
          const totalItems = scrollItems.length;
          const finalOffset = (totalItems - 1) * itemHeight + itemHeight / 2;

          // å…ˆå¿«åæ…¢çš„æ»šåŠ¨æ•ˆæœ
          const duration = 3000;
          scrollContainer.style.transition = `transform ${duration}ms cubic-bezier(0.15, 0.85, 0.35, 1)`;
          scrollContainer.style.transform = `translateY(-${finalOffset}px)`;

          // Promise that resolves when animation should end (either timeout or click)
          let resolveAnimation;
          const animationPromise = new Promise(r => resolveAnimation = r);
          
          let isStopped = false;
          let selectedCity = finalDest; // Default to finalDest

          // Auto stop after duration + buffer
          const autoTimer = setTimeout(() => {
             if(!isStopped) {
                 isStopped = true;
                 resolveAnimation();
             }
          }, duration + 200);

      // Manual stop: pause immediately and wait for second click
      stopBtn.onclick = () => {
        if (!isStopped) {
          isStopped = true;
          clearTimeout(autoTimer);

          // Immediately freeze at the current transform value
          const computed = window.getComputedStyle(scrollContainer).transform;
          let currentY = 0;
          if (computed && computed !== "none") {
            // Handle matrix and matrix3d formats
            const matMatch = computed.match(/matrix.*\((.+)\)/);
            if (matMatch) {
              const values = matMatch[1].split(',');
              if (values.length === 6) {
              // matrix(a, b, c, d, tx, ty)
              currentY = parseFloat(values[5]);
            } else if (values.length === 16) {
              // matrix3d(..., ty at index 13)
              currentY = parseFloat(values[13]);
            }
            }
          } else {
            // Fallback: try to get transform from inline style
            const inlineTransform = scrollContainer.style.transform.match(/translateY\((-?\d+\.?\d*)px\)/);
            if (inlineTransform) currentY = parseFloat(inlineTransform[1]);
          }

          // Snap to nearest item (align to center)
          // currentY is negative. Center of item i is at -(i*h + h/2)
          // i = (-currentY - h/2) / h
          let itemIndex = Math.round((-currentY - itemHeight / 2) / itemHeight);
          // Clamp index
          itemIndex = Math.max(0, Math.min(itemIndex, scrollItems.length - 1));
          
          const snappedY = -(itemIndex * itemHeight + itemHeight / 2);

          // Get the city name at this position
          const cityName = scrollItems[itemIndex];
          selectedCity = stations.find(s => s.stationName === cityName) || finalDest;

          // Freeze at snapped position with smooth transition
          scrollContainer.style.transition = "transform 0.2s ease-out";
          scrollContainer.style.transform = `translateY(${snappedY}px)`;

          // After snap animation, change button text to "ç°åœ¨å‡ºå‘"
          setTimeout(() => {
            stopBtn.innerHTML = '<span class="mr-2 text-2xl">ğŸš€</span> ç°åœ¨å‡ºå‘';
            
            // Wait for second click to continue
            stopBtn.onclick = () => {
              resolveAnimation();
            };
          }, 200);
        }
      };

          // Wait for animation to finish (or be skipped)
          await animationPromise;
          
          // Update finalDest to the selected city
          finalDest = selectedCity;

          // ç›´æ¥æ·¡å‡ºå¹¶è¿”å›æ¸¸æˆ
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();
          
          return finalDest;
        }

        createDestinationMarker(tile) {
          const group = new THREE.Group();

          // å‘å…‰åœ†ç¯
          const ringGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 32);
          const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.y = 0.3;
          group.add(ring);

          // æ——æ†
          const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
          const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
          const pole = new THREE.Mesh(poleGeo, poleMat);
          pole.position.set(1.5, 3, 1.5);
          group.add(pole);

          // æ——å¸œ
          const flagGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
          const flagMat = new THREE.MeshLambertMaterial({ color: 0xff4444, side: THREE.DoubleSide });
          const flag = new THREE.Mesh(flagGeo, flagMat);
          flag.position.set(2.5, 5, 1.5);
          group.add(flag);

          // ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»çš„æ˜Ÿæ˜Ÿ
          const starGeo = new THREE.OctahedronGeometry(0.5, 0);
          const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const star = new THREE.Mesh(starGeo, starMat);
          star.position.y = 3;
          star.userData.baseY = 3;
          star.userData.animate = true;
          group.add(star);

          // å®šä½åˆ°ç›®çš„åœ°æ ¼å­
          group.position.copy(tile.worldPos);
          group.position.y = 1;

          this.scene.add(group);
          this.destinationMarker = group;

          // æ˜Ÿæ˜ŸåŠ¨ç”»
          const animateStar = () => {
            if (!this.destinationMarker) return;
            const star = this.destinationMarker.children.find((c) => c.userData.animate);
            if (star) {
              star.position.y = star.userData.baseY + Math.sin(Date.now() * 0.003) * 0.5;
              star.rotation.y += 0.02;
            }
            requestAnimationFrame(animateStar);
          };
          animateStar();
        }

        // æ˜¾ç¤ºåˆ°è¾¾ç›®çš„åœ°çš„ç»“ç®—åŠ¨ç”»
        async showDestinationArrival(player) {
          if (!this.destinationTile) return;

          const destName = this.destinationTile.stationName;

          // åˆ›å»ºç»“ç®—åŠ¨ç”»å¼¹çª—
          const overlay = document.createElement("div");
          overlay.id = "arrival-overlay";
          overlay.className = "fixed inset-0 flex items-center justify-center z-50";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.backdropFilter = "blur(4px)";

          overlay.innerHTML = `
            <div class="text-center transform scale-0 transition-transform duration-500" id="arrival-content">
                <div class="text-8xl mb-6 animate-bounce">ğŸ†</div>
                <div class="text-4xl font-black text-white mb-4">åˆ°è¾¾ç›®çš„åœ°!</div>
                <div class="text-3xl font-bold text-yellow-400 mb-6">${destName}</div>
                <div class="text-6xl font-mono font-black text-green-400 mb-4">+Â¥${DESTINATION_REWARD}</div>
                <div class="text-xl text-gray-300">${player.name} è·å¾—æ´åŠ©é‡‘!</div>
                <div class="mt-6 flex justify-center gap-2">
                    <span class="text-4xl">ğŸ‰</span>
                    <span class="text-4xl">ğŸŠ</span>
                    <span class="text-4xl">âœ¨</span>
                </div>
            </div>
        `;

          document.body.appendChild(overlay);

          // å¼¹å‡ºåŠ¨ç”»
          await wait(100);
          document.getElementById("arrival-content").style.transform = "scale(1)";

          // æ’­æ”¾é‡‘å¸éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
          this.log(`ğŸ† ${player.name} åˆ°è¾¾ç›®çš„åœ° ${destName}!`, "#22c55e");
          showToast(`ğŸ† ${player.name} è·å¾—æ´åŠ©é‡‘ Â¥${DESTINATION_REWARD}!`, "#22c55e");

          player.money += DESTINATION_REWARD;

          // --- ç©·ç¥é™„èº«é€»è¾‘ ---
          // å¯»æ‰¾è·ç¦»ç›®çš„åœ°æœ€è¿œçš„ç©å®¶ï¼ˆé™¤äº†åˆ°è¾¾è€…ï¼‰
          let maxDist = -1;
          let victim = null;

          // è®¡ç®—æ‰€æœ‰å…¶ä»–ç©å®¶åˆ°å½“å‰ç›®çš„åœ°çš„è·ç¦»
          for (const p of this.players) {
            if (p === player) continue;

            const dist = this.calculateDistanceToDestination(p.currentTile);
            // å¦‚æœæ— æ³•åˆ°è¾¾(-1)ï¼Œè§†ä¸ºæ— ç©·è¿œ
            const effectiveDist = dist === -1 ? 9999 : dist;

            if (effectiveDist > maxDist) {
              maxDist = effectiveDist;
              victim = p;
            } else if (effectiveDist === maxDist) {
              // è·ç¦»ç›¸åŒæ—¶ï¼Œéšæœºé€‰æ‹©
              if (Math.random() > 0.5) victim = p;
            }
          }

          if (victim) {
            // å¦‚æœç©·ç¥å·²ç»åœ¨æŸäººèº«ä¸Šï¼Œä¸”é‚£ä¸ªäººä¸æ˜¯victimï¼Œåˆ™è½¬ç§»
            // å¦‚æœç©·ç¥è¿˜æ²¡å‡ºç°ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰ï¼Œåˆ™é™„èº«victim
            const currentOwner = this.players.find((p) => p.hasBinbougami);
            if (currentOwner !== victim) {
              await wait(500);
              await this.attachBinbougami(victim);
            }
          }

          this.updateUI();

          // ç­‰å¾…åŠ¨ç”»å±•ç¤º
          await wait(2500);

          // æ·¡å‡ºåŠ¨ç”»
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.5s";
          await wait(500);
          overlay.remove();

          // è®¾ç½®æ–°çš„ç›®çš„åœ°
          await this.setNewDestination();
        }

        // --- å¹´åº¦å†³ç®—ç³»ç»Ÿ ---

        advanceTime() {
          this.totalTurns++;
          this.gameMonth++;

          if (this.gameMonth > 12) {
            this.gameMonth = 1;
            this.gameYear++;
          }

          // æ›´æ–°æ—¶é—´æ˜¾ç¤º
          document.getElementById("game-year").innerText = this.gameYear;
          document.getElementById("game-month").innerText = this.gameMonth;

          // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å†³ç®—æœˆï¼ˆ3æœˆï¼‰
          if (this.gameMonth === SETTLEMENT_MONTH) {
            return true; // éœ€è¦å†³ç®—
          }
          return false;
        }

        async performSettlement() {
          this.log(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—å¼€å§‹ï¼`, "#fbbf24");
          showToast(`ğŸ“Š ${this.gameYear}å¹´åº¦å†³ç®—ï¼`, "#fbbf24");

          await wait(500);

          for (const player of this.players) {
            let totalIncome = 0;
            const ownedStations = new Map(); // stationName -> buildingCount

            // ç»Ÿè®¡æ¯ä¸ªè½¦ç«™çš„ç‰©ä»¶
            this.map.forEach((tile) => {
              if (tile.type === "green" && tile.owner === player.id) {
                const stationBuildings = tile.buildings.length;
                if (stationBuildings > 0) {
                  ownedStations.set(tile.stationName, stationBuildings);

                  // è®¡ç®—è¯¥è½¦ç«™çš„æ”¶ç›Š
                  let stationIncome = 0;
                  tile.buildings.forEach((tierIndex) => {
                    stationIncome += BUILDING_INCOME[tierIndex];
                  });

                  // ç‹¬å å¥–åŠ±ï¼šå¦‚æœæ‹¥æœ‰å…¨éƒ¨3ç§ç‰©ä»¶ï¼Œæ”¶ç›Šç¿»å€
                  const isMonopoly = tile.buildings.length === 3;
                  if (isMonopoly) {
                    stationIncome *= 2;
                    this.log(`ğŸ† ${tile.stationName} ç‹¬å åŠ æˆï¼`, "#a855f7");
                  }

                  totalIncome += stationIncome;
                }
              }
            });

            if (totalIncome > 0) {
              player.money += totalIncome;
              this.log(`ğŸ’° ${player.name} æ”¶åˆ°çº¢åˆ© Â¥${totalIncome}`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
              await this.showMoneyChangeDialog(player, totalIncome);
            } else {
              this.log(`${player.name} æ²¡æœ‰ç‰©ä»¶æ”¶ç›Š`, "#9ca3af");
            }
          }

          this.updateUI();
          await wait(500);
        }

        // --- UI & Interaction ---

        log(msg, color = "white") {
          const logEl = document.getElementById("game-log");
          const entry = document.createElement("div");
          entry.innerHTML = `<span style="color:${color}; text-shadow: 1px 1px 0 #000">${msg}</span>`;
          logEl.appendChild(entry);
          if (logEl.children.length > 5) logEl.removeChild(logEl.firstChild);
          setTimeout(() => {
            entry.style.opacity = "0";
            setTimeout(() => entry.remove(), 500);
          }, 4000);
        }

        startTurn() {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          const p = this.players[this.turn];
          document.getElementById("turn-indicator").innerText = `${p.name} çš„å›åˆ`;

          // Center camera on the current player
          this.centerCameraOnPlayer(p);

          const p1Panel = document.getElementById("p1-panel");
          const comPanel = document.getElementById("com-panel");

          p1Panel.style.opacity = this.turn === 0 ? "1" : "0.6";
          p1Panel.style.transform = this.turn === 0 ? "scale(1.05)" : "scale(1)";
          p1Panel.classList.toggle("border-yellow-400", this.turn === 0);

          comPanel.style.opacity = this.turn === 1 ? "1" : "0.6";
          comPanel.style.transform = this.turn === 1 ? "scale(1.05)" : "scale(1)";
          comPanel.classList.toggle("border-yellow-400", this.turn === 1);

          this.state = "IDLE";

          // Check for skip turn (Hibernate)
          if (p.skipNextTurn) {
            p.skipNextTurn = false;
            this.log(`ğŸ’¤ ${p.name} æ­£åœ¨å†¬çœ ï¼Œè·³è¿‡å›åˆ`, "#9ca3af");
            setTimeout(() => this.nextTurn(), 1500);
            return;
          }

          if (p.isAI) {
            document.getElementById("roll-btn").classList.add("hidden");
            document.getElementById("use-card-btn").classList.add("hidden");
            setTimeout(() => this.aiAction(), 1000);
          } else {
            document.getElementById("roll-btn").classList.remove("hidden");
            const useCardBtn = document.getElementById("use-card-btn");
            if (p.cards.length > 0) {
              useCardBtn.classList.remove("hidden");
              useCardBtn.onclick = () => this.openUseCardModal();
            } else {
              useCardBtn.classList.add("hidden");
            }
          }
        }

        async playerRoll() {
          if (this.state !== "IDLE") return;
          document.getElementById("roll-btn").classList.add("hidden");
          await this.processMove();
        }

        async aiAction() {
          this.log("ç”µè„‘æ­£åœ¨æ€è€ƒ...", "#fca5a5");
          await wait(1000);
          await this.processMove();
        }

        async processMove(diceCount = 1) {
          this.state = "MOVING";
          
          const player = this.players[this.turn];
          
          // Use dice animation to roll
          const { results: rolls, total: steps } = await diceAnimation.roll(diceCount);
          
          this.log(`${player.name} æ·å‡ºäº† ${rolls.join("+")} = ${steps} ç‚¹!`, "#fbbf24");

          // Allow changing direction at the start of the turn
          player.previousTile = null;

          let remainingSteps = steps;
          let reachedDestination = false;

          while (remainingSteps > 0) {
            const current = player.currentTile;
            const neighbors = current.neighbors;

            let validNext = neighbors.filter((n) => n !== player.previousTile);
            if (validNext.length === 0 && neighbors.length > 0) {
              validNext = neighbors; // Dead end fallback
            }

            let nextTile = null;

            if (validNext.length === 1) {
              nextTile = validNext[0];
            } else if (validNext.length > 1) {
              if (player.isAI) {
                nextTile = this.chooseBestDirection(validNext);
              } else {
                nextTile = await this.askDirection(player, validNext);
              }
            } else {
              break;
            }

            // Physics Move
            player.previousTile = player.currentTile;
            player.currentTile = nextTile;

            await this.animateMove(player, nextTile.worldPos);

            // --- Binbougami Transfer Check ---
            // Check if we passed another player
            for (const other of this.players) {
              if (other !== player && other.currentTile === player.currentTile) {
                // Collision!
                if (player.hasBinbougami) {
                  // Transfer FROM player TO other
                  this.log(`ğŸ‘» ç©·ç¥ä» ${player.name} è½¬ç§»åˆ°äº† ${other.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(other);
                } else if (other.hasBinbougami) {
                  // Transfer FROM other TO player
                  this.log(`ğŸ‘» ç©·ç¥ä» ${other.name} è½¬ç§»åˆ°äº† ${player.name}ï¼`, "#a855f7");
                  await this.attachBinbougami(player);
                }
              }
            }

            // æ›´æ–°è·ç¦»æ˜¾ç¤º
            this.updateDistanceDisplay();

            // æ£€æŸ¥æ˜¯å¦è·¯è¿‡ç›®çš„åœ°ï¼ˆå³ä½¿è¿˜æœ‰æ­¥æ•°ä¹Ÿç®—åˆ°è¾¾ï¼‰
            if (!reachedDestination && this.destinationTile && nextTile === this.destinationTile) {
              reachedDestination = true;
              await this.showDestinationArrival(player);
            }

            if (nextTile.isColored) {
              remainingSteps--;
            }
          }

          await wait(300);
          await this.triggerTileEvent(player, reachedDestination);
        }

        animateMove(player, targetVec3) {
          if (!this.isUserInteracting) {
            this.cameraLocked = true;
          }
          return new Promise((resolve) => {
            const startPos = player.mesh.position.clone();
            const startTime = Date.now();
            const duration = 300; // ms

            // Simple Hop Animation
            const animateStep = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Linear Interpolation for X/Z
              player.mesh.position.lerpVectors(startPos, targetVec3, progress);

              // Parabolic Arc for Y (Jump)
              // y = 4 * height * x * (1-x) + baseline
              const jumpHeight = 2;
              const baseHeight = 1.5;
              player.mesh.position.y = baseHeight + 4 * jumpHeight * progress * (1 - progress);

              if (progress < 1) {
                requestAnimationFrame(animateStep);
              } else {
                player.mesh.position.copy(targetVec3);
                player.mesh.position.y = baseHeight;
                resolve();
              }
            };
            animateStep();
          });
        }

        async askDirection(player, options) {
          // Center camera on the player before showing direction options
          await this.centerCameraOnPlayer(player, 300);

          // Determine best direction
          let bestTile = null;
          if (this.destinationTile) {
             bestTile = this.chooseBestDirection(options);
          }

          return new Promise((resolve) => {
            const overlay = document.createElement("div");
            overlay.className = "absolute inset-0 pointer-events-auto z-50";
            overlay.id = "direction-overlay";
            document.getElementById("ui-layer").appendChild(overlay);

            options.forEach((tile) => {
              // Lift the icon slightly so it appears on top of the tile
              const targetPos = tile.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
              const screenPos = this.getScreenPosition(targetPos);

              let label = "ğŸ“";
              const dx = tile.gridX - player.currentTile.gridX;
              const dy = tile.gridY - player.currentTile.gridY; // using gridY as Z

                if (dx > 0) label = "â–¶";
                else if (dx < 0) label = "â—€";
                else if (dy > 0) label = "â–¼";
                else if (dy < 0) label = "â–²";

              // Container for positioning (handles centering)
              const container = document.createElement("div");
              container.className = "absolute";
              container.style.left = `${screenPos.x}px`;
              container.style.top = `${screenPos.y}px`;
              container.style.transform = "translate(-50%, -50%)";

              // Button for appearance and interaction (handles animation)
              const btn = document.createElement("button");
              btn.innerText = label;
              
              const isBest = tile === bestTile;
              const baseClass = "w-12 h-12 rounded-full text-2xl shadow-xl border-4 animate-bounce-custom cursor-pointer transition-transform hover:scale-110";
              const colorClass = isBest 
                ? "bg-yellow-400 hover:bg-yellow-300 border-white text-black ring-4 ring-yellow-300 ring-opacity-50" 
                : "bg-blue-300 hover:bg-blue-200 border-white text-black";
              
              btn.className = `${baseClass} ${colorClass}`;
              
              if (isBest) {
                  btn.style.zIndex = "10";
                  // Add a small indicator for "Best"
                  const badge = document.createElement("div");
                  badge.className = "absolute -top-2 -right-2 bg-yellow-300 text-yellow-800 text-xs font-bold px-1 rounded border border-yellow-500";
                  container.appendChild(badge);
              }

              btn.onclick = () => {
                document.getElementById("direction-overlay").remove();
                resolve(tile);
              };

              container.appendChild(btn);

              // Store 3D position on container for frame updates
              container.target3D = targetPos;

              overlay.appendChild(container);
            });
          });
        }

        async showMoneyChangeDialog(player, changeAmount) {
          return new Promise((resolve) => {
            const modal = document.getElementById("money-modal");
            const title = document.getElementById("money-modal-title");
            const amountEl = document.getElementById("money-modal-amount");
            const deltaEl = document.getElementById("money-modal-delta");
            const icon = document.getElementById("money-modal-icon");
            const container = modal.firstElementChild;

            modal.classList.remove("hidden");

            const endMoney = player.money;
            const startMoneyVal = endMoney - changeAmount;

            const isGain = changeAmount > 0;
            const colorClass = isGain ? "text-blue-600" : "text-red-600";
            const borderClass = isGain ? "border-blue-500" : "border-red-500";

            container.className = `bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full border-4 relative text-center transform transition-all scale-100 ${borderClass}`;

            title.innerText = player.name;
            icon.innerText = isGain ? "ğŸ¤‘" : "ğŸ’¸";

            deltaEl.className = `text-3xl font-black mb-2 ${colorClass}`;
            deltaEl.innerText = (isGain ? "+" : "") + "Â¥" + changeAmount;

            // Animation
            const duration = 1500;
            const startTime = Date.now();

            const animate = () => {
              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);
              const ease = 1 - Math.pow(1 - progress, 4); // Ease out

              const currentVal = Math.floor(startMoneyVal + changeAmount * ease);
              amountEl.innerText = "Â¥" + currentVal;

              if (progress < 1) {
                requestAnimationFrame(animate);
              } else {
                amountEl.innerText = "Â¥" + endMoney;
                setTimeout(() => {
                  modal.classList.add("hidden");
                  resolve();
                }, 800);
              }
            };

            animate();
          });
        }

        // --- ç©·ç¥ç³»ç»Ÿæ–¹æ³• ---

        async attachBinbougami(player) {
          // Remove from current owner
          const currentOwner = this.players.find((p) => p.hasBinbougami);
          if (currentOwner) {
            currentOwner.hasBinbougami = false;
            // Remove visual from current owner
            if (currentOwner.binbougamiMesh) {
              // Remove from whichever parent it was attached to
              try {
                if (typeof currentOwner.binbougamiMesh.removeFromParent === "function") currentOwner.binbougamiMesh.removeFromParent();
                else if (currentOwner.binbougamiMesh.parent) currentOwner.binbougamiMesh.parent.remove(currentOwner.binbougamiMesh);
              } catch (e) {
                // swallow
              }
              currentOwner.binbougamiMesh = null;
            }
          }

          // Attach to new player
          player.hasBinbougami = true;
          player.binbougamiTurns = 0;
          player.binbougamiLevel = 0; // Reset to normal

          this.log(`ğŸ‘» ç©·ç¥é™„èº«åœ¨äº† ${player.name} èº«ä¸Šï¼`, "#a855f7");

          // Play possession sequence
          await this.showBinbougamiPossessionSequence(player);

          this.updateUI();
        }

        async showBinbougamiPossessionSequence(player) {
          // 1. Show Fullscreen UI
          const modal = document.getElementById("possession-modal");
          const content = document.getElementById("possession-content");
          const text = document.getElementById("possession-text");

          if (modal && content && text) {
            text.innerText = `${player.name} è¢«ç©·ç¥é™„èº«äº†ï¼`;
            modal.classList.remove("hidden");

            // Trigger animation
            // Force reflow
            void modal.offsetWidth;

            content.classList.remove("scale-0");
            content.classList.add("scale-100");

            // Wait for UI
            await new Promise((resolve) => setTimeout(resolve, 2500));

            // Hide UI
            content.classList.remove("scale-100");
            content.classList.add("scale-0");
            setTimeout(() => {
              modal.classList.add("hidden");
            }, 500);
          }

          // 2. Move Camera to Player
          this.cameraLocked = false;
          await this.centerCameraOnPlayer(player, 800);

          // 3. Create Falling Binbougami
          this.createBinbougamiMesh(player, true);

          // Wait for fall animation (approx 1s)
          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Shake effect (simple camera shake)
          const originalPos = this.camera.position.clone();
          for (let i = 0; i < 10; i++) {
            this.camera.position.x = originalPos.x + (Math.random() - 0.5) * 2;
            this.camera.position.y = originalPos.y + (Math.random() - 0.5) * 2;
            this.camera.position.z = originalPos.z + (Math.random() - 0.5) * 2;
            await new Promise((r) => setTimeout(r, 30));
          }
          this.camera.position.copy(originalPos);

          // Restore camera lock if in game mode
          if (this.mode === "GAME") {
            this.cameraLocked = true;
          }
        }

        createBinbougamiMesh(player, animateFalling = false) {
          if (player.binbougamiMesh) return;

          const group = new THREE.Group();
          // Use a modest world scale so the ghost matches character size
          const scale = 1.2; // slightly bigger than player head

          // Simple Ghost Shape
          const bodyGeo = new THREE.SphereGeometry(0.4, 16, 16);
          const bodyMat = new THREE.MeshLambertMaterial({ color: 0xa855f7 }); // Purple
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 0.5;
          group.add(body);

          // Tail
          const tailGeo = new THREE.ConeGeometry(0.2, 0.6, 16);
          const tail = new THREE.Mesh(tailGeo, bodyMat);
          tail.position.y = 0.1;
          tail.rotation.x = Math.PI;
          group.add(tail);

          // Eyes
          const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
          const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.position.set(-0.15, 0.55, 0.3);
          group.add(leftEye);

          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.position.set(0.15, 0.55, 0.3);
          group.add(rightEye);

          // Apply scale
          group.scale.set(scale, scale, scale);

          // ç®€åŒ–ä½ç½®ç®—æ³•ï¼šç›´æ¥æŒ‚åœ¨ player.mesh ä¸Šï¼Œä½¿ç”¨å›ºå®šé«˜åº¦
          // ç©å®¶æ¨¡å‹é«˜åº¦çº¦ä¸º 3 å•ä½ï¼ˆå¤´é¡¶ hat åœ¨ y=3ï¼‰ï¼Œç©·ç¥æ˜¾ç¤ºåœ¨ y=4.5 çš„ä½ç½®
          const fixedHeight = 4.5;

          // å…ˆé™„åŠ åˆ°ç©å®¶meshå¹¶è®¾ç½®å¼•ç”¨ï¼Œè¿™æ ·åŠ¨ç”»å›è°ƒå¯ä»¥æ­£å¸¸å·¥ä½œ
          player.mesh.add(group);
          player.binbougamiMesh = group;

          if (animateFalling) {
            const startHeight = fixedHeight + 10; // ä»ä¸Šæ–¹10å•ä½è½ä¸‹
            group.position.set(0, startHeight, 0);

            const startTime = Date.now();
            const duration = 600; // 0.6 second fall

            const animateFall = () => {
              if (!player.binbougamiMesh || !group.parent) return;

              const now = Date.now();
              const progress = Math.min((now - startTime) / duration, 1);

              // Quadratic ease in (accelerate)
              const currentY = startHeight - (startHeight - fixedHeight) * (progress * progress);
              group.position.y = currentY;

              if (progress < 1) {
                requestAnimationFrame(animateFall);
              } else {
                group.position.y = fixedHeight;
                this.animateBinbougamiHover(group, fixedHeight);
              }
            };
            animateFall();
          } else {
            group.position.set(0, fixedHeight, 0);
            this.animateBinbougamiHover(group, fixedHeight);
          }
        }

        animateBinbougamiHover(group, baseY) {
          const animate = () => {
            if (!group.parent) return; // Removed from scene

            const time = Date.now() * 0.002;
            group.position.y = baseY + Math.sin(time) * 0.5;
            group.rotation.y = Math.sin(time * 0.5) * 0.2; // Slight rotation

            requestAnimationFrame(animate);
          };
          animate();
        }

        async handleBinbougamiAction(player) {
          if (!player.hasBinbougami) return;

          player.binbougamiTurns++;

          // æ£€æŸ¥æ˜¯å¦å‡çº§ä¸ºå¤§é­”ç‹ (ä¾‹å¦‚8å›åˆå)
          if (player.binbougamiLevel === 0 && player.binbougamiTurns >= BINBOUGAMI_UPGRADE_TURNS) {
            player.binbougamiLevel = 1;
            this.log(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            showToast(`ğŸ‘» ç©·ç¥è¿›åŒ–ä¸ºå¤§é­”ç‹äº†ï¼`, "#ef4444");
            // Update visual to look scarier (scale up, turn red)
            if (player.binbougamiMesh) {
              player.binbougamiMesh.children[0].material.color.setHex(0xef4444); // Red body
              // Scale up modestly for 'king' mode rather than huge value
              player.binbougamiMesh.scale.set(2.4, 2.4, 2.4);
            }
            await wait(1000);
          }

          // å†³å®šæ•ˆæœ
          const effects = player.binbougamiLevel === 1 ? BINBOUGAMI_EFFECTS.king : BINBOUGAMI_EFFECTS.normal;
          const effect = effects[Math.floor(Math.random() * effects.length)];

          // æ˜¾ç¤ºå¼¹çª—
          await this.showBinbougamiDialog(player, effect);

          // æ‰§è¡Œæ•ˆæœ
          switch (effect.type) {
            case "loseMoney":
              const amount = rand(effect.min, effect.max);
              player.money -= amount;
              this.log(`${player.name} æŸå¤±äº† Â¥${amount}`, "#ef4444");
              break;
            case "debt":
              const debt = rand(effect.min, effect.max);
              player.money -= debt;
              this.log(`${player.name} èƒŒè´Ÿäº† Â¥${debt} å€ºåŠ¡`, "#ef4444");
              break;
            case "sellProperty":
              await this.sellRandomProperty(player);
              break;
            case "sellAllProperty":
              // Sell multiple properties
              let count = 0;
              while ((await this.sellRandomProperty(player, false)) && count < 5) {
                count++;
              }
              break;
            case "nothing":
              this.log("ç©·ç¥ä»€ä¹ˆä¹Ÿæ²¡åš", "#9ca3af");
              break;
          }

          this.updateUI();
        }

        async sellRandomProperty(player, showLog = true) {
          // Find owned properties
          const ownedTiles = this.map.filter((t) => t.owner === player.id && t.buildings.length > 0);
          if (ownedTiles.length === 0) {
            if (showLog) this.log("ç©·ç¥æƒ³å–åœ°ï¼Œä½†ä½ ä¸€æ— æ‰€æœ‰...", "#9ca3af");
            return false;
          }

          const tile = ownedTiles[Math.floor(Math.random() * ownedTiles.length)];
          // Sell the most expensive building on this tile
          const buildingIdx = tile.buildings.pop(); // Remove last added

          const sellPrice = Math.floor(BUILDING_COSTS[buildingIdx] / 2);
          player.money += sellPrice;
          player.assets -= BUILDING_COSTS[buildingIdx];

          // If no buildings left, clear owner
          if (tile.buildings.length === 0) {
            tile.owner = null;
          }

          this.removeBuildingVisually(tile);

          if (showLog) this.log(`ç©·ç¥å–æ‰äº† ${tile.stationName} çš„ç‰©ä»¶ï¼Œè·å¾— Â¥${sellPrice}`, "#ef4444");
          return true;
        }

        removeBuildingVisually(stationTile) {
          // Find environment tiles around station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              if (t && !t.isRoad && t.mesh.children.length > 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            // Pick one and remove a child
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            if (target.mesh.children.length > 0) {
              target.mesh.remove(target.mesh.children[target.mesh.children.length - 1]);
            }
          }
        }

        async showBinbougamiDialog(player, effect) {
          return new Promise((resolve) => {
            const modal = document.getElementById("binbougami-modal");
            const title = document.getElementById("binbougami-modal-title");
            const desc = document.getElementById("binbougami-modal-desc");
            const effectEl = document.getElementById("binbougami-modal-effect");
            const hint = document.getElementById("binbougami-modal-hint");

            modal.classList.remove("hidden");

            title.innerText = player.binbougamiLevel === 1 ? "å¤§é­”ç‹é™ä¸´ï¼" : "ç©·ç¥æ¥è¢­ï¼";
            desc.innerText = effect.msg;
            effectEl.innerText = "";
            hint.innerText = "ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...";

            // Auto close after delay
            setTimeout(() => {
              modal.classList.add("hidden");
              resolve();
            }, 2500);
          });
        }

        // --- å¡ç‰Œç³»ç»Ÿæ–¹æ³• ---

        async handleCardStation(player) {
          // Randomly pick a card from pool based on rarity weights
          const r = Math.random();
          let pool = CARD_POOL.common;
          if (r > 0.7) pool = CARD_POOL.rare;
          if (r > 0.95) pool = CARD_POOL.epic;

          const cardKey = pool[Math.floor(Math.random() * pool.length)];
          const card = CARD_TYPES[cardKey];

          // Add to player hand
          if (player.cards.length < MAX_HAND_SIZE) {
            player.cards.push(cardKey);
            this.log(`ğŸ´ ${player.name} è·å¾—äº† [${card.name}]`, "#fbbf24");
            await this.showCardGetDialog(player, card);
          } else {
            this.log(`ğŸ´ ${player.name} æ‰¾åˆ°äº† [${card.name}]ï¼Œä½†æ˜¯æ‰‹ç‰Œæ»¡äº†...`, "#9ca3af");
            showToast("æ‰‹ç‰Œå·²æ»¡ï¼Œæ— æ³•è·å–æ–°å¡ç‰‡", "gray");
          }
        }

        async showCardGetDialog(player, card) {
          return new Promise((resolve) => {
            const modal = document.getElementById("card-modal");
            const content = document.getElementById("card-modal-content");

            modal.classList.remove("hidden");
            content.innerHTML = `
                <div class="text-center">
                    <div class="text-6xl mb-4">${card.icon}</div>
                    <div class="text-3xl font-bold text-gray-800 mb-2">${card.name}</div>
                    <div class="text-gray-600">${card.desc}</div>
                    <div class="mt-4 text-sm text-yellow-600 font-bold">ç¨€æœ‰åº¦: ${card.rarity.toUpperCase()}</div>
                </div>
            `;

            if (player.isAI) {
              setTimeout(() => {
                this.closeCardModal();
                resolve();
              }, 1500);
            } else {
              this._resolveCardModal = resolve;
            }
          });
        }

        closeCardModal() {
          document.getElementById("card-modal").classList.add("hidden");
          if (this._resolveCardModal) {
            this._resolveCardModal();
            this._resolveCardModal = null;
          }
        }

        openUseCardModal() {
          const player = this.players[0]; // Human player
          if (player.cards.length === 0) return;

          const modal = document.getElementById("use-card-modal");
          const list = document.getElementById("use-card-list");
          list.innerHTML = "";

          player.cards.forEach((cardKey, index) => {
            const card = CARD_TYPES[cardKey];
            const div = document.createElement("div");
            div.className = `card-item w-32 p-3 rounded-xl border-2 flex flex-col items-center gap-2 bg-white shadow-md card-rarity-${card.rarity}`;
            div.onclick = () => this.useCard(index);

            div.innerHTML = `
                <div class="text-3xl">${card.icon}</div>
                <div class="font-bold text-sm text-center">${card.name}</div>
                <div class="text-xs text-gray-600 text-center leading-tight">${card.desc}</div>
            `;
            list.appendChild(div);
          });

          modal.classList.remove("hidden");
        }

        closeUseCardModal() {
          document.getElementById("use-card-modal").classList.add("hidden");
        }

        async useCard(cardIndex) {
          this.closeUseCardModal();
          const player = this.players[0];
          const cardKey = player.cards[cardIndex];
          const card = CARD_TYPES[cardKey];

          // Remove card from hand
          player.cards.splice(cardIndex, 1);
          this.updateUI();

          this.log(`ğŸƒ ${player.name} ä½¿ç”¨äº† [${card.name}]`, "#a855f7");

          // Hide buttons
          document.getElementById("roll-btn").classList.add("hidden");
          document.getElementById("use-card-btn").classList.add("hidden");

          // Execute Effect
          if (card.type === "move") {
            await this.processMove(card.diceCount);
          } else if (card.type === "attack") {
            await this.handleAttackCard(player, card);
            this.nextTurn();
          } else if (card.type === "special") {
            await this.handleSpecialCard(player, card);
            this.nextTurn();
          }
        }

        async handleAttackCard(player, card) {
          const target = this.players.find((p) => p !== player); // Simple 1v1 logic

          if (card.effect === "skip") {
            target.skipNextTurn = true;
            this.log(`ğŸ’¤ ${target.name} ä¸‹å›åˆå°†æ— æ³•è¡ŒåŠ¨ï¼`, "#3b82f6");
            showToast(`${target.name} è¿›å…¥å†¬çœ ï¼`, "#3b82f6");
          } else if (card.effect === "blowAway") {
            const randomTile = this.map[Math.floor(Math.random() * this.map.length)];
            target.currentTile = randomTile;
            target.mesh.position.copy(randomTile.worldPos);
            target.mesh.position.y = 1.5;
            this.log(`ğŸ’¨ ${target.name} è¢«å¹é£åˆ°äº†ä¸çŸ¥åçš„åœ°æ–¹ï¼`, "#3b82f6");
            this.updateDistanceDisplay();
          } else if (card.effect === "trap") {
            this.log("é™·é˜±å¡å°šæœªå®è£…", "gray");
          }
          await wait(1000);
        }

        async handleSpecialCard(player, card) {
          if (card.effect === "backward") {
            this.log("åé€€å¡å°šæœªå®è£…", "gray");
          } else if (card.effect === "teleport") {
            const stations = this.map.filter((t) => t.type === "green");
            const target = stations[Math.floor(Math.random() * stations.length)];
            player.currentTile = target;
            player.mesh.position.copy(target.worldPos);
            player.mesh.position.y = 1.5;
            this.log(`ğŸšª ${player.name} ä½¿ç”¨ä»»æ„é—¨ä¼ é€åˆ°äº† ${target.stationName}`, "#a855f7");
            this.updateDistanceDisplay();
          } else if (card.effect === "exorcise") {
            if (player.hasBinbougami) {
              player.hasBinbougami = false;
              if (player.binbougamiMesh) {
                try {
                  if (typeof player.binbougamiMesh.removeFromParent === "function") player.binbougamiMesh.removeFromParent();
                  else if (player.binbougamiMesh.parent) player.binbougamiMesh.parent.remove(player.binbougamiMesh);
                } catch (e) {}
                player.binbougamiMesh = null;
              }
              this.log(`ğŸ“¿ ç©·ç¥è¢«é©±æ•£äº†ï¼`, "#fbbf24");
            } else {
              this.log("ä½ èº«ä¸Šæ²¡æœ‰ç©·ç¥...", "gray");
            }
          }
          await wait(1000);
        }

        async triggerTileEvent(player, alreadyReachedDestination = false) {
          this.state = "EVENT";
          const tile = player.currentTile;
          let endTurn = true;

          // ç›®çš„åœ°åˆ°è¾¾å·²åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­å¤„ç†ï¼Œä¸å†é‡å¤æ£€æŸ¥

          switch (tile.type) {
            case "blue":
              const bonus = rand(500, 2000);
              player.money += bonus;
              this.log(`å¹¸è¿ï¼è·å¾—èµ„é‡‘ Â¥${bonus}`, "#60a5a5");
              await this.showMoneyChangeDialog(player, bonus);
              break;
            case "red":
              const loss = rand(500, 1500);
              player.money -= loss;
              this.log(`å€’éœ‰ï¼æŸå¤± Â¥${loss}`, "#f87171");
              await this.showMoneyChangeDialog(player, -loss);
              break;
            case "yellow":
              await this.handleCardStation(player);
              break;
            case "green":
              endTurn = false;
              await this.handleStation(player, tile);
              break;
          }

          // Handle Binbougami at end of turn
          if (player.hasBinbougami) {
            await wait(500);
            await this.handleBinbougamiAction(player);
          }

          this.updateUI();
          if (endTurn) this.nextTurn();
        }

        spawnFloatingText(pos, text, color) {
          const div = document.createElement("div");
          div.innerText = text;
          div.style.color = color;
          div.className = "absolute text-2xl font-black shadow-white drop-shadow-md pointer-events-none transition-all duration-1000 ease-out";

          const screenPos = this.getScreenPosition(pos);
          div.style.left = screenPos.x + "px";
          div.style.top = screenPos.y + "px";

          document.getElementById("ui-layer").appendChild(div);

          // Animate via CSS
          requestAnimationFrame(() => {
            div.style.transform = "translateY(-50px)";
            div.style.opacity = "0";
          });

          setTimeout(() => div.remove(), 1000);
        }

        async handleStation(player, tile) {
          if (player.isAI) {
            // AIç­–ç•¥ï¼šå°è¯•è´­ä¹°æˆ¿äº§
            const playerProperties = this.generatePlayerProperties(tile);
            
            // ç­›é€‰å¯è´­ä¹°çš„æˆ¿äº§ï¼ˆæœªè´­ä¹° + èƒ½æ”¯ä»˜ï¼‰
            const affordableProperties = playerProperties.filter(
              p => !p.isPurchased && player.money >= p.price * 1.2
            );
            
            if (affordableProperties.length > 0) {
              // é€‰æ‹©æœ€ä¾¿å®œçš„æˆ¿äº§
              const property = affordableProperties.sort((a, b) => a.price - b.price)[0];
              const propertyIndex = playerProperties.indexOf(property);
              
              // æ›´æ–°ç¼“å­˜
              const propertyRecord = getOrCreatePropertyId(tile.stationName, propertyIndex);
              propertyRecord.purchasedBy = player.id;
              propertyRecord.purchasePrice = property.price;
              
              // æ‰§è¡Œè´­ä¹°
              player.money -= property.price;
              player.assets += property.price;
              
              this.log(`ğŸ  ç”µè„‘ ${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, "#fca5a5");
              await wait(800);
            } else {
              this.log("ç”µè„‘æ²¡æœ‰è´­ä¹°æ„å‘", "#9ca3af");
            }
            this.nextTurn();
          } else {
            this.state = "BUYING";
            this.showCityInfoModal(tile);
          }
        }

        playerBuy(tierIndex) {
          // This method is deprecated - use purchaseProperty instead
          // Kept for backward compatibility
          const player = this.players[0];
          const tile = player.currentTile;
          if (tile.buildings.includes(tierIndex) || player.money < BUILDING_COSTS[tierIndex]) return;

          this.doBuy(player, tile, tierIndex);
          this.populatePropertiesAndBuildingsTab(tile);
          this.updateUI();
        }

        doBuy(player, tile, tierIndex) {
          player.money -= BUILDING_COSTS[tierIndex];
          player.assets += BUILDING_COSTS[tierIndex];
          tile.buildings.push(tierIndex);
          tile.buildings.sort();
          tile.owner = player.id;

          this.placeBuildingVisually(tile, tierIndex);
          this.log(`${player.name} è´­ä¹°äº† ${BUILDING_NAMES[tierIndex]}!`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
        }

        placeBuildingVisually(stationTile, tierIndex) {
          // Find a spot near the station
          const range = 2;
          const candidates = [];
          for (let x = stationTile.gridX - range; x <= stationTile.gridX + range; x++) {
            for (let z = stationTile.gridY - range; z <= stationTile.gridY + range; z++) {
              const t = this.tilesMap.get(`${x},${z}`);
              // Must be environment (not road) and empty
              if (t && !t.isRoad && t.mesh.children.length === 0) {
                candidates.push(t);
              }
            }
          }

          if (candidates.length > 0) {
            const target = candidates[Math.floor(Math.random() * candidates.length)];

            const bColor = COLORS.building[tierIndex];
            const h = (tierIndex + 1) * 3; // Height varies by tier

            const bGeo = new THREE.BoxGeometry(2.5, h, 2.5);
            const bMat = new THREE.MeshLambertMaterial({ color: bColor });
            const bMesh = new THREE.Mesh(bGeo, bMat);
            bMesh.position.y = h / 2 + 1; // Adjust for height
            bMesh.castShadow = true;
            bMesh.receiveShadow = true;

            // Add windows texture logic (simplified as black boxes)
            const winGeo = new THREE.BoxGeometry(2.6, h * 0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x334155 });
            const wins = new THREE.Mesh(winGeo, winMat);
            bMesh.add(wins);

            target.mesh.add(bMesh);

            // Juice effect
            const scaleUp = () => {
              bMesh.scale.set(0.1, 0.1, 0.1);
              let s = 0.1;
              const grow = setInterval(() => {
                s += 0.1;
                bMesh.scale.set(s, s, s);
                if (s >= 1) clearInterval(grow);
              }, 16);
            };
            scaleUp();
          }
        }

        onGameClick(event) {
          // Perform raycasting to detect clicked tiles
          const rect = this.renderer.domElement.getBoundingClientRect();
          this.gameMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.gameMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          this.gameRaycaster.setFromCamera(this.gameMouse, this.camera);
          
          // Get all tile meshes
          const tileMeshes = this.map.map((tile) => tile.mesh);
          const intersects = this.gameRaycaster.intersectObjects(tileMeshes);

          if (intersects.length > 0) {
            // Find which tile was clicked
            const clickedMesh = intersects[0].object;
            const clickedTile = this.map.find((tile) => tile.mesh === clickedMesh);
            
            if (clickedTile && clickedTile.type === "green") {
              // Open city info panel in "view-only" mode (no purchase)
              this.showCityInfoModalViewOnly(clickedTile);
            }
          }
        }

        showCityInfoModal(tile) {
          const modal = document.getElementById("city-info-modal");
          this.currentCityInfoTile = tile;
          this.cityInfoPanelMode = "purchase"; // Mark as purchase mode (when stopped at city)
          
          // Update header
          document.getElementById("city-info-title").innerText = tile.stationName;
          document.getElementById("city-info-subtitle").innerText = `äººå£: ${tile.population?.toLocaleString() || 'æœªçŸ¥'} | çº§åˆ«: ${tile.level || 'N/A'}`;
          
          // Show modal
          modal.classList.remove("hidden");
          
          // In purchase mode, show properties tab (merged with buildings)
          this.switchCityInfoTab("properties");
          
          // Populate merged properties & buildings tab
          this.populatePropertiesAndBuildingsTab(tile);
          
          // Also populate info tab for reference
          this.populateCityInfoTab(tile);
          
          // Setup tab switching
          this.setupCityInfoTabs();
        }

        showCityInfoModalViewOnly(tile) {
          // Open city info panel in view-only mode (when clicking from map, not stopped)
          const modal = document.getElementById("city-info-modal");
          this.currentCityInfoTile = tile;
          this.cityInfoPanelMode = "view-only"; // Mark as view-only mode
          
          // Update header
          document.getElementById("city-info-title").innerText = tile.stationName;
          document.getElementById("city-info-subtitle").innerText = `äººå£: ${tile.population?.toLocaleString() || 'æœªçŸ¥'} | çº§åˆ«: ${tile.level || 'N/A'}`;
          
          // Show modal
          modal.classList.remove("hidden");
          
          // Reset to properties tab (merged)
          this.switchCityInfoTab("properties");
          
          // Populate merged properties & buildings tab
          this.populatePropertiesAndBuildingsTab(tile);
          
          // Load city info from LLM (async, no await needed for UI responsiveness)
          this.populateCityInfoTab(tile);
          
          // Setup tab switching
          this.setupCityInfoTabs();
        }

        closeCityInfoModal() {
          document.getElementById("city-info-modal").classList.add("hidden");
          
          // Only proceed to next turn if in purchase mode (stopped at city)
          // In view-only mode (clicked from map), just close the panel
          if (this.cityInfoPanelMode === "purchase") {
            this.nextTurn();
          }
        }

        switchCityInfoTab(tabName) {
          // Hide all tabs
          document.querySelectorAll(".city-info-tab-content").forEach(el => {
            el.classList.add("hidden");
          });
          
          // Remove active border from all buttons
          document.querySelectorAll(".city-info-tab").forEach(btn => {
            btn.classList.remove("border-blue-600", "text-blue-600");
            btn.classList.add("border-transparent", "text-gray-600");
          });
          
          // Show selected tab
          const tabEl = document.getElementById(`city-info-${tabName}-tab`);
          if (tabEl) {
            tabEl.classList.remove("hidden");
          }
          
          // Highlight selected button
          const btnEl = document.querySelector(`.city-info-tab[data-tab="${tabName}"]`);
          if (btnEl) {
            btnEl.classList.remove("border-transparent", "text-gray-600");
            btnEl.classList.add("border-blue-600", "text-blue-600");
          }
        }

        setupCityInfoTabs() {
          document.querySelectorAll(".city-info-tab").forEach(btn => {
            btn.onclick = () => {
              const tabName = btn.dataset.tab;
              this.switchCityInfoTab(tabName);
            };
          });
        }

        populatePropertiesAndBuildingsTab(tile) {
          // Update player money display
          const player = this.players[0];
          document.getElementById("city-info-player-money").innerText = player.money.toLocaleString();
          
          // Show/hide destination indicator
          const destIndicator = document.getElementById("city-info-dest-indicator");
          const isDestination = tile === this.destinationTile;
          if (isDestination) {
            destIndicator.classList.remove("hidden");
          } else {
            destIndicator.classList.add("hidden");
          }
          
          // Get player properties (these are homes available for purchase)
          const container = document.getElementById("city-info-properties-list");
          const emptyDiv = document.getElementById("city-info-empty-properties");
          
          container.innerHTML = "";
          
          // Get player properties (homes from other players)
          const playerProperties = this.generatePlayerProperties(tile);
          
          if (playerProperties.length === 0) {
            container.style.display = "none";
            emptyDiv.style.display = "block";
            return;
          }
          
          emptyDiv.style.display = "none";
          container.style.display = "grid";
          
          // Render all property cards
          playerProperties.forEach((property, index) => {
            const card = document.createElement("div");
            card.className = "bg-white rounded-lg border-2 border-blue-300 overflow-hidden shadow-md hover:shadow-lg transition flex flex-col";
            
            // Check if already purchased
            const isPurchased = property.isPurchased;
            
            // Top section: Home name, price, income, and action button
            const headerBg = isPurchased ? "from-purple-100 to-pink-100" : "from-blue-100 to-cyan-100";
            const borderColor = isPurchased ? "border-purple-400" : "border-blue-400";
            
            let actionBtn = "";
            if (isPurchased) {
              actionBtn = `<span class="text-purple-600 font-bold text-xs whitespace-nowrap">âœ“ è¢« ${property.purchasedByName} è´­ä¹°</span>`;
            } else {
              // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å½“å‰åŸå¸‚ï¼ˆåªæœ‰åœ¨è´­ä¹°æ¨¡å¼ä¸‹ä¸”ç©å®¶åœ¨æ­£ç¡®ä½ç½®æ‰èƒ½è´­ä¹°ï¼‰
              const isPlayerHere = tile.stationName === player.currentTile.stationName && this.cityInfoPanelMode === "purchase";
              const canAfford = player.money >= property.price;
              
              if (isPlayerHere && canAfford) {
                actionBtn = `<button class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-xs font-bold shadow transition" onclick="game.purchaseProperty(${index})">è´­ä¹°</button>`;
              } else if (!isPlayerHere) {
                actionBtn = `<span class="text-gray-400 text-xs font-bold"></span>`;
              } else {
                actionBtn = `<span class="text-red-400 text-xs font-bold">ğŸ’¸ ç¼ºé’±</span>`;
              }
            }
            
            card.className = `bg-white rounded-lg border-2 ${borderColor} overflow-hidden shadow-md hover:shadow-lg transition flex flex-col`;
            card.innerHTML = `
              <!-- Header: Home name, price, income, action button -->
              <div class="bg-gradient-to-br ${headerBg} p-3 flex justify-between items-start gap-2">
                <div class="flex-1 min-w-0">
                  <p class="font-bold text-gray-800 text-base truncate">${property.homeName}</p>
                  <div class="text-xs text-gray-700 mt-1 space-y-0.5">
                    <p>ğŸ’° ä»·æ ¼: <span class="font-bold">Â¥${property.price.toLocaleString()}</span></p>
                    <p>ğŸ“ˆ å¹´æ”¶ç›Š: <span class="font-bold text-green-600">Â¥${property.income || 0}</span></p>
                  </div>
                </div>
                <div class="flex-shrink-0 text-center">
                  ${actionBtn}
                </div>
              </div>
              
              <!-- Footer: Player info (avatar, name, level) -->
              <div class="p-3 flex items-center justify-between bg-gray-50 border-t border-gray-200">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                  <img src="${property.avatar}" alt="å¤´åƒ" class="w-10 h-10 rounded-full border-2 border-blue-400 flex-shrink-0">
                  <div class="min-w-0">
                    <p class="font-bold text-gray-800 text-sm truncate">${property.playerName}</p>
                    <p class="text-xs text-gray-600">ç­‰çº§: ${property.level} â­</p>
                  </div>
                </div>
                <div class="flex-shrink-0">
                  <div class="${property.isOnline ? 'bg-green-500' : 'bg-gray-400'} text-white px-2 py-0.5 rounded-full text-xs font-bold">
                    ${property.isOnline ? 'ğŸŸ¢' : 'âš«'}
                  </div>
                </div>
              </div>
            `;
            
            container.appendChild(card);
          });
          
          // Hide monopoly hint (not applicable for home purchases)
          const monopolyContainer = document.getElementById("city-info-properties-tab").querySelector(".bg-purple-50");
          if (monopolyContainer) {
            monopolyContainer.style.display = "none";
          }
        }

        generatePlayerProperties(tile) {
          // Generate player property data for display with session-persistent ordering
          // éœ€æ±‚: 
          // 1. å·²è´­ä¹°çš„åœ°äº§å§‹ç»ˆç½®é¡¶æ˜¾ç¤º
          // 2. å…¶ä»–åœ°äº§åœ¨ä¸€å±€æ¸¸æˆä¸­ä¿æŒå›ºå®šé¡ºåºï¼ˆé€šè¿‡sessionç¼“å­˜ï¼‰
          // 3. æ¯å±€æ–°æ¸¸æˆæ—¶éšæœºç”Ÿæˆ
          
          const playerNames = ["å°æ˜", "å°çº¢", "è€ç‹", "å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­", "å­™ä¸ƒ", "å‘¨å…«", "å´ä¹"];
          const homeNames = ["æ¢¦å¹»åº„å›­", "ç»¿æ´²å®¶å›­", "å¤©ç©ºä¹‹åŸ", "æ£®æ—å°å±‹", "äº‘ç«¯åˆ«å¢…", "æµ·æ»¨åº¦å‡", "å±±é¡¶åˆ«å¢…", "å¤é•‡æ°‘å®¿", "æ¹–è¾¹å°å±‹", "èŠ±å›­æ´‹æˆ¿"];
          
          const cityName = tile.stationName;
          
          // ç¡®ä¿cityçš„ç¼“å­˜å­˜åœ¨
          if (!this.sessionPropertyCache[cityName]) {
            // é¦–æ¬¡è®¿é—®æ­¤åŸå¸‚ - ç”Ÿæˆéšæœºå±æ€§æ•°é‡å’Œé¡ºåº
            const minProperties = 5;
            const maxProperties = 8;
            const count = Math.floor(Math.random() * (maxProperties - minProperties + 1)) + minProperties;
            
            // åˆ›å»ºå±æ€§ç´¢å¼•æ•°ç»„ [0, 1, 2, ..., count-1]
            const indices = Array.from({length: count}, (_, i) => i);
            
            // ç”Ÿæˆéšæœºç§å­ç”¨äºæ´—ç‰Œ
            const seed = Math.random();
            
            // ä¿å­˜åˆ°ç¼“å­˜ - è¿™æ ·åç»­è®¿é—®åŒä¸€åŸå¸‚æ—¶ä¼šä¿æŒç›¸åŒé¡ºåº
            this.sessionPropertyCache[cityName] = {
              seed: seed,
              totalCount: count,
              displayOrder: indices  // å°†åœ¨ä¸‹æ–¹ä½¿ç”¨
            };
          }
          
          const cachedData = this.sessionPropertyCache[cityName];
          const totalCount = cachedData.totalCount;
          
          // ä¸ºæ‰€æœ‰å±æ€§ç”Ÿæˆæ•°æ®
          const allProperties = [];
          for (let i = 0; i < totalCount; i++) {
            const level = Math.floor(Math.random() * 5) + 1;
            const propertyData = getOrCreatePropertyId(cityName, i);
            
            // Determine if purchased and by whom
            const isPurchased = propertyData.purchasedBy !== null;
            let ownerName = "";
            
            if (isPurchased) {
              const purchaser = this.players.find((p) => p.id === propertyData.purchasedBy);
              ownerName = purchaser ? purchaser.name : "æœªçŸ¥ç©å®¶";
            }
            
            const price = PROPERTY_PRICE_RANGE[0] + Math.floor(Math.random() * (PROPERTY_PRICE_RANGE[1] - PROPERTY_PRICE_RANGE[0]));
            const income = Math.floor((Math.random() * 2000) + 500 * level);
            
            allProperties.push({
              type: "property",
              id: propertyData.id,
              index: i,
              playerId: `P${Math.floor(Math.random() * 10000)}`,
              playerName: playerNames[i % playerNames.length],
              avatar: `https://i.pravatar.cc/150?img=${Math.floor(Math.random() * 70)}`,
              homeName: homeNames[i % homeNames.length],
              level: level,
              price: price,
              income: income,
              isOnline: Math.random() > 0.3,
              isPurchased: isPurchased,
              purchasedBy: propertyData.purchasedBy,
              purchasedByName: ownerName
            });
          }
          
          // åˆ†ç¦»å·²è´­ä¹°å’Œæœªè´­ä¹°çš„å±æ€§
          const purchasedProps = allProperties.filter(p => p.isPurchased);
          const unpurchasedProps = allProperties.filter(p => !p.isPurchased);
          
          // å·²è´­ä¹°çš„å§‹ç»ˆåœ¨å‰ï¼Œæœªè´­ä¹°çš„æŒ‰ç…§sessionä¸­ä¿å­˜çš„é¡ºåºæ˜¾ç¤º
          const result = [...purchasedProps, ...unpurchasedProps];
          
          return result;
        }

        purchaseProperty(propertyIndex) {
          const player = this.players[0];
          const tile = player.currentTile;
          
          // éªŒè¯ç©å®¶æ˜¯å¦åœ¨æ­£ç¡®çš„åŸå¸‚
          // ç¡®ä¿ç©å®¶åªèƒ½è´­ä¹°å½“å‰æ‰€åœ¨åŸå¸‚çš„åœ°äº§
          if (!this.currentCityInfoTile || tile.stationName !== this.currentCityInfoTile.stationName) {
            this.log("åªèƒ½è´­ä¹°å½“å‰æ‰€åœ¨åŸå¸‚çš„åœ°äº§ï¼", "#ef4444");
            return;
          }
          
          // Get the properties list
          const playerProperties = this.generatePlayerProperties(tile);
          if (propertyIndex >= playerProperties.length) return;
          
          const property = playerProperties[propertyIndex];
          
          // Check if already purchased
          if (property.isPurchased) {
            this.log("è¯¥å®¶å›­å·²è¢«è´­ä¹°", "#9ca3af");
            return;
          }
          
          // Check if player has enough money
          if (player.money < property.price) {
            this.log("èµ„é‡‘ä¸è¶³ï¼Œæ— æ³•è´­ä¹°", "#ef4444");
            return;
          }
          
          // Update cache to mark as purchased
          const propertyRecord = getOrCreatePropertyId(tile.stationName, propertyIndex);
          propertyRecord.purchasedBy = player.id;
          propertyRecord.purchasePrice = property.price;
          
          // Purchase the property
          player.money -= property.price;
          player.assets += property.price;
          
          this.log(`${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, player.color === 0x3b82f6 ? "#60a5fa" : "#f87171");
          showToast(`ğŸ  ${player.name} è´­ä¹°äº† ${property.homeName}ï¼`, "#22c55e");
          
          // Refresh the UI
          this.populatePropertiesAndBuildingsTab(tile);
          this.updateUI();
        }

        async populateCityInfoTab(tile) {
          const container = document.getElementById("city-llm-content");
          
          // Check cache first
          if (this.cityInfoCache && this.cityInfoCache[tile.stationName]) {
            container.innerHTML = this.cityInfoCache[tile.stationName];
            return;
          }
          
          // Check if already loading this city to prevent duplicate requests
          if (!this.cityInfoLoadingPromises) {
            this.cityInfoLoadingPromises = {};
          }
          
          if (this.cityInfoLoadingPromises[tile.stationName]) {
            // Already loading, wait for it to complete
            await this.cityInfoLoadingPromises[tile.stationName];
            // After loading completes, render from cache
            if (this.cityInfoCache && this.cityInfoCache[tile.stationName]) {
              container.innerHTML = this.cityInfoCache[tile.stationName];
            }
            return;
          }
          
          try {
            // Show loading state
            container.innerHTML = `
              <div class="text-center py-8">
                <div class="inline-block animate-spin">â³</div>
                <p class="text-gray-600 mt-2">åŠ è½½åŸå¸‚ä¿¡æ¯ä¸­...</p>
              </div>
            `;
            
            // Create a promise for this request and track it
            const loadPromise = this.generateCityInfoFromLLM(tile.stationName, tile.population, tile.level, container);
            this.cityInfoLoadingPromises[tile.stationName] = loadPromise;
            
            // Generate city info using LLM with streaming
            await loadPromise;
            
            // Clean up the loading promise
            delete this.cityInfoLoadingPromises[tile.stationName];
          } catch (error) {
            console.error("Error loading city info:", error);
            container.innerHTML = `
              <div class="text-center py-12">
                <p class="text-red-500 text-xl">åŠ è½½åŸå¸‚ä¿¡æ¯å¤±è´¥</p>
                <p class="text-gray-500 mt-2">${error.message}</p>
              </div>
            `;
            // Clean up the loading promise
            delete this.cityInfoLoadingPromises[tile.stationName];
          }
        }

        async generateCityInfoFromLLM(cityName, population, level, container) {
          // Initialize Keepwork SDK if not already done
          if (!window.sdk) {
            window.sdk = new KeepworkSDK({
              timeout: 30000
            });
            console.log(`Keepwork SDK initialized token: ${window.sdk.token}`);
          }

          const prompt = `è¯·ç”¨ä¸­æ–‡ä¸ºæˆ‘ç”Ÿæˆå…³äºåŸå¸‚"${cityName}"çš„æœ‰è¶£ä¿¡æ¯ã€‚å†…å®¹åº”è¯¥åŒ…æ‹¬ï¼š
1. åŸå¸‚çš„åœ°ç†ä½ç½®å’Œç‰¹ç‚¹ï¼ˆ2-3å¥ï¼‰
2. å†å²èƒŒæ™¯æˆ–æ–‡åŒ–ç‰¹è‰²ï¼ˆ2-3å¥ï¼‰
3. ä¸»è¦æ™¯ç‚¹æˆ–ç‰¹è‰²ï¼ˆ3-4ä¸ªç‚¹ï¼‰
4. ç¾é£Ÿæ–‡åŒ–ï¼ˆ2-3å¥ï¼‰
5. æ—…æ¸¸å»ºè®®ï¼ˆ2-3å¥ï¼‰

è¯·ä½¿ç”¨markdownæ ¼å¼ï¼ŒåŒ…å«æ ‡é¢˜ã€åˆ—è¡¨ç­‰ã€‚å†…å®¹åº”è¯¥é€šä¿—æ˜“æ‡‚ï¼Œæœ‰è¶£ä¸”å‡†ç¡®ã€‚`;

          try {
            // Reuse a single session for all city info requests
            if (!window.sdk || !window.sdk.aiChat) {
              throw new Error("AI chat not available");
            }
            
            // Create session only once and reuse it
            if (!window.cityInfoChatSession) {
              window.cityInfoChatSession = window.sdk.aiChat.createSession({
                stream: true,
              });
            }
            
            const aiChatSession = window.cityInfoChatSession;

            // Use SDK aiChat session to send message and stream response
            let fullResponse = "";
            let lastRenderedResponse = "";
            
            const shouldRenderUpdate = (text) => {
              // Only render if we have at least one complete paragraph or line
              // Look for complete sentences ending with Chinese punctuation or newline
              const lastNewlineIdx = text.lastIndexOf('\n');
              const lastSentenceEnd = Math.max(
                text.lastIndexOf('ã€‚'),
                text.lastIndexOf('ï¼'),
                text.lastIndexOf('ï¼Ÿ'),
                text.lastIndexOf('\n')
              );
              
              // Render if we have meaningful content since last render
              // and either have a complete sentence or significant new content
              const newContent = text.substring(lastRenderedResponse.length);
              const hasCompleteSentence = newContent.includes('ã€‚') || 
                                         newContent.includes('ï¼') || 
                                         newContent.includes('ï¼Ÿ') ||
                                         newContent.includes('\n');
              const significantContent = newContent.length > 50;
              
              return hasCompleteSentence || significantContent;
            };
            
            const renderStreamingContent = (text) => {
              const htmlContent = this.markdownToHtml(text);
              container.innerHTML = htmlContent;
              lastRenderedResponse = text;
            };

            await aiChatSession.send(prompt, {
              onMessage: (partialText, fullResponse) => {
                if (partialText !== undefined && partialText !== null) {
                  fullResponse = partialText;
                  // Only render when we have complete sentences to avoid flickering
                  if (shouldRenderUpdate(fullResponse)) {
                    renderStreamingContent(fullResponse);
                  }
                }
              },
              onComplete: (finalText, fullResponse) => {
                // Final render - always render complete content
                fullResponse = finalText || "";
                if (fullResponse) {
                  renderStreamingContent(fullResponse);
                  
                  // Cache the final result
                  if (!this.cityInfoCache) this.cityInfoCache = {};
                  this.cityInfoCache[cityName] = this.markdownToHtml(fullResponse);
                }
              },
              onError: (error) => {
                throw error;
              },
            });
          } catch (error) {
            console.error("LLM Error:", error);
            // Fallback: render formatted HTML with generic info
            const fallbackContent = this.generateFallbackCityInfo(cityName);
            container.innerHTML = fallbackContent;
            
            // Cache the fallback result
            if (!this.cityInfoCache) this.cityInfoCache = {};
            this.cityInfoCache[cityName] = fallbackContent;
          }
        }

        markdownToHtml(markdown) {
          // Simple markdown to HTML converter
          let html = markdown;
          
          // Headers
          html = html.replace(/^### (.*?)$/gm, '<h3 class="text-2xl font-bold mt-4 mb-2 text-gray-800">$1</h3>');
          html = html.replace(/^## (.*?)$/gm, '<h2 class="text-3xl font-bold mt-6 mb-3 text-gray-900">$1</h2>');
          html = html.replace(/^# (.*?)$/gm, '<h1 class="text-4xl font-bold mt-8 mb-4 text-gray-900">$1</h1>');
          
          // Bold
          html = html.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
          html = html.replace(/__(.*?)__/g, '<strong class="font-bold text-gray-900">$1</strong>');
          
          // Italic
          html = html.replace(/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>');
          html = html.replace(/_(.*?)_/g, '<em class="italic text-gray-700">$1</em>');
          
          // Lists
          html = html.replace(/^\* (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          html = html.replace(/^- (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          html = html.replace(/^\d+\. (.*?)$/gm, '<li class="ml-6 text-gray-700 mb-2">$1</li>');
          
          // Wrap consecutive lists
          html = html.replace(/(<li[^>]*>.*?<\/li>)/gs, (match) => {
            if (!match.includes('<ul') && !match.includes('<ol')) {
              return '<ul class="list-disc">' + match + '</ul>';
            }
            return match;
          });
          
          // Line breaks
          html = html.replace(/\n\n/g, '</p><p class="mb-4 text-gray-700">');
          html = html.replace(/\n/g, '<br>');
          
          // Wrap in paragraph tags if not already wrapped
          if (!html.includes('<p') && !html.includes('<h') && !html.includes('<ul')) {
            html = '<p class="mb-4 text-gray-700">' + html + '</p>';
          }
          
          return `<div class="prose prose-lg max-w-none">${html}</div>`;
        }

        generateFallbackCityInfo(cityName) {
          return `
            <div class="bg-blue-50 rounded-lg p-6">
              <h2 class="text-3xl font-bold mb-4 text-gray-900">ğŸŒ ${cityName}</h2>
              <div class="space-y-4 text-gray-700">
                <p class="text-lg"><strong>ğŸ“ åœ°ç†ä½ç½®ï¼š</strong>è¿™æ˜¯ä¸€ä¸ªå……æ»¡æ´»åŠ›çš„åŸå¸‚ï¼Œæ‹¥æœ‰æ‚ ä¹…çš„å†å²å’Œç°ä»£çš„é­…åŠ›ã€‚</p>
                <p class="text-lg"><strong>ğŸ›ï¸ å†å²æ–‡åŒ–ï¼š</strong>åŸå¸‚èåˆäº†ä¼ ç»Ÿä¸ç°ä»£ï¼Œå±•ç°äº†ç‹¬ç‰¹çš„æ–‡åŒ–ç‰¹è‰²ã€‚</p>
                <p class="text-lg"><strong>ğŸ¯ ä¸»è¦æ™¯ç‚¹ï¼š</strong></p>
                <ul class="list-disc ml-8 space-y-2">
                  <li>å†å²é—è¿¹å’Œå¤å»ºç­‘</li>
                  <li>ç°ä»£è‰ºæœ¯å’Œæ–‡åŒ–ä¸­å¿ƒ</li>
                  <li>è‡ªç„¶é£æ™¯å’Œå…¬å›­</li>
                  <li>ç¹åçš„å•†ä¸šè¡—åŒº</li>
                </ul>
                <p class="text-lg"><strong>ğŸœ ç¾é£Ÿæ–‡åŒ–ï¼š</strong>åŸå¸‚æ‹¥æœ‰ä¸°å¯Œçš„ç¾é£Ÿæ–‡åŒ–ï¼Œèåˆäº†ä¼ ç»Ÿå’Œå›½é™…é£å‘³ã€‚</p>
                <p class="text-lg"><strong>âœˆï¸ æ—…æ¸¸å»ºè®®ï¼š</strong>æœ€ä½³è®¿é—®å­£èŠ‚æ˜¯æ˜¥å­£å’Œç§‹å­£ï¼Œå»ºè®®åœç•™3-5å¤©ä»¥å……åˆ†ä½“éªŒåŸå¸‚çš„é­…åŠ›ã€‚</p>
              </div>
            </div>
          `;
        }

        async nextTurn() {
          // æ—¶é—´æ¨è¿›ï¼ˆæ¯ä¸¤ä¸ªå›åˆï¼ˆP1+COMå„èµ°ä¸€æ¬¡ï¼‰ç®—ä¸€ä¸ªæœˆï¼‰
          // è¿™é‡Œæ¯ä¸ªç©å®¶å›åˆç»“æŸåï¼Œå¦‚æœæ˜¯COMå›åˆç»“æŸï¼Œåˆ™æ¨è¿›ä¸€ä¸ªæœˆ
          if (this.turn === 1) {
            // COMåˆšç»“æŸå›åˆ
            const needSettlement = this.advanceTime();
            if (needSettlement) {
              await this.performSettlement();
            }
          }

          this.turn = (this.turn + 1) % 2;
          this.startTurn();
        }

        updateUI() {
          const p1 = this.players[0];
          const com = this.players[1];
          document.getElementById("p1-money").innerText = p1.money.toLocaleString();
          document.getElementById("com-money").innerText = com.money.toLocaleString();

          // Update Binbougami Indicators
          const p1Binbougami = document.getElementById("p1-binbougami");
          const comBinbougami = document.getElementById("com-binbougami");

          if (this.players[0].hasBinbougami) p1Binbougami.classList.remove("hidden");
          else p1Binbougami.classList.add("hidden");

          if (this.players[1].hasBinbougami) comBinbougami.classList.remove("hidden");
          else comBinbougami.classList.add("hidden");

          // Update Hand Panel (for P1)
          const handPanel = document.getElementById("card-hand-panel");
          const handContainer = document.getElementById("card-hand");

          if (this.turn === 0 && !this.players[0].isAI && this.players[0].cards.length > 0) {
            handPanel.classList.remove("hidden");
            handContainer.innerHTML = "";
            this.players[0].cards.forEach((cardKey, index) => {
              const card = CARD_TYPES[cardKey];
              const div = document.createElement("div");
              div.className = `flex-shrink-0 w-16 h-20 bg-white rounded border-2 flex flex-col items-center justify-center cursor-pointer hover:scale-110 transition-transform card-rarity-${card.rarity}`;
              div.title = `${card.name}: ${card.desc}`;
              div.onclick = () => this.useCard(index);
              div.innerHTML = `<div class="text-2xl">${card.icon}</div><div class="text-[10px] font-bold truncate w-full text-center">${card.name}</div>`;
              handContainer.appendChild(div);
            });
          } else {
            handPanel.classList.add("hidden");
          }

          // æ›´æ–°è·ç¦»æ˜¾ç¤º
          this.updateDistanceDisplay();
        }

        // --- Rendering Loop ---

        getScreenPosition(vec3) {
          const v = vec3.clone();
          v.project(this.camera);
          const x = (v.x * 0.5 + 0.5) * this.width;
          const y = (-(v.y * 0.5) + 0.5) * this.height;
          return { x, y };
        }

        centerCameraOnPlayer(player, duration = 500) {
          return new Promise((resolve) => {
            if (!player || !player.mesh) {
              resolve();
              return;
            }

            const targetPos = player.mesh.position.clone();
            const startTarget = this.controls.target.clone();
            const startCamPos = this.camera.position.clone();

            // Calculate camera offset from current target
            const offset = startCamPos.clone().sub(startTarget);
            const endCamPos = targetPos.clone().add(offset);

            const startTime = Date.now();

            const animateCamera = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(elapsed / duration, 1);

              // Ease out cubic for smooth deceleration
              const eased = 1 - Math.pow(1 - progress, 3);

              this.controls.target.lerpVectors(startTarget, targetPos, eased);
              this.camera.position.lerpVectors(startCamPos, endCamPos, eased);

              if (progress < 1) {
                requestAnimationFrame(animateCamera);
              } else {
                resolve();
              }
            };

            animateCamera();
          });
        }

        // Focus camera on a specific player by index (0 = P1, 1 = COM)
        focusOnPlayer(playerIndex) {
          if (this.mode !== "GAME") return;
          if (playerIndex < 0 || playerIndex >= this.players.length) return;

          const player = this.players[playerIndex];
          if (!player || !player.mesh) return;

          // Temporarily disable camera lock to allow manual focus
          this.cameraLocked = false;

          // Center camera on the selected player
          this.centerCameraOnPlayer(player, 400);
        }

        // æ˜¾ç¤ºç©å®¶è¯¦æƒ…å¼¹çª—
        showPlayerDetail(playerIndex) {
          if (playerIndex < 0 || playerIndex >= this.players.length) return;
          
          const player = this.players[playerIndex];
          this.currentDetailPlayer = playerIndex;
          
          const modal = document.getElementById("player-detail-modal");
          const content = document.getElementById("player-detail-content");
          const colorDiv = document.getElementById("player-detail-color");
          const nameEl = document.getElementById("player-detail-name");
          const binbougamiEl = document.getElementById("player-detail-binbougami");
          const moneyEl = document.getElementById("player-detail-money");
          const assetsEl = document.getElementById("player-detail-assets");
          const distanceEl = document.getElementById("player-detail-distance");
          const cardsEl = document.getElementById("player-detail-cards");
          
          // è®¾ç½®è¾¹æ¡†é¢œè‰²
          const borderColor = playerIndex === 0 ? "border-blue-400" : "border-red-400";
          content.className = `bg-gradient-to-b from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl max-w-sm w-full border-4 ${borderColor} relative`;
          
          // è®¾ç½®é¢œè‰²åœ†ç‚¹
          colorDiv.style.backgroundColor = playerIndex === 0 ? "#60a5fa" : "#ef4444";
          
          // è®¾ç½®åå­—
          nameEl.textContent = player.name;
          
          // ç©·ç¥çŠ¶æ€
          if (player.hasBinbougami) {
            binbougamiEl.classList.remove("hidden");
          } else {
            binbougamiEl.classList.add("hidden");
          }
          
          // è®¾ç½®æ•°æ®
          moneyEl.textContent = "Â¥" + player.money.toLocaleString();
          assetsEl.textContent = "Â¥" + player.assets.toLocaleString();
          cardsEl.textContent = player.cards.length;
          
          // è·ç¦»
          if (this.destinationTile && player.currentTile) {
            const distance = this.calculateDistanceToDestination(player.currentTile);
            distanceEl.textContent = distance >= 0 ? distance + " æ ¼" : "--";
          } else {
            distanceEl.textContent = "--";
          }
          
          modal.classList.remove("hidden");
        }
        
        // å…³é—­ç©å®¶è¯¦æƒ…å¼¹çª—
        closePlayerDetailModal() {
          document.getElementById("player-detail-modal").classList.add("hidden");
        }

        onResize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          // Update Game Camera
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();

          // Update Map Camera
          if (this.worldMap) {
            this.worldMap.camera.aspect = this.width / this.height;
            this.worldMap.camera.updateProjectionMatrix();
          }

          this.renderer.setSize(this.width, this.height);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          if (this.mode === "MAP") {
            if (this.worldMap) {
              this.worldMap.update();
              this.renderer.render(this.worldMap.scene, this.worldMap.camera);
            }
            return;
          }

          // Camera Follow Logic
          if (this.cameraLocked) {
            const activePlayer = this.players[this.turn];
            if (activePlayer && activePlayer.mesh) {
              const targetPos = activePlayer.mesh.position;

              // Smoothly move both target and camera to maintain angle
              const currentTarget = this.controls.target.clone();
              const newTarget = currentTarget.clone().lerp(targetPos, 0.1);
              const delta = new THREE.Vector3().subVectors(newTarget, currentTarget);

              this.camera.position.add(delta);
              this.controls.target.copy(newTarget);
            }
          }

          if (this.controls) this.controls.update();

          // Update Station Labels
          this.map.forEach((tile) => {
            if (tile.labelElement) {
              // Only update if visible (optional optimization)
              const pos = this.getScreenPosition(tile.mesh.position);
              const offset = tile.labelOffset || { x: 0, y: -30, align: "center" };

              // Apply position based on label alignment
              let transform;
              if (offset.align === "left") {
                // Label on right side of station, align left edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(0%, -50%)`;
              } else if (offset.align === "right") {
                // Label on left side of station, align right edge
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-100%, -50%)`;
              } else {
                // Label on top (default), center aligned
                transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px) translate(-50%, -100%)`;
              }
              tile.labelElement.style.transform = transform;

              // Hide if offscreen
              if (pos.x < 0 || pos.x > this.width || pos.y < 0 || pos.y > this.height) {
                tile.labelElement.style.opacity = "0";
              } else {
                tile.labelElement.style.opacity = "1";
              }
            }
          });

          // Update off-screen destination indicator
          this.updateDestinationIndicator();

          // Update Overlay Buttons if active
          const overlay = document.getElementById("direction-overlay");
          if (overlay) {
            Array.from(overlay.children).forEach((btn) => {
              if (btn.target3D) {
                const screenPos = this.getScreenPosition(btn.target3D);
                btn.style.left = `${screenPos.x}px`;
                btn.style.top = `${screenPos.y}px`;
              }
            });
          }

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Boot
      window.onload = async () => {
        // Initialize game first (starts rendering loop and rotating earth)
        window.game = new Game();

        // Load cities data for world map
        await loadCitiesData();

        // Load station data for game map (full city info with lat/lng/population)
        await loadStationData();

        // Render map objects (cities, continents) after data is loaded
        if (window.game.worldMap) {
          window.game.worldMap.renderMapObjects();
        }
      };
    </script>
  </body>
</html>
