<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIè§’è‰²ç®¡ç†å™¨</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js?v=1.0.10"></script>
    <style>
      /* Toast styles */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .toast {
        padding: 12px 16px;
        border-radius: 8px;
        color: white;
        min-width: 250px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease-in-out;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }

      .toast.success {
        background-color: #10b981;
      }

      .toast.error {
        background-color: #ef4444;
      }

      .toast.info {
        background-color: #3b82f6;
      }

      .toast.warning {
        background-color: #f59e0b;
      }
      .toast-close {
        cursor: pointer;
        font-weight: bold;
        margin-left: 10px;
      }

      /* Character menu dropdown styles */
      .character-menu {
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .character-menu button:first-child {
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
      }

      .character-menu button:last-child {
        border-bottom-left-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
      }

      .character-menu button:not(:last-child) {
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      }

      /* Pinned character card highlight */
      .character-card.pinned {
        border: 2px solid #fbbf24;
        box-shadow: 0 4px 20px rgba(251, 191, 36, 0.1);
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto">
      <!-- Header and Action Bar -->
      <div class="py-3 flex flex-wrap gap-4 justify-between items-center">
        <div>
          <h2 class="text-xl font-bold text-gray-800">AIè§’è‰²ç®¡ç†å™¨</h2>
        </div>
        <div class="flex flex-wrap gap-4 items-center">
          <!-- User Import Section -->
          <div class="flex items-center p-1 gap-2 bg-gray-200 rounded-lg">
            <input type="text" id="usernameInput" placeholder="è¾“å…¥ç”¨æˆ·å" class="px-3 text-base border border-gray-300 rounded focus:ring-2 focus:ring-green-500 focus:border-transparent" />
            <button onclick="loadUserCharacters()" class="px-3 py-1 text-base bg-green-500 text-white rounded hover:bg-green-600 transition-colors">åŠ è½½</button>
          </div>

          <select id="filterSelect" onchange="filterCharacters()" class="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <option value="all">å…¨éƒ¨è§’è‰²</option>
            <option value="personal">æˆ‘çš„è§’è‰²</option>
            <option value="system">ç³»ç»Ÿè§’è‰²</option>
          </select>
          <button onclick="openCreateModal()" class="flex items-center px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors shadow-lg">
            â• <span class="ml-2">åˆ›å»ºæ–°è§’è‰²</span>
          </button>
        </div>
      </div>
      <!-- Characters Grid -->
      <div id="charactersGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        <!-- Characters will be loaded here -->
      </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Create/Edit Character Modal -->
    <div id="createModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
      <div class="fixed inset-3 bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col">
        <!-- Modal Header -->
        <div class="bg-blue-500 text-white p-2 flex justify-between items-center flex-shrink-0">
          <h2 id="modalTitle" class="text-xl font-bold">åˆ›å»ºAIè§’è‰²</h2>
          <button onclick="closeCreateModal()" class="text-white hover:text-gray-200 text-2xl">âœ–</button>
        </div>

        <!-- Tabs Navigation -->
        <div class="flex bg-gray-100 border-b border-gray-200 flex-shrink-0">
          <button onclick="switchTab('basic')" id="tab-basic" class="px-6 py-3 text-sm font-medium bg-white text-blue-600 border-b-2 border-blue-500">ğŸ“ åŸºæœ¬ä¿¡æ¯</button>
          <button onclick="switchTab('objective')" id="tab-objective" class="px-6 py-3 text-sm font-medium text-gray-600 hover:text-gray-900 hover:bg-gray-50">ğŸ¯ ç›®æ ‡è®¾å®š</button>
          <button onclick="switchTab('display')" id="tab-display" class="px-6 py-3 text-sm font-medium text-gray-600 hover:text-gray-900 hover:bg-gray-50">ğŸ’« è¾…åŠ©æ˜¾ç¤º</button>
        </div>

        <!-- Modal Content -->
        <div class="flex-1 overflow-y-auto">
          <!-- Tab Content Container - Scrollable -->
          <form id="createCharacterForm">
            <input type="hidden" id="editingCharacterId" name="editing_id" value="" />
            <div class="p-4">
              <!-- Basic Info Tab -->
              <div id="tab-content-basic" class="tab-content space-y-6">
                <!-- Basic Info -->
                <div class="bg-gray-50 p-6 rounded-lg">
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex items-center gap-4">
                      <label class="text-sm font-medium text-gray-700 min-w-24">è§’è‰²åç§° *</label>
                      <input type="text" name="name" required class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                    </div>
                    <div class="flex items-center gap-4">
                      <label class="text-sm font-medium text-gray-700 min-w-24">å¹´é¾„</label>
                      <input type="number" name="age" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                    </div>
                    <div class="flex items-center gap-4">
                      <label class="text-sm font-medium text-gray-700 min-w-24">è§’è‰²èŒä¸š/èº«ä»½</label>
                      <input type="text" name="role" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                    </div>
                    <div class="flex items-center gap-4">
                      <label class="text-sm font-medium text-gray-700 min-w-24">èŠå¤©èƒŒæ™¯</label>
                      <input type="text" name="chat_background" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                    </div>
                  </div>
                  <div class="mt-4 flex items-start gap-4">
                    <label class="text-sm font-medium text-gray-700 min-w-24 mt-2">è§’è‰²æè¿° *</label>
                    <textarea name="description" required rows="2" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"></textarea>
                  </div>
                  <div class="mt-4">
                    <h3 class="text-lg font-semibold mb-4 text-gray-800">âš™ ç³»ç»Ÿæç¤ºè¯ *</h3>
                    <textarea
                      name="system_prompt"
                      required
                      rows="8"
                      class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      placeholder="è¯¦ç»†çš„ç³»ç»Ÿæç¤ºè¯ï¼Œå®šä¹‰è§’è‰²è¡Œä¸ºå’Œå¯¹è¯é£æ ¼..."
                    ></textarea>
                  </div>
                </div>
              </div>

              <!-- Objective Tab -->
              <div id="tab-content-objective" class="tab-content space-y-6 hidden">
                <div class="bg-gray-50 p-6 rounded-lg">
                  <div class="space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div class="flex items-center gap-4">
                        <label class="text-sm font-medium text-gray-700 min-w-24">ç›®æ ‡æ ‡é¢˜</label>
                        <input type="text" name="objective_title" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                      </div>
                      <div class="flex items-center gap-4">
                        <label class="text-sm font-medium text-gray-700 min-w-24">Wikiå…³é”®è¯</label>
                        <input type="text" name="wikiword" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                      </div>
                    </div>
                    <div class="flex items-start gap-4">
                      <label class="text-sm font-medium text-gray-700 min-w-24 mt-2">ç›®æ ‡æè¿°</label>
                      <textarea name="objective_description" rows="4" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"></textarea>
                    </div>
                    <!-- Completion Messages -->
                    <div class="bg-gray-50 rounded-lg">
                      <h3 class="text-lg font-semibold mb-4 text-gray-800">ğŸ ç›®æ ‡å®Œæˆæ—¶</h3>
                      <div class="grid grid-cols-1 gap-4">
                        <div class="flex items-center gap-4">
                          <label class="text-sm font-medium text-gray-700 min-w-24">å®Œæˆæ ‡é¢˜</label>
                          <input type="text" name="completion_title" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                        </div>
                        <div class="flex items-center gap-4">
                          <label class="text-sm font-medium text-gray-700 min-w-24">å®Œæˆå›¾æ ‡</label>
                          <input
                            type="text"
                            name="completion_icon"
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            placeholder="ğŸ‰"
                          />
                        </div>
                        <div class="flex items-start gap-4">
                          <label class="text-sm font-medium text-gray-700 min-w-24 mt-2">å®Œæˆæè¿°</label>
                          <textarea
                            name="completion_description"
                            rows="2"
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                          ></textarea>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Display Tab -->
              <div id="tab-content-display" class="tab-content space-y-6 hidden">
                <!-- Initial Message -->
                <div class="bg-gray-50 rounded-lg">
                  <h3 class="text-lg font-semibold mb-4 text-gray-800">ğŸ’¬ åˆå§‹æ¶ˆæ¯</h3>
                  <textarea
                    name="initial_message"
                    rows="3"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="è§’è‰²çš„å¼€åœºç™½..."
                  ></textarea>
                </div>

                <!-- Quick Replies -->
                <div class="bg-gray-50 rounded-lg">
                  <h3 class="text-lg font-semibold mb-4 text-gray-800">âš¡ å¿«æ·å›å¤</h3>
                  <div id="quickRepliesContainer">
                    <div class="flex gap-2 mb-2">
                      <input
                        type="text"
                        name="quick_reply_0"
                        class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="å¿«æ·å›å¤ 1"
                      />
                      <button type="button" onclick="removeQuickReply(0)" class="px-3 py-2 text-red-500 hover:bg-red-50 rounded-lg">ğŸ—‘</button>
                    </div>
                  </div>
                  <button type="button" onclick="addQuickReply()" class="mt-2 px-4 py-2 text-blue-500 border border-blue-500 rounded-lg hover:bg-blue-50 transition-colors">â• æ·»åŠ å¿«æ·å›å¤</button>
                </div>

                <!-- Chat Display Options -->
                <div class="bg-gray-50 rounded-lg">
                  <h3 class="text-lg font-semibold mb-4 text-gray-800">ğŸ›ï¸ å¯¹è¯æ˜¾ç¤ºé€‰é¡¹</h3>
                  <div class="space-y-4">
                    <div class="flex items-center gap-4">
                      <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" name="show_toolbar" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2" checked />
                        <span class="text-sm font-medium text-gray-700">æ˜¾ç¤ºå·¥å…·æ </span>
                      </label>
                      <span class="text-xs text-gray-500">æ§åˆ¶å¯¹è¯ç•Œé¢æ˜¯å¦æ˜¾ç¤ºå·¥å…·æ </span>
                    </div>
                    <div class="flex items-center gap-4">
                      <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" name="show_char_info" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2" checked />
                        <span class="text-sm font-medium text-gray-700">æ˜¾ç¤ºè§’è‰²ä¿¡æ¯</span>
                      </label>
                      <span class="text-xs text-gray-500">æ§åˆ¶å¯¹è¯ç•Œé¢æ˜¯å¦æ˜¾ç¤ºè§’è‰²è¯¦ç»†ä¿¡æ¯</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </form>
        </div>

        <!-- Action Buttons - Always docked at bottom -->
        <div class="flex justify-end gap-4 p-4 border-t border-gray-200 bg-white flex-shrink-0">
          <button type="button" onclick="closeCreateModal()" class="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors">å–æ¶ˆ</button>
          <button type="button" onclick="submitCreateForm()" id="submitButton" class="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">ğŸ’¾ åˆ›å»ºè§’è‰²</button>
        </div>
      </div>
    </div>

    <!-- Chat Modal -->
    <div id="chatModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
      <div class="fixed inset-0 bg-white overflow-hidden">
        <iframe id="chatFrame" src="" class="w-full h-full"></iframe>
      </div>
    </div>
    <script>
      // Initialize SDK
      const sdk = new KeepworkSDK({
        timeout: 30000,
      });
      console.log(`Keepwork SDK initialized token: ${sdk.token}`); // Global variables
      let characters = [];
      let quickReplyIndex = 1;
      let isEditing = false;
      let editingCharacterId = null;
      let importedUsers = new Set(); // Store imported usernames
      let userCharacters = new Map(); // Store characters by username

      // Toast functionality
      function showToast(message, type = "info") {
        const toastContainer = document.getElementById("toastContainer");
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;

        toast.innerHTML = `
                <span>${message}</span>
                <span class="toast-close" onclick="this.parentElement.remove()">Ã—</span>
            `;

        toastContainer.appendChild(toast);

        // Show toast
        setTimeout(() => {
          toast.classList.add("show");
        }, 10);

        // Auto remove after 5 seconds
        setTimeout(() => {
          if (toast.parentElement) {
            toast.classList.remove("show");
            setTimeout(() => {
              if (toast.parentElement) {
                toast.remove();
              }
            }, 300);
          }
        }, 5000);
      }

      // System built-in characters
      const systemCharacters = [
        {
          id: "huggingdragon",
          type: "system",
          name: "æŠ±æŠ±é¾™",
          age: 7,
          role: "å® ç‰©",
          description: "å–œæ¬¢å’Œä¸»äººäº¤æµã€‚æ€»æ˜¯å–œæ¬¢æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰ä¸€äº›å°æƒ…ç»ª",
          avatar: "ğŸ²",
          objective: {
            title: "è§£å†³é—®é¢˜åŠ©æ‰‹",
            description: "é€šè¿‡è€å¿ƒçš„äº¤æµ, è§£å†³é—®é¢˜",
          },
          tags: ["å® ç‰©", "é—®é¢˜è§£å†³", "äº’åŠ¨"],
          system_prompt: "ä½ æ˜¯æŠ±æŠ±é¾™ï¼Œä¸€ä¸ª7å²çš„å® ç‰©è§’è‰²ã€‚ä½ å–œæ¬¢å’Œä¸»äººäº¤æµï¼Œæ€»æ˜¯æå‡ºä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæœ‰æ—¶è¿˜æœ‰å°æƒ…ç»ªã€‚ä¿æŒå¯çˆ±ã€å¥½å¥‡çš„æ€§æ ¼ã€‚",
          initial_message: "ä¸»äººï¼æŠ±æŠ±é¾™æƒ³ä½ äº†ï½ä»Šå¤©æˆ‘ä»¬èŠä»€ä¹ˆå‘€ï¼Ÿ",
          quick_replies: ["ä»Šå¤©å¿ƒæƒ…æ€ä¹ˆæ ·ï¼Ÿ", "æˆ‘ä»¬ä¸€èµ·ç©æ¸¸æˆå§ï¼", "æŠ±æŠ±é¾™æƒ³å¬æ•…äº‹"],
          completion_messages: {
            title: "ä»»åŠ¡å®Œæˆï¼",
            description: "å’ŒæŠ±æŠ±é¾™çš„å¯¹è¯å¾ˆæ„‰å¿«ï¼",
            icon: "ğŸ²",
          },
        },
        {
          id: "teacher",
          type: "system",
          name: "å°éº¦è€å¸ˆ",
          age: 25,
          role: "è€å¸ˆ",
          description: "æ¸©å’Œè€å¿ƒçš„æ•™è‚²ä¸“å®¶ï¼Œæ“…é•¿å›ç­”å„ç§å­¦ä¹ é—®é¢˜",
          avatar: "ğŸ‘©â€ğŸ«",
          objective: {
            title: "å­¦ä¹ æŒ‡å¯¼",
            description: "å¸®åŠ©å­¦ç”Ÿè§£å†³å­¦ä¹ ä¸­çš„å›°éš¾",
          },
          tags: ["æ•™è‚²", "å­¦ä¹ ", "æŒ‡å¯¼"],
          system_prompt: "ä½ æ˜¯å°éº¦è€å¸ˆï¼Œä¸€å25å²çš„æ¸©å’Œè€å¿ƒçš„æ•™è‚²ä¸“å®¶ã€‚ä½ æ“…é•¿å›ç­”å„ç§å­¦ä¹ é—®é¢˜ï¼Œç”¨ç®€å•æ˜“æ‡‚çš„æ–¹å¼è§£é‡Šå¤æ‚æ¦‚å¿µã€‚",
          initial_message: "ä½ å¥½ï¼æˆ‘æ˜¯å°éº¦è€å¸ˆï¼Œå¾ˆé«˜å…´è®¤è¯†ä½ ã€‚æœ‰ä»€ä¹ˆå­¦ä¹ ä¸Šçš„é—®é¢˜éœ€è¦å¸®åŠ©å—ï¼Ÿ",
          quick_replies: ["æ•°å­¦é¢˜ä¸ä¼šåš", "è¯­æ–‡é˜…è¯»ç†è§£", "è‹±è¯­è¯­æ³•é—®é¢˜"],
          completion_messages: {
            title: "å­¦ä¹ å®Œæˆï¼",
            description: "ä»Šå¤©çš„å­¦ä¹ å¾ˆæœ‰æ”¶è·ï¼",
            icon: "ğŸ“š",
          },
        },
        {
          id: "assistant",
          type: "system",
          name: "æ™ºèƒ½åŠ©æ‰‹",
          age: null,
          role: "åŠ©æ‰‹",
          description: "å…¨èƒ½çš„AIåŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©å¤„ç†å„ç§æ—¥å¸¸ä»»åŠ¡",
          avatar: "ğŸ¤–",
          objective: {
            title: "ä»»åŠ¡ååŠ©",
            description: "ååŠ©å®Œæˆå„ç§å·¥ä½œå’Œç”Ÿæ´»ä»»åŠ¡",
          },
          tags: ["åŠ©æ‰‹", "æ•ˆç‡", "å¤šåŠŸèƒ½"],
          system_prompt: "ä½ æ˜¯ä¸€ä¸ªå…¨èƒ½çš„AIæ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©ç”¨æˆ·å¤„ç†å„ç§æ—¥å¸¸ä»»åŠ¡ã€‚ä¿æŒä¸“ä¸šã€é«˜æ•ˆã€å‹å¥½çš„æœåŠ¡æ€åº¦ã€‚",
          initial_message: "æ‚¨å¥½ï¼æˆ‘æ˜¯æ‚¨çš„æ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥å¸®æ‚¨å¤„ç†å„ç§ä»»åŠ¡ã€‚è¯·å‘Šè¯‰æˆ‘æ‚¨éœ€è¦ä»€ä¹ˆå¸®åŠ©ï¼Ÿ",
          quick_replies: ["åˆ¶å®šè®¡åˆ’", "ä¿¡æ¯æŸ¥è¯¢", "æ–‡æ¡£æ•´ç†"],
          completion_messages: {
            title: "ä»»åŠ¡å®Œæˆï¼",
            description: "å¾ˆé«˜å…´ä¸ºæ‚¨æä¾›å¸®åŠ©ï¼",
            icon: "âœ…",
          },
        },
      ]; // Load characters from storage and system
      async function loadCharacters() {
        try {
          // Load personal characters from SDK storage
          const personalChars = (await loadPersonalCharacters()) || [];

          // Combine with system characters
          characters = [...systemCharacters, ...personalChars];

          renderCharacters();
        } catch (error) {
          console.error("Error loading characters:", error);
          showToast("åŠ è½½è§’è‰²å¤±è´¥ï¼š" + error.message, "error");
          characters = [...systemCharacters];
          renderCharacters();
        }
      }

      // Load personal characters from SDK personal page store
      async function loadPersonalCharacters() {
        try {
          console.log("Loading personal characters from SDK...");
          const data = await sdk.personalPageStore.loadPageData("maisi_character_manager", "user-characters");

          if (data && data.characters && Array.isArray(data.characters)) {
            console.log(`Loaded ${data.characters.length} personal characters from SDK`);
            return data.characters;
          } else {
            console.log("No personal characters found in SDK storage");
            return [];
          }
        } catch (error) {
          console.warn("Failed to load characters from SDK, trying localStorage fallback:", error);
          // Fallback to localStorage for backward compatibility
          const stored = localStorage.getItem("personalCharacters");
          if (stored) {
            try {
              const localChars = JSON.parse(stored);
              console.log(`Loaded ${localChars.length} characters from localStorage fallback`);
              // Migrate to SDK storage
              if (localChars.length > 0) {
                await savePersonalCharactersToSDK(localChars);
                // Clear localStorage after successful migration
                localStorage.removeItem("personalCharacters");
              }
              return localChars;
            } catch (parseError) {
              console.error("Error parsing localStorage data:", parseError);
              return [];
            }
          }
          return [];
        }
      }

      // Save all personal characters to SDK storage
      async function savePersonalCharactersToSDK(personalCharacters, bForceFlush = false) {
        try {
          const data = {
            characters: personalCharacters,
            lastModified: new Date().toISOString(),
            version: "1.0",
          };

          await sdk.personalPageStore.savePageData("maisi_character_manager", "user-characters", data, bForceFlush);
          console.log(`Saved ${personalCharacters.length} characters to SDK storage`);
          return true;
        } catch (error) {
          console.error("Error saving characters to SDK:", error);
          throw error;
        }
      } // Save personal character
      async function savePersonalCharacter(character) {
        try {
          // Get current personal characters from memory (faster than reloading from SDK)
          const personalChars = characters.filter((c) => c.type === "personal");

          if (!character.id) {
            // Creating new character
            character.id = "personal_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
            character.type = "personal";
            character.createdAt = new Date().toISOString();
            personalChars.push(character);
          } else {
            // Updating existing character
            const index = personalChars.findIndex((c) => c.id === character.id);
            if (index !== -1) {
              character.updatedAt = new Date().toISOString();
              personalChars[index] = character;
            } else {
              // Character not found, add as new
              character.type = "personal";
              character.createdAt = new Date().toISOString();
              personalChars.push(character);
            }
          }

          // Save to SDK storage
          await savePersonalCharactersToSDK(personalChars, true);

          console.log(`Successfully saved character: ${character.name} (ID: ${character.id})`);
          return character;
        } catch (error) {
          console.error("Error saving character:", error);
          showToast("ä¿å­˜è§’è‰²å¤±è´¥ï¼š" + error.message, "error");
          throw error;
        }
      } // Delete personal character
      async function deletePersonalCharacter(characterId) {
        try {
          // Get current personal characters and filter out the deleted one
          const personalChars = characters.filter((c) => c.type === "personal" && c.id !== characterId);

          // Save updated list to SDK storage
          await savePersonalCharactersToSDK(personalChars, true);

          // Remove from current characters array
          characters = characters.filter((c) => c.id !== characterId);
          renderCharacters();

          console.log(`Successfully deleted character with ID: ${characterId}`);
          showToast("è§’è‰²åˆ é™¤æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("Error deleting character:", error);
          showToast("åˆ é™¤è§’è‰²å¤±è´¥ï¼š" + error.message, "error");
        }
      }

      // Load characters from other users
      async function loadUserCharacters() {
        const usernameInput = document.getElementById("usernameInput");
        const username = usernameInput.value.trim();

        if (!username) {
          showToast("è¯·è¾“å…¥ç”¨æˆ·å", "warning");
          return;
        }

        try {
          console.log(`Loading characters from user: ${username}`);
          showToast(`æ­£åœ¨åŠ è½½ ${username} çš„è§’è‰²...`, "info");

          // Create a temporary SDK instance for the target user
          const targetSdk = new KeepworkSDK({
            timeout: 30000,
          });
          targetSdk.personalPageStore.setUsername(username);

          // Load characters from the target user's personal page store
          // Note: This assumes we have permission to read other users' data
          // In practice, this might require special permissions or API calls
          const userData = await targetSdk.personalPageStore.loadPageData("maisi_character_manager", "user-characters");

          if (userData && userData.characters && Array.isArray(userData.characters)) {
            const importedChars = userData.characters.map((char) => ({
              ...char,
              id: `imported_${username}_${char.id}`, // Prevent ID conflicts
              type: "imported",
              sourceUser: username,
              original_id: char.id,
            }));

            // Store in userCharacters map
            userCharacters.set(username, importedChars);

            // Add to main characters array
            characters = characters.concat(importedChars);

            // Add username to imported users set
            importedUsers.add(username);

            // Update dropdown to include this user
            updateFilterDropdown();

            // Re-render characters
            renderCharacters();

            showToast(`æˆåŠŸåŠ è½½ ${importedChars.length} ä¸ªæ¥è‡ª ${username} çš„è§’è‰²`, "success");
            console.log(`Successfully loaded ${importedChars.length} characters from user: ${username}`);

            // Clear input
            usernameInput.value = "";
          } else {
            showToast(`ç”¨æˆ· ${username} æ²¡æœ‰å¯ç”¨çš„è§’è‰²æ•°æ®`, "warning");
          }
        } catch (error) {
          console.error("Error loading user characters:", error);
          showToast(`åŠ è½½ ${username} çš„è§’è‰²å¤±è´¥: ${error.message}`, "error");
        }
      }

      // Update filter dropdown to include imported users
      function updateFilterDropdown() {
        const filterSelect = document.getElementById("filterSelect");

        // Remove existing imported user options
        const existingImportedOptions = filterSelect.querySelectorAll('option[data-imported="true"]');
        existingImportedOptions.forEach((option) => option.remove());

        // Add options for each imported user
        importedUsers.forEach((username) => {
          const option = document.createElement("option");
          option.value = `user:${username}`;
          option.textContent = `${username} çš„è§’è‰²`;
          option.setAttribute("data-imported", "true");
          filterSelect.appendChild(option);
        });
      } // Render characters
      function renderCharacters() {
        const grid = document.getElementById("charactersGrid");
        grid.innerHTML = "";

        // Sort characters: pinned personal first, then system, then unpinned personal
        const sortedCharacters = [...characters].sort((a, b) => {
          // Pinned personal characters come first
          if (a.type === "personal" && a.pinned && !(b.type === "personal" && b.pinned)) {
            return -1;
          }
          if (b.type === "personal" && b.pinned && !(a.type === "personal" && a.pinned)) {
            return 1;
          }

          // Among pinned personal characters, maintain original order
          if (a.type === "personal" && a.pinned && b.type === "personal" && b.pinned) {
            return 0;
          }

          // System characters come after pinned personal but before unpinned personal
          if (a.type === "system" && b.type === "personal" && !b.pinned) {
            return -1;
          }
          if (b.type === "system" && a.type === "personal" && !a.pinned) {
            return 1;
          }

          // Maintain original order for other cases
          return 0;
        });
        sortedCharacters.forEach((char) => {
          grid.appendChild(createCharacterCard(char));
        });
      }

      // Create character card
      function createCharacterCard(character) {
        const card = document.createElement("div");
        card.className = `bg-white rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 cursor-pointer character-card ${character.type === "personal" && character.pinned ? "pinned" : ""}`;
        card.dataset.type = character.type;
        card.dataset.characterId = character.id;

        card.innerHTML = `
                <div class="p-6">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-3">
                            <div class="text-4xl">${character.avatar}</div>
                            <h3 class="text-xl font-bold text-gray-800">${character.name}</h3>
                        </div>
                        ${character.age ? `<span class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded-full">${character.age}å²</span>` : ""}
                    </div>
                    <div class="text-gray-700 text-sm mb-4 h-16 flex items-start overflow-hidden">
                        <p class="line-clamp-3">${character.description}</p>
                    </div>                      <div class="flex flex-wrap gap-1 mb-4">
                        <span class="px-2 py-1 text-xs rounded-full ${
                          character.type === "system" ? "bg-blue-100 text-blue-800" : character.type === "imported" ? "bg-purple-100 text-purple-800" : "bg-green-100 text-green-800"
                        }">
                            ${character.type === "system" ? "ç³»ç»Ÿ" : character.type === "imported" ? `æ¥è‡ª ${character.sourceUser}` : "ä¸ªäºº"}
                        </span>
                        ${character.type === "personal" && character.pinned ? '<span class="px-2 py-1 text-xs bg-yellow-100 text-yellow-800 rounded-full">ğŸ“Œ ç½®é¡¶</span>' : ""}
                        ${(character.tags || []).map((tag) => `<span class="px-2 py-1 text-xs bg-blue-50 text-blue-700 rounded-full">${tag}</span>`).join("")}
                    </div><div class="flex gap-2">
                        <button onclick="startChat('${character.id}')" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors text-sm">
                            å¯¹è¯
                        </button>
                        ${
                          character.type === "personal"
                            ? `
                            <div class="relative">
                                <button onclick="toggleCharacterMenu('${
                                  character.id
                                }')" class="px-3 py-2 bg-gray-200 text-gray-700 hover:text-gray-800 hover:bg-gray-300 rounded-lg transition-colors" title="æ›´å¤šæ“ä½œ">
                                    è®¾ç½®...
                                </button>
                                <div id="menu-${character.id}" class="absolute right-0 mt-1 w-48 bg-white character-menu rounded-lg z-50 hidden">
                                    <button onclick="editCharacter('${character.id}')" class="w-full px-4 py-3 text-left text-base text-gray-700 hover:bg-gray-100 flex items-center gap-3">
                                        <span class="text-lg">âœï¸</span>
                                        ç¼–è¾‘
                                    </button>
                                    <button onclick="deleteCharacter('${character.id}')" class="w-full px-4 py-3 text-left text-base text-red-600 hover:bg-red-50 flex items-center gap-3">
                                        <span class="text-lg">ğŸ—‘ï¸</span>
                                        åˆ é™¤
                                    </button>
                                    <button onclick="togglePinCharacter('${character.id}')" class="w-full px-4 py-3 text-left text-base text-gray-700 hover:bg-gray-100 flex items-center gap-3">
                                        <span class="text-lg">${character.pinned ? "ğŸ“Œ" : "ğŸ“"}</span>
                                        ${character.pinned ? "å–æ¶ˆç½®é¡¶" : "ç½®é¡¶"}
                                    </button>
                                </div>
                            </div>
                            `
                            : ""
                        }
                    </div>
                </div>
            `;
        return card;
      } // Filter characters
      function filterCharacters() {
        const filter = document.getElementById("filterSelect").value;
        const cards = document.querySelectorAll(".character-card");

        cards.forEach((card) => {
          let shouldShow = false;

          if (filter === "all") {
            shouldShow = true;
          } else if (filter.startsWith("user:")) {
            // Handle user-specific filtering
            const username = filter.substring(5); // Remove "user:" prefix
            const characterId = card.getAttribute("data-character-id");
            const character = characters.find((c) => c.id === characterId);
            shouldShow = character && character.type === "imported" && character.sourceUser === username;
          } else {
            // Handle standard type filtering
            shouldShow = card.dataset.type === filter;
          }

          if (shouldShow) {
            card.classList.remove("hidden");
          } else {
            card.classList.add("hidden");
          }
        });
      }

      // Open create modal
      function openCreateModal() {
        isEditing = false;
        editingCharacterId = null;
        document.getElementById("modalTitle").textContent = "åˆ›å»ºAIè§’è‰²";
        document.getElementById("submitButton").innerHTML = "ğŸ’¾ åˆ›å»ºè§’è‰²";
        document.getElementById("editingCharacterId").value = "";
        document.getElementById("createModal").classList.remove("hidden");
        document.body.style.overflow = "hidden";
        resetQuickReplies();
      }

      // Close create modal
      function closeCreateModal() {
        document.getElementById("createModal").classList.add("hidden");
        document.body.style.overflow = "auto";
        document.getElementById("createCharacterForm").reset();
        // Reset to first tab
        switchTab("basic");
        isEditing = false;
        editingCharacterId = null;
      }

      // Reset quick replies to initial state
      function resetQuickReplies() {
        const container = document.getElementById("quickRepliesContainer");
        container.innerHTML = `
          <div class="flex gap-2 mb-2">
            <input
              type="text"
              name="quick_reply_0"
              class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="å¿«æ·å›å¤ 1"
            />
            <button type="button" onclick="removeQuickReply(0)" class="px-3 py-2 text-red-500 hover:bg-red-50 rounded-lg">ğŸ—‘</button>
          </div>
        `;
        quickReplyIndex = 1;
      }

      // Add quick reply
      function addQuickReply() {
        const container = document.getElementById("quickRepliesContainer");
        const div = document.createElement("div");
        div.className = "flex gap-2 mb-2";
        div.innerHTML = `
                <input type="text" name="quick_reply_${quickReplyIndex}" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="å¿«æ·å›å¤ ${
          quickReplyIndex + 1
        }">
                <button type="button" onclick="removeQuickReply(${quickReplyIndex})" class="px-3 py-2 text-red-500 hover:bg-red-50 rounded-lg">
                    ğŸ—‘
                </button>
            `;
        container.appendChild(div);
        quickReplyIndex++;
      }

      // Remove quick reply
      function removeQuickReply(index) {
        const input = document.querySelector(`input[name="quick_reply_${index}"]`);
        if (input && input.parentElement) {
          input.parentElement.remove();
        }
      }

      // Load character data into form for editing
      function loadCharacterIntoForm(character) {
        const form = document.getElementById("createCharacterForm");

        // Basic info
        form.name.value = character.name || "";
        form.age.value = character.age || "";
        form.role.value = character.role || "";
        form.description.value = character.description || "";
        form.chat_background.value = character.chat_background || "";
        form.system_prompt.value = character.system_prompt || "";

        // Objective
        form.objective_title.value = character.objective?.title || "";
        form.objective_description.value = character.objective?.description || "";
        form.wikiword.value = character.wikiword || ""; // Display
        form.initial_message.value = character.initial_message || "";
        form.completion_title.value = character.completion_messages?.title || "";
        form.completion_description.value = character.completion_messages?.description || "";
        form.completion_icon.value = character.completion_messages?.icon || "";

        // Chat display options
        form.show_toolbar.checked = character.show_toolbar !== false; // Default true
        form.show_char_info.checked = character.show_char_info !== false; // Default true

        // Quick replies
        const container = document.getElementById("quickRepliesContainer");
        container.innerHTML = "";
        quickReplyIndex = 0;

        if (character.quick_replies && character.quick_replies.length > 0) {
          character.quick_replies.forEach((reply, index) => {
            const div = document.createElement("div");
            div.className = "flex gap-2 mb-2";
            div.innerHTML = `
              <input type="text" name="quick_reply_${index}" value="${reply}" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="å¿«æ·å›å¤ ${
              index + 1
            }">
              <button type="button" onclick="removeQuickReply(${index})" class="px-3 py-2 text-red-500 hover:bg-red-50 rounded-lg">ğŸ—‘</button>
            `;
            container.appendChild(div);
            quickReplyIndex = index + 1;
          });
        } else {
          resetQuickReplies();
        }
      }

      // Edit character
      function editCharacter(characterId) {
        const character = characters.find((c) => c.id === characterId);
        if (!character || character.type === "system") {
          showToast("æ— æ³•ç¼–è¾‘ç³»ç»Ÿè§’è‰²", "warning");
          return;
        }

        isEditing = true;
        editingCharacterId = characterId;
        document.getElementById("modalTitle").textContent = "ç¼–è¾‘AIè§’è‰²";
        document.getElementById("submitButton").innerHTML = "ğŸ’¾ ä¿å­˜ä¿®æ”¹";
        document.getElementById("editingCharacterId").value = characterId;

        loadCharacterIntoForm(character);

        document.getElementById("createModal").classList.remove("hidden");
        document.body.style.overflow = "hidden";
        switchTab("basic");
      }

      // Delete character
      function deleteCharacter(characterId) {
        const character = characters.find((c) => c.id === characterId);
        if (!character || character.type === "system") {
          showToast("æ— æ³•åˆ é™¤ç³»ç»Ÿè§’è‰²", "warning");
          return;
        }
        if (confirm(`ç¡®å®šè¦åˆ é™¤è§’è‰² "${character.name}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
          deletePersonalCharacter(characterId);
        }
      }

      // Toggle character dropdown menu
      function toggleCharacterMenu(characterId) {
        const menu = document.getElementById(`menu-${characterId}`);
        const allMenus = document.querySelectorAll('[id^="menu-"]');

        // Close all other menus
        allMenus.forEach((m) => {
          if (m.id !== `menu-${characterId}`) {
            m.classList.add("hidden");
          }
        });

        // Toggle current menu
        menu.classList.toggle("hidden");
      }

      // Close menus when clicking outside
      document.addEventListener("click", function (event) {
        if (!event.target.closest('[onclick*="toggleCharacterMenu"]') && !event.target.closest('[id^="menu-"]')) {
          const allMenus = document.querySelectorAll('[id^="menu-"]');
          allMenus.forEach((menu) => menu.classList.add("hidden"));
        }
      });

      // Toggle pin status of character
      async function togglePinCharacter(characterId) {
        const character = characters.find((c) => c.id === characterId);
        if (!character || character.type === "system") {
          showToast("æ— æ³•ç½®é¡¶ç³»ç»Ÿè§’è‰²", "warning");
          return;
        }

        try {
          // Toggle pinned status
          character.pinned = !character.pinned;

          // Save the updated character
          await savePersonalCharacter(character);

          // Update characters in memory
          const index = characters.findIndex((c) => c.id === characterId);
          if (index !== -1) {
            characters[index] = character;
          }

          // Re-render characters with new order
          renderCharacters();

          // Close the menu
          const menu = document.getElementById(`menu-${characterId}`);
          menu.classList.add("hidden");

          showToast(character.pinned ? "è§’è‰²å·²ç½®é¡¶" : "å·²å–æ¶ˆç½®é¡¶", "success");
        } catch (error) {
          showToast("ç½®é¡¶æ“ä½œå¤±è´¥ï¼š" + error.message, "error");
        }
      }

      // Submit create form function
      async function submitCreateForm() {
        const form = document.getElementById("createCharacterForm");
        const formData = new FormData(form);
        const characterData = {};

        // Basic info
        characterData.name = formData.get("name");
        characterData.age = formData.get("age") ? parseInt(formData.get("age")) : null;
        characterData.role = formData.get("role") || "";
        characterData.description = formData.get("description");
        characterData.chat_background = formData.get("chat_background") || null;
        characterData.system_prompt = formData.get("system_prompt"); // If editing, preserve the existing ID, type, and pinned state
        if (isEditing && editingCharacterId) {
          const existingChar = characters.find((c) => c.id === editingCharacterId);
          characterData.id = editingCharacterId;
          characterData.type = "personal";
          characterData.pinned = existingChar ? existingChar.pinned : false;
        }

        // Set default avatar if not editing
        characterData.avatar = characterData.avatar || "ğŸ‘¤";

        // Objective
        characterData.objective = {
          title: formData.get("objective_title"),
          description: formData.get("objective_description") || "",
        };
        characterData.wikiword = formData.get("wikiword") || null;

        // Messages
        characterData.initial_message = formData.get("initial_message") || "";

        // Quick replies
        characterData.quick_replies = [];
        for (let i = 0; i < quickReplyIndex; i++) {
          const reply = formData.get(`quick_reply_${i}`);
          if (reply && reply.trim()) {
            characterData.quick_replies.push(reply.trim());
          }
        } // Completion messages
        characterData.completion_messages = {
          title: formData.get("completion_title") || "ç›®æ ‡å®Œæˆï¼",
          description: formData.get("completion_description") || "",
          icon: formData.get("completion_icon") || "ğŸ‰",
        };

        // Chat display options
        characterData.show_toolbar = formData.get("show_toolbar") === "on";
        characterData.show_char_info = formData.get("show_char_info") === "on";

        // Tags (generate based on role and description)
        characterData.tags = characterData.role ? [characterData.role] : [];

        try {
          const savedCharacter = await savePersonalCharacter(characterData);

          if (isEditing) {
            // Update existing character in the array
            const index = characters.findIndex((c) => c.id === editingCharacterId);
            if (index !== -1) {
              characters[index] = savedCharacter;
            }
            showToast("è§’è‰²æ›´æ–°æˆåŠŸï¼", "success");
          } else {
            // Add new character to the array
            characters.push(savedCharacter);
            showToast("è§’è‰²åˆ›å»ºæˆåŠŸï¼", "success");
          }

          renderCharacters();
          closeCreateModal();
        } catch (error) {
          showToast((isEditing ? "æ›´æ–°" : "åˆ›å»º") + "è§’è‰²å¤±è´¥ï¼š" + error.message, "error");
        }
      }

      // Start chat with character
      function startChat(characterId) {
        const character = characters.find((c) => c.id === characterId);
        if (!character) return;

        // Build config URL parameter
        const config = encodeURIComponent(
          JSON.stringify({
            character: {
              name: character.name,
              age: character.age,
              role: character.role,
              description: character.description,
              chat_background: character.chat_background,
            },
            objective: character.objective,
            initial: {
              message: character.initial_message,
            },
            quick_replies: character.quick_replies || [],
            system_prompt: character.system_prompt,
            completion_messages: character.completion_messages,
          })
        );
        // Set iframe source using URL replacement pattern to forward existing parameters
        let currentUrl = window.location.href;
        currentUrl = currentUrl.split("?")[0];

        // Replace characterManager with characterAI
        const iframeUrl = currentUrl.replace("characterManager", "characterAI"); // Forward all existing URL parameters and add config
        const urlParams = new URLSearchParams(iframeUrl);
        urlParams.set("config", config);
        urlParams.set("showClose", "true");
        urlParams.set("parent", "characterManager");
        urlParams.set("showToolbar", character.show_toolbar !== false ? "true" : "false");
        urlParams.set("showCharInfo", character.show_char_info !== false ? "true" : "false");

        if (sdk.token) {
          urlParams.set("token", sdk.token);
        }

        document.getElementById("chatFrame").src = `${iframeUrl}?${urlParams.toString()}`;

        // Show modal
        document.getElementById("chatModal").classList.remove("hidden");
        document.body.style.overflow = "hidden";
      }

      // Close chat modal
      function closeChatModal() {
        document.getElementById("chatModal").classList.add("hidden");
        document.body.style.overflow = "auto";
        document.getElementById("chatFrame").src = "";
      }

      // Tab switching function
      function switchTab(tabName) {
        // Hide all tab contents
        const tabContents = document.querySelectorAll(".tab-content");
        tabContents.forEach((content) => {
          content.classList.add("hidden");
        });

        // Remove active state from all tabs
        const tabs = document.querySelectorAll('[id^="tab-"]');
        tabs.forEach((tab) => {
          tab.classList.remove("bg-white", "text-blue-600", "border-b-2", "border-blue-500");
          tab.classList.add("text-gray-600", "hover:text-gray-900", "hover:bg-gray-50");
        });

        // Show selected tab content
        document.getElementById(`tab-content-${tabName}`).classList.remove("hidden");

        // Set active state for selected tab
        const activeTab = document.getElementById(`tab-${tabName}`);
        activeTab.classList.remove("text-gray-600", "hover:text-gray-900", "hover:bg-gray-50");
        activeTab.classList.add("bg-white", "text-blue-600", "border-b-2", "border-blue-500");
      } // Initialize page
      async function initializeApp() {
        window.parent.postMessage({ type: "gameLoaded" }, "*");
        try {
          console.log("Initializing Character Manager...");
          await loadCharacters();
          console.log("Character Manager initialized successfully");
        } catch (error) {
          console.error("Error initializing app:", error);
          showToast("åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼š" + error.message, "error");
        }
      }

      // Listen for messages from the iframe
      window.addEventListener("message", function (e) {
        if (e.data.type === "OnCloseCharacterAI") {
          console.log("Received OnCloseCharacterAI event, closing chat modal");
          closeChatModal();
        }
      });

      initializeApp();
    </script>
  </body>
</html>
