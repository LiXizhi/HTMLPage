<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Rush - 宝石迷阵</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js"></script>
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background: radial-gradient(circle at center, #2b1055 0%, #1a0b2e 100%);
            color: white;
            overflow: hidden;
            touch-action: none; /* Prevent scroll on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Grid Styling */
        #grid-area {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 4px solid #4c2e85;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            touch-action: none;
        }

        /* Gem Styles */
        .gem {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.2s ease;
            cursor: pointer;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            /* GPU Acceleration hint */
            will-change: transform;
        }

        .gem-inner {
            width: 85%;
            height: 85%;
            border-radius: 20%;
            box-shadow: inset 0 4px 8px rgba(255,255,255,0.4), 
                        inset 0 -4px 8px rgba(0,0,0,0.4),
                        0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .gem-inner::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 15%;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
        }

        /* Gem Colors */
        .type-0 .gem-inner { background: linear-gradient(135deg, #ff4d4d, #b30000); border: 1px solid #ff8080; } /* Red */
        .type-1 .gem-inner { background: linear-gradient(135deg, #4da6ff, #0059b3); border: 1px solid #80bfff; border-radius: 50%; } /* Blue Circle */
        .type-2 .gem-inner { background: linear-gradient(135deg, #4dff88, #00b33c); border: 1px solid #80ffaa; border-radius: 10%; transform: rotate(45deg) scale(0.85); } /* Green Diamond */
        .type-3 .gem-inner { background: linear-gradient(135deg, #ffff4d, #b3b300); border: 1px solid #ffff80; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); border-radius: 0; width: 80%; height: 80%;} /* Yellow Triangle */
        .type-4 .gem-inner { background: linear-gradient(135deg, #bf4dff, #7300b3); border: 1px solid #df80ff; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); border-radius: 0; } /* Purple Lozenge */
        .type-5 .gem-inner { background: linear-gradient(135deg, #ffae4d, #b36b00); border: 1px solid #ffce80; border-radius: 30%; } /* Orange Hex */

        .gem.has-word {
            z-index: 15;
        }

        .gem.selected {
            z-index: 50;
        }

        .gem.selected .gem-inner {
            filter: brightness(1.4);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            z-index: 20;
        }

        /* Particles */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: pop 0.6s ease-out forwards;
        }

        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; top: var(--dest-y); left: var(--dest-x); }
        }

        /* Floating Text */
        .float-text {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 50;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        .hidden { display: none !important; }

        .btn-primary {
            background: linear-gradient(to bottom, #ff4d4d, #c41e1e);
            border: none;
            padding: 12px 30px;
            color: white;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 77, 77, 0.4);
            transition: transform 0.1s;
            font-family: 'Fredoka', sans-serif;
        }
        .btn-primary:active { transform: scale(0.95); }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            color: #aaa;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Fredoka', sans-serif;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-secondary.selected {
            background: #4da6ff;
            border-color: #4da6ff;
            color: white;
            box-shadow: 0 0 10px rgba(77, 166, 255, 0.5);
        }

        /* Word Overlay */
        .gem-word {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.4rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px #000, 0 0 2px #000;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            width: max-content;
            white-space: nowrap;
            transform-origin: center center;
        }
        
        .entangled .gem-inner {
            filter: grayscale(0.8) brightness(0.6);
            box-shadow: inset 0 0 10px #000;
        }
        
        .entangled::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(0,0,0,0.2),
                rgba(0,0,0,0.2) 5px,
                rgba(0,0,0,0.4) 5px,
                rgba(0,0,0,0.4) 10px
            );
            z-index: 14;
            border-radius: 20%;
        }

        /* Word Cell Animations */
        @keyframes pulseShadow {
            0% { filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8)); }
            50% { filter: drop-shadow(0 0 8px rgba(255, 255, 255, 1)); }
            100% { filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8)); }
        }

        @keyframes rainbowGlow {
            0% { filter: drop-shadow(0 0 3px #ff0000) drop-shadow(0 0 5px #ff0000); }
            25% { filter: drop-shadow(0 0 3px #ffff00) drop-shadow(0 0 5px #ffff00); }
            50% { filter: drop-shadow(0 0 3px #00ff00) drop-shadow(0 0 5px #00ff00); }
            75% { filter: drop-shadow(0 0 3px #00ffff) drop-shadow(0 0 5px #00ffff); }
            100% { filter: drop-shadow(0 0 3px #ff00ff) drop-shadow(0 0 5px #ff00ff); }
        }

        /* English Word Style */
        .gem.lang-en {
            animation: pulseShadow 2s infinite;
        }

        /* Chinese Word Style - Special */
        .gem.lang-cn {
            animation: rainbowGlow 3s linear infinite;
        }
        
        /* Enhance text readability */
        .gem.has-word .gem-word {
            text-shadow: 0 0 4px #000, 0 0 3px #000, 0 0 2px #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Close Button -->
    <button id="close-game-btn" class="fixed top-4 right-4 z-50 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition shadow-lg border border-red-400">
        ✕ 退出
    </button>
    
    <!-- UI Header -->
    <div class="w-full px-6 mb-4 flex justify-between items-end relative">
        <div>
            <div class="text-sm text-gray-300 opacity-80">分数</div>
            <div id="score-display" class="text-3xl font-bold text-yellow-400">0</div>
        </div>
        <div class="text-center">
            <div class="text-sm text-gray-300 opacity-80">关卡</div>
            <div id="level-display" class="text-4xl font-bold text-white">1</div>
        </div>
        <div class="text-right">
            <div id="moves-label" class="text-sm text-gray-300 opacity-80">步数</div>
            <div id="moves-display" class="text-3xl font-bold text-red-400">20</div>
        </div>
    </div>

    <!-- Progress Bar -->
    <div class="w-full max-w-[90%] h-4 bg-gray-800 rounded-full mb-4 overflow-hidden border border-gray-600 relative">
        <div id="progress-fill" class="h-full bg-gradient-to-r from-green-400 to-blue-500 transition-all duration-500" style="width: 0%"></div>
        <div class="absolute inset-0 flex items-center justify-center text-[10px] font-bold tracking-wider text-white drop-shadow-md">
            目标: <span id="target-display">1000</span>
        </div>
    </div>

    <!-- Game Board -->
    <div id="grid-area">
        <!-- Gems generated by JS -->
    </div>

    <!-- Settings Footer -->
    <div class="w-full mt-2 flex justify-center gap-3 items-center z-20">
        <div class="flex flex-col items-start">
            <label class="text-xs text-gray-400 ml-1">词汇等级</label>
            <select id="word-level-select" class="bg-gray-800 text-white border border-gray-600 rounded-lg px-3 py-1 focus:outline-none focus:border-blue-500 text-sm">
                <option value="1" selected>Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
                <option value="4">Level 4</option>
                <option value="5">Level 5</option>
                <option value="6">Level 6</option>
            </select>
        </div>

        <div class="flex flex-col items-start">
            <label class="text-xs text-gray-400 ml-1">难度</label>
            <select id="difficulty-select" class="bg-gray-800 text-white border border-gray-600 rounded-lg px-3 py-1 focus:outline-none focus:border-blue-500 text-sm">
                <option value="easy">简单</option>
                <option value="normal" selected>普通</option>
                <option value="hard">困难</option>
            </select>
        </div>
        
        <div class="flex flex-col items-start">
            <label class="text-xs text-gray-400 ml-1">模式</label>
            <select id="mode-select" class="bg-gray-800 text-white border border-gray-600 rounded-lg px-3 py-1 focus:outline-none focus:border-blue-500 text-sm">
                <option value="moves" selected>步数</option>
                <option value="time">倒计时</option>
            </select>
        </div>

        <div class="flex flex-col items-start">
             <label class="text-xs text-transparent ml-1">.</label>
             <button id="footer-restart-btn" class="bg-gradient-to-b from-red-500 to-red-700 hover:from-red-400 hover:to-red-600 text-white rounded-lg px-4 py-1 font-bold shadow-lg text-sm border border-red-400">
                重开
            </button>
        </div>
    </div>
</div>

<!-- Success Overlay -->
<div id="success-overlay" class="hidden fixed inset-0 pointer-events-none z-50 flex items-center justify-center">
    <canvas id="confetti-canvas" class="absolute inset-0 w-full h-full"></canvas>
    <div class="absolute text-6xl font-bold text-yellow-300 drop-shadow-[0_5px_5px_rgba(0,0,0,0.5)] animate-bounce">关卡完成!</div>
</div>

<!-- Level Complete Modal -->
<div id="level-modal" class="modal hidden">
    <div class="bg-gray-900 p-8 rounded-2xl border-2 border-yellow-500 text-center max-w-xs w-full transform transition-all scale-100 shadow-2xl">
        <h2 class="text-3xl font-bold text-yellow-400 mb-2">过关!</h2>
        <p class="text-gray-300 mb-6">做得好!</p>
        <div class="text-lg mb-6">分数: <span id="level-score-final" class="text-white font-bold">0</span></div>
        <button id="next-level-btn" class="btn-primary w-full">下一关</button>
    </div>
</div>

<!-- Game Over Modal -->
<div id="game-over-modal" class="modal hidden">
    <div class="bg-gray-900 p-8 rounded-2xl border-2 border-red-600 text-center max-w-xs w-full shadow-2xl">
        <h2 class="text-3xl font-bold text-red-500 mb-2">游戏结束</h2>
        <p class="text-gray-300 mb-6">步数用尽!</p>
        <div class="text-lg mb-6">最终分数: <span id="final-score" class="text-white font-bold">0</span></div>
        <button id="restart-btn" class="btn-primary w-full">重试</button>
    </div>
</div>

<script>
    /**
     * Game Configuration & State
     */
    const COLS = 8;
    const ROWS = 8;
    const GEM_TYPES = 6; // Number of colors
    let GRID_SIZE = 0; // Calculated dynamically
    let CELL_SIZE = 0;

    let RAW_WORD_DATA = `
## level 1
苹果: Apple
香蕉: Banana
橙子: Orange
葡萄: Grape
西瓜: Watermelon
草莓: Strawberry
樱桃: Cherry
梨: Pear
桃子: Peach
柠檬: Lemon

## level 2
红色: Red
蓝色: Blue
`;

    let WORD_PAIRS = [];
    const ALL_WORD_LEVELS = {};

    function parseWordData(text) {
        const lines = text.split('\n');
        let currentLevel = 0;
        
        lines.forEach(line => {
            line = line.trim();
            if (!line) return;
            if (line.toLowerCase().startsWith('## level')) {
                currentLevel = parseInt(line.toLowerCase().replace('## level', '').trim());
                if (!ALL_WORD_LEVELS[currentLevel]) ALL_WORD_LEVELS[currentLevel] = [];
            } else if (line.includes(':')) {
                const [cn, en] = line.split(':').map(s => s.trim());
                if (currentLevel > 0 && cn && en) {
                    ALL_WORD_LEVELS[currentLevel].push({cn, en});
                }
            }
        });
    }

    // Initial parse
    parseWordData(RAW_WORD_DATA);

    const gameState = {
        grid: [], // 2D array storing gem types (0-5) or null
        wordGrid: [], // 2D array storing word objects {word, lang, pairId, isEntangled}
        currentPair: null, // {cn, en}
        selectedGem: null, // {r, c}
        score: 0,
        moves: 0,
        level: 1,
        wordLevel: 1, // New config
        targetScore: 1000,
        isLocked: false, // Locks input during animations
        comboMultiplier: 1,
        difficulty: 'normal', // easy, normal, hard
        mode: 'moves', // moves, time
        timeLeft: 0,
        timerInterval: null,
        crushedPairs: new Set(), // Track crushed word pairs by index
        availablePairs: [] // Pairs not yet crushed
    };

    const dom = {
        grid: document.getElementById('grid-area'),
        score: document.getElementById('score-display'),
        moves: document.getElementById('moves-display'),
        movesLabel: document.getElementById('moves-label'),
        level: document.getElementById('level-display'),
        target: document.getElementById('target-display'),
        progress: document.getElementById('progress-fill'),
        levelModal: document.getElementById('level-modal'),
        gameOverModal: document.getElementById('game-over-modal'),
        nextLevelBtn: document.getElementById('next-level-btn'),
        restartBtn: document.getElementById('restart-btn'),
        levelScoreFinal: document.getElementById('level-score-final'),
        finalScore: document.getElementById('final-score'),
        diffSelect: document.getElementById('difficulty-select'),
        modeSelect: document.getElementById('mode-select'),
        wordLevelSelect: document.getElementById('word-level-select'),
        footerRestartBtn: document.getElementById('footer-restart-btn'),
        closeGameBtn: document.getElementById('close-game-btn')
    };

    /* --- Initialization & Resizing --- */

    // Initialize SDK
    let sdk = null;
    try {
        if (typeof KeepworkSDK !== 'undefined') {
            sdk = new KeepworkSDK({
                timeout: 30000
            });
            console.log(`Keepwork SDK initialized token: ${sdk.token}`);
        }
    } catch (e) {
        console.error("SDK Init Failed", e);
    }

    async function speak(text) {
        if (sdk && sdk.speech) {
            try {
                const result = await sdk.speech.textToAudio(text, {
                    per: 4, 
                    spd: 5,
                    pit: 5,
                    vol: 5
                });
                if (result && result.url) {
                    const audio = new Audio(result.url);
                    audio.play();
                    return;
                }
            } catch (e) {
                console.error("SDK TTS failed", e);
            }
        }
        
        // Fallback
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            window.speechSynthesis.speak(utterance);
        }
    }

    function animateAndCrush(p1, p2, wordPair) {
        return new Promise(async (resolve) => {
            gameState.isLocked = true;
            
            const el1 = getGemDOM(p1.r, p1.c);
            const el2 = getGemDOM(p2.r, p2.c);
            
            if (!el1 || !el2) {
                resolve();
                return;
            }

            // Determine which is CN and which is EN
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            
            let cnEl = el1;
            // Default to el1 being CN if we can't tell, but logic below fixes it
            if (w1 && w1.lang === 'EN') {
                cnEl = el2; // el1 is EN, so el2 must be CN
            } else if (w2 && w2.lang === 'CN') {
                cnEl = el2;
            } else {
                cnEl = el1;
            }

            // Bring to front
            el1.style.zIndex = 1000;
            el2.style.zIndex = 1000;

            // Calculate center
            const centerPos = GRID_SIZE / 2 - CELL_SIZE / 2;
            const offset = CELL_SIZE * 0.8; // Vertical offset for stacking
            
            el1.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            el2.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            
            // Force reflow
            el1.offsetHeight; 
            
            // Move to center and scale up significantly
            // CN on top (visually higher -> smaller Y)
            // EN on bottom (visually lower -> larger Y)
            
            if (cnEl === el1) {
                el1.style.transform = `translate(${centerPos}px, ${centerPos - offset}px) scale(2.5)`;
                el2.style.transform = `translate(${centerPos}px, ${centerPos + offset}px) scale(2.5)`;
            } else {
                el1.style.transform = `translate(${centerPos}px, ${centerPos + offset}px) scale(2.5)`;
                el2.style.transform = `translate(${centerPos}px, ${centerPos - offset}px) scale(2.5)`;
            }
            
            // Wait for movement
            await new Promise(r => setTimeout(r, 600));
            
            // Play TTS
            if(wordPair && wordPair.en) {
                speak(wordPair.en);
            }
            
            // Wait for reading (approx 1.5s)
            await new Promise(r => setTimeout(r, 1500));
            
            // Create particles at new positions
            const commonX = centerPos + CELL_SIZE/2;
            const cnY = centerPos - offset + CELL_SIZE/2;
            const enY = centerPos + offset + CELL_SIZE/2;
            
            if (cnEl === el1) {
                createParticles(p1.r, p1.c, gameState.grid[p1.r][p1.c], commonX, cnY);
                createParticles(p2.r, p2.c, gameState.grid[p2.r][p2.c], commonX, enY);
            } else {
                createParticles(p1.r, p1.c, gameState.grid[p1.r][p1.c], commonX, enY);
                createParticles(p2.r, p2.c, gameState.grid[p2.r][p2.c], commonX, cnY);
            }

            resolve();
        });
    }

    function init() {
        updateLevelDropdown();

        // Fetch Data
        fetch('candy_word_crush_data_cn_en')
            .then(res => {
                if(res.ok) return res.text();
                throw new Error('Network response was not ok');
            })
            .then(text => {
                // Reset levels before parsing new data
                for (let key in ALL_WORD_LEVELS) delete ALL_WORD_LEVELS[key];

                parseWordData(text);
                updateLevelDropdown();
                // Update word list with new data
                updateWordList();
                // Recreate grid to regenerate words from new data
                createInitialGrid();
            })
            .catch(e => console.error("Failed to load word data", e));

        // Calculate sizes first so we have valid CELL_SIZE
        resizeGrid();
        
        // Settings Listeners
        dom.diffSelect.addEventListener('change', (e) => {
            gameState.difficulty = e.target.value;
            startLevel(gameState.level);
        });

        dom.modeSelect.addEventListener('change', (e) => {
            gameState.mode = e.target.value;
            startLevel(gameState.level);
        });

        dom.wordLevelSelect.addEventListener('change', (e) => {
            gameState.wordLevel = parseInt(e.target.value);
            updateWordList();
            startLevel(1);
        });

        dom.footerRestartBtn.addEventListener('click', () => {
             startLevel(gameState.level);
        });
        
        // Close button - notify parent and close
        dom.closeGameBtn.addEventListener('click', () => {
            window.parent.postMessage({ 
                type: 'gameFinished', 
                data: { 
                    score: gameState.score, 
                    level: gameState.level,
                    difficulty: gameState.difficulty,
                    mode: gameState.mode,
                    closed: true  // 标记为用户主动关闭
                } 
            }, '*');
        });
        
        window.addEventListener('resize', resizeGrid);
        dom.nextLevelBtn.addEventListener('click', () => startLevel(gameState.level + 1));
        dom.restartBtn.addEventListener('click', () => {
            startLevel(gameState.level);
            dom.gameOverModal.classList.add('hidden');
        });

        // Notify parent
        window.parent.postMessage({ type: 'gameLoaded' }, '*');
        
        // Initial Word List
        updateWordList();

        // Auto start
        startLevel(1);
    }

    function updateWordList() {
        // Get words for current level
        // If level 1, get level 1. If level 2, get level 2 (or 1+2?)
        // Usually "Level 2" means words from level 2.
        // But if level 2 has few words, maybe we want cumulative?
        // The user said "fetch word from candy_word_crush_data_cn_en, with levels. the UI should add one more config for english word level, 词汇等级: 1-6. based on the candy_word_crush_data_cn_en, default to level 1."
        // I will assume it means "use words from the selected level".
        
        const levelWords = ALL_WORD_LEVELS[gameState.wordLevel];
        if (levelWords && levelWords.length > 0) {
            WORD_PAIRS = [...levelWords];
        } else {
            // Fallback if empty or invalid level, use all or level 1
            WORD_PAIRS = ALL_WORD_LEVELS[1] || [];
        }
        
        // If still empty (should not happen with embedded data), add dummy
        if (WORD_PAIRS.length === 0) {
            WORD_PAIRS = [{cn: "空", en: "Empty"}];
        }
        
        // Reset current pair to force pick new one
        gameState.currentPair = null;
        gameState.nextSequentialPair = null;
        
        // Reset crushed pairs tracking when word list changes
        resetCrushedPairs();
    }
    
    function resetCrushedPairs() {
        gameState.crushedPairs = new Set();
        gameState.availablePairs = [...WORD_PAIRS];
    }
    
    function markPairAsCrushed(pair) {
        if (!pair) return;
        
        // Find the index of this pair in WORD_PAIRS
        const pairKey = `${pair.cn}:${pair.en}`;
        gameState.crushedPairs.add(pairKey);
        
        // Remove from available pairs
        gameState.availablePairs = gameState.availablePairs.filter(
            p => `${p.cn}:${p.en}` !== pairKey
        );
        
        // If all pairs are crushed, reset for next cycle
        if (gameState.availablePairs.length === 0) {
            console.log('All word pairs crushed! Resetting for next cycle.');
            resetCrushedPairs();
        }
    }
    
    function getAvailablePair() {
        // Return a random pair from available (non-crushed) pairs
        if (gameState.availablePairs.length === 0) {
            resetCrushedPairs();
        }
        return gameState.availablePairs[Math.floor(Math.random() * gameState.availablePairs.length)];
    }
    
    function isPairCrushed(pair) {
        if (!pair) return false;
        const pairKey = `${pair.cn}:${pair.en}`;
        return gameState.crushedPairs.has(pairKey);
    }

    function resizeGrid() {
        const maxWidth = Math.min(window.innerWidth - 30, 500);
        const maxHeight = window.innerHeight * 0.55; 
        
        let size = Math.min(maxWidth, maxHeight);
        
        GRID_SIZE = size;
        CELL_SIZE = (GRID_SIZE - 8) / COLS; // -8 for border

        dom.grid.style.width = `${GRID_SIZE}px`;
        dom.grid.style.height = `${GRID_SIZE}px`;

        // IMPORTANT: Only render if grid exists
        if (gameState.grid && gameState.grid.length > 0) {
            renderGrid(); 
        }
    }

    function startLevel(lvl) {
        gameState.level = lvl;
        
        if (lvl === 1) {
            gameState.score = 0;
            createInitialGrid();
        }
        
        gameState.levelStartScore = gameState.score;

        // Difficulty Multipliers
        let scoreMult = 1;
        let movesBase = 30;
        let timeBase = 90;

        if (gameState.difficulty === 'easy') {
            scoreMult = 0.8;
            movesBase = 40;
            timeBase = 120;
        } else if (gameState.difficulty === 'hard') {
            scoreMult = 1.2;
            movesBase = 20;
            timeBase = 60;
        }

        // Infinite Level Logic
        const pointsToEarn = Math.floor((3000 + (lvl * 100)) * scoreMult); 
        gameState.targetScore = gameState.score + pointsToEarn;
        
        // Mode Setup
        if (gameState.mode === 'time') {
            gameState.timeLeft = timeBase;
            dom.movesLabel.textContent = "时间";
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(updateTimer, 1000);
        } else {
            gameState.moves = movesBase;
            dom.movesLabel.textContent = "步数";
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        }
        
        gameState.comboMultiplier = 1;
        gameState.isLocked = false;
        gameState.selectedGem = null;

        dom.levelModal.classList.add('hidden');
        dom.gameOverModal.classList.add('hidden');
        document.getElementById('success-overlay').classList.add('hidden');

        updateUI();
    }

    function updateTimer() {
        if (gameState.isLocked) return; // Pause timer during animations? Maybe not. Let's keep it running or pause? Usually pause.
        // Actually, standard match-3 timers keep running. But if animations are long, it might be unfair.
        // Let's pause timer if isLocked is true to be fair, as user cannot interact.
        if (gameState.isLocked) return;

        gameState.timeLeft--;
        if (gameState.timeLeft <= 0) {
            gameState.timeLeft = 0;
            clearInterval(gameState.timerInterval);
            checkWinCondition();
        }
        updateUI();
    }

    function createInitialGrid() {
        gameState.grid = [];
        gameState.wordGrid = [];
        dom.grid.innerHTML = ''; 

        for (let r = 0; r < ROWS; r++) {
            gameState.grid[r] = [];
            gameState.wordGrid[r] = [];
            for (let c = 0; c < COLS; c++) {
                gameState.wordGrid[r][c] = null;
                let type;
                // Prevent initial matches
                do {
                    type = Math.floor(Math.random() * GEM_TYPES);
                } while (
                    (c >= 2 && gameState.grid[r][c-1] === type && gameState.grid[r][c-2] === type) ||
                    (r >= 2 && gameState.grid[r-1][c] === type && gameState.grid[r-2][c] === type)
                );
                gameState.grid[r][c] = type;
                createGemDOM(r, c, type);
            }
        }
        ensureWords();
    }

    /* --- DOM Manipulation --- */

    function createGemDOM(r, c, type) {
        const div = document.createElement('div');
        div.classList.add('gem', `type-${type}`);
        div.id = `gem-${r}-${c}`;
        div.setAttribute('data-r', r);
        div.setAttribute('data-c', c);
        
        div.style.width = `${CELL_SIZE}px`;
        div.style.height = `${CELL_SIZE}px`;
        div.style.transform = `translate(${c * CELL_SIZE}px, ${r * CELL_SIZE}px)`;
        
        const inner = document.createElement('div');
        inner.classList.add('gem-inner');
        div.appendChild(inner);

        // Word Overlay
        const wordData = gameState.wordGrid[r] && gameState.wordGrid[r][c];
        if (wordData) {
            div.classList.add('has-word');
            div.classList.add(wordData.lang === 'CN' ? 'lang-cn' : 'lang-en');
            const wordEl = document.createElement('div');
            wordEl.classList.add('gem-word');
            wordEl.textContent = wordData.word;
            div.appendChild(wordEl);
            fitText(wordEl);
            if (wordData.isEntangled) {
                div.classList.add('entangled');
            }
        }

        // Event Listeners
        bindInteraction(div, r, c);

        dom.grid.appendChild(div);
        return div;
    }

    function getGemDOM(r, c) {
        return document.getElementById(`gem-${r}-${c}`);
    }

    function renderGrid() {
        // Safe check
        if (!gameState.grid || gameState.grid.length === 0) return;

        for (let r = 0; r < ROWS; r++) {
            // Extra safety if row is somehow missing
            if (!gameState.grid[r]) continue;

            for (let c = 0; c < COLS; c++) {
                if (gameState.grid[r][c] !== null) {
                    const gem = getGemDOM(r, c);
                    if (gem) {
                        gem.style.width = `${CELL_SIZE}px`;
                        gem.style.height = `${CELL_SIZE}px`;
                        gem.style.transform = `translate(${c * CELL_SIZE}px, ${r * CELL_SIZE}px)`;
                        
                        const wordEl = gem.querySelector('.gem-word');
                        if (wordEl) fitText(wordEl);
                    }
                }
            }
        }
    }

    /* --- Core Logic --- */

    function handleInput(r, c) {
        if (gameState.isLocked) return;
        if (gameState.grid[r][c] === null) return;

        // Block entangled
        if (gameState.wordGrid[r][c] && gameState.wordGrid[r][c].isEntangled) return;

        const clicked = { r, c };

        // Deselect
        if (gameState.selectedGem && gameState.selectedGem.r === r && gameState.selectedGem.c === c) {
            toggleSelectVisual(gameState.selectedGem, false);
            gameState.selectedGem = null;
            return;
        }

        // Select First
        if (!gameState.selectedGem) {
            gameState.selectedGem = clicked;
            toggleSelectVisual(clicked, true);
            return;
        }

        // Swap logic
        if (isAdjacent(gameState.selectedGem, clicked)) {
            toggleSelectVisual(gameState.selectedGem, false);
            attemptSwap(gameState.selectedGem, clicked);
            gameState.selectedGem = null;
        } else {
            toggleSelectVisual(gameState.selectedGem, false);
            gameState.selectedGem = clicked;
            toggleSelectVisual(clicked, true);
        }
    }

    function isAdjacent(p1, p2) {
        return Math.abs(p1.r - p2.r) + Math.abs(p1.c - p2.c) === 1;
    }

    function toggleSelectVisual(pos, isSelected) {
        const el = getGemDOM(pos.r, pos.c);
        if (el) {
            if (isSelected) el.classList.add('selected');
            else el.classList.remove('selected');
        }
    }

    function isWordOnBoard(word, excludePos) {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if (excludePos && r === excludePos.r && c === excludePos.c) continue;
                const w = gameState.wordGrid[r][c];
                if(w && w.word === word) return true;
            }
        }
        return false;
    }

    async function attemptSwap(p1, p2) {
        gameState.isLocked = true;

        // Visual Swap First
        await swapAnimation(p1, p2);

        // Check Entangled
        const w1 = gameState.wordGrid[p1.r][p1.c];
        const w2 = gameState.wordGrid[p2.r][p2.c];
        if ((w1 && w1.isEntangled) || (w2 && w2.isEntangled)) {
             // Revert visual swap manually because IDs haven't changed
             const el1 = getGemDOM(p1.r, p1.c);
             const el2 = getGemDOM(p2.r, p2.c);
             if(el1 && el2) {
                 el1.style.transform = `translate(${p1.c * CELL_SIZE}px, ${p1.r * CELL_SIZE}px)`;
                 el2.style.transform = `translate(${p2.c * CELL_SIZE}px, ${p2.r * CELL_SIZE}px)`;
                 await new Promise(r => setTimeout(r, 210));
             }
             gameState.isLocked = false;
             return;
        }

        // Check Word Match
        if (w1 && w2 && w1.lang !== w2.lang) {
            // Potential Word Match
            const cn = w1.lang === 'CN' ? w1 : w2;
            const en = w1.lang === 'EN' ? w1 : w2;
            
            const pair = WORD_PAIRS.find(p => p.cn === cn.word && p.en === en.word);
            
            if (pair) {
                // Correct Match!
                if (gameState.mode === 'moves') gameState.moves--;
                updateUI();
                processWordMatch(p1, p2, true);
                return;
            } else {
                // Wrong Match
                await swapAnimation(p1, p2); // Revert visual
                if (gameState.mode === 'moves') gameState.moves--;
                updateUI();
                processWordMatch(p1, p2, false);
                checkWinCondition();
                return;
            }
        }

        // Swap Data
        const t = gameState.grid[p1.r][p1.c];
        gameState.grid[p1.r][p1.c] = gameState.grid[p2.r][p2.c];
        gameState.grid[p2.r][p2.c] = t;

        // Swap Word Data
        const tw = gameState.wordGrid[p1.r][p1.c];
        gameState.wordGrid[p1.r][p1.c] = gameState.wordGrid[p2.r][p2.c];
        gameState.wordGrid[p2.r][p2.c] = tw;

        updateDomIds(p1, p2);

        const matches = findMatches();

        if (matches.length > 0) {
            if (gameState.mode === 'moves') gameState.moves--;
            gameState.comboMultiplier = 1;
            updateUI();
            await processMatches(matches);
        } else {
            // Invalid Move - Revert
            await swapAnimation(p1, p2);
            
            const t = gameState.grid[p1.r][p1.c];
            gameState.grid[p1.r][p1.c] = gameState.grid[p2.r][p2.c];
            gameState.grid[p2.r][p2.c] = t;

            const tw = gameState.wordGrid[p1.r][p1.c];
            gameState.wordGrid[p1.r][p1.c] = gameState.wordGrid[p2.r][p2.c];
            gameState.wordGrid[p2.r][p2.c] = tw;
            
            updateDomIds(p1, p2);
            gameState.isLocked = false;

            // Check for English word special logic
            const w1 = gameState.wordGrid[p1.r][p1.c];
            if (w1 && w1.lang === 'EN') {
                if (gameState.currentPair && w1.word === gameState.currentPair.en) {
                    // Remote Match!
                    let cnPos = null;
                    for(let r=0; r<ROWS; r++) {
                        for(let c=0; c<COLS; c++) {
                            const w = gameState.wordGrid[r][c];
                            if (w && w.lang === 'CN' && w.word === gameState.currentPair.cn) {
                                cnPos = {r, c};
                                break;
                            }
                        }
                    }

                    if (cnPos) {
                        gameState.isLocked = true;
                        if (gameState.mode === 'moves') gameState.moves--;
                        
                        await animateAndCrush(p1, cnPos, gameState.currentPair);

                        gameState.score += 500;
                        showFloatingText(500, p1);
                        
                        removeGem(p1.r, p1.c, true);
                        removeGem(cnPos.r, cnPos.c, true);
                        
                        advanceWordPair();
                        
                        updateUI();
                        
                        setTimeout(async () => {
                            await applyGravity();
                            ensureWords();
                            const matches = findMatches();
                            if(matches.length > 0) {
                                await processMatches(matches);
                            } else {
                                checkWinCondition();
                            }
                        }, 300);
                    } else {
                         // Should not happen if ensureWords works correctly, but fallback
                         // If no CN word found, maybe just entangle?
                         // Or do nothing.
                         // Let's treat as entangle if we can't find the pair to explode.
                         w1.isEntangled = true;
                         // Pick from available pairs only
                         const availableForEntangle = gameState.availablePairs.filter(
                             p => p.en !== w1.word && !isWordOnBoard(p.en, {r: p1.r, c: p1.c})
                         );
                         if (availableForEntangle.length > 0) {
                             const randomPair = availableForEntangle[Math.floor(Math.random() * availableForEntangle.length)];
                             w1.word = randomPair.en;
                         }
                         updateWordVisuals(p1.r, p1.c);
                    }
                } else {
                    // Entangle
                    w1.isEntangled = true;
                    // Pick from available pairs only
                    const availableForEntangle = gameState.availablePairs.filter(
                        p => p.en !== w1.word && !isWordOnBoard(p.en, {r: p1.r, c: p1.c})
                    );
                    if (availableForEntangle.length > 0) {
                        const randomPair = availableForEntangle[Math.floor(Math.random() * availableForEntangle.length)];
                        w1.word = randomPair.en;
                    }
                    updateWordVisuals(p1.r, p1.c);
                }
            }
        }
    }

    function advanceWordPair() {
        if (gameState.currentPair) {
            // Mark the current pair as crushed
            markPairAsCrushed(gameState.currentPair);
            
            // Pick next pair from available (non-crushed) pairs
            gameState.nextSequentialPair = getAvailablePair();
        }
        gameState.currentPair = null;
    }

    function removeGem(r, c, skipParticles = false) {
        const el = getGemDOM(r, c);
        if (el) {
            if (!skipParticles) {
                createParticles(r, c, gameState.grid[r][c]);
            }
            el.style.transform += " scale(0)";
            el.style.opacity = "0";
        }
        gameState.grid[r][c] = null;
        gameState.wordGrid[r][c] = null;
        setTimeout(() => { if(el) el.remove(); }, 300);
    }

    async function processWordMatch(p1, p2, isCorrect) {
        if (isCorrect) {
            // Find the pair info to get English word
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            let pair = gameState.currentPair;
            
            // If currentPair doesn't match (e.g. random match), try to find it from w1/w2
            if (w1 && w2) {
                 const cn = w1.lang === 'CN' ? w1 : w2;
                 const en = w1.lang === 'EN' ? w1 : w2;
                 const found = WORD_PAIRS.find(p => p.cn === cn.word && p.en === en.word);
                 if(found) pair = found;
            }

            await animateAndCrush(p1, p2, pair);

            gameState.score += 500;
            showFloatingText(500, p1);
            
            removeGem(p1.r, p1.c, true);
            removeGem(p2.r, p2.c, true);
            
            advanceWordPair();
            
            updateUI();
            
            setTimeout(async () => {
                await applyGravity();
                ensureWords();
                const matches = findMatches();
                if(matches.length > 0) {
                    await processMatches(matches);
                } else {
                    checkWinCondition();
                }
            }, 300);
            
        } else {
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            let enPos = w1.lang === 'EN' ? p1 : p2;
            
            // Pick from available pairs only for entangle
            const availableForEntangle = gameState.availablePairs.filter(
                p => (!gameState.currentPair || p.en !== gameState.currentPair.en) && !isWordOnBoard(p.en, enPos)
            );
            
            let newWord = null;
            if (availableForEntangle.length > 0) {
                const randomPair = availableForEntangle[Math.floor(Math.random() * availableForEntangle.length)];
                newWord = randomPair.en;
            }
            
            gameState.wordGrid[enPos.r][enPos.c] = {
                word: newWord || gameState.wordGrid[enPos.r][enPos.c].word,
                lang: 'EN',
                isEntangled: true
            };
            updateWordVisuals(enPos.r, enPos.c);
        }
    }

    function updateDomIds(p1, p2) {
        const dom1 = document.getElementById(`gem-${p1.r}-${p1.c}`);
        const dom2 = document.getElementById(`gem-${p2.r}-${p2.c}`);
        
        if(dom1 && dom2) {
            dom1.id = "temp_id";
            dom2.id = `gem-${p1.r}-${p1.c}`;
            dom1.id = `gem-${p2.r}-${p2.c}`;
            
            // Update event listeners to new coords
            updateListener(dom1, p2.r, p2.c);
            updateListener(dom2, p1.r, p1.c);
        }
    }
    
    function updateListener(el, r, c) {
        bindInteraction(el, r, c);
    }

    function bindInteraction(el, r, c) {
        const startHandler = (e) => {
            if (e.cancelable && e.type === 'touchstart') e.preventDefault();
            handleInteractionStart(e, r, c);
        };
        el.onmousedown = startHandler;
        el.ontouchstart = startHandler;
    }

    let dragStart = null;

    function handleInteractionStart(e, r, c) {
        if (gameState.isLocked) return;
        
        // Block entangled
        if (gameState.wordGrid[r][c] && gameState.wordGrid[r][c].isEntangled) return;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        dragStart = {
            r, c,
            x: clientX,
            y: clientY,
            moved: false
        };

        document.addEventListener('mousemove', handleInteractionMove);
        document.addEventListener('mouseup', handleInteractionEnd);
        document.addEventListener('touchmove', handleInteractionMove, { passive: false });
        document.addEventListener('touchend', handleInteractionEnd);
    }

    function handleInteractionMove(e) {
        if (!dragStart || gameState.isLocked) return;

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const dx = clientX - dragStart.x;
        const dy = clientY - dragStart.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 20) { // Threshold
            dragStart.moved = true;
            
            // Determine direction
            let targetR = dragStart.r;
            let targetC = dragStart.c;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (dx > 0) targetC++; else targetC--;
            } else {
                // Vertical
                if (dy > 0) targetR++; else targetR--;
            }

            // Check bounds
            if (targetR >= 0 && targetR < ROWS && targetC >= 0 && targetC < COLS) {
                // Execute Swap
                const p1 = { r: dragStart.r, c: dragStart.c };
                const p2 = { r: targetR, c: targetC };
                
                // Clear any existing selection
                if (gameState.selectedGem) {
                    toggleSelectVisual(gameState.selectedGem, false);
                    gameState.selectedGem = null;
                }

                attemptSwap(p1, p2);
            }
            
            // Stop tracking immediately after triggering swap
            cleanupInteraction();
        }
    }

    function handleInteractionEnd(e) {
        if (dragStart && !dragStart.moved) {
            // It was a click
            handleInput(dragStart.r, dragStart.c);
        }
        cleanupInteraction();
    }

    function cleanupInteraction() {
        dragStart = null;
        document.removeEventListener('mousemove', handleInteractionMove);
        document.removeEventListener('mouseup', handleInteractionEnd);
        document.removeEventListener('touchmove', handleInteractionMove);
        document.removeEventListener('touchend', handleInteractionEnd);
    }

    function swapAnimation(p1, p2) {
        return new Promise(resolve => {
            const el1 = getGemDOM(p1.r, p1.c);
            const el2 = getGemDOM(p2.r, p2.c);

            if(!el1 || !el2) { resolve(); return; }

            el1.style.transition = 'transform 0.2s ease';
            el2.style.transition = 'transform 0.2s ease';

            el1.style.transform = `translate(${p2.c * CELL_SIZE}px, ${p2.r * CELL_SIZE}px)`;
            el2.style.transform = `translate(${p1.c * CELL_SIZE}px, ${p1.r * CELL_SIZE}px)`;

            setTimeout(() => {
                resolve();
            }, 210);
        });
    }

    /* --- Matching Engine --- */

    function findMatches() {
        const matchedSet = new Set();

        // Horizontal
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS - 2; c++) {
                const type = gameState.grid[r][c];
                if (type === null) continue;
                if (gameState.grid[r][c+1] === type && gameState.grid[r][c+2] === type) {
                    matchedSet.add(`${r},${c}`);
                    matchedSet.add(`${r},${c+1}`);
                    matchedSet.add(`${r},${c+2}`);
                }
            }
        }

        // Vertical
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 2; r++) {
                const type = gameState.grid[r][c];
                if (type === null) continue;
                if (gameState.grid[r+1][c] === type && gameState.grid[r+2][c] === type) {
                    matchedSet.add(`${r},${c}`);
                    matchedSet.add(`${r+1},${c}`);
                    matchedSet.add(`${r+2},${c}`);
                }
            }
        }

        return Array.from(matchedSet).map(str => {
            const [r, c] = str.split(',').map(Number);
            return { r, c };
        });
    }

    async function processMatches(matches) {
        // Check for EN word match and include CN word if exists
        // Also check for CN word match and include EN word if exists
        if (gameState.currentPair) {
            let enExploded = false;
            let cnExploded = false;
            
            for (const m of matches) {
                const w = gameState.wordGrid[m.r][m.c];
                if (w) {
                    if (w.word === gameState.currentPair.en) enExploded = true;
                    if (w.word === gameState.currentPair.cn) cnExploded = true;
                }
            }

            if (enExploded || cnExploded) {
                // Find the other part of the pair
                let targetWord = enExploded ? gameState.currentPair.cn : gameState.currentPair.en;
                let targetPos = null;
                
                // If both exploded, we are good. If only one, find the other.
                if (!(enExploded && cnExploded)) {
                    for(let r=0; r<ROWS; r++) {
                        for(let c=0; c<COLS; c++) {
                            const w = gameState.wordGrid[r][c];
                            if (w && w.word === targetWord) {
                                targetPos = {r, c};
                                break;
                            }
                        }
                        if(targetPos) break;
                    }

                    if (targetPos) {
                        const alreadyMatched = matches.some(m => m.r === targetPos.r && m.c === targetPos.c);
                        if (!alreadyMatched) {
                            matches.push(targetPos);
                            gameState.score += 300; 
                            showFloatingText("连消!", targetPos);
                        }
                    }
                }
            }
        }

        // Score
        const baseScore = 100;
        const points = (matches.length * baseScore) * gameState.comboMultiplier;
        gameState.score += points;
        
        if(matches.length > 0) {
            showFloatingText(points, matches[0]);
        }

        let cnExploded = false;
        // Check for words in matches
        matches.forEach(m => {
            const w = gameState.wordGrid[m.r][m.c];
            if (w) {
                if (gameState.currentPair) {
                    if (w.word === gameState.currentPair.cn) {
                        cnExploded = true;
                    }
                    if (w.word === gameState.currentPair.cn || w.word === gameState.currentPair.en) {
                        gameState.score += 200; // Bonus
                        showFloatingText("奖励!", m);
                    }
                }
            }
            
            // Disentangle neighbors
            const neighbors = [
                {r: m.r-1, c: m.c}, {r: m.r+1, c: m.c},
                {r: m.r, c: m.c-1}, {r: m.r, c: m.c+1}
            ];
            neighbors.forEach(n => {
                if(n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS) {
                    const nw = gameState.wordGrid[n.r][n.c];
                    if(nw && nw.isEntangled) {
                        nw.isEntangled = false;
                        updateWordVisuals(n.r, n.c);
                    }
                }
            });
        });
        
        gameState.comboMultiplier++;
        updateUI();

        if (cnExploded) {
            advanceWordPair();
        }

        // Check for pair animation
        const animatedGems = new Set();
        let pairToAnimate = null;
        let enGem = null;
        let cnGem = null;
        
        for(let i=0; i<matches.length; i++) {
            const m1 = matches[i];
            const w1 = gameState.wordGrid[m1.r][m1.c];
            if(!w1) continue;
            
            for(let j=i+1; j<matches.length; j++) {
                const m2 = matches[j];
                const w2 = gameState.wordGrid[m2.r][m2.c];
                if(!w2) continue;
                
                if(w1.lang !== w2.lang) {
                    const cn = w1.lang === 'CN' ? w1 : w2;
                    const en = w1.lang === 'EN' ? w1 : w2;
                    const p = WORD_PAIRS.find(wp => wp.cn === cn.word && wp.en === en.word);
                    if(p) {
                        pairToAnimate = p;
                        enGem = w1.lang === 'EN' ? m1 : m2;
                        cnGem = w1.lang === 'CN' ? m1 : m2;
                        break;
                    }
                }
            }
            if(pairToAnimate) break;
        }
        
        if(pairToAnimate && enGem && cnGem) {
            await animateAndCrush(enGem, cnGem, pairToAnimate);
            animatedGems.add(`${enGem.r},${enGem.c}`);
            animatedGems.add(`${cnGem.r},${cnGem.c}`);
        }

        // Remove
        matches.forEach(m => {
            const skipParticles = animatedGems.has(`${m.r},${m.c}`);
            removeGem(m.r, m.c, skipParticles);
        });

        await new Promise(r => setTimeout(r, 300));

        // Clean DOM
        matches.forEach(m => {
            const el = getGemDOM(m.r, m.c);
            if (el) el.remove();
        });

        await applyGravity();
        ensureWords();

        // Cascade
        const newMatches = findMatches();
        if (newMatches.length > 0) {
            await new Promise(r => setTimeout(r, 200));
            await processMatches(newMatches);
        } else {
            checkWinCondition();
        }
    }

    async function applyGravity() {
        const moves = []; 

        // 1. Shift down
        for (let c = 0; c < COLS; c++) {
            let emptySlots = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (gameState.grid[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const type = gameState.grid[r][c];
                    const newR = r + emptySlots;
                    
                    gameState.grid[newR][c] = type;
                    gameState.grid[r][c] = null;

                    gameState.wordGrid[newR][c] = gameState.wordGrid[r][c];
                    gameState.wordGrid[r][c] = null;

                    const el = getGemDOM(r, c);
                    if(el) {
                        el.id = `gem-${newR}-${c}`;
                        moves.push({ el, r: newR, c });
                    }
                }
            }

            // 2. Fill top
            for(let r = 0; r < emptySlots; r++) {
                const type = Math.floor(Math.random() * GEM_TYPES);
                gameState.grid[r][c] = type;
                gameState.wordGrid[r][c] = null;
                
                const div = document.createElement('div');
                div.classList.add('gem', `type-${type}`);
                div.id = `gem-${r}-${c}`;
                div.style.width = `${CELL_SIZE}px`;
                div.style.height = `${CELL_SIZE}px`;
                div.style.transform = `translate(${c * CELL_SIZE}px, -${(emptySlots - r + 1) * CELL_SIZE}px)`;
                
                const inner = document.createElement('div');
                inner.classList.add('gem-inner');
                div.appendChild(inner);
                
                dom.grid.appendChild(div);
                moves.push({ el: div, r: r, c: c });
            }
        }

        await new Promise(r => requestAnimationFrame(r));

        moves.forEach(m => {
            m.el.style.transition = 'transform 0.4s cubic-bezier(0.25, 1, 0.5, 1)';
            m.el.style.transform = `translate(${m.c * CELL_SIZE}px, ${m.r * CELL_SIZE}px)`;
            
            // Update Listener for new position
            updateListener(m.el, m.r, m.c);
        });

        await new Promise(r => setTimeout(r, 400));
    }

    /* --- VFX & UI --- */

    function playWinEffect() {
        const overlay = document.getElementById('success-overlay');
        const canvas = document.getElementById('confetti-canvas');
        overlay.classList.remove('hidden');
        
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

        for(let i=0; i<200; i++) {
            particles.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 30,
                vy: (Math.random() - 0.5) * 30,
                color: colors[Math.floor(Math.random() * colors.length)],
                size: Math.random() * 10 + 5,
                life: 100
            });
        }

        function animate() {
            if(overlay.classList.contains('hidden')) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let active = false;
            particles.forEach(p => {
                if(p.life > 0) {
                    active = true;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // Gravity
                    p.life--;
                    
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            });

            if(active) requestAnimationFrame(animate);
        }
        
        animate();
    }

    function createParticles(r, c, type, x, y) {
        const centerX = x !== undefined ? x : (c * CELL_SIZE + CELL_SIZE / 2);
        const centerY = y !== undefined ? y : (r * CELL_SIZE + CELL_SIZE / 2);
        const colors = ['#ff4d4d', '#4da6ff', '#4dff88', '#ffff4d', '#bf4dff', '#ffae4d'];
        const color = colors[type] || '#fff';

        for (let i = 0; i < 8; i++) {
            const p = document.createElement('div');
            p.classList.add('particle');
            p.style.backgroundColor = color;
            p.style.left = `${centerX}px`;
            p.style.top = `${centerY}px`;
            p.style.width = `${Math.random() * 10 + 5}px`;
            p.style.height = p.style.width;
            
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * 60 + 20;
            p.style.setProperty('--dest-x', `${Math.cos(angle) * velocity}px`);
            p.style.setProperty('--dest-y', `${Math.sin(angle) * velocity}px`);
            
            dom.grid.appendChild(p);
            setTimeout(() => p.remove(), 600);
        }
    }

    function showFloatingText(text, pos) {
        const el = document.createElement('div');
        el.classList.add('float-text');
        el.textContent = typeof text === 'number' ? `+${text}` : text;
        // Safety check for pos
        if(pos && pos.c !== undefined) {
            el.style.left = `${pos.c * CELL_SIZE + CELL_SIZE/2 - 20}px`;
            el.style.top = `${pos.r * CELL_SIZE}px`;
            dom.grid.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
    }

    function updateUI() {
        dom.score.textContent = gameState.score;
        
        if (gameState.mode === 'time') {
            const m = Math.floor(gameState.timeLeft / 60);
            const s = gameState.timeLeft % 60;
            dom.moves.textContent = `${m}:${s.toString().padStart(2, '0')}`;
        } else {
            dom.moves.textContent = gameState.moves;
        }
        
        dom.level.textContent = gameState.level;
        dom.target.textContent = gameState.targetScore;

        const levelEarned = gameState.score - (gameState.levelStartScore || 0);
        const levelGoal = gameState.targetScore - (gameState.levelStartScore || 0);
        const progress = levelGoal > 0 ? Math.min(100, (levelEarned / levelGoal) * 100) : 0;
        
        dom.progress.style.width = `${progress}%`;
    }

    function checkWinCondition() {
        if (gameState.score >= gameState.targetScore) {
            gameState.isLocked = true;
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            dom.levelScoreFinal.textContent = gameState.score;
            playWinEffect();
            
            // Notify parent of level completion
            window.parent.postMessage({ 
                type: 'levelCompleted', 
                data: {
                    score: gameState.score, 
                    level: gameState.level,
                    difficulty: gameState.difficulty,
                    mode: gameState.mode
                }
            }, '*');

            setTimeout(() => {
                // Auto advance to next level
                startLevel(gameState.level + 1);
            }, 2000);
        } else {
            let isGameOver = false;
            if (gameState.mode === 'time') {
                if (gameState.timeLeft <= 0) isGameOver = true;
            } else {
                if (gameState.moves <= 0) isGameOver = true;
            }

            if (isGameOver) {
                gameState.isLocked = true;
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                dom.finalScore.textContent = gameState.score;
                
                // Notify parent of game over
                window.parent.postMessage({ 
                    type: 'gameFinished', 
                    data: { 
                        score: gameState.score, 
                        level: gameState.level,
                        difficulty: gameState.difficulty,
                        mode: gameState.mode
                    } 
                }, '*');

                setTimeout(() => {
                    dom.gameOverModal.classList.remove('hidden');
                }, 500);
            } else {
                gameState.isLocked = false;
            }
        }
    }

    function fitText(el) {
        requestAnimationFrame(() => {
            if (!el || !el.parentElement) return;
            const w = el.offsetWidth;
            const max = CELL_SIZE * 2.8; 
            if (w > max) {
                const s = max / w;
                el.style.transform = `translate(-50%, -50%) scale(${s})`;
            } else {
                el.style.transform = `translate(-50%, -50%)`;
            }
        });
    }

    function ensureWords() {
        // Count existing words
        let cnCount = 0;
        let enCount = 0;
        let hasTargetCN = false;
        let hasTargetEN = false;
        
        const existingWordCols = [];
        const existingWords = new Set();

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const w = gameState.wordGrid[r][c];
                if(w) {
                    existingWordCols.push({r, c});
                    existingWords.add(w.word);
                    if(w.lang === 'CN') cnCount++;
                    if(w.lang === 'EN') enCount++;
                    if(gameState.currentPair) {
                        if(w.word === gameState.currentPair.cn) hasTargetCN = true;
                        if(w.word === gameState.currentPair.en) hasTargetEN = true;
                    }
                }
            }
        }

        // If current pair is missing, pick new one
        if (!gameState.currentPair) {
             if (cnCount > 0) {
                 // Find the CN word on board
                 let found = null;
                 for(let r=0; r<ROWS; r++) {
                     for(let c=0; c<COLS; c++) {
                         if(gameState.wordGrid[r][c] && gameState.wordGrid[r][c].lang === 'CN') {
                             found = gameState.wordGrid[r][c];
                             break;
                         }
                     }
                 }
                 if(found) {
                     const pair = WORD_PAIRS.find(p => p.cn === found.word);
                     if(pair && !isPairCrushed(pair)) gameState.currentPair = pair;
                     else gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
                 } else {
                     gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
                 }
             } else if (enCount > 0) {
                 // 70% chance to use existing English words in the scene first
                 if (Math.random() < 0.7) {
                     // Find an EN word on board to match (only non-crushed)
                     const enWords = [];
                     for(let r=0; r<ROWS; r++) {
                         for(let c=0; c<COLS; c++) {
                             if(gameState.wordGrid[r][c] && gameState.wordGrid[r][c].lang === 'EN') {
                                 enWords.push(gameState.wordGrid[r][c]);
                             }
                         }
                     }
                     
                     if (enWords.length > 0) {
                         const randomEn = enWords[Math.floor(Math.random() * enWords.length)];
                         const pair = WORD_PAIRS.find(p => p.en === randomEn.word);
                         if(pair && !isPairCrushed(pair)) gameState.currentPair = pair;
                         else gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
                     } else {
                         gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
                     }
                 } else {
                     // 30% chance to pick a new pair from available
                     gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
                 }
             } else {
                 gameState.currentPair = gameState.nextSequentialPair || getAvailablePair();
             }
        }

        if (!gameState.currentPair) {
            gameState.currentPair = {cn: "空", en: "Empty"};
        }

        function getValidSpot() {
            let candidates = [];
            
            // Pass 1: Strict constraints
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if (!gameState.wordGrid[r][c] && gameState.grid[r][c] !== null) {
                        // Constraint 1: Not left/right most
                        if (c === 0 || c === COLS - 1) continue;
                        
                        // Constraint 2: At least 1 cell away (gap) in either row or col
                        let valid = true;
                        for (const w of existingWordCols) {
                            if (Math.abs(w.r - r) < 2 && Math.abs(w.c - c) < 2) {
                                valid = false;
                                break;
                            }
                        }
                        
                        if (valid) {
                            candidates.push({r, c});
                        }
                    }
                }
            }
            
            if (candidates.length > 0) {
                return candidates[Math.floor(Math.random() * candidates.length)];
            }

            // Pass 2: Fallback - any empty spot
            candidates = [];
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if (!gameState.wordGrid[r][c] && gameState.grid[r][c] !== null) {
                        candidates.push({r, c});
                    }
                }
            }
            
            if (candidates.length === 0) return null;
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        // Add CN if missing
        if (cnCount < 1) {
            const spot = getValidSpot();
            if (spot) {
                gameState.wordGrid[spot.r][spot.c] = {
                    word: gameState.currentPair.cn,
                    lang: 'CN',
                    isEntangled: false
                };
                updateWordVisuals(spot.r, spot.c);
                existingWordCols.push(spot);
                existingWords.add(gameState.currentPair.cn);
                cnCount++;
            }
        }

        // Add Target EN if missing
        hasTargetEN = false;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const w = gameState.wordGrid[r][c];
                if(w && w.word === gameState.currentPair.en) hasTargetEN = true;
            }
        }

        if (!hasTargetEN) {
            const spot = getValidSpot();
            if (spot) {
                gameState.wordGrid[spot.r][spot.c] = {
                    word: gameState.currentPair.en,
                    lang: 'EN',
                    isEntangled: false
                };
                updateWordVisuals(spot.r, spot.c);
                existingWordCols.push(spot);
                existingWords.add(gameState.currentPair.en);
                enCount++;
            }
        }

        // Fill remaining EN slots (up to 4) - only use non-crushed pairs
        let attempts = 0;
        while (enCount < 4 && attempts < 20) {
            const spot = getValidSpot();
            if (!spot) break;
            
            // Get available pairs that are not already on the board
            const availableForFill = gameState.availablePairs.filter(
                p => p.en !== gameState.currentPair.en && !existingWords.has(p.en)
            );
            
            if (availableForFill.length === 0) break; // No more available pairs
            
            const randomPair = availableForFill[Math.floor(Math.random() * availableForFill.length)];

            gameState.wordGrid[spot.r][spot.c] = {
                word: randomPair.en,
                lang: 'EN',
                isEntangled: false
            };
            updateWordVisuals(spot.r, spot.c);
            existingWordCols.push(spot);
            existingWords.add(randomPair.en);
            enCount++;
            attempts++;
        }
    }

    function updateWordVisuals(r, c) {
        const el = getGemDOM(r, c);
        if (!el) return;
        
        const existing = el.querySelector('.gem-word');
        if (existing) existing.remove();
        el.classList.remove('entangled');
        el.classList.remove('has-word');
        el.classList.remove('lang-cn');
        el.classList.remove('lang-en');

        const data = gameState.wordGrid[r][c];
        if (data) {
            el.classList.add('has-word');
            el.classList.add(data.lang === 'CN' ? 'lang-cn' : 'lang-en');
            const wordEl = document.createElement('div');
            wordEl.classList.add('gem-word');
            wordEl.textContent = data.word;
            el.appendChild(wordEl);
            fitText(wordEl);
            
            if (data.isEntangled) {
                el.classList.add('entangled');
            }
        }
 }

    function updateLevelDropdown() {
        const select = dom.wordLevelSelect;
        const currentVal = parseInt(select.value) || 1;
        select.innerHTML = '';
        
        const levels = Object.keys(ALL_WORD_LEVELS).map(Number).sort((a, b) => a - b);
        
        if (levels.length === 0) {
             const option = document.createElement('option');
             option.value = 1;
             option.textContent = 'Level 1';
             select.appendChild(option);
             return;
        }

        levels.forEach(lvl => {
            const option = document.createElement('option');
            option.value = lvl;
            option.textContent = `Level ${lvl}`;
            if (lvl === currentVal) {
                option.selected = true;
            }
            select.appendChild(option);
        });
        
        // If current selection is no longer valid, select the first one
        if (!levels.includes(currentVal)) {
             select.value = levels[0];
             gameState.wordLevel = levels[0];
        }
    }

    // Run
    init();

</script>
</body>
</html>
