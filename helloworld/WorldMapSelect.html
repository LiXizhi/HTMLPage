<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>World Map City Selector</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/npm/three%400.128.0/build/three.min.js"></script>
    <script src="https://cdn.keepwork.com/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
        outline: none;
        touch-action: none;
      }

      /* Off-screen destination indicator */
      .destination-indicator {
        position: fixed;
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        white-space: nowrap;
        border: 2px solid #fff;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        z-index: 1;
        display: flex;
        align-items: center;
        gap: 6px;
        animation: indicator-pulse 1s ease-in-out infinite;
      }

      @keyframes indicator-pulse {
        0%, 100% {
          opacity: 1;
          box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
        }
        50% {
          opacity: 0.9;
          box-shadow: 0 0 25px rgba(251, 191, 36, 1);
        }
      }
    </style>
  </head>
  <body>
    <!-- Container for Three.js renderer -->
    <div id="map-container" class="w-full h-full relative"></div>

    <!-- Off-screen Destination Indicator -->
    <div id="destination-indicator" class="destination-indicator hidden">
      <span id="indicator-arrow">→</span>
      <span id="indicator-name">---</span>
    </div>

    <!-- Title Overlay -->
    <div id="map-title" class="absolute top-4 left-4 z-50 pointer-events-none">
      <h1
        class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg"
        style="font-family: 'Arial Black', sans-serif; -webkit-text-stroke: 1px white"
      >
        HelloWorld
      </h1>
      <p class="text-sm text-white font-semibold tracking-wider drop-shadow-md mt-1 ml-1">Select a city to travel</p>
    </div>

    <!-- Close Button -->
    <button
      id="close-btn"
      class="absolute top-4 right-4 z-50 bg-gray-800/80 hover:bg-gray-700 text-white p-3 rounded-full shadow-lg border-2 border-white transition-transform hover:scale-110"
      title="关闭"
    >
      ✕
    </button>

    <script>
      /**
       * World Map City Selector - Standalone Component
       * Communicates with parent window via postMessage API
       * 
       * Messages sent to parent:
       * - { type: 'mapLoaded' } - When map is ready
       * - { type: 'citySelected', city: {...} } - When user selects a city
       * - { type: 'mapClosed' } - When user closes the map
       * - { type: 'travelComplete', city: {...} } - When plane animation completes
       * 
       * Messages received from parent:
       * - { type: 'setConfig', homeCity: string, currentCity: string } - Configure map state
       * - { type: 'flyToCity', cityName: string, enterCity: boolean } - Trigger plane animation
       * - { type: 'close' } - Close the map selector
       */

      // --- Configuration ---
      let homeCity = "深圳";
      let currentCityName = null;

      // --- Load World Map Data from External File ---
      let CITIES = [];
      let CONTINENTS = {};

      async function loadCitiesData() {
        const defaultCities = [
          { name: "深圳", lat: 22.5431, lon: 114.0579, population: 12590000, level: 1 },
          { name: "东京", lat: 35.6762, lon: 139.6503, population: 13960000, level: 1 },
        ];

        try {
          const response = await fetch("world_traveler_data.json");
          const text = await response.text();

          const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
          if (jsonMatch) {
            const jsonText = jsonMatch[0].replace(/\/\/.*$/gm, "");
            const parsed = JSON.parse(jsonText);
            if (Array.isArray(parsed)) {
              CITIES = parsed;
              CONTINENTS = {};
            } else {
              CITIES = parsed.cities || defaultCities;
              CONTINENTS = parsed.continents || {};
            }
            console.log(`Loaded ${CITIES.length} cities from world_traveler_data`);
          } else {
            console.error("Could not parse cities data");
            CITIES = defaultCities;
          }
        } catch (error) {
          console.error("Error loading cities data:", error);
          CITIES = defaultCities;
        }
      }

      // --- World Map Manager Class ---
      class WorldMapManager {
        constructor(container) {
          this.container = container;
          this.width = window.innerWidth;
          this.height = window.innerHeight;

          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x000000);
          this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.1, 1000);

          // Center camera on initial location
          const initialLat = 25;
          const initialLon = 105;
          const cameraDistance = 28;
          const phi = (90 - initialLat) * (Math.PI / 180);
          const theta = (initialLon + 180) * (Math.PI / 180);
          const camX = -(cameraDistance * Math.sin(phi) * Math.cos(theta));
          const camZ = cameraDistance * Math.sin(phi) * Math.sin(theta);
          const camY = cameraDistance * Math.cos(phi);
          this.camera.position.set(camX, camY, camZ);

          this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          this.renderer.setSize(this.width, this.height);
          this.container.appendChild(this.renderer.domElement);

          this.group = new THREE.Group();
          this.scene.add(this.group);

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();

          this.cities = [];
          this.planes = [];
          this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.minDistance = 15;
          this.controls.maxDistance = 60;
          this.controls.enablePan = false;

          this.autoRotate = true;
          this.clock = new THREE.Clock();
          this.cameraRestoreAnim = null;
          this.isStarted = false;

          this.init();
          this.setupEventListeners();
        }

        init() {
          // Earth Sphere with terrain texture
          // Texture covers: lon -180 to 180, lat -60 to 85
          const textureLonMin = -180;
          const textureLonMax = 180;
          const textureLatMin = -60;
          const textureLatMax = 85;

          // Create custom sphere geometry with manual triangles and UV mapping
          const radius = 10;
          const widthSegments = 64;
          const heightSegments = 64;
          
          const geometry = this.createCustomSphereGeometry(
            radius, widthSegments, heightSegments,
            textureLonMin, textureLonMax, textureLatMin, textureLatMax
          );

          // Load terrain texture with nearest (block) filtering
          const textureLoader = new THREE.TextureLoader();
          const terrainTexture = textureLoader.load(
            'https://cdn.keepwork.com/worldmap/terrain_-180_180_-60_85.png',
            (texture) => {
              console.log('Terrain texture loaded successfully');
              texture.wrapS = THREE.ClampToEdgeWrapping;
              texture.wrapT = THREE.ClampToEdgeWrapping;
              texture.magFilter = THREE.NearestFilter;
              texture.minFilter = THREE.NearestFilter;
              texture.needsUpdate = true;
            },
            undefined,
            (error) => {
              console.error('Error loading terrain texture:', error);
            }
          );
          // Set filters immediately as well
          terrainTexture.magFilter = THREE.NearestFilter;
          terrainTexture.minFilter = THREE.NearestFilter;

          const material = new THREE.MeshPhongMaterial({
            map: terrainTexture,
            color: 0xffffff,
            emissive: 0x111111,
            specular: 0x111111,
            shininess: 5,
          });
          this.earth = new THREE.Mesh(geometry, material);
          this.group.add(this.earth);

          // Atmosphere glow
          const atmGeo = new THREE.SphereGeometry(10.2, 64, 64);
          const atmMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide });
          this.group.add(new THREE.Mesh(atmGeo, atmMat));

          // Lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          this.scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 1);
          dirLight.position.set(50, 30, 50);
          this.scene.add(dirLight);
        }

        setupEventListeners() {
          const canvas = this.renderer.domElement;
          let downX = 0;
          let downY = 0;

          canvas.addEventListener("pointerdown", (e) => {
            downX = e.clientX;
            downY = e.clientY;
            this.autoRotate = false;
          });

          canvas.addEventListener("pointerup", (e) => {
            const moveDist = Math.sqrt(Math.pow(e.clientX - downX, 2) + Math.pow(e.clientY - downY, 2));
            if (moveDist < 10) {
              this.onClick(e);
            }
          });

          this.controls.addEventListener("start", () => {
            this.autoRotate = false;
          });

          window.addEventListener("resize", () => this.onResize());
        }

        onResize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.width, this.height);
        }

        renderMapObjects() {
          this.createContinentOutlines();
          this.createCities();
        }

        // Create custom sphere geometry with manual triangles and UV mapping
        // This ensures precise UV mapping that matches our latLonToVector3 coordinate system
        createCustomSphereGeometry(radius, widthSegments, heightSegments, texLonMin, texLonMax, texLatMin, texLatMax) {
          const vertices = [];
          const uvs = [];
          const indices = [];
          const normals = [];

          // Generate vertices, normals, and UVs for each grid point
          // We iterate by latitude (phi) and longitude (theta)
          for (let latIdx = 0; latIdx <= heightSegments; latIdx++) {
            // Map latIdx to latitude: 0 -> 90 (north pole), heightSegments -> -90 (south pole)
            const lat = 90 - (latIdx / heightSegments) * 180;
            
            for (let lonIdx = 0; lonIdx <= widthSegments; lonIdx++) {
              // Map lonIdx to longitude: 0 -> -180, widthSegments -> 180
              const lon = -180 + (lonIdx / widthSegments) * 360;
              
              // Convert lat/lon to 3D position using same formula as latLonToVector3
              const phi = (90 - lat) * (Math.PI / 180);
              const theta = (lon + 180) * (Math.PI / 180);
              const x = -(radius * Math.sin(phi) * Math.cos(theta));
              const z = radius * Math.sin(phi) * Math.sin(theta);
              const y = radius * Math.cos(phi);
              
              vertices.push(x, y, z);
              
              // Normal is just the normalized position (pointing outward)
              const nx = x / radius;
              const ny = y / radius;
              const nz = z / radius;
              normals.push(nx, ny, nz);
              
              // UV mapping: map lon/lat to texture coordinates
              // U: lon -180 -> 0, lon 180 -> 1
              const u = (lon - texLonMin) / (texLonMax - texLonMin);
              
              // V: texLatMax (85) -> 0 (top of texture), texLatMin (-60) -> 1 (bottom of texture)
              // Clamp latitude to texture bounds for areas outside texture coverage
              const clampedLat = Math.max(texLatMin, Math.min(texLatMax, lat));
              const v = (clampedLat - texLatMin) / (texLatMax - texLatMin);
              
              uvs.push(u, v);
            }
          }

          // Generate triangle indices
          // Each quad is made of 2 triangles
          const vertsPerRow = widthSegments + 1;
          
          for (let latIdx = 0; latIdx < heightSegments; latIdx++) {
            for (let lonIdx = 0; lonIdx < widthSegments; lonIdx++) {
              // Indices of the 4 corners of this quad
              const topLeft = latIdx * vertsPerRow + lonIdx;
              const topRight = topLeft + 1;
              const bottomLeft = (latIdx + 1) * vertsPerRow + lonIdx;
              const bottomRight = bottomLeft + 1;
              
              // First triangle (top-left, bottom-left, bottom-right)
              indices.push(topLeft, bottomLeft, bottomRight);
              
              // Second triangle (top-left, bottom-right, top-right)
              indices.push(topLeft, bottomRight, topRight);
            }
          }

          // Create BufferGeometry
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
          geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
          geometry.setIndex(indices);
          
          return geometry;
        }

        createContinentOutlines() {
          const radius = 10.05;
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x44ff88, linewidth: 2, transparent: true, opacity: 0.8 });

          const defaultContinents = {
            asia: [
              [66, 170], [70, 140], [75, 100], [70, 70], [55, 60], [45, 35], [35, 35],
              [25, 55], [10, 75], [8, 80], [20, 90], [22, 90], [25, 95], [10, 100],
              [5, 105], [1, 104], [-8, 110], [-8, 115], [-5, 120], [5, 120], [10, 125],
              [20, 120], [25, 122], [35, 130], [40, 130], [45, 140], [50, 140],
              [55, 160], [60, 170], [66, 170],
            ],
          };
          const continents = Object.keys(CONTINENTS).length > 0 ? CONTINENTS : defaultContinents;

          Object.values(continents).forEach((coords) => {
            const points = [];
            for (let i = 0; i < coords.length; i++) {
              const [lat1, lon1] = coords[i];
              const [lat2, lon2] = coords[(i + 1) % coords.length];

              points.push(this.latLonToVector3(lat1, lon1, radius));

              const segments = 5;
              for (let j = 1; j < segments; j++) {
                const t = j / segments;
                const latInterp = lat1 + (lat2 - lat1) * t;
                const lonInterp = lon1 + (lon2 - lon1) * t;
                points.push(this.latLonToVector3(latInterp, lonInterp, radius));
              }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, lineMaterial);
            this.group.add(line);
          });
        }

        latLonToVector3(lat, lon, radius) {
          const phi = (90 - lat) * (Math.PI / 180);
          const theta = (lon + 180) * (Math.PI / 180);
          const x = -(radius * Math.sin(phi) * Math.cos(theta));
          const z = radius * Math.sin(phi) * Math.sin(theta);
          const y = radius * Math.cos(phi);
          return new THREE.Vector3(x, y, z);
        }

        createCities() {
          const sortedCities = [...CITIES].sort((a, b) => b.population - a.population);

          const cityData = sortedCities.map((city) => ({
            city,
            pos: this.latLonToVector3(city.lat, city.lon, 10),
            mass: city.population,
          }));

          const minMarkerDistance = 0.5;
          const maxIterations = 50;

          for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;

            for (let i = 0; i < cityData.length; i++) {
              for (let j = i + 1; j < cityData.length; j++) {
                const a = cityData[i];
                const b = cityData[j];
                const dist = a.pos.distanceTo(b.pos);

                if (dist < minMarkerDistance && dist > 0.001) {
                  hasOverlap = true;

                  const direction = new THREE.Vector3().subVectors(b.pos, a.pos).normalize();
                  const totalMass = a.mass + b.mass;
                  const overlap = minMarkerDistance - dist;
                  const moveA = overlap * (b.mass / totalMass);
                  const moveB = overlap * (a.mass / totalMass);

                  a.pos.addScaledVector(direction, -moveA);
                  b.pos.addScaledVector(direction, moveB);

                  a.pos.normalize().multiplyScalar(10);
                  b.pos.normalize().multiplyScalar(10);
                }
              }
            }

            if (!hasOverlap) break;
          }

          cityData.forEach(({ city, pos }) => {
            const markerSize = city.level === 1 ? 0.25 : city.level === 2 ? 0.18 : 0.12;
            const markerGeo = new THREE.SphereGeometry(markerSize, 16, 16);

            let color;
            if (city.name === homeCity) {
              color = 0x00ff00;
            } else if (city.level === 1) {
              color = 0xffaa00;
            } else if (city.level === 2) {
              color = 0x88aaff;
            } else {
              color = 0xaaaaaa;
            }

            const markerMat = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(pos);
            marker.userData = { city: city };
            this.group.add(marker);

            const canvas = document.createElement("canvas");
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext("2d");
            const fontSize = city.level === 1 ? 28 : city.level === 2 ? 22 : 18;
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = city.level === 1 ? "#ffffff" : city.level === 2 ? "#ccddff" : "#999999";
            context.textAlign = "center";
            context.fillText(city.name, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);

            const labelPos = pos.clone().normalize().multiplyScalar(10.5);
            sprite.position.copy(labelPos);

            const spriteScale = city.level === 1 ? 2.5 : city.level === 2 ? 2.0 : 1.5;
            sprite.scale.set(spriteScale, spriteScale * 0.25, 1);

            this.group.add(sprite);

            this.cities.push({ marker, sprite, data: city, basePos: pos.clone() });
          });
        }

        onClick(event) {
          if (!this.isStarted) return;
          if (this.planes && this.planes.length > 0) return;

          this.mouse.x = (event.clientX / this.width) * 2 - 1;
          this.mouse.y = -(event.clientY / this.height) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const markers = this.cities
            .map((c) => c.marker)
            .filter((marker) => marker && marker.visible);

          if (!markers || markers.length === 0) return;

          try {
            const intersects = this.raycaster.intersectObjects(markers);

            if (intersects.length > 0) {
              const city = intersects[0].object.userData.city;
              // Send message to parent
              window.parent.postMessage({ type: 'citySelected', city: city }, '*');
            }
          } catch (e) {
            console.error("Error during raycasting:", e);
          }
        }

        update() {
          this.controls.update();

          if (this.autoRotate) {
            this.group.rotation.y += 0.001;
          }

          const dist = this.camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
          const showLevel2 = dist < 35;
          const showLevel3 = dist < 22;

          const visibleLabels = [];

          this.cities.forEach((c) => {
            const level = c.data.level || 1;
            const isHomeCity = c.data.name === homeCity;
            let shouldShowByLevel = false;

            if (isHomeCity || level === 1) {
              shouldShowByLevel = true;
            } else if (level === 2) {
              shouldShowByLevel = showLevel2;
            } else if (level === 3) {
              shouldShowByLevel = showLevel3;
            }

            const cameraPos = this.camera.position.clone().normalize();
            const markerDir = c.marker.position.clone().normalize();
            const dotProduct = markerDir.dot(cameraPos);
            const isFrontFacing = dotProduct > -0.1;

            const shouldShow = shouldShowByLevel && isFrontFacing;

            c.marker.visible = shouldShow;
            c.sprite.visible = false;
            c.potentiallyVisible = shouldShow;

            if (shouldShow) {
              const screenPos = c.marker.position.clone().project(this.camera);
              c.screenX = ((screenPos.x + 1) / 2) * this.width;
              c.screenY = ((-screenPos.y + 1) / 2) * this.height;

              visibleLabels.push(c);
            }
          });

          visibleLabels.sort((a, b) => b.data.population - a.data.population);

          const labelRadius = 50;
          const shownLabels = [];

          visibleLabels.forEach((c) => {
            let hasOverlap = false;

            for (const shown of shownLabels) {
              const dx = c.screenX - shown.screenX;
              const dy = c.screenY - shown.screenY;
              const screenDist = Math.sqrt(dx * dx + dy * dy);

              const minDist = labelRadius * (c.data.level === 1 ? 1.2 : c.data.level === 2 ? 1.0 : 0.8);

              if (screenDist < minDist) {
                hasOverlap = true;
                break;
              }
            }

            if (!hasOverlap) {
              c.sprite.visible = true;
              shownLabels.push(c);
            }
          });

          // Update plane animations
          this.updatePlaneAnimations();

          // Smooth camera restore animation
          this.updateCameraRestore();
        }

        updatePlaneAnimations() {
          if (!this.planes || this.planes.length === 0) return;

          const toRemove = [];
          for (let i = 0; i < this.planes.length; i++) {
            const anim = this.planes[i];
            const mesh = anim.mesh;
            const angleBetween = anim.start.clone().normalize().dot(anim.end.clone().normalize());
            const dtheta = Math.acos(THREE.MathUtils.clamp(angleBetween, -1, 1));
            const baseSpeed = 0.002 + 0.01 / (dtheta + 1.0);

            if (anim.state === "takeoff") {
              anim.t += 0.005;
              const s = THREE.MathUtils.lerp(0.01, 0.9, Math.min(1, anim.t / 0.15));
              mesh.scale.set(s, s, s);
              const pos = this.computeGreatCirclePoint(anim.start, anim.end, 0, anim.radius, anim.altitude * 0.2);
              mesh.position.copy(pos);
              mesh.lookAt(this.computeGreatCirclePoint(anim.start, anim.end, 0.05, anim.radius, anim.altitude * 0.2));
              if (anim.t >= 0.15) {
                anim.state = "cruise";
                anim.t = 0;
              }
            } else if (anim.state === "cruise") {
              anim.t += baseSpeed;
              const t = Math.min(1, anim.t);
              const pos = this.computeGreatCirclePoint(anim.start, anim.end, t, anim.radius, anim.altitude);
              mesh.position.copy(pos);
              mesh.scale.set(1.4, 1.4, 1.4);
              const lookAheadT = Math.min(1, t + 0.02);
              const aheadPos = this.computeGreatCirclePoint(anim.start, anim.end, lookAheadT, anim.radius, anim.altitude);
              mesh.lookAt(aheadPos);
              if (t >= 1) {
                if (anim.circleRoundsLeft <= 0) {
                  anim.state = "landing";
                  anim.t = 0;
                } else {
                  anim.state = "circle";
                  anim.circleAngle = 0;
                  anim.center = anim.end.clone().setLength(anim.radius + anim.altitude);
                  anim.circleRadius = Math.max(0.6, 0.6);
                  const normal = anim.center.clone().normalize();
                  const arbitrary = new THREE.Vector3(0, 1, 0);
                  if (Math.abs(normal.dot(arbitrary)) > 0.95) arbitrary.set(1, 0, 0);
                  anim.u = new THREE.Vector3().crossVectors(normal, arbitrary).normalize();
                  anim.v = new THREE.Vector3().crossVectors(normal, anim.u).normalize();
                }
              }
            } else if (anim.state === "circle") {
              anim.circleAngle += 0.04;
              const a = anim.circleAngle;
              const pos = anim.center
                .clone()
                .add(anim.u.clone().multiplyScalar(Math.cos(a) * anim.circleRadius))
                .add(anim.v.clone().multiplyScalar(Math.sin(a) * anim.circleRadius));
              mesh.position.copy(pos);
              const tangent = anim.u
                .clone()
                .multiplyScalar(-Math.sin(a) * anim.circleRadius)
                .add(anim.v.clone().multiplyScalar(Math.cos(a) * anim.circleRadius));
              const lookAt = pos.clone().add(tangent);
              mesh.lookAt(lookAt);
              if (anim.circleAngle >= Math.PI * 2 * anim.circleRoundsLeft) {
                anim.state = "landing";
                anim.t = 0;
              }
            } else if (anim.state === "landing") {
              anim.t += 0.03;
              const s = THREE.MathUtils.lerp(mesh.scale.x, 0.02, 0.2);
              mesh.scale.set(s, s, s);
              const current = mesh.position.clone();
              const dirToEnd = anim.end.clone().sub(current).multiplyScalar(0.15);
              mesh.position.add(dirToEnd);
              mesh.lookAt(anim.end);
              if (mesh.position.distanceTo(anim.end) < 0.08 || mesh.scale.x <= 0.03) {
                // Trigger completion
                if (typeof anim.onComplete === "function") {
                  try { anim.onComplete(); } catch (e) { console.error(e); }
                }
                // Send message to parent
                if (anim.destinationCity) {
                  window.parent.postMessage({ type: 'travelComplete', city: anim.destinationCity }, '*');
                }
                // Cleanup
                if (anim.trailMesh) {
                  try { this.group.remove(anim.trailMesh); } catch (e) {}
                }
                this.group.remove(mesh);
                if (this.controls && typeof anim.prevControlsEnabled !== "undefined") {
                  this.controls.enabled = anim.prevControlsEnabled;
                }
                // Camera restore
                try {
                  const preservedDistance = anim.prevCameraLen || this.camera.position.length();
                  const toDir = anim.end ? anim.end.clone().normalize() : this.camera.position.clone().normalize();
                  const toPos = toDir.clone().multiplyScalar(preservedDistance);

                  this.cameraRestoreAnim = {
                    fromPos: this.camera.position.clone(),
                    toPos: toPos,
                    fromTarget: this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0),
                    toTarget: new THREE.Vector3(0, 0, 0),
                    t: 0,
                    duration: 0.35,
                  };
                } catch (e) {}
                // Hide indicator
                try {
                  const indicator = document.getElementById("destination-indicator");
                  if (indicator) indicator.classList.add("hidden");
                } catch (e) {}
                toRemove.push(i);
              }
            }

            // Camera follow
            if (anim.followCamera && mesh) {
              if (anim.state === "takeoff") {
                anim.zoomInT = Math.min(1, anim.zoomInT + anim.zoomSpeed);
                const camLen = THREE.MathUtils.lerp(anim.prevCameraLen, anim.zoomInDistance, anim.zoomInT);
                const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                this.camera.position.lerp(targetCamPos, 0.25);
                if (this.controls) this.controls.target.lerp(mesh.position, 0.25);
                if (this.controls) this.controls.update();
              } else if (anim.state === "cruise") {
                anim.zoomOutT = Math.min(1, anim.zoomOutT + anim.zoomSpeed * 0.25);
                const camLen = THREE.MathUtils.lerp(anim.zoomInDistance, anim.zoomOutDistance, anim.zoomOutT);
                const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                this.camera.position.lerp(targetCamPos, 0.12);
                if (this.controls) this.controls.target.lerp(mesh.position, 0.12);
                if (this.controls) this.controls.update();
                // Update trail
                if (anim.trailMesh) {
                  anim.trailPoints.push(mesh.position.clone());
                  if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                  anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                  try { anim.trailMesh.computeLineDistances(); } catch (e) {}
                  anim.trailMesh.visible = true;
                }
              } else if (anim.state === "circle") {
                const shouldZoomIn = anim.circleRoundsLeft <= 1;
                if (shouldZoomIn) {
                  anim.zoomLandingT = Math.min(1, anim.zoomLandingT + anim.zoomLandingSpeed);
                } else {
                  anim.zoomLandingT = Math.max(0, anim.zoomLandingT - anim.zoomLandingSpeed * 0.5);
                }
                const camLen = THREE.MathUtils.lerp(anim.zoomOutDistance, anim.zoomLandingDistance, anim.zoomLandingT);
                const targetCamPos = mesh.position.clone().normalize().multiplyScalar(camLen);
                this.camera.position.lerp(targetCamPos, 0.18);
                if (this.controls) this.controls.target.lerp(mesh.position, 0.18);
                if (this.controls) this.controls.update();
                // Update trail
                if (anim.trailMesh) {
                  anim.trailPoints.push(mesh.position.clone());
                  if (anim.trailPoints.length > anim.trailMaxPoints) anim.trailPoints.shift();
                  anim.trailMesh.geometry.setFromPoints(anim.trailPoints);
                  try { anim.trailMesh.computeLineDistances(); } catch (e) {}
                  anim.trailMesh.visible = true;
                }
              }
            }
          }
          // Remove finished
          for (let r = toRemove.length - 1; r >= 0; r--) {
            this.planes.splice(toRemove[r], 1);
          }
        }

        updateCameraRestore() {
          try {
            const dt = this.clock.getDelta();
            if (this.cameraRestoreAnim) {
              const a = this.cameraRestoreAnim;
              a.t = Math.min(a.duration, a.t + dt);
              const u = Math.min(1, a.t / a.duration);
              if (a.fromPos && a.toPos) {
                this.camera.position.lerpVectors(a.fromPos, a.toPos, u);
              }
              if (this.controls && a.fromTarget && a.toTarget) {
                this.controls.target.lerpVectors(a.fromTarget, a.toTarget, u);
                this.controls.update();
              }
              if (u >= 1) {
                this.cameraRestoreAnim = null;
              }
            }
          } catch (e) {}
        }

        createPlaneMesh() {
          const group = new THREE.Group();

          const body = new THREE.BoxGeometry(0.5, 0.12, 0.8);
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffee88 });
          const bodyMesh = new THREE.Mesh(body, bodyMat);
          group.add(bodyMesh);

          const wingGeo = new THREE.BoxGeometry(0.9, 0.02, 0.08);
          const wingMat = new THREE.MeshStandardMaterial({ color: 0xdd3333 });
          const wing = new THREE.Mesh(wingGeo, wingMat);
          wing.position.set(0, 0, 0);
          group.add(wing);

          const tailGeo = new THREE.BoxGeometry(0.16, 0.2, 0.02);
          const tailMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
          const tail = new THREE.Mesh(tailGeo, tailMat);
          tail.position.set(-0.28, 0.08, 0);
          group.add(tail);

          group.scale.set(0.001, 0.001, 0.001);
          group.castShadow = true;
          group.receiveShadow = false;
          return group;
        }

        computeGreatCirclePoint(startVec, endVec, t, radius, altitude) {
          const v0 = startVec.clone().normalize();
          const v1 = endVec.clone().normalize();
          const dot = THREE.MathUtils.clamp(v0.dot(v1), -1, 1);
          const theta = Math.acos(dot);
          if (theta === 0) {
            const final = v0.clone().multiplyScalar(radius + altitude);
            return final;
          }
          const sinTheta = Math.sin(theta);
          const s0 = Math.sin((1 - t) * theta) / sinTheta;
          const s1 = Math.sin(t * theta) / sinTheta;
          const interpolated = v0.multiplyScalar(s0).add(v1.multiplyScalar(s1)).normalize();
          const lift = Math.sin(Math.PI * t) * altitude;
          return interpolated.multiplyScalar(radius + lift);
        }

        flyPlane(cityAName, cityBName, options = {}) {
          const {
            loopRounds = 0,
            altitude = 2.0,
            onComplete = null,
            followCamera = true,
            zoomInDistance = 18,
            zoomOutDistance = 25,
            zoomSpeed = 0.08,
            trailMaxPoints = 64,
            trailColor = 0xffffff,
            zoomLandingDistance = 14,
            zoomLandingSpeed = 0.06,
          } = options;

          if (!this.cities || this.cities.length === 0) return;

          const cityA = this.cities.find((c) => c.data.name === cityAName) || this.cities.find((c) => c.data.name === homeCity);
          const cityB = this.cities.find((c) => c.data.name === cityBName) || this.cities.find((c) => c.data.name === homeCity);
          if (!cityA || !cityB) return;

          const startPosSurface = cityA.basePos.clone();
          const endPosSurface = cityB.basePos.clone();

          const plane = this.createPlaneMesh();
          this.group.add(plane);

          const anim = {
            mesh: plane,
            start: startPosSurface.clone().normalize().multiplyScalar(10 + 0.01),
            end: endPosSurface.clone().normalize().multiplyScalar(10 + 0.01),
            t: 0,
            state: "takeoff",
            radius: 10,
            altitude: altitude,
            circleAngle: 0,
            circleRoundsLeft: loopRounds,
            onComplete: onComplete,
            destinationCity: cityB.data,
          };

          anim.followCamera = followCamera;
          anim.zoomInDistance = zoomInDistance;
          anim.zoomOutDistance = zoomOutDistance;
          anim.zoomSpeed = zoomSpeed;
          anim.zoomInT = 0;
          anim.zoomOutT = 0;
          anim.zoomLandingDistance = zoomLandingDistance;
          anim.zoomLandingSpeed = zoomLandingSpeed;
          anim.zoomLandingT = 0;
          anim.prevCameraPos = this.camera.position.clone();
          anim.prevControlsTarget = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
          anim.prevCameraLen = this.camera.position.length();

          anim.trailPoints = [];
          anim.trailMaxPoints = trailMaxPoints;
          const trailMat = new THREE.LineDashedMaterial({ color: trailColor, dashSize: 0.25, gapSize: 0.15, scale: 1 });
          const trailGeo = new THREE.BufferGeometry().setFromPoints(anim.trailPoints);
          const trailLine = new THREE.Line(trailGeo, trailMat);
          trailLine.computeLineDistances();
          trailLine.visible = false;
          this.group.add(trailLine);
          anim.trailMesh = trailLine;

          const startWorld = anim.start.clone().setLength(anim.radius + 0.1);
          plane.position.copy(startWorld);
          plane.lookAt(anim.end);
          plane.scale.set(0.01, 0.01, 0.01);

          this.planes.push(anim);

          try {
            const indicator = document.getElementById("destination-indicator");
            if (indicator) {
              indicator.classList.remove("hidden");
              const nameElem = document.getElementById("indicator-name");
              if (nameElem) nameElem.textContent = cityBName;
            }
          } catch (e) {}

          if (this.controls) {
            anim.prevControlsEnabled = this.controls.enabled;
            this.controls.enabled = false;
          }

          anim.isAnimating = true;
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          this.update();
          this.renderer.render(this.scene, this.camera);
        }

        start() {
          this.isStarted = true;
        }
      }

      // --- Main ---
      let worldMap = null;
https://cdn.keepwork.com/worldmap/terrain_-180_180_-60_85.png
      window.onload = async () => {
        const container = document.getElementById("map-container");
        worldMap = new WorldMapManager(container);

        await loadCitiesData();
        worldMap.renderMapObjects();
        worldMap.animate();

        // Auto-start the map
        worldMap.start();

        // Setup close button
        document.getElementById("close-btn").onclick = () => {
          window.parent.postMessage({ type: 'mapClosed' }, '*');
        };

        // Listen for messages from parent
        window.addEventListener("message", (e) => {
          const data = e.data;
          if (!data || !data.type) return;

          switch (data.type) {
            case 'setConfig':
              if (data.homeCity) homeCity = data.homeCity;
              if (data.currentCity) currentCityName = data.currentCity;
              break;

            case 'flyToCity':
              if (data.cityName) {
                const fromCity = currentCityName || homeCity;
                worldMap.flyPlane(fromCity, data.cityName, {
                  altitude: 2.2,
                  followCamera: true,
                  zoomInDistance: 18,
                  zoomOutDistance: 30,
                  zoomSpeed: 0.08,
                  trailMaxPoints: 96,
                  trailColor: 0xffee88,
                });
                currentCityName = data.cityName;
              }
              break;

            case 'start':
              worldMap.start();
              break;

            case 'close':
              window.parent.postMessage({ type: 'mapClosed' }, '*');
              break;
          }
        });

        // Notify parent that map is loaded
        window.parent.postMessage({ type: 'mapLoaded' }, '*');
      };
    </script>
  </body>
</html>
