<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HelloCrush Level Editor</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="BattleCore.js"></script>
    <script src="Spells.js"></script>
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background: #1a1a2e;
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2a2a3e; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4c2e85; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6c4e95; 
        }

        /* Grid Styling */
        #grid-area {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 2px solid #4c2e85;
            margin: 0 auto;
            touch-action: none;
        }

        #terrain-grid {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .terrain-cell {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Terrain colors */
        .terrain-0 { background: rgba(255, 77, 77, 0.55); }
        .terrain-1 { background: rgba(77, 166, 255, 0.55); }
        .terrain-2 { background: rgba(77, 255, 136, 0.55); }
        .terrain-3 { background: rgba(255, 255, 77, 0.55); }
        .terrain-4 { background: rgba(191, 77, 255, 0.55); }
        .terrain-5 { background: rgba(139, 69, 19, 0.55); }

        /* Gem Styles */
        .gem {
            position: absolute;
            width: 100%; height: 100%;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .gem-inner {
            width: 80%; height: 80%;
            border-radius: 20%;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.4);
        }
        .type-0 .gem-inner { background: #ff4d4d; border: 1px solid #ff8080; }
        .type-1 .gem-inner { background: #4da6ff; border: 1px solid #80bfff; border-radius: 50%; }
        .type-2 .gem-inner { background: #4dff88; border: 1px solid #80ffaa; border-radius: 10%; transform: rotate(45deg) scale(0.75); }
        .type-3 .gem-inner { background: #ffff4d; border: 1px solid #ffff80; border-radius: 50% 50% 50% 0; transform: rotate(-45deg) scale(0.8); }
        .type-4 .gem-inner { background: #bf4dff; border: 1px solid #df80ff; border-radius: 30%; transform: rotate(45deg) scale(0.85); }
        .type-5 .gem-inner { background: #8b4513; border: 1px solid #a0522d; border-radius: 30%; }

        /* Editor Specific Styles */
        .panel {
            background: rgba(30, 30, 40, 0.9);
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
        }
        
        .tool-btn {
            transition: all 0.2s;
        }
        .tool-btn.active {
            background-color: #4c2e85;
            border-color: #8b5cf6;
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
        }

        .enemy-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .enemy-card:hover {
            background: rgba(255,255,255,0.05);
        }
        .enemy-card.selected {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }

        /* Boss/Enemy Preview */
        .boss-preview {
            width: 40px; height: 40px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
            border: 2px solid #fff;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: #1e1e2e;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #4c2e85;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .form-group {
            margin-bottom: 12px;
        }
        .form-label {
            display: block;
            margin-bottom: 4px;
            color: #a0a0b0;
            font-size: 12px;
        }
        .form-input {
            width: 100%;
            background: #2a2a3e;
            border: 1px solid #444;
            color: white;
            padding: 6px;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-input:focus {
            border-color: #8b5cf6;
            outline: none;
        }
    </style>
</head>
<body class="flex h-screen w-screen overflow-hidden text-sm">

    <!-- Left Panel: Level List -->
    <div class="w-64 flex-shrink-0 panel border-r border-gray-700 flex flex-col">
        <div class="p-4 border-b border-gray-700 bg-gray-800">
            <h2 class="text-xl font-bold text-purple-400 mb-2">Levels</h2>
            <button id="btn-new-level" class="w-full bg-green-600 hover:bg-green-700 text-white py-1 px-3 rounded transition">
                + New Level
            </button>
        </div>
        <div id="level-list" class="flex-1 overflow-y-auto p-2 space-y-2">
            <!-- Level items will be injected here -->
        </div>
    </div>

    <!-- Middle Panel: JSON Editor -->
    <div class="flex-1 panel border-r border-gray-700 flex flex-col min-w-[300px]">
        <div class="p-2 border-b border-gray-700 bg-gray-800 flex justify-between items-center">
            <h2 class="font-bold text-blue-400">Code</h2>
            <div class="space-x-2">
                <button id="btn-random-gen" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-xs">
                    ðŸŽ² Random Gen
                </button>
                <button id="btn-apply-json" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-xs">
                    Apply to View
                </button>
                <button id="btn-save-level" class="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-1 rounded text-xs">
                    ðŸ’¾ Save
                </button>
            </div>
        </div>
        <textarea id="json-editor" class="flex-1 bg-[#1e1e1e] text-green-400 font-mono p-4 resize-none focus:outline-none text-xs leading-relaxed" spellcheck="false"></textarea>
        <div id="json-error" class="bg-red-900 text-white text-xs p-2 hidden"></div>
    </div>

    <!-- Right Panel: Visual Editor -->
    <div class="flex-1 panel flex flex-col min-w-[400px] bg-gray-900">
        <div class="p-2 border-b border-gray-700 bg-gray-800 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <h2 class="font-bold text-yellow-400">Preview</h2>
                <button id="btn-play-level" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs flex items-center space-x-1">
                    <span>â–¶</span><span>Play</span>
                </button>
            </div>
            <div class="flex space-x-2 bg-gray-700 rounded p-1">
                <button class="tool-btn px-3 py-1 rounded text-xs active" data-tool="terrain">Terrain</button>
                <button class="tool-btn px-3 py-1 rounded text-xs" data-tool="gem">Gems</button>
            </div>
        </div>

        <!-- Toolbar / Palette -->
        <div class="p-2 bg-gray-800 border-b border-gray-700">
            <div id="palette" class="flex flex-wrap gap-2 justify-center">
                <!-- Palette items generated by JS -->
            </div>
        </div>

        <!-- Preview Area -->
        <div class="flex-1 overflow-y-auto p-4 flex flex-col items-center relative">
            
            <!-- Enemy Section -->
            <div class="w-full mb-4">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-gray-400 font-bold text-xs">ENEMIES</h3>
                    <button id="btn-add-enemy" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded">+ Add</button>
                </div>
                <div id="enemy-list-visual" class="flex flex-wrap gap-2 justify-center">
                    <!-- Enemy visual cards -->
                </div>
            </div>

            <!-- Grid Section -->
            <div id="grid-container" class="relative mb-4">
                <div id="grid-area">
                    <div id="terrain-grid"></div>
                    <div id="gem-grid"></div>
                </div>
            </div>

            <!-- Spirit Section -->
            <div class="w-full mb-4">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-gray-400 font-bold text-xs">SPIRITS</h3>
                    <button id="btn-add-spirit" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded">+ Add</button>
                </div>
                <div id="spirit-list-visual" class="flex flex-wrap gap-2 justify-center">
                    <!-- Spirit visual cards -->
                </div>
            </div>

            <!-- Word Pairs Section -->
            <div class="w-full">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-gray-400 font-bold text-xs">WORD PAIRS</h3>
                    <button id="btn-add-word" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded">+ Add</button>
                </div>
                <div id="word-list-visual" class="flex flex-col gap-1 max-h-40 overflow-y-auto">
                    <!-- Word pairs list -->
                </div>
            </div>

        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-purple-400">Edit Object</h3>
            <div id="modal-form-container">
                <!-- Form fields injected here -->
            </div>
            <div class="flex justify-end space-x-2 mt-4 pt-4 border-t border-gray-700">
                <button id="btn-modal-cancel" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-sm">Cancel</button>
                <button id="btn-modal-save" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded text-sm">Save</button>
            </div>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const STORAGE_KEY = 'helloCrushLevels';
        const DEFAULT_ROWS = 8;
        const DEFAULT_COLS = 8;
        
        const TERRAIN_TYPES = [
            { id: 0, name: 'Forge', color: '#ff4d4d' },
            { id: 1, name: 'Tide', color: '#4da6ff' },
            { id: 2, name: 'Life', color: '#4dff88' },
            { id: 3, name: 'Sol', color: '#ffff4d' },
            { id: 4, name: 'Stone', color: '#bf4dff' },
            { id: 5, name: 'Root', color: '#8b4513' }
        ];

        const GEM_TYPES = [
            { id: 0, name: 'Red' },
            { id: 1, name: 'Blue' },
            { id: 2, name: 'Green' },
            { id: 3, name: 'Yellow' },
            { id: 4, name: 'Purple' },
            { id: 5, name: 'Brown' }
        ];

        // --- State ---
        let levels = [];
        let currentLevelId = null;
        let currentConfig = {};
        let currentTool = 'terrain'; // 'terrain' or 'gem'
        let selectedPaletteId = 0;

        // --- DOM Elements ---
        const els = {
            levelList: document.getElementById('level-list'),
            jsonEditor: document.getElementById('json-editor'),
            jsonError: document.getElementById('json-error'),
            gridArea: document.getElementById('grid-area'),
            terrainGrid: document.getElementById('terrain-grid'),
            gemGrid: document.getElementById('gem-grid'),
            palette: document.getElementById('palette'),
            enemyListVisual: document.getElementById('enemy-list-visual'),
            spiritListVisual: document.getElementById('spirit-list-visual'),
            wordListVisual: document.getElementById('word-list-visual'),
            toolBtns: document.querySelectorAll('.tool-btn')
        };

        // --- Initialization ---
        function init() {
            loadLevels();
            setupEventListeners();
            renderPalette();
            
            if (levels.length === 0) {
                createNewLevel();
            } else {
                selectLevel(levels[0].id);
            }
        }

        function loadLevels() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    levels = JSON.parse(stored);
                } catch (e) {
                    console.error("Failed to parse levels", e);
                    levels = [];
                }
            }
        }

        function saveLevels() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(levels));
            renderLevelList();
        }

        function createNewLevel() {
            const newLevel = generateRandomLevelConfig();
            newLevel.id = 'level_' + Date.now();
            newLevel.name = 'New Level ' + (levels.length + 1);
            levels.push(newLevel);
            saveLevels();
            selectLevel(newLevel.id);
        }

        function deleteLevel(id, event) {
            event.stopPropagation();
            if (!confirm('Are you sure you want to delete this level?')) return;
            
            levels = levels.filter(l => l.id !== id);
            saveLevels();
            
            if (levels.length > 0) {
                selectLevel(levels[0].id);
            } else {
                createNewLevel();
            }
        }

        function selectLevel(id) {
            currentLevelId = id;
            const level = levels.find(l => l.id === id);
            if (!level) return;

            currentConfig = JSON.parse(JSON.stringify(level)); // Deep copy
            
            // Update UI
            renderLevelList();
            updateJsonEditor();
            renderVisualEditor();
        }

        function updateJsonEditor() {
            let json = JSON.stringify(currentConfig, null, 2);
            // Format arrays of numbers to be on a single line (for grid/terrainGrid)
            json = json.replace(/\[\s+([\d,\s]+?)\s+\]/g, (match, content) => {
                return '[' + content.replace(/\s+/g, ' ').trim() + ']';
            });
            els.jsonEditor.value = json;
            els.jsonError.classList.add('hidden');
        }

        function applyJsonToConfig() {
            try {
                const newConfig = JSON.parse(els.jsonEditor.value);
                // Basic validation
                if (!newConfig.grid || !newConfig.terrainGrid) throw new Error("Missing grid or terrainGrid");
                
                currentConfig = newConfig;
                els.jsonError.classList.add('hidden');
                renderVisualEditor();
            } catch (e) {
                els.jsonError.textContent = "Invalid JSON: " + e.message;
                els.jsonError.classList.remove('hidden');
            }
        }

        function saveCurrentLevel() {
            applyJsonToConfig(); // Ensure config is up to date with JSON editor
            
            const index = levels.findIndex(l => l.id === currentLevelId);
            if (index !== -1) {
                levels[index] = JSON.parse(JSON.stringify(currentConfig));
                saveLevels();
                alert('Level saved!');
            }
        }

        // --- Random Generation ---
        function generateRandomLevelConfig() {
            const rows = DEFAULT_ROWS;
            const cols = DEFAULT_COLS;
            
            // Generate Grid
            const grid = [];
            const terrainGrid = [];
            
            for (let r = 0; r < rows; r++) {
                const row = [];
                const terrainRow = [];
                for (let c = 0; c < cols; c++) {
                    row.push(Math.floor(Math.random() * 6));
                    terrainRow.push(Math.floor(Math.random() * 6));
                }
                grid.push(row);
                terrainGrid.push(terrainRow);
            }

            // Generate Enemies
            const enemies = [
                {
                    id: 0,
                    name: "Boss",
                    hp: 2000,
                    maxHp: 2000,
                    level: 1,
                    avatar: "ðŸ‘¹",
                    isBoss: true,
                    turn: 3,
                    maxTurn: 3,
                    defense: 10,
                    element: Math.floor(Math.random() * 6)
                }
            ];

            // Generate Spirits
            const spirits = [];
            for(let i=0; i<3; i++) {
                spirits.push({
                    type: i,
                    mana: 0,
                    maxMana: 100,
                    damage: 10,
                    defense: 5
                });
            }

            return {
                id: '',
                name: 'Random Level',
                config: {
                    rows,
                    cols,
                    gemTypes: 6,
                    moves: 30,
                    time: 90,
                    mode: 'moves'
                },
                grid,
                terrainGrid,
                wordPairs: [
                    {cn: "è‹¹æžœ", en: "Apple"},
                    {cn: "é¦™è•‰", en: "Banana"}
                ],
                enemies,
                spirits,
                player: {
                    hp: 1000,
                    maxHp: 1000,
                    defense: 0
                }
            };
        }

        // --- Rendering ---

        function renderLevelList() {
            els.levelList.innerHTML = '';
            levels.forEach(level => {
                const div = document.createElement('div');
                div.className = `p-3 rounded cursor-pointer flex justify-between items-center ${level.id === currentLevelId ? 'bg-purple-900 border border-purple-500' : 'bg-gray-700 hover:bg-gray-600'}`;
                div.onclick = () => selectLevel(level.id);
                
                div.innerHTML = `
                    <div class="truncate font-bold text-sm">${level.name}</div>
                    <button class="text-red-400 hover:text-red-200 px-2" onclick="deleteLevel('${level.id}', event)">âœ•</button>
                `;
                els.levelList.appendChild(div);
            });
        }

        function renderVisualEditor() {
            renderGrid();
            renderEnemies();
            renderSpirits();
            renderWordPairs();
        }

        function renderGrid() {
            const rows = currentConfig.config.rows || 8;
            const cols = currentConfig.config.cols || 8;
            const cellSize = 40; // Fixed size for editor
            
            els.gridArea.style.width = `${cols * cellSize}px`;
            els.gridArea.style.height = `${rows * cellSize}px`;
            
            // Render Terrain
            els.terrainGrid.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const type = currentConfig.terrainGrid[r][c];
                    const cell = document.createElement('div');
                    cell.className = `terrain-cell terrain-${type}`;
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.left = `${c * cellSize}px`;
                    cell.style.top = `${r * cellSize}px`;
                    
                    // Click handler
                    cell.onclick = () => handleGridClick(r, c, 'terrain');
                    
                    els.terrainGrid.appendChild(cell);
                }
            }

            // Render Gems
            els.gemGrid.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const type = currentConfig.grid[r][c];
                    const cell = document.createElement('div');
                    cell.className = `gem type-${type}`;
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.left = `${c * cellSize}px`;
                    cell.style.top = `${r * cellSize}px`;
                    
                    cell.innerHTML = `<div class="gem-inner"></div>`;
                    
                    // Click handler
                    cell.onclick = (e) => {
                        e.stopPropagation(); // Prevent clicking through to terrain
                        handleGridClick(r, c, 'gem');
                    };
                    
                    els.gemGrid.appendChild(cell);
                }
            }
        }

        function renderEnemies() {
            els.enemyListVisual.innerHTML = '';
            if (!currentConfig.enemies) return;
            
            currentConfig.enemies.forEach((enemy, index) => {
                const div = document.createElement('div');
                div.className = 'enemy-card flex flex-col items-center w-24 relative group';
                div.innerHTML = `
                    <button class="absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition" onclick="deleteEnemy(${index}, event)">Ã—</button>
                    <div class="boss-preview mb-1" style="background: ${getEnemyColor(enemy.element)}">${enemy.avatar || 'ðŸ‘¾'}</div>
                    <div class="text-xs font-bold truncate w-full text-center">${enemy.name}</div>
                    <div class="text-[10px] text-gray-400">HP: ${enemy.hp}</div>
                `;
                div.onclick = (e) => {
                    if(e.target.tagName !== 'BUTTON') editEnemy(index);
                };
                els.enemyListVisual.appendChild(div);
            });
        }

        function renderSpirits() {
            els.spiritListVisual.innerHTML = '';
            if (!currentConfig.spirits) return;

            currentConfig.spirits.forEach((spirit, index) => {
                const div = document.createElement('div');
                div.className = 'enemy-card flex flex-col items-center w-24 relative group';
                div.innerHTML = `
                    <button class="absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition" onclick="deleteSpirit(${index}, event)">Ã—</button>
                    <div class="boss-preview mb-1" style="background: ${getSpiritColor(spirit.type)}">âš¡</div>
                    <div class="text-xs font-bold">Type ${spirit.type}</div>
                    <div class="text-[10px] text-gray-400">Dmg: ${spirit.damage}</div>
                `;
                div.onclick = (e) => {
                    if(e.target.tagName !== 'BUTTON') editSpirit(index);
                };
                els.spiritListVisual.appendChild(div);
            });
        }

        function renderWordPairs() {
            els.wordListVisual.innerHTML = '';
            if (!currentConfig.wordPairs) return;

            currentConfig.wordPairs.forEach((pair, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-gray-800 p-2 rounded text-xs hover:bg-gray-700 cursor-pointer';
                div.innerHTML = `
                    <div class="flex-1 flex space-x-2">
                        <span class="text-green-400">${pair.cn}</span>
                        <span class="text-gray-500">|</span>
                        <span class="text-blue-400">${pair.en}</span>
                    </div>
                    <button class="text-red-500 hover:text-red-300 px-1" onclick="deleteWordPair(${index}, event)">âœ•</button>
                `;
                div.onclick = (e) => {
                    if(e.target.tagName !== 'BUTTON') editWordPair(index);
                };
                els.wordListVisual.appendChild(div);
            });
        }

        function renderPalette() {
            els.palette.innerHTML = '';
            const items = currentTool === 'terrain' ? TERRAIN_TYPES : GEM_TYPES;
            
            items.forEach(item => {
                const btn = document.createElement('button');
                btn.className = `w-8 h-8 rounded border-2 transition transform hover:scale-110 ${selectedPaletteId === item.id ? 'border-white scale-110 shadow-lg' : 'border-transparent opacity-70'}`;
                btn.style.backgroundColor = item.color || getGemColor(item.id);
                btn.title = item.name;
                btn.onclick = () => {
                    selectedPaletteId = item.id;
                    renderPalette();
                };
                els.palette.appendChild(btn);
            });
        }

        // --- Interaction Handlers ---

        function handleGridClick(r, c, layer) {
            if (currentTool !== layer) return;
            
            if (layer === 'terrain') {
                currentConfig.terrainGrid[r][c] = selectedPaletteId;
            } else {
                currentConfig.grid[r][c] = selectedPaletteId;
            }
            
            updateJsonEditor();
            renderGrid(); // Re-render to show changes
        }

        // --- Modal Logic ---
        let currentEditCallback = null;
        const modal = document.getElementById('edit-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalForm = document.getElementById('modal-form-container');

        function openModal(title, fields, data, onSave) {
            modalTitle.textContent = title;
            modalForm.innerHTML = '';
            
            fields.forEach(field => {
                const div = document.createElement('div');
                div.className = 'form-group';
                
                const label = document.createElement('label');
                label.className = 'form-label';
                label.textContent = field.label;
                
                let input;
                if (field.type === 'select') {
                    input = document.createElement('select');
                    input.className = 'form-input';
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        if (opt.value == data[field.key]) option.selected = true;
                        input.appendChild(option);
                    });
                } else {
                    input = document.createElement('input');
                    input.className = 'form-input';
                    input.type = field.type || 'text';
                    input.value = data[field.key] !== undefined ? data[field.key] : '';
                }
                
                input.dataset.key = field.key;
                input.dataset.type = field.dataType || 'string'; // 'number', 'array'
                
                div.appendChild(label);
                div.appendChild(input);
                modalForm.appendChild(div);
            });

            currentEditCallback = onSave;
            modal.classList.remove('hidden');
        }

        function closeModal() {
            modal.classList.add('hidden');
            currentEditCallback = null;
        }

        document.getElementById('btn-modal-cancel').onclick = closeModal;
        document.getElementById('btn-modal-save').onclick = () => {
            if (!currentEditCallback) return;
            
            const newData = {};
            const inputs = modalForm.querySelectorAll('.form-input');
            inputs.forEach(input => {
                const key = input.dataset.key;
                const type = input.dataset.type;
                let value = input.value;
                
                if (type === 'number') {
                    value = Number(value);
                } else if (type === 'array') {
                    value = value.split(',').map(s => s.trim()).filter(s => s);
                }
                
                newData[key] = value;
            });
            
            currentEditCallback(newData);
            closeModal();
        };

        function deleteEnemy(index, event) {
            event.stopPropagation();
            if(confirm("Delete this enemy?")) {
                currentConfig.enemies.splice(index, 1);
                updateJsonEditor();
                renderEnemies();
            }
        }

        function deleteSpirit(index, event) {
            event.stopPropagation();
            if(confirm("Delete this spirit?")) {
                currentConfig.spirits.splice(index, 1);
                updateJsonEditor();
                renderSpirits();
            }
        }

        function editEnemy(index) {
            const enemy = currentConfig.enemies[index];
            const fields = [
                { key: 'name', label: 'Name', type: 'text' },
                { key: 'avatar', label: 'Avatar (Emoji)', type: 'text' },
                { key: 'hp', label: 'HP', type: 'number', dataType: 'number' },
                { key: 'defense', label: 'Defense', type: 'number', dataType: 'number' },
                { key: 'turn', label: 'Turn Interval', type: 'number', dataType: 'number' },
                { key: 'element', label: 'Element (0-5)', type: 'number', dataType: 'number' },
                { key: 'skills', label: 'Skills (comma separated IDs)', type: 'text', dataType: 'array' }
            ];
            
            // Prepare data with skills joined
            const data = { ...enemy };
            if (Array.isArray(data.skills)) data.skills = data.skills.join(', ');
            
            openModal('Edit Enemy', fields, data, (newData) => {
                Object.assign(enemy, newData);
                enemy.maxHp = enemy.hp; // Sync maxHp
                enemy.maxTurn = enemy.turn; // Sync maxTurn
                updateJsonEditor();
                renderEnemies();
            });
        }

        function editSpirit(index) {
            const spirit = currentConfig.spirits[index];
            
            // Get available spells from SpellRegistry
            const spellIds = spellRegistry.getAllSpellIds();
            const spellOptions = spellIds.map(id => {
                const info = spellRegistry.getSpellInfo(id);
                return {
                    value: id,
                    label: info ? `${info.icon} ${info.name}` : id
                };
            });
            // Add "None" option
            spellOptions.unshift({ value: '', label: 'None' });

            const fields = [
                { key: 'type', label: 'Type (0-5)', type: 'number', dataType: 'number' },
                { key: 'damage', label: 'Damage', type: 'number', dataType: 'number' },
                { key: 'defense', label: 'Defense', type: 'number', dataType: 'number' },
                { key: 'maxMana', label: 'Max Mana', type: 'number', dataType: 'number' },
                { key: 'skills', label: 'Spell', type: 'select', dataType: 'array', options: spellOptions }
            ];
            
            const data = { ...spirit };
            // Handle array to single value for select
            if (Array.isArray(data.skills) && data.skills.length > 0) {
                data.skills = data.skills[0];
            } else {
                data.skills = '';
            }

            openModal('Edit Spirit', fields, data, (newData) => {
                Object.assign(spirit, newData);
                updateJsonEditor();
                renderSpirits();
            });
        }

        function editWordPair(index) {
            const pair = currentConfig.wordPairs[index];
            const newCn = prompt("Chinese Word:", pair.cn);
            if (newCn !== null) {
                const newEn = prompt("English Word:", pair.en);
                if (newEn !== null) {
                    pair.cn = newCn;
                    pair.en = newEn;
                    updateJsonEditor();
                    renderWordPairs();
                }
            }
        }

        function deleteWordPair(index, event) {
            event.stopPropagation();
            if(confirm("Delete this word pair?")) {
                currentConfig.wordPairs.splice(index, 1);
                updateJsonEditor();
                renderWordPairs();
            }
        }

        function setupEventListeners() {
            document.getElementById('btn-new-level').onclick = createNewLevel;
            document.getElementById('btn-save-level').onclick = saveCurrentLevel;
            document.getElementById('btn-apply-json').onclick = applyJsonToConfig;
            document.getElementById('btn-random-gen').onclick = () => {
                if(confirm("Overwrite current config with random data?")) {
                    const random = generateRandomLevelConfig();
                    // Keep ID and Name
                    random.id = currentConfig.id;
                    random.name = currentConfig.name;
                    currentConfig = random;
                    updateJsonEditor();
                    renderVisualEditor();
                }
            };
            
            document.getElementById('btn-play-level').onclick = () => {
                // Save current config first
                applyJsonToConfig();
                const index = levels.findIndex(l => l.id === currentLevelId);
                if (index !== -1) {
                    levels[index] = JSON.parse(JSON.stringify(currentConfig));
                    saveLevels();
                }
                // Encode config as base64 and open HelloCrush with levelconfig hash
                const jsonStr = JSON.stringify(currentConfig);
                const base64 = btoa(unescape(encodeURIComponent(jsonStr)));
                window.open(`HelloCrush.html#levelconfig=${base64}`, '_blank');
            };
            
            document.getElementById('btn-add-enemy').onclick = () => {
                if (!currentConfig.enemies) currentConfig.enemies = [];
                currentConfig.enemies.push({
                    id: Date.now(),
                    name: "New Enemy",
                    hp: 1000,
                    maxHp: 1000,
                    level: 1,
                    avatar: "ðŸ’€",
                    isBoss: false,
                    turn: 2,
                    maxTurn: 2,
                    defense: 5,
                    element: 0
                });
                updateJsonEditor();
                renderEnemies();
            };

            document.getElementById('btn-add-spirit').onclick = () => {
                if (!currentConfig.spirits) currentConfig.spirits = [];
                currentConfig.spirits.push({
                    type: 0,
                    mana: 0,
                    maxMana: 100,
                    damage: 10,
                    defense: 5
                });
                updateJsonEditor();
                renderSpirits();
            };

            document.getElementById('btn-add-word').onclick = () => {
                if (!currentConfig.wordPairs) currentConfig.wordPairs = [];
                currentConfig.wordPairs.push({
                    cn: "æ–°è¯",
                    en: "New Word"
                });
                updateJsonEditor();
                renderWordPairs();
            };

            els.toolBtns.forEach(btn => {
                btn.onclick = () => {
                    els.toolBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    selectedPaletteId = 0; // Reset selection
                    renderPalette();
                };
            });

            // Sync JSON editor changes on blur
            els.jsonEditor.addEventListener('blur', applyJsonToConfig);
        }

        // --- Helpers ---
        function getEnemyColor(elementId) {
            const colors = ['#ff4d4d', '#4da6ff', '#4dff88', '#ffff4d', '#bf4dff', '#8b4513'];
            return colors[elementId] || '#fff';
        }
        
        function getSpiritColor(typeId) {
            const colors = ['#ff4d4d', '#4da6ff', '#4dff88', '#ffff4d', '#bf4dff', '#8b4513'];
            return colors[typeId] || '#fff';
        }

        function getGemColor(typeId) {
            const colors = ['#ff4d4d', '#4da6ff', '#4dff88', '#ffff4d', '#bf4dff', '#8b4513'];
            return colors[typeId] || '#fff';
        }

        // Start
        init();

    </script>
</body>
</html>
