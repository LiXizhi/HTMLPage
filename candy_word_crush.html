<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Rush - 宝石迷阵</title>
    <script src="https://cdn.keepwork.com/keepwork/cdn/tailwindcss@3.4.16.js"></script>
    <script src="https://cdn.keepwork.com/sdk/keepworkSDK.iife.js"></script>
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background: radial-gradient(circle at center, #2b1055 0%, #1a0b2e 100%);
            color: white;
            overflow: hidden;
            touch-action: none; /* Prevent scroll on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Grid Styling */
        #grid-area {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 4px solid #4c2e85;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            touch-action: none;
        }

        /* Gem Styles */
        .gem {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.2s ease;
            cursor: pointer;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            /* GPU Acceleration hint */
            will-change: transform;
        }

        .gem-inner {
            width: 85%;
            height: 85%;
            border-radius: 20%;
            box-shadow: inset 0 4px 8px rgba(255,255,255,0.4), 
                        inset 0 -4px 8px rgba(0,0,0,0.4),
                        0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .gem-inner::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 15%;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
        }

        /* Gem Colors */
        .type-0 .gem-inner { background: linear-gradient(135deg, #ff4d4d, #b30000); border: 1px solid #ff8080; } /* Red */
        .type-1 .gem-inner { background: linear-gradient(135deg, #4da6ff, #0059b3); border: 1px solid #80bfff; border-radius: 50%; } /* Blue Circle */
        .type-2 .gem-inner { background: linear-gradient(135deg, #4dff88, #00b33c); border: 1px solid #80ffaa; border-radius: 10%; transform: rotate(45deg) scale(0.85); } /* Green Diamond */
        .type-3 .gem-inner { background: linear-gradient(135deg, #ffff4d, #b3b300); border: 1px solid #ffff80; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); border-radius: 0; width: 80%; height: 80%;} /* Yellow Triangle */
        .type-4 .gem-inner { background: linear-gradient(135deg, #bf4dff, #7300b3); border: 1px solid #df80ff; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); border-radius: 0; } /* Purple Lozenge */
        .type-5 .gem-inner { background: linear-gradient(135deg, #ffae4d, #b36b00); border: 1px solid #ffce80; border-radius: 30%; } /* Orange Hex */

        .gem.has-word {
            z-index: 15;
        }

        .gem.selected {
            z-index: 50;
        }

        .gem.selected .gem-inner {
            filter: brightness(1.4);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            z-index: 20;
        }

        /* Particles */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: pop 0.6s ease-out forwards;
        }

        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; top: var(--dest-y); left: var(--dest-x); }
        }

        /* Floating Text */
        .float-text {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 50;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        .hidden { display: none !important; }

        .btn-primary {
            background: linear-gradient(to bottom, #ff4d4d, #c41e1e);
            border: none;
            padding: 12px 30px;
            color: white;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 77, 77, 0.4);
            transition: transform 0.1s;
            font-family: 'Fredoka', sans-serif;
        }
        .btn-primary:active { transform: scale(0.95); }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            color: #aaa;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Fredoka', sans-serif;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-secondary.selected {
            background: #4da6ff;
            border-color: #4da6ff;
            color: white;
            box-shadow: 0 0 10px rgba(77, 166, 255, 0.5);
        }

        /* Word Overlay */
        .gem-word {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.4rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px #000, 0 0 2px #000;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            width: 100%;
            line-height: 1.1;
            white-space: nowrap;
        }
        
        .entangled .gem-inner {
            filter: grayscale(0.8) brightness(0.6);
            box-shadow: inset 0 0 10px #000;
        }
        
        .entangled::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(0,0,0,0.2),
                rgba(0,0,0,0.2) 5px,
                rgba(0,0,0,0.4) 5px,
                rgba(0,0,0,0.4) 10px
            );
            z-index: 14;
            border-radius: 20%;
        }

        /* Word Cell Animations */
        @keyframes pulseShadow {
            0% { filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8)); }
            50% { filter: drop-shadow(0 0 8px rgba(255, 255, 255, 1)); }
            100% { filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8)); }
        }

        @keyframes rainbowGlow {
            0% { filter: drop-shadow(0 0 3px #ff0000) drop-shadow(0 0 5px #ff0000); }
            25% { filter: drop-shadow(0 0 3px #ffff00) drop-shadow(0 0 5px #ffff00); }
            50% { filter: drop-shadow(0 0 3px #00ff00) drop-shadow(0 0 5px #00ff00); }
            75% { filter: drop-shadow(0 0 3px #00ffff) drop-shadow(0 0 5px #00ffff); }
            100% { filter: drop-shadow(0 0 3px #ff00ff) drop-shadow(0 0 5px #ff00ff); }
        }

        /* English Word Style */
        .gem.lang-en {
            animation: pulseShadow 2s infinite;
        }

        /* Chinese Word Style - Special */
        .gem.lang-cn {
            animation: rainbowGlow 3s linear infinite;
        }
        
        /* Enhance text readability */
        .gem.has-word .gem-word {
            text-shadow: 0 0 4px #000, 0 0 3px #000, 0 0 2px #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- UI Header -->
    <div class="w-full px-6 mb-4 flex justify-between items-end relative">
        <div>
            <div class="text-sm text-gray-300 opacity-80">分数</div>
            <div id="score-display" class="text-3xl font-bold text-yellow-400">0</div>
        </div>
        <div class="text-center">
            <div class="text-sm text-gray-300 opacity-80">关卡</div>
            <div id="level-display" class="text-4xl font-bold text-white">1</div>
        </div>
        <div class="text-right">
            <div id="moves-label" class="text-sm text-gray-300 opacity-80">步数</div>
            <div id="moves-display" class="text-3xl font-bold text-red-400">20</div>
        </div>
    </div>

    <!-- Progress Bar -->
    <div class="w-full max-w-[90%] h-4 bg-gray-800 rounded-full mb-4 overflow-hidden border border-gray-600 relative">
        <div id="progress-fill" class="h-full bg-gradient-to-r from-green-400 to-blue-500 transition-all duration-500" style="width: 0%"></div>
        <div class="absolute inset-0 flex items-center justify-center text-[10px] font-bold tracking-wider text-white drop-shadow-md">
            目标: <span id="target-display">1000</span>
        </div>
    </div>

    <!-- Game Board -->
    <div id="grid-area">
        <!-- Gems generated by JS -->
    </div>

    <!-- Settings Footer -->
    <div class="w-full mt-2 flex justify-center gap-3 items-center z-20">
        <div class="flex flex-col items-start">
            <label class="text-xs text-gray-400 ml-1">难度</label>
            <select id="difficulty-select" class="bg-gray-800 text-white border border-gray-600 rounded-lg px-3 py-1 focus:outline-none focus:border-blue-500 text-sm">
                <option value="easy">简单</option>
                <option value="normal" selected>普通</option>
                <option value="hard">困难</option>
            </select>
        </div>
        
        <div class="flex flex-col items-start">
            <label class="text-xs text-gray-400 ml-1">模式</label>
            <select id="mode-select" class="bg-gray-800 text-white border border-gray-600 rounded-lg px-3 py-1 focus:outline-none focus:border-blue-500 text-sm">
                <option value="moves" selected>步数</option>
                <option value="time">倒计时</option>
            </select>
        </div>

        <div class="flex flex-col items-start">
             <label class="text-xs text-transparent ml-1">.</label>
             <button id="footer-restart-btn" class="bg-gradient-to-b from-red-500 to-red-700 hover:from-red-400 hover:to-red-600 text-white rounded-lg px-4 py-1 font-bold shadow-lg text-sm border border-red-400">
                重开
            </button>
        </div>
    </div>
</div>

<!-- Success Overlay -->
<div id="success-overlay" class="hidden fixed inset-0 pointer-events-none z-50 flex items-center justify-center">
    <canvas id="confetti-canvas" class="absolute inset-0 w-full h-full"></canvas>
    <div class="absolute text-6xl font-bold text-yellow-300 drop-shadow-[0_5px_5px_rgba(0,0,0,0.5)] animate-bounce">关卡完成!</div>
</div>

<!-- Level Complete Modal -->
<div id="level-modal" class="modal hidden">
    <div class="bg-gray-900 p-8 rounded-2xl border-2 border-yellow-500 text-center max-w-xs w-full transform transition-all scale-100 shadow-2xl">
        <h2 class="text-3xl font-bold text-yellow-400 mb-2">过关!</h2>
        <p class="text-gray-300 mb-6">做得好!</p>
        <div class="text-lg mb-6">分数: <span id="level-score-final" class="text-white font-bold">0</span></div>
        <button id="next-level-btn" class="btn-primary w-full">下一关</button>
    </div>
</div>

<!-- Game Over Modal -->
<div id="game-over-modal" class="modal hidden">
    <div class="bg-gray-900 p-8 rounded-2xl border-2 border-red-600 text-center max-w-xs w-full shadow-2xl">
        <h2 class="text-3xl font-bold text-red-500 mb-2">游戏结束</h2>
        <p class="text-gray-300 mb-6">步数用尽!</p>
        <div class="text-lg mb-6">最终分数: <span id="final-score" class="text-white font-bold">0</span></div>
        <button id="restart-btn" class="btn-primary w-full">重试</button>
    </div>
</div>

<script>
    /**
     * Game Configuration & State
     */
    const COLS = 8;
    const ROWS = 8;
    const GEM_TYPES = 6; // Number of colors
    let GRID_SIZE = 0; // Calculated dynamically
    let CELL_SIZE = 0;

    const WORD_PAIRS = [
        {cn: "苹果", en: "Apple"}, {cn: "香蕉", en: "Banana"}, {cn: "橙子", en: "Orange"},
        {cn: "葡萄", en: "Grape"}, {cn: "西瓜", en: "Watermelon"}, {cn: "草莓", en: "Strawberry"},
        {cn: "樱桃", en: "Cherry"}, {cn: "柠檬", en: "Lemon"}, {cn: "桃子", en: "Peach"},
        {cn: "梨", en: "Pear"}, {cn: "猫", en: "Cat"}, {cn: "狗", en: "Dog"},
        {cn: "鸟", en: "Bird"}, {cn: "鱼", en: "Fish"}, {cn: "大象", en: "Elephant"},
        {cn: "狮子", en: "Lion"}, {cn: "老虎", en: "Tiger"}, {cn: "猴子", en: "Monkey"},
        {cn: "熊猫", en: "Panda"}, {cn: "兔子", en: "Rabbit"}, {cn: "书", en: "Book"},
        {cn: "笔", en: "Pen"}, {cn: "学校", en: "School"}, {cn: "老师", en: "Teacher"},
        {cn: "学生", en: "Student"}, {cn: "红", en: "Red"}, {cn: "蓝", en: "Blue"},
        {cn: "绿", en: "Green"}, {cn: "黄", en: "Yellow"}, {cn: "白", en: "White"},
        {cn: "黑", en: "Black"}, {cn: "灰", en: "Gray"}, {cn: "粉红", en: "Pink"},
        {cn: "紫", en: "Purple"}, {cn: "棕", en: "Brown"}, {cn: "太阳", en: "Sun"},
        {cn: "月亮", en: "Moon"}, {cn: "星星", en: "Star"}, {cn: "云", en: "Cloud"},
        {cn: "雨", en: "Rain"}, {cn: "雪", en: "Snow"}, {cn: "风", en: "Wind"},
        {cn: "树", en: "Tree"}, {cn: "花", en: "Flower"}, {cn: "草", en: "Grass"},
        {cn: "山", en: "Mountain"}, {cn: "河", en: "River"}, {cn: "海", en: "Sea"},
        {cn: "汽车", en: "Car"}, {cn: "飞机", en: "Plane"}, {cn: "火车", en: "Train"},
        {cn: "船", en: "Boat"}, {cn: "自行车", en: "Bike"}, {cn: "房子", en: "House"},
        {cn: "门", en: "Door"}, {cn: "窗户", en: "Window"}, {cn: "桌子", en: "Table"},
        {cn: "椅子", en: "Chair"}, {cn: "床", en: "Bed"}, {cn: "杯子", en: "Cup"},
        {cn: "盘子", en: "Plate"}, {cn: "碗", en: "Bowl"}, {cn: "筷子", en: "Chopsticks"},
        {cn: "勺子", en: "Spoon"}, {cn: "叉子", en: "Fork"}, {cn: "刀", en: "Knife"},
        {cn: "米饭", en: "Rice"}, {cn: "面条", en: "Noodles"}, {cn: "面包", en: "Bread"},
        {cn: "牛奶", en: "Milk"}, {cn: "水", en: "Water"}, {cn: "茶", en: "Tea"},
        {cn: "咖啡", en: "Coffee"}, {cn: "果汁", en: "Juice"}, {cn: "爸爸", en: "Dad"},
        {cn: "妈妈", en: "Mom"}, {cn: "哥哥", en: "Brother"}, {cn: "姐姐", en: "Sister"},
        {cn: "朋友", en: "Friend"}, {cn: "医生", en: "Doctor"}, {cn: "护士", en: "Nurse"},
        {cn: "警察", en: "Police"}, {cn: "消防员", en: "Firefighter"}, {cn: "医生", en: "Doctor"},
        {cn: "护士", en: "Nurse"}, {cn: "农民", en: "Farmer"}, {cn: "工人", en: "Worker"},
        {cn: "司机", en: "Driver"}, {cn: "厨师", en: "Chef"}, {cn: "画家", en: "Painter"},
        {cn: "歌手", en: "Singer"}, {cn: "舞者", en: "Dancer"}, {cn: "运动员", en: "Athlete"},
        {cn: "春天", en: "Spring"}, {cn: "夏天", en: "Summer"}, {cn: "秋天", en: "Autumn"},
        {cn: "冬天", en: "Winter"}, {cn: "早晨", en: "Morning"}, {cn: "中午", en: "Noon"},
        {cn: "晚上", en: "Evening"}, {cn: "夜晚", en: "Night"}, {cn: "今天", en: "Today"},
        {cn: "明天", en: "Tomorrow"}, {cn: "昨天", en: "Yesterday"}, {cn: "星期一", en: "Monday"},
        {cn: "星期二", en: "Tuesday"}, {cn: "星期三", en: "Wednesday"}, {cn: "星期四", en: "Thursday"},
        {cn: "星期五", en: "Friday"}, {cn: "星期六", en: "Saturday"}, {cn: "星期日", en: "Sunday"},
        {cn: "一月", en: "January"}, {cn: "二月", en: "February"}, {cn: "三月", en: "March"},
        {cn: "四月", en: "April"}, {cn: "五月", en: "May"}, {cn: "六月", en: "June"},
        {cn: "七月", en: "July"}, {cn: "八月", en: "August"}, {cn: "九月", en: "September"},
        {cn: "十月", en: "October"}, {cn: "十一月", en: "November"}, {cn: "十二月", en: "December"},
        {cn: "零", en: "Zero"}, {cn: "一", en: "One"}, {cn: "二", en: "Two"},
        {cn: "三", en: "Three"}, {cn: "四", en: "Four"}, {cn: "五", en: "Five"},
        {cn: "六", en: "Six"}, {cn: "七", en: "Seven"}, {cn: "八", en: "Eight"},
        {cn: "九", en: "Nine"}, {cn: "十", en: "Ten"}, {cn: "百", en: "Hundred"},
        {cn: "千", en: "Thousand"}, {cn: "万", en: "Ten Thousand"}, {cn: "快乐", en: "Happy"},
        {cn: "悲伤", en: "Sad"}, {cn: "生气", en: "Angry"}, {cn: "害怕", en: "Scared"},
        {cn: "惊讶", en: "Surprised"}, {cn: "累", en: "Tired"}, {cn: "饿", en: "Hungry"},
        {cn: "渴", en: "Thirsty"}, {cn: "热", en: "Hot"}, {cn: "冷", en: "Cold"},
        {cn: "大", en: "Big"}, {cn: "小", en: "Small"}, {cn: "长", en: "Long"},
        {cn: "短", en: "Short"}, {cn: "高", en: "Tall"}, {cn: "矮", en: "Short"},
        {cn: "胖", en: "Fat"}, {cn: "瘦", en: "Thin"}, {cn: "新", en: "New"},
        {cn: "旧", en: "Old"}, {cn: "好", en: "Good"}, {cn: "坏", en: "Bad"},
        {cn: "快", en: "Fast"}, {cn: "慢", en: "Slow"}, {cn: "多", en: "Many"},
        {cn: "少", en: "Few"}, {cn: "远", en: "Far"}, {cn: "近", en: "Near"}
    ];

    const gameState = {
        grid: [], // 2D array storing gem types (0-5) or null
        wordGrid: [], // 2D array storing word objects {word, lang, pairId, isEntangled}
        currentPair: null, // {cn, en}
        selectedGem: null, // {r, c}
        score: 0,
        moves: 0,
        level: 1,
        targetScore: 1000,
        isLocked: false, // Locks input during animations
        comboMultiplier: 1,
        difficulty: 'normal', // easy, normal, hard
        mode: 'moves', // moves, time
        timeLeft: 0,
        timerInterval: null
    };

    const dom = {
        grid: document.getElementById('grid-area'),
        score: document.getElementById('score-display'),
        moves: document.getElementById('moves-display'),
        movesLabel: document.getElementById('moves-label'),
        level: document.getElementById('level-display'),
        target: document.getElementById('target-display'),
        progress: document.getElementById('progress-fill'),
        levelModal: document.getElementById('level-modal'),
        gameOverModal: document.getElementById('game-over-modal'),
        nextLevelBtn: document.getElementById('next-level-btn'),
        restartBtn: document.getElementById('restart-btn'),
        levelScoreFinal: document.getElementById('level-score-final'),
        finalScore: document.getElementById('final-score'),
        diffSelect: document.getElementById('difficulty-select'),
        modeSelect: document.getElementById('mode-select'),
        footerRestartBtn: document.getElementById('footer-restart-btn')
    };

    /* --- Initialization & Resizing --- */

    // Initialize SDK
    let sdk = null;
    try {
        if (typeof KeepworkSDK !== 'undefined') {
            sdk = new KeepworkSDK({
                timeout: 30000
            });
            console.log(`Keepwork SDK initialized token: ${sdk.token}`);
        }
    } catch (e) {
        console.error("SDK Init Failed", e);
    }

    async function speak(text) {
        if (sdk && sdk.speech) {
            try {
                const result = await sdk.speech.textToAudio(text, {
                    per: 4, 
                    spd: 5,
                    pit: 5,
                    vol: 5
                });
                if (result && result.url) {
                    const audio = new Audio(result.url);
                    audio.play();
                    return;
                }
            } catch (e) {
                console.error("SDK TTS failed", e);
            }
        }
        
        // Fallback
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            window.speechSynthesis.speak(utterance);
        }
    }

    function animateAndCrush(p1, p2, wordPair) {
        return new Promise(async (resolve) => {
            gameState.isLocked = true;
            
            const el1 = getGemDOM(p1.r, p1.c);
            const el2 = getGemDOM(p2.r, p2.c);
            
            if (!el1 || !el2) {
                resolve();
                return;
            }

            // Determine which is CN and which is EN
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            
            let cnEl = el1;
            // Default to el1 being CN if we can't tell, but logic below fixes it
            if (w1 && w1.lang === 'EN') {
                cnEl = el2; // el1 is EN, so el2 must be CN
            } else if (w2 && w2.lang === 'CN') {
                cnEl = el2;
            } else {
                cnEl = el1;
            }

            // Bring to front
            el1.style.zIndex = 1000;
            el2.style.zIndex = 1000;

            // Calculate center
            const centerPos = GRID_SIZE / 2 - CELL_SIZE / 2;
            const offset = CELL_SIZE * 0.8; // Vertical offset for stacking
            
            el1.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            el2.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            
            // Force reflow
            el1.offsetHeight; 
            
            // Move to center and scale up significantly
            // CN on top (visually higher -> smaller Y)
            // EN on bottom (visually lower -> larger Y)
            
            if (cnEl === el1) {
                el1.style.transform = `translate(${centerPos}px, ${centerPos - offset}px) scale(2.5)`;
                el2.style.transform = `translate(${centerPos}px, ${centerPos + offset}px) scale(2.5)`;
            } else {
                el1.style.transform = `translate(${centerPos}px, ${centerPos + offset}px) scale(2.5)`;
                el2.style.transform = `translate(${centerPos}px, ${centerPos - offset}px) scale(2.5)`;
            }
            
            // Wait for movement
            await new Promise(r => setTimeout(r, 600));
            
            // Play TTS
            if(wordPair && wordPair.en) {
                speak(wordPair.en);
            }
            
            // Wait for reading (approx 1.5s)
            await new Promise(r => setTimeout(r, 1500));
            
            // Create particles at new positions
            const commonX = centerPos + CELL_SIZE/2;
            const cnY = centerPos - offset + CELL_SIZE/2;
            const enY = centerPos + offset + CELL_SIZE/2;
            
            if (cnEl === el1) {
                createParticles(p1.r, p1.c, gameState.grid[p1.r][p1.c], commonX, cnY);
                createParticles(p2.r, p2.c, gameState.grid[p2.r][p2.c], commonX, enY);
            } else {
                createParticles(p1.r, p1.c, gameState.grid[p1.r][p1.c], commonX, enY);
                createParticles(p2.r, p2.c, gameState.grid[p2.r][p2.c], commonX, cnY);
            }

            resolve();
        });
    }

    function init() {
        // Calculate sizes first so we have valid CELL_SIZE
        resizeGrid();
        
        // Settings Listeners
        dom.diffSelect.addEventListener('change', (e) => {
            gameState.difficulty = e.target.value;
            startLevel(gameState.level);
        });

        dom.modeSelect.addEventListener('change', (e) => {
            gameState.mode = e.target.value;
            startLevel(gameState.level);
        });

        dom.footerRestartBtn.addEventListener('click', () => {
             startLevel(gameState.level);
        });
        
        window.addEventListener('resize', resizeGrid);
        dom.nextLevelBtn.addEventListener('click', () => startLevel(gameState.level + 1));
        dom.restartBtn.addEventListener('click', () => {
            startLevel(gameState.level);
            dom.gameOverModal.classList.add('hidden');
        });

        // Notify parent
        window.parent.postMessage({ type: 'gameLoaded' }, '*');
        
        // Auto start
        startLevel(1);
    }

    function resizeGrid() {
        const maxWidth = Math.min(window.innerWidth - 30, 500);
        const maxHeight = window.innerHeight * 0.55; 
        
        let size = Math.min(maxWidth, maxHeight);
        
        GRID_SIZE = size;
        CELL_SIZE = (GRID_SIZE - 8) / COLS; // -8 for border

        dom.grid.style.width = `${GRID_SIZE}px`;
        dom.grid.style.height = `${GRID_SIZE}px`;

        // IMPORTANT: Only render if grid exists
        if (gameState.grid && gameState.grid.length > 0) {
            renderGrid(); 
        }
    }

    function startLevel(lvl) {
        gameState.level = lvl;
        
        if (lvl === 1) {
            gameState.score = 0;
            createInitialGrid();
        }
        
        gameState.levelStartScore = gameState.score;

        // Difficulty Multipliers
        let scoreMult = 1;
        let movesBase = 30;
        let timeBase = 90;

        if (gameState.difficulty === 'easy') {
            scoreMult = 0.8;
            movesBase = 40;
            timeBase = 120;
        } else if (gameState.difficulty === 'hard') {
            scoreMult = 1.2;
            movesBase = 20;
            timeBase = 60;
        }

        // Infinite Level Logic
        const pointsToEarn = Math.floor((3000 + (lvl * 100)) * scoreMult); 
        gameState.targetScore = gameState.score + pointsToEarn;
        
        // Mode Setup
        if (gameState.mode === 'time') {
            gameState.timeLeft = timeBase;
            dom.movesLabel.textContent = "时间";
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(updateTimer, 1000);
        } else {
            gameState.moves = movesBase;
            dom.movesLabel.textContent = "步数";
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        }
        
        gameState.comboMultiplier = 1;
        gameState.isLocked = false;
        gameState.selectedGem = null;

        dom.levelModal.classList.add('hidden');
        dom.gameOverModal.classList.add('hidden');
        document.getElementById('success-overlay').classList.add('hidden');

        updateUI();
    }

    function updateTimer() {
        if (gameState.isLocked) return; // Pause timer during animations? Maybe not. Let's keep it running or pause? Usually pause.
        // Actually, standard match-3 timers keep running. But if animations are long, it might be unfair.
        // Let's pause timer if isLocked is true to be fair, as user cannot interact.
        if (gameState.isLocked) return;

        gameState.timeLeft--;
        if (gameState.timeLeft <= 0) {
            gameState.timeLeft = 0;
            clearInterval(gameState.timerInterval);
            checkWinCondition();
        }
        updateUI();
    }

    function createInitialGrid() {
        gameState.grid = [];
        gameState.wordGrid = [];
        dom.grid.innerHTML = ''; 

        for (let r = 0; r < ROWS; r++) {
            gameState.grid[r] = [];
            gameState.wordGrid[r] = [];
            for (let c = 0; c < COLS; c++) {
                gameState.wordGrid[r][c] = null;
                let type;
                // Prevent initial matches
                do {
                    type = Math.floor(Math.random() * GEM_TYPES);
                } while (
                    (c >= 2 && gameState.grid[r][c-1] === type && gameState.grid[r][c-2] === type) ||
                    (r >= 2 && gameState.grid[r-1][c] === type && gameState.grid[r-2][c] === type)
                );
                gameState.grid[r][c] = type;
                createGemDOM(r, c, type);
            }
        }
        ensureWords();
    }

    /* --- DOM Manipulation --- */

    function createGemDOM(r, c, type) {
        const div = document.createElement('div');
        div.classList.add('gem', `type-${type}`);
        div.id = `gem-${r}-${c}`;
        div.setAttribute('data-r', r);
        div.setAttribute('data-c', c);
        
        div.style.width = `${CELL_SIZE}px`;
        div.style.height = `${CELL_SIZE}px`;
        div.style.transform = `translate(${c * CELL_SIZE}px, ${r * CELL_SIZE}px)`;
        
        const inner = document.createElement('div');
        inner.classList.add('gem-inner');
        div.appendChild(inner);

        // Word Overlay
        const wordData = gameState.wordGrid[r] && gameState.wordGrid[r][c];
        if (wordData) {
            div.classList.add('has-word');
            div.classList.add(wordData.lang === 'CN' ? 'lang-cn' : 'lang-en');
            const wordEl = document.createElement('div');
            wordEl.classList.add('gem-word');
            wordEl.textContent = wordData.word;
            div.appendChild(wordEl);
            if (wordData.isEntangled) {
                div.classList.add('entangled');
            }
        }

        // Event Listeners
        bindInteraction(div, r, c);

        dom.grid.appendChild(div);
        return div;
    }

    function getGemDOM(r, c) {
        return document.getElementById(`gem-${r}-${c}`);
    }

    function renderGrid() {
        // Safe check
        if (!gameState.grid || gameState.grid.length === 0) return;

        for (let r = 0; r < ROWS; r++) {
            // Extra safety if row is somehow missing
            if (!gameState.grid[r]) continue;

            for (let c = 0; c < COLS; c++) {
                if (gameState.grid[r][c] !== null) {
                    const gem = getGemDOM(r, c);
                    if (gem) {
                        gem.style.width = `${CELL_SIZE}px`;
                        gem.style.height = `${CELL_SIZE}px`;
                        gem.style.transform = `translate(${c * CELL_SIZE}px, ${r * CELL_SIZE}px)`;
                    }
                }
            }
        }
    }

    /* --- Core Logic --- */

    function handleInput(r, c) {
        if (gameState.isLocked) return;
        if (gameState.grid[r][c] === null) return;

        // Block entangled
        if (gameState.wordGrid[r][c] && gameState.wordGrid[r][c].isEntangled) return;

        const clicked = { r, c };

        // Deselect
        if (gameState.selectedGem && gameState.selectedGem.r === r && gameState.selectedGem.c === c) {
            toggleSelectVisual(gameState.selectedGem, false);
            gameState.selectedGem = null;
            return;
        }

        // Select First
        if (!gameState.selectedGem) {
            gameState.selectedGem = clicked;
            toggleSelectVisual(clicked, true);
            return;
        }

        // Swap logic
        if (isAdjacent(gameState.selectedGem, clicked)) {
            toggleSelectVisual(gameState.selectedGem, false);
            attemptSwap(gameState.selectedGem, clicked);
            gameState.selectedGem = null;
        } else {
            toggleSelectVisual(gameState.selectedGem, false);
            gameState.selectedGem = clicked;
            toggleSelectVisual(clicked, true);
        }
    }

    function isAdjacent(p1, p2) {
        return Math.abs(p1.r - p2.r) + Math.abs(p1.c - p2.c) === 1;
    }

    function toggleSelectVisual(pos, isSelected) {
        const el = getGemDOM(pos.r, pos.c);
        if (el) {
            if (isSelected) el.classList.add('selected');
            else el.classList.remove('selected');
        }
    }

    async function attemptSwap(p1, p2) {
        gameState.isLocked = true;

        // Visual Swap First
        await swapAnimation(p1, p2);

        // Check Entangled
        const w1 = gameState.wordGrid[p1.r][p1.c];
        const w2 = gameState.wordGrid[p2.r][p2.c];
        if ((w1 && w1.isEntangled) || (w2 && w2.isEntangled)) {
             // Revert visual swap manually because IDs haven't changed
             const el1 = getGemDOM(p1.r, p1.c);
             const el2 = getGemDOM(p2.r, p2.c);
             if(el1 && el2) {
                 el1.style.transform = `translate(${p1.c * CELL_SIZE}px, ${p1.r * CELL_SIZE}px)`;
                 el2.style.transform = `translate(${p2.c * CELL_SIZE}px, ${p2.r * CELL_SIZE}px)`;
                 await new Promise(r => setTimeout(r, 210));
             }
             gameState.isLocked = false;
             return;
        }

        // Check Word Match
        if (w1 && w2 && w1.lang !== w2.lang) {
            // Potential Word Match
            const cn = w1.lang === 'CN' ? w1 : w2;
            const en = w1.lang === 'EN' ? w1 : w2;
            
            const pair = WORD_PAIRS.find(p => p.cn === cn.word && p.en === en.word);
            
            if (pair) {
                // Correct Match!
                if (gameState.mode === 'moves') gameState.moves--;
                updateUI();
                processWordMatch(p1, p2, true);
                return;
            } else {
                // Wrong Match
                await swapAnimation(p1, p2); // Revert visual
                if (gameState.mode === 'moves') gameState.moves--;
                updateUI();
                processWordMatch(p1, p2, false);
                checkWinCondition();
                return;
            }
        }

        // Swap Data
        const t = gameState.grid[p1.r][p1.c];
        gameState.grid[p1.r][p1.c] = gameState.grid[p2.r][p2.c];
        gameState.grid[p2.r][p2.c] = t;

        // Swap Word Data
        const tw = gameState.wordGrid[p1.r][p1.c];
        gameState.wordGrid[p1.r][p1.c] = gameState.wordGrid[p2.r][p2.c];
        gameState.wordGrid[p2.r][p2.c] = tw;

        updateDomIds(p1, p2);

        const matches = findMatches();

        if (matches.length > 0) {
            if (gameState.mode === 'moves') gameState.moves--;
            gameState.comboMultiplier = 1;
            updateUI();
            await processMatches(matches);
        } else {
            // Invalid Move - Revert
            await swapAnimation(p1, p2);
            
            const t = gameState.grid[p1.r][p1.c];
            gameState.grid[p1.r][p1.c] = gameState.grid[p2.r][p2.c];
            gameState.grid[p2.r][p2.c] = t;

            const tw = gameState.wordGrid[p1.r][p1.c];
            gameState.wordGrid[p1.r][p1.c] = gameState.wordGrid[p2.r][p2.c];
            gameState.wordGrid[p2.r][p2.c] = tw;
            
            updateDomIds(p1, p2);
            gameState.isLocked = false;

            // Check for English word special logic
            const w1 = gameState.wordGrid[p1.r][p1.c];
            if (w1 && w1.lang === 'EN') {
                if (gameState.currentPair && w1.word === gameState.currentPair.en) {
                    // Remote Match!
                    let cnPos = null;
                    for(let r=0; r<ROWS; r++) {
                        for(let c=0; c<COLS; c++) {
                            const w = gameState.wordGrid[r][c];
                            if (w && w.lang === 'CN' && w.word === gameState.currentPair.cn) {
                                cnPos = {r, c};
                                break;
                            }
                        }
                    }

                    if (cnPos) {
                        gameState.isLocked = true;
                        if (gameState.mode === 'moves') gameState.moves--;
                        
                        await animateAndCrush(p1, cnPos, gameState.currentPair);

                        gameState.score += 500;
                        showFloatingText(500, p1);
                        
                        removeGem(p1.r, p1.c, true);
                        removeGem(cnPos.r, cnPos.c, true);
                        
                        advanceWordPair();
                        
                        updateUI();
                        
                        setTimeout(async () => {
                            await applyGravity();
                            ensureWords();
                            const matches = findMatches();
                            if(matches.length > 0) {
                                await processMatches(matches);
                            } else {
                                checkWinCondition();
                            }
                        }, 300);
                    } else {
                         // Should not happen if ensureWords works correctly, but fallback
                         // If no CN word found, maybe just entangle?
                         // Or do nothing.
                         // Let's treat as entangle if we can't find the pair to explode.
                         w1.isEntangled = true;
                         let randomPair;
                         do {
                             randomPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
                         } while (randomPair.en === w1.word);
                         
                         w1.word = randomPair.en;
                         updateWordVisuals(p1.r, p1.c);
                    }
                } else {
                    // Entangle
                    w1.isEntangled = true;
                    let randomPair;
                    do {
                        randomPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
                    } while (randomPair.en === w1.word);
                    
                    w1.word = randomPair.en;
                    updateWordVisuals(p1.r, p1.c);
                }
            }
        }
    }

    function advanceWordPair() {
        if (!gameState.currentPair) return;
        const currentIndex = WORD_PAIRS.findIndex(p => p.cn === gameState.currentPair.cn);
        if (currentIndex !== -1) {
            const nextIndex = (currentIndex + 1) % WORD_PAIRS.length;
            gameState.currentPair = WORD_PAIRS[nextIndex];
        }
    }

    function removeGem(r, c, skipParticles = false) {
        const el = getGemDOM(r, c);
        if (el) {
            if (!skipParticles) {
                createParticles(r, c, gameState.grid[r][c]);
            }
            el.style.transform += " scale(0)";
            el.style.opacity = "0";
        }
        gameState.grid[r][c] = null;
        gameState.wordGrid[r][c] = null;
        setTimeout(() => { if(el) el.remove(); }, 300);
    }

    async function processWordMatch(p1, p2, isCorrect) {
        if (isCorrect) {
            // Find the pair info to get English word
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            let pair = gameState.currentPair;
            
            // If currentPair doesn't match (e.g. random match), try to find it from w1/w2
            if (w1 && w2) {
                 const cn = w1.lang === 'CN' ? w1 : w2;
                 const en = w1.lang === 'EN' ? w1 : w2;
                 const found = WORD_PAIRS.find(p => p.cn === cn.word && p.en === en.word);
                 if(found) pair = found;
            }

            await animateAndCrush(p1, p2, pair);

            gameState.score += 500;
            showFloatingText(500, p1);
            
            removeGem(p1.r, p1.c, true);
            removeGem(p2.r, p2.c, true);
            
            advanceWordPair();
            
            updateUI();
            
            setTimeout(async () => {
                await applyGravity();
                ensureWords();
                const matches = findMatches();
                if(matches.length > 0) {
                    await processMatches(matches);
                } else {
                    checkWinCondition();
                }
            }, 300);
            
        } else {
            const w1 = gameState.wordGrid[p1.r][p1.c];
            const w2 = gameState.wordGrid[p2.r][p2.c];
            let enPos = w1.lang === 'EN' ? p1 : p2;
            
            let randomPair;
            do {
                randomPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
            } while (gameState.currentPair && randomPair.en === gameState.currentPair.en);
            
            gameState.wordGrid[enPos.r][enPos.c] = {
                word: randomPair.en,
                lang: 'EN',
                isEntangled: true
            };
            updateWordVisuals(enPos.r, enPos.c);
        }
    }

    function updateDomIds(p1, p2) {
        const dom1 = document.getElementById(`gem-${p1.r}-${p1.c}`);
        const dom2 = document.getElementById(`gem-${p2.r}-${p2.c}`);
        
        if(dom1 && dom2) {
            dom1.id = "temp_id";
            dom2.id = `gem-${p1.r}-${p1.c}`;
            dom1.id = `gem-${p2.r}-${p2.c}`;
            
            // Update event listeners to new coords
            updateListener(dom1, p2.r, p2.c);
            updateListener(dom2, p1.r, p1.c);
        }
    }
    
    function updateListener(el, r, c) {
        bindInteraction(el, r, c);
    }

    function bindInteraction(el, r, c) {
        const startHandler = (e) => {
            if (e.cancelable && e.type === 'touchstart') e.preventDefault();
            handleInteractionStart(e, r, c);
        };
        el.onmousedown = startHandler;
        el.ontouchstart = startHandler;
    }

    let dragStart = null;

    function handleInteractionStart(e, r, c) {
        if (gameState.isLocked) return;
        
        // Block entangled
        if (gameState.wordGrid[r][c] && gameState.wordGrid[r][c].isEntangled) return;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        dragStart = {
            r, c,
            x: clientX,
            y: clientY,
            moved: false
        };

        document.addEventListener('mousemove', handleInteractionMove);
        document.addEventListener('mouseup', handleInteractionEnd);
        document.addEventListener('touchmove', handleInteractionMove, { passive: false });
        document.addEventListener('touchend', handleInteractionEnd);
    }

    function handleInteractionMove(e) {
        if (!dragStart || gameState.isLocked) return;

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const dx = clientX - dragStart.x;
        const dy = clientY - dragStart.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 20) { // Threshold
            dragStart.moved = true;
            
            // Determine direction
            let targetR = dragStart.r;
            let targetC = dragStart.c;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (dx > 0) targetC++; else targetC--;
            } else {
                // Vertical
                if (dy > 0) targetR++; else targetR--;
            }

            // Check bounds
            if (targetR >= 0 && targetR < ROWS && targetC >= 0 && targetC < COLS) {
                // Execute Swap
                const p1 = { r: dragStart.r, c: dragStart.c };
                const p2 = { r: targetR, c: targetC };
                
                // Clear any existing selection
                if (gameState.selectedGem) {
                    toggleSelectVisual(gameState.selectedGem, false);
                    gameState.selectedGem = null;
                }

                attemptSwap(p1, p2);
            }
            
            // Stop tracking immediately after triggering swap
            cleanupInteraction();
        }
    }

    function handleInteractionEnd(e) {
        if (dragStart && !dragStart.moved) {
            // It was a click
            handleInput(dragStart.r, dragStart.c);
        }
        cleanupInteraction();
    }

    function cleanupInteraction() {
        dragStart = null;
        document.removeEventListener('mousemove', handleInteractionMove);
        document.removeEventListener('mouseup', handleInteractionEnd);
        document.removeEventListener('touchmove', handleInteractionMove);
        document.removeEventListener('touchend', handleInteractionEnd);
    }

    function swapAnimation(p1, p2) {
        return new Promise(resolve => {
            const el1 = getGemDOM(p1.r, p1.c);
            const el2 = getGemDOM(p2.r, p2.c);

            if(!el1 || !el2) { resolve(); return; }

            el1.style.transition = 'transform 0.2s ease';
            el2.style.transition = 'transform 0.2s ease';

            el1.style.transform = `translate(${p2.c * CELL_SIZE}px, ${p2.r * CELL_SIZE}px)`;
            el2.style.transform = `translate(${p1.c * CELL_SIZE}px, ${p1.r * CELL_SIZE}px)`;

            setTimeout(() => {
                resolve();
            }, 210);
        });
    }

    /* --- Matching Engine --- */

    function findMatches() {
        const matchedSet = new Set();

        // Horizontal
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS - 2; c++) {
                const type = gameState.grid[r][c];
                if (type === null) continue;
                if (gameState.grid[r][c+1] === type && gameState.grid[r][c+2] === type) {
                    matchedSet.add(`${r},${c}`);
                    matchedSet.add(`${r},${c+1}`);
                    matchedSet.add(`${r},${c+2}`);
                }
            }
        }

        // Vertical
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 2; r++) {
                const type = gameState.grid[r][c];
                if (type === null) continue;
                if (gameState.grid[r+1][c] === type && gameState.grid[r+2][c] === type) {
                    matchedSet.add(`${r},${c}`);
                    matchedSet.add(`${r+1},${c}`);
                    matchedSet.add(`${r+2},${c}`);
                }
            }
        }

        return Array.from(matchedSet).map(str => {
            const [r, c] = str.split(',').map(Number);
            return { r, c };
        });
    }

    async function processMatches(matches) {
        // Check for EN word match and include CN word if exists
        // Also check for CN word match and include EN word if exists
        if (gameState.currentPair) {
            let enExploded = false;
            let cnExploded = false;
            
            for (const m of matches) {
                const w = gameState.wordGrid[m.r][m.c];
                if (w) {
                    if (w.word === gameState.currentPair.en) enExploded = true;
                    if (w.word === gameState.currentPair.cn) cnExploded = true;
                }
            }

            if (enExploded || cnExploded) {
                // Find the other part of the pair
                let targetWord = enExploded ? gameState.currentPair.cn : gameState.currentPair.en;
                let targetPos = null;
                
                // If both exploded, we are good. If only one, find the other.
                if (!(enExploded && cnExploded)) {
                    for(let r=0; r<ROWS; r++) {
                        for(let c=0; c<COLS; c++) {
                            const w = gameState.wordGrid[r][c];
                            if (w && w.word === targetWord) {
                                targetPos = {r, c};
                                break;
                            }
                        }
                        if(targetPos) break;
                    }

                    if (targetPos) {
                        const alreadyMatched = matches.some(m => m.r === targetPos.r && m.c === targetPos.c);
                        if (!alreadyMatched) {
                            matches.push(targetPos);
                            gameState.score += 300; 
                            showFloatingText("连消!", targetPos);
                        }
                    }
                }
            }
        }

        // Score
        const baseScore = 100;
        const points = (matches.length * baseScore) * gameState.comboMultiplier;
        gameState.score += points;
        
        if(matches.length > 0) {
            showFloatingText(points, matches[0]);
        }

        let cnExploded = false;
        // Check for words in matches
        matches.forEach(m => {
            const w = gameState.wordGrid[m.r][m.c];
            if (w) {
                if (gameState.currentPair) {
                    if (w.word === gameState.currentPair.cn) {
                        cnExploded = true;
                    }
                    if (w.word === gameState.currentPair.cn || w.word === gameState.currentPair.en) {
                        gameState.score += 200; // Bonus
                        showFloatingText("奖励!", m);
                    }
                }
            }
            
            // Disentangle neighbors
            const neighbors = [
                {r: m.r-1, c: m.c}, {r: m.r+1, c: m.c},
                {r: m.r, c: m.c-1}, {r: m.r, c: m.c+1}
            ];
            neighbors.forEach(n => {
                if(n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS) {
                    const nw = gameState.wordGrid[n.r][n.c];
                    if(nw && nw.isEntangled) {
                        nw.isEntangled = false;
                        updateWordVisuals(n.r, n.c);
                    }
                }
            });
        });
        
        gameState.comboMultiplier++;
        updateUI();

        if (cnExploded) {
            advanceWordPair();
        }

        // Check for pair animation
        const animatedGems = new Set();
        let pairToAnimate = null;
        let enGem = null;
        let cnGem = null;
        
        for(let i=0; i<matches.length; i++) {
            const m1 = matches[i];
            const w1 = gameState.wordGrid[m1.r][m1.c];
            if(!w1) continue;
            
            for(let j=i+1; j<matches.length; j++) {
                const m2 = matches[j];
                const w2 = gameState.wordGrid[m2.r][m2.c];
                if(!w2) continue;
                
                if(w1.lang !== w2.lang) {
                    const cn = w1.lang === 'CN' ? w1 : w2;
                    const en = w1.lang === 'EN' ? w1 : w2;
                    const p = WORD_PAIRS.find(wp => wp.cn === cn.word && wp.en === en.word);
                    if(p) {
                        pairToAnimate = p;
                        enGem = w1.lang === 'EN' ? m1 : m2;
                        cnGem = w1.lang === 'CN' ? m1 : m2;
                        break;
                    }
                }
            }
            if(pairToAnimate) break;
        }
        
        if(pairToAnimate && enGem && cnGem) {
            await animateAndCrush(enGem, cnGem, pairToAnimate);
            animatedGems.add(`${enGem.r},${enGem.c}`);
            animatedGems.add(`${cnGem.r},${cnGem.c}`);
        }

        // Remove
        matches.forEach(m => {
            const skipParticles = animatedGems.has(`${m.r},${m.c}`);
            removeGem(m.r, m.c, skipParticles);
        });

        await new Promise(r => setTimeout(r, 300));

        // Clean DOM
        matches.forEach(m => {
            const el = getGemDOM(m.r, m.c);
            if (el) el.remove();
        });

        await applyGravity();
        ensureWords();

        // Cascade
        const newMatches = findMatches();
        if (newMatches.length > 0) {
            await new Promise(r => setTimeout(r, 200));
            await processMatches(newMatches);
        } else {
            checkWinCondition();
        }
    }

    async function applyGravity() {
        const moves = []; 

        // 1. Shift down
        for (let c = 0; c < COLS; c++) {
            let emptySlots = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (gameState.grid[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const type = gameState.grid[r][c];
                    const newR = r + emptySlots;
                    
                    gameState.grid[newR][c] = type;
                    gameState.grid[r][c] = null;

                    gameState.wordGrid[newR][c] = gameState.wordGrid[r][c];
                    gameState.wordGrid[r][c] = null;

                    const el = getGemDOM(r, c);
                    if(el) {
                        el.id = `gem-${newR}-${c}`;
                        moves.push({ el, r: newR, c });
                    }
                }
            }

            // 2. Fill top
            for(let r = 0; r < emptySlots; r++) {
                const type = Math.floor(Math.random() * GEM_TYPES);
                gameState.grid[r][c] = type;
                gameState.wordGrid[r][c] = null;
                
                const div = document.createElement('div');
                div.classList.add('gem', `type-${type}`);
                div.id = `gem-${r}-${c}`;
                div.style.width = `${CELL_SIZE}px`;
                div.style.height = `${CELL_SIZE}px`;
                div.style.transform = `translate(${c * CELL_SIZE}px, -${(emptySlots - r + 1) * CELL_SIZE}px)`;
                
                const inner = document.createElement('div');
                inner.classList.add('gem-inner');
                div.appendChild(inner);
                
                dom.grid.appendChild(div);
                moves.push({ el: div, r: r, c: c });
            }
        }

        await new Promise(r => requestAnimationFrame(r));

        moves.forEach(m => {
            m.el.style.transition = 'transform 0.4s cubic-bezier(0.25, 1, 0.5, 1)';
            m.el.style.transform = `translate(${m.c * CELL_SIZE}px, ${m.r * CELL_SIZE}px)`;
            
            // Update Listener for new position
            updateListener(m.el, m.r, m.c);
        });

        await new Promise(r => setTimeout(r, 400));
    }

    /* --- VFX & UI --- */

    function playWinEffect() {
        const overlay = document.getElementById('success-overlay');
        const canvas = document.getElementById('confetti-canvas');
        overlay.classList.remove('hidden');
        
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

        for(let i=0; i<200; i++) {
            particles.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 30,
                vy: (Math.random() - 0.5) * 30,
                color: colors[Math.floor(Math.random() * colors.length)],
                size: Math.random() * 10 + 5,
                life: 100
            });
        }

        function animate() {
            if(overlay.classList.contains('hidden')) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let active = false;
            particles.forEach(p => {
                if(p.life > 0) {
                    active = true;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // Gravity
                    p.life--;
                    
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            });

            if(active) requestAnimationFrame(animate);
        }
        
        animate();
    }

    function createParticles(r, c, type, x, y) {
        const centerX = x !== undefined ? x : (c * CELL_SIZE + CELL_SIZE / 2);
        const centerY = y !== undefined ? y : (r * CELL_SIZE + CELL_SIZE / 2);
        const colors = ['#ff4d4d', '#4da6ff', '#4dff88', '#ffff4d', '#bf4dff', '#ffae4d'];
        const color = colors[type] || '#fff';

        for (let i = 0; i < 8; i++) {
            const p = document.createElement('div');
            p.classList.add('particle');
            p.style.backgroundColor = color;
            p.style.left = `${centerX}px`;
            p.style.top = `${centerY}px`;
            p.style.width = `${Math.random() * 10 + 5}px`;
            p.style.height = p.style.width;
            
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * 60 + 20;
            p.style.setProperty('--dest-x', `${Math.cos(angle) * velocity}px`);
            p.style.setProperty('--dest-y', `${Math.sin(angle) * velocity}px`);
            
            dom.grid.appendChild(p);
            setTimeout(() => p.remove(), 600);
        }
    }

    function showFloatingText(text, pos) {
        const el = document.createElement('div');
        el.classList.add('float-text');
        el.textContent = typeof text === 'number' ? `+${text}` : text;
        // Safety check for pos
        if(pos && pos.c !== undefined) {
            el.style.left = `${pos.c * CELL_SIZE + CELL_SIZE/2 - 20}px`;
            el.style.top = `${pos.r * CELL_SIZE}px`;
            dom.grid.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
    }

    function updateUI() {
        dom.score.textContent = gameState.score;
        
        if (gameState.mode === 'time') {
            const m = Math.floor(gameState.timeLeft / 60);
            const s = gameState.timeLeft % 60;
            dom.moves.textContent = `${m}:${s.toString().padStart(2, '0')}`;
        } else {
            dom.moves.textContent = gameState.moves;
        }
        
        dom.level.textContent = gameState.level;
        dom.target.textContent = gameState.targetScore;

        const levelEarned = gameState.score - (gameState.levelStartScore || 0);
        const levelGoal = gameState.targetScore - (gameState.levelStartScore || 0);
        const progress = levelGoal > 0 ? Math.min(100, (levelEarned / levelGoal) * 100) : 0;
        
        dom.progress.style.width = `${progress}%`;
    }

    function checkWinCondition() {
        if (gameState.score >= gameState.targetScore) {
            gameState.isLocked = true;
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            dom.levelScoreFinal.textContent = gameState.score;
            playWinEffect();
            
            // Notify parent of level completion (optional, but good practice)
            // window.parent.postMessage({ type: 'levelCompleted', score: gameState.score, level: gameState.level }, '*');

            setTimeout(() => {
                // Auto advance to next level
                startLevel(gameState.level + 1);
            }, 2000);
        } else {
            let isGameOver = false;
            if (gameState.mode === 'time') {
                if (gameState.timeLeft <= 0) isGameOver = true;
            } else {
                if (gameState.moves <= 0) isGameOver = true;
            }

            if (isGameOver) {
                gameState.isLocked = true;
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                dom.finalScore.textContent = gameState.score;
                
                // Notify parent of game over
                window.parent.postMessage({ 
                    type: 'gameFinished', 
                    data: { 
                        score: gameState.score, 
                        level: gameState.level,
                        difficulty: gameState.difficulty,
                        mode: gameState.mode
                    } 
                }, '*');

                setTimeout(() => {
                    dom.gameOverModal.classList.remove('hidden');
                }, 500);
            } else {
                gameState.isLocked = false;
            }
        }
    }

    function ensureWords() {
        // Count existing words
        let cnCount = 0;
        let enCount = 0;
        let hasTargetCN = false;
        let hasTargetEN = false;
        
        // Flatten grid to find empty spots
        const emptySpots = [];
        
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const w = gameState.wordGrid[r][c];
                if(w) {
                    if(w.lang === 'CN') cnCount++;
                    if(w.lang === 'EN') enCount++;
                    if(gameState.currentPair) {
                        if(w.word === gameState.currentPair.cn) hasTargetCN = true;
                        if(w.word === gameState.currentPair.en) hasTargetEN = true;
                    }
                } else if (gameState.grid[r][c] !== null) {
                    emptySpots.push({r, c});
                }
            }
        }

        // If current pair is missing, pick new one
        if (!gameState.currentPair) {
             if (cnCount > 0) {
                 // Find the CN word on board
                 let found = null;
                 for(let r=0; r<ROWS; r++) {
                     for(let c=0; c<COLS; c++) {
                         if(gameState.wordGrid[r][c] && gameState.wordGrid[r][c].lang === 'CN') {
                             found = gameState.wordGrid[r][c];
                             break;
                         }
                     }
                 }
                 if(found) {
                     const pair = WORD_PAIRS.find(p => p.cn === found.word);
                     if(pair) gameState.currentPair = pair;
                 } else {
                     gameState.currentPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
                 }
             } else {
                 gameState.currentPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
             }
        }

        // Add CN if missing
        if (cnCount < 1 && emptySpots.length > 0) {
            const idx = Math.floor(Math.random() * emptySpots.length);
            const spot = emptySpots.splice(idx, 1)[0];
            gameState.wordGrid[spot.r][spot.c] = {
                word: gameState.currentPair.cn,
                lang: 'CN',
                isEntangled: false
            };
            updateWordVisuals(spot.r, spot.c);
            cnCount++;
        }

        // Add Target EN if missing
        hasTargetEN = false;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const w = gameState.wordGrid[r][c];
                if(w && w.word === gameState.currentPair.en) hasTargetEN = true;
            }
        }

        if (!hasTargetEN && emptySpots.length > 0) {
            const idx = Math.floor(Math.random() * emptySpots.length);
            const spot = emptySpots.splice(idx, 1)[0];
            gameState.wordGrid[spot.r][spot.c] = {
                word: gameState.currentPair.en,
                lang: 'EN',
                isEntangled: false
            };
            updateWordVisuals(spot.r, spot.c);
            enCount++;
        }

        // Fill remaining EN slots (up to 4)
        while (enCount < 4 && emptySpots.length > 0) {
            const idx = Math.floor(Math.random() * emptySpots.length);
            const spot = emptySpots.splice(idx, 1)[0];
            
            let randomPair;
            do {
                randomPair = WORD_PAIRS[Math.floor(Math.random() * WORD_PAIRS.length)];
            } while (randomPair.en === gameState.currentPair.en);

            gameState.wordGrid[spot.r][spot.c] = {
                word: randomPair.en,
                lang: 'EN',
                isEntangled: false
            };
            updateWordVisuals(spot.r, spot.c);
            enCount++;
        }
    }

    function updateWordVisuals(r, c) {
        const el = getGemDOM(r, c);
        if (!el) return;
        
        const existing = el.querySelector('.gem-word');
        if (existing) existing.remove();
        el.classList.remove('entangled');
        el.classList.remove('has-word');
        el.classList.remove('lang-cn');
        el.classList.remove('lang-en');

        const data = gameState.wordGrid[r][c];
        if (data) {
            el.classList.add('has-word');
            el.classList.add(data.lang === 'CN' ? 'lang-cn' : 'lang-en');
            const wordEl = document.createElement('div');
            wordEl.classList.add('gem-word');
            wordEl.textContent = data.word;
            el.appendChild(wordEl);
            
            if (data.isEntangled) {
                el.classList.add('entangled');
            }
        }
    }

    // Run
    init();

</script>
</body>
</html>
