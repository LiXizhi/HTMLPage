<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰å¿ƒäºŒæ„ - æ³¨æ„åŠ›è®­ç»ƒæ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        .game-container {
            width: 1280px;
            height: 720px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        .header {
            height: 80px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        .game-area {
            height: 640px;
            display: flex;
        }

        .side {
            width: 50%;
            height: 100%;
            position: relative;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .left-side {
            background: #f8f9fa;
            border-right: 3px solid #dee2e6;
        }

        .right-side {
            background: #f1f3f4;
        }

        .instruction-container {
            margin-bottom: 20px;
        }

        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffa500, #ffff00, #90ee90, #87ceeb);
            border-radius: 4px;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
            animation: shimmer 1s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-20px); }
            100% { transform: translateX(20px); }
        }

        .instruction {
            height: 60px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            padding: 15px;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .mini-timer {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(220, 53, 69, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
        }

        .game-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 360px;
            z-index: 1000;
            animation: fadeInOut 1s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .success { color: #28a745; }
        .failure { color: #dc3545; }

        .highlight {
            color: #007bff;
            background: rgba(0,123,255,0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* æ¸¸æˆç»„ä»¶æ ·å¼ */
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
            justify-items: center;
            align-items: center;
            margin-top: 30px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .option, .clickable {
            padding: 25px 35px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 48px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 180px;
            min-height: 120px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-shadow: 0 4px 8px rgba(0,123,255,0.2);
        }

        .option:active, .clickable:active {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,123,255,0.4);
        }

        .question {
            font-size: 56px;
            font-weight: bold;
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        /* è¿·å®«æ ·å¼ */
        .maze {
            display: grid;
            gap: 2px;
            margin: 20px auto;
        }

        .maze-cell {
            width: 30px;
            height: 30px;
            background: #333;
            cursor: pointer;
            transition: background 0.2s;
        }

        .maze-path {
            background: #fff !important;
        }

        .maze-start {
            background: #28a745 !important;
        }

        .maze-end {
            background: #dc3545 !important;
        }

        .maze-current {
            background: #ffc107 !important;
        }

        /* çº¸æ¯æ¸¸æˆæ ·å¼ */
        .cups {
            display: flex;
            gap: 50px;
            justify-content: center;
            align-items: flex-end;
            margin-top: 40px;
            height: 180px;
        }

        .cup-container {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 150px;
            height: 180px;
        }

        .cup {
            width: 120px;
            height: 150px;
            background: linear-gradient(to bottom, #D2B48C 0%, #CD853F 50%, #8B4513 100%);
            /* å€’æ‰£çº¸æ¯å½¢çŠ¶ï¼šä¸Šçª„ä¸‹å®½ */
            clip-path: polygon(25% 0%, 75% 0%, 90% 100%, 10% 100%);
            cursor: pointer;
            position: relative;
            transform: translateY(-30px);
            transition: all 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .cup:hover {
            transform: translateY(-35px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .cup.swapping {
            z-index: 10;
        }

        .ball {
            width: 36px;
            height: 36px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #dc3545);
            border-radius: 50%;
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* æ°”æ³¡æ¸¸æˆæ ·å¼ */
        .bubble-area {
            position: relative;
            width: 100%;
            height: 400px;
            overflow: hidden;
        }

        .bubble {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: pointer;
            /* åŠ¨ç”»æ—¶é—´å°†é€šè¿‡JavaScriptåŠ¨æ€è®¾ç½® */
        }

        @keyframes bubbleUp {
            from { bottom: -60px; }
            to { bottom: 100%; }
        }

        /* å¤šè¾¹å½¢æ ·å¼ */
        .shapes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 25px;
            justify-items: center;
            align-items: center;
            margin-top: 30px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .shape {
            width: 160px;
            height: 160px;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 56px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .shape:active {
            transform: scale(1.1);
        }

        .selected {
            border: 3px solid #ffc107 !important;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.6);
        }

        /* è¿·å®«æ ·å¼ */
        .maze-container {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .maze-cell {
            background: rgba(248, 249, 250, 0.8);
            /* ç§»é™¤è¾¹æ¡† */
        }

        .maze-wall {
            background: #333 !important;
        }

        .maze-path-line {
            pointer-events: none;
        }

        /* æ±‰å­—é¢œè‰²æ¸¸æˆæ ·å¼ */
        .chinese-char {
            font-size: 36px;
            font-weight: bold;
            padding: 20px;
            margin: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .chinese-char:active {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px 36px;
            border-radius: 16px;
            font-weight: bold;
            font-size: 24px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            background: #0056b3;
            transform: translate(-50%, -50%) translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }

        .start-btn:active {
            transform: translate(-50%, -50%) translateY(0);
        }

        /* è§„åˆ™æŒ‰é’®æ ·å¼ */
        .rules-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .rules-button:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }

        .rules-button:active {
            transform: scale(0.95);
        }

        /* ç§¯åˆ†æŒ‰é’®æ ·å¼ */
        .points-button {
            position: fixed;
            bottom: 88px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #ffc107;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .points-button:hover {
            box-shadow: 0 6px 16px rgba(255, 193, 7, 0.4);
            transform: scale(1.05);
        }

        .points-button:active {
            transform: scale(0.95);
        }

        /* å¼¹çª—é®ç½© */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* å¼¹çª—ä¸»ä½“ */
        .rules-modal {
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            max-width: 768px;
            width: 90%;
            background: white;
            border-radius: 16px;
            padding: 36px;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.show .rules-modal {
            transform: translateY(0);
        }

        /* ç§¯åˆ†å¼¹çª—æ ·å¼ */
        .points-modal {
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .modal-overlay.show .points-modal {
            transform: translateY(0);
        }

        /* ç§¯åˆ†å¼¹çª—å¤´éƒ¨ */
        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 36px;
            background: rgba(0, 123, 255, 0.1);
            color: #333;
        }

        .points-header h2 {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .points-close {
            background: none;
            border: none;
            font-size: 32px;
            cursor: pointer;
            color: rgba(51, 51, 51, 0.7);
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .points-close:hover {
            background: rgba(51, 51, 51, 0.1);
            color: #333;
        }

        /* ç§¯åˆ†å¼¹çª—å†…å®¹ */
        .points-body {
            padding: 36px;
            color: #333;
            overflow-y: auto;
            flex: 1;
        }

        .points-body::-webkit-scrollbar {
            display: none;
        }

        .points-stats {
            margin-bottom: 32px;
        }

        .points-stats h3 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }

        .stat-card {
            text-align: center;
            background: rgba(0, 123, 255, 0.05);
            border: 1px solid rgba(0, 123, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .stat-card.total {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .stat-card.daily {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .stat-label {
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: white;
        }

        .last-update {
            text-align: center;
            font-size: 14px;
            color: rgba(51, 51, 51, 0.6);
            margin-bottom: 32px;
        }

        .points-rules h3 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .rules-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .rules-list li {
            margin-bottom: 16px;
            padding: 16px 20px;
            color: #333;
        }

        .points-highlight {
            color: #f39c12;
            font-weight: bold;
        }

        /* å¼¹çª—å¤´éƒ¨ */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 36px;
            font-size: 36px;
            font-weight: bold;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 36px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        /* å¼¹çª—è§„åˆ™è¯´æ˜ */
        .rules-content {
            list-style-type: decimal;
            margin-left: 36px;
            font-weight: 500;
            font-size: 27px;
        }

        .rules-content li {
            margin-bottom: 18px;
            line-height: 1.5;
        }

        /* å¼¹çª—åº•éƒ¨æŒ‰é’® */
        .modal-button {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            padding: 12px 36px;
            border-radius: 16px;
            font-weight: bold;
            font-size: 24px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }

        .modal-button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div>ğŸ¯ ä¸‰å¿ƒäºŒæ„</div>
            <div>â° æ—¶é—´: <span id="timer">60</span>s</div>
            <div>ğŸ¯ æ­£ç¡®ç‡: <span id="score">0%</span></div>
            <div>â­ æ€»ç§¯åˆ†: <span id="totalPoints">0</span></div>
        </div>
        <div class="game-area">
            <div class="side left-side">
                <div class="instruction-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="left-progress"></div>
                    </div>
                    <div class="instruction" id="left-instruction">
                        ç‚¹å‡»å¼€å§‹æŒ‰é’®å¼€å§‹è®­ç»ƒ
                        <div class="mini-timer" id="left-timer">-</div>
                    </div>
                </div>
                <div class="game-content" id="left-content">
                    <button class="start-btn" onclick="startGame()">å¼€å§‹è®­ç»ƒ</button>
                </div>
            </div>
            <div class="side right-side">
                <div class="instruction-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="right-progress"></div>
                    </div>
                    <div class="instruction" id="right-instruction">
                        å‡†å¤‡å°±ç»ª
                        <div class="mini-timer" id="right-timer">-</div>
                    </div>
                </div>
                <div class="game-content" id="right-content"></div>
            </div>
        </div>
    </div>

    <!-- ç§¯åˆ†æŒ‰é’® -->
    <div class="points-button" onclick="showPointsModal()">â˜…</div>

    <!-- è§„åˆ™æŒ‰é’® -->
    <div class="rules-button" onclick="showRulesModal()">â“</div>

    <!-- ç§¯åˆ†å¼¹çª— -->
    <div class="modal-overlay" id="pointsModal" onclick="hidePointsModal(event)">
        <div class="points-modal" onclick="event.stopPropagation()">
            <div class="points-header">
                <h2>â˜… ç§¯åˆ†ç³»ç»Ÿ</h2>
                <button class="points-close" onclick="hidePointsModal()">Ã—</button>
            </div>
            <div class="points-body">
                <div class="points-stats">
                    <h3>ç§¯åˆ†ç»Ÿè®¡</h3>
                    <div class="stats-grid">
                        <div class="stat-card total">
                            <div class="stat-label">æ€»ç§¯åˆ†</div>
                            <div id="modalTotalPoints" class="stat-value">0</div>
                        </div>
                        <div class="stat-card daily">
                            <div class="stat-label">ä»Šæ—¥ç§¯åˆ†</div>
                            <div id="modalDailyPoints" class="stat-value">0</div>
                        </div>
                    </div>
                    <div class="last-update">
                        æœ€åæ›´æ–°: <span id="lastUpdateDate">--</span>
                    </div>
                </div>
                <div class="points-rules">
                    <h3>ç§¯åˆ†è·å¾—è§„åˆ™</h3>
                    <ul class="rules-list">
                        <li>æ¯æ­£ç¡®å®Œæˆä¸€ä¸ªæ³¨æ„åŠ›åˆ†é…ä»»åŠ¡è·å¾— <span class="points-highlight">5ç§¯åˆ†</span></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- è§„åˆ™å¼¹çª— -->
    <div class="modal-overlay" id="rulesModal" onclick="hideRulesModal(event)">
        <div class="rules-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div>ğŸ¯ ä¸‰å¿ƒäºŒæ„</div>
                <button class="modal-close" onclick="hideRulesModal()">Ã—</button>
            </div>
            <ol class="rules-content">
                <li>è¿™æ˜¯ä¸€ä¸ªåŒä»»åŠ¡æ³¨æ„åŠ›åˆ†é…è®­ç»ƒï¼Œå·¦å³ä¸¤ä¾§ä¼šåŒæ—¶æ˜¾ç¤ºä¸åŒçš„ä»»åŠ¡</li>
                <li>ä½ éœ€è¦åŒæ—¶å…³æ³¨å¹¶å®Œæˆä¸¤ä¾§çš„ä»»åŠ¡ï¼Œè®­ç»ƒåˆ†é…æ³¨æ„åŠ›</li>
                <li>æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡å¯è·å¾—5åˆ†ç§¯åˆ†ï¼Œæ­£ç¡®ç‡æ˜¾ç¤ºä¸ºå®Œæˆæ­£ç¡®çš„ä»»åŠ¡æ•°/æ€»å®Œæˆä»»åŠ¡æ•°</li>
                <li>ä»»åŠ¡ç±»å‹åŒ…æ‹¬ï¼šç®€å•ç®—æœ¯ã€è®°å¿†çº¸æ¯ã€æ°”æ³¡ç‚¹å‡»ã€æ‰¾ä¸åŒç­‰</li>
            </ol>
            <button class="modal-button" onclick="startGame(); hideRulesModal()">å¼€å§‹è®­ç»ƒ</button>
        </div>
    </div>

    <script>
        // ========== æ¸¸æˆé…ç½®åŒºåŸŸ ==========
        const GAME_CONFIG = {
            GAME_TIME_LIMIT: 15,        // æ¯ä¸ªå°æ¸¸æˆçš„æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
            TOTAL_GAME_TIME: 90,       // æ€»æ¸¸æˆæ—¶é—´ï¼ˆç§’ï¼‰
            BUBBLE_RISE_TIME: 5,       // æ°”æ³¡ä¸Šå‡æ—¶é—´ï¼ˆç§’ï¼‰
            SCORE_PER_SUCCESS: 5,      // æ¯æ¬¡æˆåŠŸå¾—åˆ†ï¼ˆç§¯åˆ†ï¼‰
            
            // ========== æ¸¸æˆè¿‡æ»¤é…ç½® ==========
            // è®¾ç½®éœ€è¦ä»éšæœºç©æ³•ä¸­æ’é™¤çš„æ¸¸æˆç±»å‹
            // å¯é€‰å€¼: 'maze', 'math', 'cups', 'bubbles', 'oddOneOut', 
            //        'wordCategory', 'colorChar', 'polygonAsc', 'polygonDesc',
            //        'letterOrder', 'letterReverse', 'numberAsc', 'numberDesc'
            EXCLUDED_GAMES: ['maze'],         // ä¾‹å¦‚: ['maze', 'bubbles'] æ’é™¤è¿·å®«å’Œæ°”æ³¡æ¸¸æˆ
            
            // ========== æµ‹è¯•æ¨¡å¼é…ç½® ==========
            // è®¾ç½®ä¸ºnullè¡¨ç¤ºæ­£å¸¸éšæœºæ¨¡å¼
            // è®¾ç½®å…·ä½“æ¸¸æˆç±»å‹å¯ä»¥åªæµ‹è¯•è¯¥æ¸¸æˆ
            // å¯é€‰å€¼: 'maze', 'math', 'cups', 'bubbles', 'oddOneOut', 
            //        'wordCategory', 'colorChar', 'polygonAsc', 'polygonDesc',
            //        'letterOrder', 'letterReverse', 'numberAsc', 'numberDesc'
            TEST_GAME_TYPE: null,       // æµ‹è¯•ç‰¹å®šæ¸¸æˆç±»å‹ï¼Œnullä¸ºæ­£å¸¸æ¨¡å¼
            
            // æˆ–è€…è®¾ç½®å¤šä¸ªæ¸¸æˆç±»å‹è¿›è¡Œæµ‹è¯•
            TEST_GAME_TYPES: null       // ä¾‹å¦‚: ['math', 'colorChar'] æˆ– null
        };
        // ===================================

        class AttentionGame {
            constructor() {
                this.gameTime = GAME_CONFIG.TOTAL_GAME_TIME;
                this.completedTasks = 0;  // å·²å®Œæˆä»»åŠ¡æ•°
                this.correctTasks = 0;    // æ­£ç¡®å®Œæˆä»»åŠ¡æ•°
                this.accuracy = 0;        // æ­£ç¡®ç‡
                this.totalPoints = 0;  // æ€»ç§¯åˆ†
                this.dailyPoints = 0;  // ä»Šæ—¥ç§¯åˆ†
                this.gameEarnedPoints = 0; // æœ¬æ¬¡æ¸¸æˆè·å¾—çš„ç§¯åˆ†
                this.isGameRunning = false;
                this.leftGame = null;
                this.rightGame = null;
                this.timer = null;
                this.delayedTasks = []; // å­˜å‚¨å»¶è¿Ÿä»»åŠ¡çš„å®šæ—¶å™¨ID
                this.messageHandlerSetup = false; // æ ‡è®°æ¶ˆæ¯å¤„ç†å™¨æ˜¯å¦å·²è®¾ç½®
                
                // æ ¹æ®æµ‹è¯•é…ç½®è®¾ç½®æ¸¸æˆç±»å‹
                this.allGameTypes = [
                    'maze', 'math', 'cups', 'bubbles', 'oddOneOut', 
                    'wordCategory', 'colorChar', 'polygonAsc', 'polygonDesc',
                    'letterOrder', 'letterReverse', 'numberAsc', 'numberDesc'
                ];
                
                // æµ‹è¯•æ¨¡å¼é…ç½®
                if (GAME_CONFIG.TEST_GAME_TYPE) {
                    // å•ä¸ªæ¸¸æˆç±»å‹æµ‹è¯•
                    this.gameTypes = [GAME_CONFIG.TEST_GAME_TYPE];
                } else if (GAME_CONFIG.TEST_GAME_TYPES && Array.isArray(GAME_CONFIG.TEST_GAME_TYPES)) {
                    // å¤šä¸ªæ¸¸æˆç±»å‹æµ‹è¯•
                    this.gameTypes = GAME_CONFIG.TEST_GAME_TYPES;
                } else {
                    // æ­£å¸¸æ¨¡å¼ï¼Œä½¿ç”¨æ‰€æœ‰æ¸¸æˆç±»å‹å¹¶åº”ç”¨è¿‡æ»¤é…ç½®
                    this.gameTypes = [...this.allGameTypes];
                    
                    // åº”ç”¨æ¸¸æˆè¿‡æ»¤é…ç½®
                    if (GAME_CONFIG.EXCLUDED_GAMES && Array.isArray(GAME_CONFIG.EXCLUDED_GAMES)) {
                        this.gameTypes = this.gameTypes.filter(gameType => 
                            !GAME_CONFIG.EXCLUDED_GAMES.includes(gameType)
                        );
                    }
                    
                    // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªæ¸¸æˆç±»å‹å¯ç”¨
                    if (this.gameTypes.length === 0) {
                        console.warn('æ‰€æœ‰æ¸¸æˆç±»å‹éƒ½è¢«æ’é™¤äº†ï¼Œå›é€€åˆ°ä½¿ç”¨æ‰€æœ‰æ¸¸æˆç±»å‹');
                        this.gameTypes = [...this.allGameTypes];
                    }
                }
                
                // è®°å½•æ¯ä¸€ä¾§ä¸Šä¸€ä¸ªæ¸¸æˆç±»å‹ï¼Œé¿å…è¿ç»­é‡å¤
                this.lastGameType = {
                    left: null,
                    right: null
                };
                
                this.init();
            }

            init() {
                this.updateDisplay();
                this.setupMessageHandlers();
            }

            setupMessageHandlers() {
                // é˜²æ­¢é‡å¤æ³¨å†Œæ¶ˆæ¯ç›‘å¬å™¨
                if (this.messageHandlerSetup) {
                    return;
                }
                
                this.messageHandlerSetup = true;
                
                // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯
                this.messageHandler = (event) => {
                    const { type, totalPoints, total, dailyTotal, lastUpdateDate, action } = event.data;
                    
                    switch (type) { 
                        case 'trainingPointsResponse':
                            // æ”¶åˆ°ç§¯åˆ†æ›´æ–°å›å¤
                            this.totalPoints = totalPoints;
                            this.updatePointsDisplay();
                            break;
                            
                        case 'totalTrainingPointsResponse':
                            // æ”¶åˆ°ç§¯åˆ†æŸ¥è¯¢å›å¤
                            this.totalPoints = total;
                            this.dailyPoints = dailyTotal;
                            this.updatePointsDisplay();
                            this.updatePointsModal(total, dailyTotal, lastUpdateDate);
                            break;
                            
                        case 'setGameConfig':
                            if (event.data.quotaName === 'æ³¨æ„åˆ†é…') {
                                GAME_CONFIG.TEST_GAME_TYPES = ['cups', 'bubbles', 'numberAsc', 'numberDesc'];
                                this.gameTypes = GAME_CONFIG.TEST_GAME_TYPES;
                            }
                            // åœ¨é…ç½®å¤„ç†ç»“æŸåæŸ¥è¯¢æ€»ç§¯åˆ†
                            this.getTotalTrainingPoints();
                            break;
                        case 'gameContinue':
                            if (action === 'restart') {
                                this.startGame();
                            }
                            break;
                    }
                };
                
                window.addEventListener('message', this.messageHandler);
            }

            getTotalTrainingPoints() {
                // æŸ¥è¯¢æ€»ç§¯åˆ†
                window.parent.postMessage({ type: 'getTotalTrainingPoints' }, '*');
            }

            startGame() {
                if (this.isGameRunning) return;
                
                // å‘é€æ¸¸æˆå¼€å§‹äº‹ä»¶
                window.parent.postMessage({
                    type: 'gameStarted'
                }, '*');
                
                this.isGameRunning = true;
                this.gameTime = GAME_CONFIG.TOTAL_GAME_TIME;
                this.completedTasks = 0;   // é‡ç½®å·²å®Œæˆä»»åŠ¡æ•°
                this.correctTasks = 0;     // é‡ç½®æ­£ç¡®å®Œæˆä»»åŠ¡æ•°
                this.accuracy = 0;         // é‡ç½®æ­£ç¡®ç‡
                this.gameEarnedPoints = 0; // é‡ç½®æœ¬æ¬¡æ¸¸æˆè·å¾—çš„ç§¯åˆ†
                
                // é‡ç½®æ¸¸æˆå¯¹è±¡å¼•ç”¨
                this.leftGame = null;
                this.rightGame = null;
                
                // æ¸…ç†æ‰€æœ‰å»¶è¿Ÿä»»åŠ¡
                this.delayedTasks.forEach(taskId => {
                    clearTimeout(taskId);
                });
                this.delayedTasks = [];
                
                // é‡ç½®æ¸¸æˆç±»å‹è®°å½•
                this.lastGameType = {
                    left: null,
                    right: null
                };
                
                // é‡ç½®ç•Œé¢çŠ¶æ€
                document.getElementById('left-content').innerHTML = '';
                document.getElementById('right-content').innerHTML = '';
                
                const leftInstruction = document.getElementById('left-instruction');
                const rightInstruction = document.getElementById('right-instruction');
                leftInstruction.innerHTML = 'å‡†å¤‡å¼€å§‹';
                rightInstruction.innerHTML = '';
                
                // é‡ç½®è¿›åº¦æ¡
                document.getElementById('left-progress').style.width = '0%';
                document.getElementById('right-progress').style.width = '0%';
                
                // é‡ç½®è®¡æ—¶å™¨æ˜¾ç¤º
                const leftTimer = document.getElementById('left-timer');
                const rightTimer = document.getElementById('right-timer');
                if (leftTimer) {
                    leftTimer.textContent = '';
                    leftTimer.style.background = '';
                }
                if (rightTimer) {
                    rightTimer.textContent = '';
                    rightTimer.style.background = '';
                }
                
                this.updateDisplay();
                
                // å¼€å§‹è®¡æ—¶å™¨
                this.timer = setInterval(() => {
                    this.gameTime--;
                    this.updateDisplay();
                    
                    if (this.gameTime <= 0) {
                        this.endGame();
                    }
                }, 1000);
                
                // å¼€å§‹å·¦å³ä¸¤ä¾§æ¸¸æˆ
                this.startSideGame('left');
                this.startSideGame('right');
            }

            endGame() {
                this.isGameRunning = false;
                
                // æ¸…ç†ä¸»å®šæ—¶å™¨
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
                
                // æ¸…ç†æ‰€æœ‰å»¶è¿Ÿä»»åŠ¡
                this.delayedTasks.forEach(taskId => {
                    clearTimeout(taskId);
                });
                this.delayedTasks = [];
                
                // æ¸…ç†ä¸¤ä¾§æ¸¸æˆçš„å®šæ—¶å™¨å’Œè¿›åº¦æ¡
                if (this.leftGame) {
                    // è°ƒç”¨æ¸¸æˆç‰¹å®šçš„æ¸…ç†æ–¹æ³•
                    if (this.leftGame.cleanup) {
                        this.leftGame.cleanup();
                    }
                    if (this.leftGame.timeout) {
                        clearTimeout(this.leftGame.timeout);
                        this.leftGame.timeout = null;
                    }
                    if (this.leftGame.progressTimer) {
                        clearInterval(this.leftGame.progressTimer);
                        this.leftGame.progressTimer = null;
                    }
                }
                
                if (this.rightGame) {
                    // è°ƒç”¨æ¸¸æˆç‰¹å®šçš„æ¸…ç†æ–¹æ³•
                    if (this.rightGame.cleanup) {
                        this.rightGame.cleanup();
                    }
                    if (this.rightGame.timeout) {
                        clearTimeout(this.rightGame.timeout);
                        this.rightGame.timeout = null;
                    }
                    if (this.rightGame.progressTimer) {
                        clearInterval(this.rightGame.progressTimer);
                        this.rightGame.progressTimer = null;
                    }
                }
                
                // æ¸…ç†æ¸¸æˆå†…å®¹
                document.getElementById('left-content').innerHTML = '';
                document.getElementById('right-content').innerHTML = '';
                
                const leftInstruction = document.getElementById('left-instruction');
                const rightInstruction = document.getElementById('right-instruction');
                leftInstruction.innerHTML = 'è®­ç»ƒç»“æŸ';
                rightInstruction.innerHTML = '';
                
                // æ¸…ç†è¿›åº¦æ¡
                document.getElementById('left-progress').style.width = '0%';
                document.getElementById('right-progress').style.width = '0%';
                
                // æ¸…ç†è®¡æ—¶å™¨æ˜¾ç¤º
                const leftTimer = document.getElementById('left-timer');
                const rightTimer = document.getElementById('right-timer');
                if (leftTimer) {
                    leftTimer.textContent = '';
                    leftTimer.style.background = '';
                }
                if (rightTimer) {
                    rightTimer.textContent = '';
                    rightTimer.style.background = '';
                }
                
                // å‘é€æ¸¸æˆç»“æŸæ¶ˆæ¯ï¼ŒåŒ…å«æ­£ç¡®ç‡å’Œç§¯åˆ†
                window.parent.postMessage({
                    type: 'gameFinished',
                        data: {
                        score: this.accuracy,
                        showAccuracy: true,
                        accuracy: this.accuracy,
                        accuracyText: 'ä½ çš„ä»»åŠ¡å®Œæˆæ­£ç¡®ç‡ä¸º',
                        earnedPoints: this.gameEarnedPoints,
                        isMaxDifficulty: true,
                    },
                }, '*');
                
                // gameFinishedäº‹ä»¶å‘å‡ºåï¼Œæ¸…ç†æ¸¸æˆçŠ¶æ€
                this.leftGame = null;
                this.rightGame = null;
                this.completedTasks = 0;
                this.correctTasks = 0;
                this.accuracy = 0;
                this.gameEarnedPoints = 0;
                this.gameTime = GAME_CONFIG.TOTAL_GAME_TIME;
            }

            // æ¸…ç†æ¶ˆæ¯ç›‘å¬å™¨ï¼ˆå¯é€‰ï¼Œé€šå¸¸ä¸éœ€è¦è°ƒç”¨ï¼Œé™¤éè¦å®Œå…¨é”€æ¯æ¸¸æˆå®ä¾‹ï¼‰
            cleanupMessageHandlers() {
                if (this.messageHandler && this.messageHandlerSetup) {
                    window.removeEventListener('message', this.messageHandler);
                    this.messageHandler = null;
                    this.messageHandlerSetup = false;
                }
            }

            updateDisplay() {
                document.getElementById('timer').textContent = this.gameTime;
                document.getElementById('score').textContent = this.accuracy + '%';
                this.updatePointsDisplay();
            }

            updatePointsDisplay() {
                const totalPointsElement = document.getElementById('totalPoints');
                if (totalPointsElement) {
                    totalPointsElement.textContent = this.totalPoints;
                }
            }

            updatePointsModal(totalPoints, dailyPoints, lastUpdateDate) {
                const modalTotalPoints = document.getElementById('modalTotalPoints');
                const modalDailyPoints = document.getElementById('modalDailyPoints');
                const lastUpdate = document.getElementById('lastUpdateDate');
                
                if (modalTotalPoints) modalTotalPoints.textContent = totalPoints;
                if (modalDailyPoints) modalDailyPoints.textContent = dailyPoints;
                if (lastUpdate) lastUpdate.textContent = lastUpdateDate || '--';
            }

            startSideGame(side) {
                if (!this.isGameRunning) return;
                
                // è·å–å¯é€‰æ‹©çš„æ¸¸æˆç±»å‹ï¼ˆæ’é™¤ä¸Šä¸€ä¸ªæ¸¸æˆç±»å‹å’Œå¦ä¸€ä¾§å½“å‰æ¸¸æˆç±»å‹ï¼‰
                let availableGames = [...this.gameTypes];
                const lastGame = this.lastGameType[side];
                const otherSide = side === 'left' ? 'right' : 'left';
                const otherSideCurrentGame = this.lastGameType[otherSide];
                
                // å¦‚æœæ¸¸æˆç±»å‹è¶…è¿‡1ç§ï¼Œåˆ™æ’é™¤éœ€è¦æ’é™¤çš„æ¸¸æˆç±»å‹
                // æµ‹è¯•æ¨¡å¼ä¸‹å¦‚æœåªæœ‰ä¸€ç§æ¸¸æˆç±»å‹ï¼Œåˆ™ä¸è¿›è¡Œè¿‡æ»¤
                if (availableGames.length > 1) {
                    // æ’é™¤åŒä¾§çš„ä¸Šä¸€ä¸ªæ¸¸æˆç±»å‹
                    if (lastGame) {
                        availableGames = availableGames.filter(game => game !== lastGame);
                    }
                    
                    // æ’é™¤å¦ä¸€ä¾§çš„å½“å‰æ¸¸æˆç±»å‹
                    if (otherSideCurrentGame) {
                        availableGames = availableGames.filter(game => game !== otherSideCurrentGame);
                    }
                }
                
                // éšæœºé€‰æ‹©ä¸€ä¸ªæ¸¸æˆç±»å‹
                const randomGame = availableGames[Math.floor(Math.random() * availableGames.length)];
                
                // è®°å½•å½“å‰æ¸¸æˆç±»å‹
                this.lastGameType[side] = randomGame;
                
                const gameInstance = new GameFactory().createGame(randomGame, side, this);
                
                if (side === 'left') {
                    this.leftGame = gameInstance;
                } else {
                    this.rightGame = gameInstance;
                }
                
                gameInstance.start();
            }

            onGameComplete(side, success) {
                if (!this.isGameRunning) return;
                
                // ç»Ÿè®¡ä»»åŠ¡å®Œæˆæƒ…å†µ
                this.completedTasks++;
                if (success) {
                    this.correctTasks++;
                }
                
                // è®¡ç®—æ­£ç¡®ç‡
                this.accuracy = this.completedTasks > 0 ? Math.round(this.correctTasks / this.completedTasks * 100) : 0;

                // æ˜¾ç¤ºåé¦ˆ
                const content = document.getElementById(`${side}-content`);
                const feedback = document.createElement('div');
                feedback.className = `feedback ${success ? 'success' : 'failure'}`;
                feedback.textContent = success ? 'âœ“' : 'âœ—';
                content.appendChild(feedback);
                
                if (success) {
                    this.gameEarnedPoints += GAME_CONFIG.SCORE_PER_SUCCESS;
                    
                    // å‘é€ç§¯åˆ†è·å¾—æ¶ˆæ¯
                    window.parent.postMessage({
                        type: 'showTrainingPoints',
                        points: GAME_CONFIG.SCORE_PER_SUCCESS
                    }, '*');
                }
                
                this.updateDisplay();
                
                // é‡ç½®è¿›åº¦æ¡
                const progressBar = document.getElementById(`${side}-progress`);
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // 1ç§’åå¼€å§‹æ–°æ¸¸æˆ
                const delayedTaskId = setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.remove();
                    }
                    // ç§»é™¤å·²å®Œæˆçš„ä»»åŠ¡ID
                    const index = this.delayedTasks.indexOf(delayedTaskId);
                    if (index > -1) {
                        this.delayedTasks.splice(index, 1);
                    }
                    this.startSideGame(side);
                }, 1000);
                
                // è¿½è¸ªå»¶è¿Ÿä»»åŠ¡
                this.delayedTasks.push(delayedTaskId);
            }
        }

        class GameFactory {
            createGame(type, side, gameManager) {
                switch(type) {
                    case 'maze': return new MazeGame(side, gameManager);
                    case 'math': return new MathGame(side, gameManager);
                    case 'cups': return new CupsGame(side, gameManager);
                    case 'bubbles': return new BubblesGame(side, gameManager);
                    case 'oddOneOut': return new OddOneOutGame(side, gameManager);
                    case 'wordCategory': return new WordCategoryGame(side, gameManager);
                    case 'colorChar': return new ColorCharGame(side, gameManager);
                    case 'polygonAsc': return new PolygonGame(side, gameManager, 'asc');
                    case 'polygonDesc': return new PolygonGame(side, gameManager, 'desc');
                    case 'letterOrder': return new LetterGame(side, gameManager, 'asc');
                    case 'letterReverse': return new LetterGame(side, gameManager, 'desc');
                    case 'numberAsc': return new NumberGame(side, gameManager, 'asc');
                    case 'numberDesc': return new NumberGame(side, gameManager, 'desc');
                    default: return new MathGame(side, gameManager);
                }
            }
        }

        class BaseGame {
            constructor(side, gameManager) {
                this.side = side;
                this.gameManager = gameManager;
                this.timeout = null;
                this.gameTimeLimit = GAME_CONFIG.GAME_TIME_LIMIT; // ç»Ÿä¸€çš„æ¸¸æˆæ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
                this.timeLimit = this.gameTimeLimit * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                this.progressTimer = null;
                this.startTime = null; // æ·»åŠ å¼€å§‹æ—¶é—´æˆ³
            }

            start() {
                this.setupGame();
                this.startProgressBar();
                this.timeout = setTimeout(() => {
                    this.gameManager.onGameComplete(this.side, false);
                }, this.timeLimit);
            }

            startProgressBar() {
                // å…ˆæ¸…ç†å·²å­˜åœ¨çš„è¿›åº¦æ¡å®šæ—¶å™¨
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
                
                // è®°å½•å¼€å§‹æ—¶é—´
                this.startTime = Date.now();
                this.updateProgress();
                
                this.progressTimer = setInterval(() => {
                    this.updateProgress();
                }, 100);
            }

            updateProgress() {
                // åŸºäºæ—¶é—´æˆ³è®¡ç®—å®é™…å‰©ä½™æ—¶é—´
                const elapsed = (Date.now() - this.startTime) / 1000;
                const remainingTime = Math.max(0, this.gameTimeLimit - elapsed);
                
                const percentage = (remainingTime / this.gameTimeLimit) * 100;
                const progressBar = document.getElementById(`${this.side}-progress`);
                const timer = document.getElementById(`${this.side}-timer`);
                
                if (progressBar) {
                    progressBar.style.width = Math.max(0, percentage) + '%';
                }
                
                if (timer) {
                    timer.textContent = Math.max(0, Math.ceil(remainingTime));
                    
                    // æ ¹æ®å‰©ä½™æ—¶é—´æ”¹å˜é¢œè‰²
                    if (remainingTime <= this.gameTimeLimit * 0.375) { // 3/8çš„æ—¶é—´
                        timer.style.background = 'rgba(220, 53, 69, 0.9)';
                    } else if (remainingTime <= this.gameTimeLimit * 0.625) { // 5/8çš„æ—¶é—´
                        timer.style.background = 'rgba(255, 193, 7, 0.9)';
                    } else {
                        timer.style.background = 'rgba(40, 167, 69, 0.8)';
                    }
                }
                
                // å¦‚æœæ—¶é—´åˆ°äº†ï¼Œæ¸…ç†å®šæ—¶å™¨
                if (remainingTime <= 0) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
            }

            complete(success) {
                // å…ˆæ¸…ç†æ¸¸æˆç‰¹å®šçŠ¶æ€
                this.cleanup();
                
                // æ¸…ç†åŸºç¡€å®šæ—¶å™¨
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
                this.gameManager.onGameComplete(this.side, success);
            }

            cleanup() {
                // åŸºç¡€æ¸…ç† - ç§»é™¤æ‰€æœ‰åŠ¨ç”»å’Œäº‹ä»¶ç›‘å¬å™¨
                const content = this.getContent();
                if (content) {
                    // åœæ­¢æ‰€æœ‰CSSåŠ¨ç”»
                    const animatedElements = content.querySelectorAll('*');
                    animatedElements.forEach(element => {
                        element.style.animation = 'none';
                        element.style.transition = 'none';
                        // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                        element.onclick = null;
                        element.onmousedown = null;
                        element.onmouseup = null;
                        element.onmousemove = null;
                        element.ontouchstart = null;
                        element.ontouchend = null;
                        element.ontouchmove = null;
                    });
                    
                    // æ¸…ç†æ‰€æœ‰Web Animations APIåˆ›å»ºçš„åŠ¨ç”»
                    animatedElements.forEach(element => {
                        if (element.getAnimations) {
                            element.getAnimations().forEach(animation => {
                                animation.cancel();
                            });
                        }
                    });
                }
                
                // ç¡®ä¿æ¸…ç†è¿›åº¦æ¡å®šæ—¶å™¨
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
                
                // é‡ç½®æ—¶é—´æˆ³
                this.startTime = null;
                
                // å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•æ¥æ·»åŠ ç‰¹å®šæ¸…ç†é€»è¾‘
            }

            getContent() {
                return document.getElementById(`${this.side}-content`);
            }

            getInstruction() {
                return document.getElementById(`${this.side}-instruction`);
            }

            setInstruction(text) {
                const instruction = this.getInstruction();
                const timer = instruction.querySelector('.mini-timer');
                instruction.innerHTML = text;
                if (timer) {
                    instruction.appendChild(timer);
                }
            }

            setupGame() {
                // å­ç±»å®ç°
            }
        }

        // å¤æ‚æ‹¼å›¾è¿·å®«æ¸¸æˆ
        class MazeGame extends BaseGame {
            constructor(side, gameManager) {
                super(side, gameManager);
                this.gridSize = 6; // 6x6ç½‘æ ¼ï¼Œé€‚ä¸­éš¾åº¦
                
                // è¿™äº›ä¼šåœ¨setupGameä¸­åŠ¨æ€è®¡ç®—
                this.cellSize = 40; // é»˜è®¤å€¼
                this.actualMazeSize = 240; // é»˜è®¤å€¼
                
                this.maze = [];
                this.walls = new Set(); // å­˜å‚¨å¢™å£è¾¹
                this.paths = new Set(); // å­˜å‚¨è·¯å¾„è¾¹
                this.entrance = null;
                this.exit = null;
                this.isDragging = false;
                this.currentPath = [];
                this.isPathComplete = false;
                
                this.generateMaze();
            }

            // ç”Ÿæˆä¿„ç½—æ–¯æ–¹å—å½¢çŠ¶çš„æ‹¼å›¾å—
            getTetrisShapes() {
                return [
                    // Iå½¢çŠ¶
                    [[0,0], [0,1], [0,2], [0,3]],
                    // Oå½¢çŠ¶  
                    [[0,0], [0,1], [1,0], [1,1]],
                    // Tå½¢çŠ¶
                    [[0,0], [0,1], [0,2], [1,1]],
                    // Lå½¢çŠ¶
                    [[0,0], [0,1], [0,2], [1,2]],
                    // Jå½¢çŠ¶
                    [[0,0], [0,1], [0,2], [1,0]],
                    // Så½¢çŠ¶
                    [[0,1], [0,2], [1,0], [1,1]],
                    // Zå½¢çŠ¶
                    [[0,0], [0,1], [1,1], [1,2]]
                ];
            }

            // æ—‹è½¬å½¢çŠ¶
            rotateShape(shape) {
                const rotated = shape.map(([x, y]) => [-y, x]);
                const minX = Math.min(...rotated.map(([x, y]) => x));
                const minY = Math.min(...rotated.map(([x, y]) => y));
                return rotated.map(([x, y]) => [x - minX, y - minY]);
            }

            // è·å–å½¢çŠ¶çš„æ‰€æœ‰æ—‹è½¬ç‰ˆæœ¬
            getAllRotations(shape) {
                const rotations = [shape];
                let current = shape;
                for (let i = 0; i < 3; i++) {
                    current = this.rotateShape(current);
                    rotations.push(current);
                }
                return rotations;
            }

            // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦å¯ä»¥æ”¾ç½®åœ¨æŒ‡å®šä½ç½®
            canPlaceShape(shape, startX, startY, occupiedCells) {
                for (const [dx, dy] of shape) {
                    const x = startX + dx;
                    const y = startY + dy;
                    if (x < 0 || x >= this.gridSize || y < 0 || y >= this.gridSize) {
                        return false;
                    }
                    if (occupiedCells.has(`${x},${y}`)) {
                        return false;
                    }
                }
                return true;
            }

            // ç”Ÿæˆè¿·å®«
            generateMaze() {
                const shapes = this.getTetrisShapes();
                const occupiedCells = new Set();
                const placedShapes = [];
                
                // å°è¯•å¡«æ»¡æ•´ä¸ªç½‘æ ¼
                let attempts = 0;
                while (occupiedCells.size < this.gridSize * this.gridSize && attempts < 1000) {
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];
                    const rotations = this.getAllRotations(shape);
                    const rotation = rotations[Math.floor(Math.random() * rotations.length)];
                    
                    const startX = Math.floor(Math.random() * this.gridSize);
                    const startY = Math.floor(Math.random() * this.gridSize);
                    
                    if (this.canPlaceShape(rotation, startX, startY, occupiedCells)) {
                        const shapeData = {
                            shape: rotation,
                            x: startX,
                            y: startY,
                            cells: []
                        };
                        
                        for (const [dx, dy] of rotation) {
                            const x = startX + dx;
                            const y = startY + dy;
                            occupiedCells.add(`${x},${y}`);
                            shapeData.cells.push([x, y]);
                        }
                        
                        placedShapes.push(shapeData);
                    }
                    attempts++;
                }

                // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è¾¹
                this.generateWalls(placedShapes);
                
                // é€‰æ‹©å…¥å£å’Œå‡ºå£
                this.selectEntranceAndExit(placedShapes);
                
                // éšæœºç§»é™¤ä¸€äº›å†…éƒ¨å¢™å£åˆ›å»ºè·¯å¾„
                this.createPaths();
            }

            // ç”Ÿæˆå¢™å£
            generateWalls(placedShapes) {
                this.walls.clear();
                
                for (const shape of placedShapes) {
                    for (const [x, y] of shape.cells) {
                        // æ£€æŸ¥æ¯ä¸ªæ–¹å‘çš„è¾¹
                        const directions = [
                            [0, -1, 'top'],    // ä¸Šè¾¹
                            [1, 0, 'right'],   // å³è¾¹
                            [0, 1, 'bottom'],  // ä¸‹è¾¹
                            [-1, 0, 'left']    // å·¦è¾¹
                        ];
                        
                        for (const [dx, dy, side] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            // å¦‚æœç›¸é‚»ä½ç½®åœ¨ç½‘æ ¼å¤–æˆ–ä¸å±äºå½“å‰å½¢çŠ¶ï¼Œåˆ™æ·»åŠ å¢™å£
                            const isOutsideGrid = nx < 0 || nx >= this.gridSize || ny < 0 || ny >= this.gridSize;
                            const isInSameShape = shape.cells.some(([sx, sy]) => sx === nx && sy === ny);
                            
                            if (isOutsideGrid || !isInSameShape) {
                                this.walls.add(`${x},${y},${side}`);
                            }
                        }
                    }
                }
            }

            // é€‰æ‹©å…¥å£å’Œå‡ºå£
            selectEntranceAndExit(placedShapes) {
                const edgeWalls = Array.from(this.walls).filter(wall => {
                    const [x, y, side] = wall.split(',');
                    const xi = parseInt(x);
                    const yi = parseInt(y);
                    
                    return (
                        (side === 'top' && yi === 0) ||
                        (side === 'bottom' && yi === this.gridSize - 1) ||
                        (side === 'left' && xi === 0) ||
                        (side === 'right' && xi === this.gridSize - 1)
                    );
                });
                
                if (edgeWalls.length >= 2) {
                    const shuffled = edgeWalls.sort(() => Math.random() - 0.5);
                    const entranceWall = shuffled[0];
                    const exitWall = shuffled[1];
                    
                    this.entrance = this.parseWall(entranceWall);
                    this.exit = this.parseWall(exitWall);
                    
                    // ç§»é™¤å…¥å£å’Œå‡ºå£çš„å¢™å£
                    this.walls.delete(entranceWall);
                    this.walls.delete(exitWall);
                }
                
                // ç¡®ä¿æ‰€æœ‰è¾¹ç¼˜éƒ½è¢«å¢™å£å°é—­ï¼ˆé™¤äº†å…¥å£å’Œå‡ºå£ï¼‰
                this.ensureEdgeWalls();
            }

            // ç¡®ä¿è¾¹ç¼˜å¢™å£å®Œæ•´
            ensureEdgeWalls() {
                // æ·»åŠ é¡¶éƒ¨è¾¹ç¼˜å¢™å£
                for (let x = 0; x < this.gridSize; x++) {
                    const wallKey = `${x},0,top`;
                    if (!this.walls.has(wallKey) && 
                        (!this.entrance || this.entrance.wallStr !== wallKey) && 
                        (!this.exit || this.exit.wallStr !== wallKey)) {
                        this.walls.add(wallKey);
                    }
                }
                
                // æ·»åŠ åº•éƒ¨è¾¹ç¼˜å¢™å£
                for (let x = 0; x < this.gridSize; x++) {
                    const wallKey = `${x},${this.gridSize - 1},bottom`;
                    if (!this.walls.has(wallKey) && 
                        (!this.entrance || this.entrance.wallStr !== wallKey) && 
                        (!this.exit || this.exit.wallStr !== wallKey)) {
                        this.walls.add(wallKey);
                    }
                }
                
                // æ·»åŠ å·¦ä¾§è¾¹ç¼˜å¢™å£
                for (let y = 0; y < this.gridSize; y++) {
                    const wallKey = `0,${y},left`;
                    if (!this.walls.has(wallKey) && 
                        (!this.entrance || this.entrance.wallStr !== wallKey) && 
                        (!this.exit || this.exit.wallStr !== wallKey)) {
                        this.walls.add(wallKey);
                    }
                }
                
                // æ·»åŠ å³ä¾§è¾¹ç¼˜å¢™å£
                for (let y = 0; y < this.gridSize; y++) {
                    const wallKey = `${this.gridSize - 1},${y},right`;
                    if (!this.walls.has(wallKey) && 
                        (!this.entrance || this.entrance.wallStr !== wallKey) && 
                        (!this.exit || this.exit.wallStr !== wallKey)) {
                        this.walls.add(wallKey);
                    }
                }
            }

            // è§£æå¢™å£å­—ç¬¦ä¸²
            parseWall(wallStr) {
                const [x, y, side] = wallStr.split(',');
                return {
                    x: parseInt(x),
                    y: parseInt(y),
                    side: side,
                    wallStr: wallStr
                };
            }

            // åˆ›å»ºè·¯å¾„
            createPaths() {
                if (!this.entrance || !this.exit) return;
                
                // é¦–å…ˆåˆ›å»ºä¸€æ¡ä»å…¥å£åˆ°å‡ºå£çš„ç¡®å®šè·¯å¾„
                this.createGuaranteedPath();
                
                // ç„¶åéšæœºç§»é™¤ä¸€äº›é¢å¤–çš„å†…éƒ¨å¢™å£å¢åŠ è·¯å¾„é€‰æ‹©
                const internalWalls = Array.from(this.walls).filter(wall => {
                    const [x, y, side] = wall.split(',');
                    const xi = parseInt(x);
                    const yi = parseInt(y);
                    
                    // ä¸æ˜¯è¾¹ç¼˜å¢™å£
                    return !(
                        (side === 'top' && yi === 0) ||
                        (side === 'bottom' && yi === this.gridSize - 1) ||
                        (side === 'left' && xi === 0) ||
                        (side === 'right' && xi === this.gridSize - 1)
                    );
                });
                
                const toRemove = Math.floor(internalWalls.length * 0.3);
                const shuffled = internalWalls.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < toRemove; i++) {
                    this.walls.delete(shuffled[i]);
                    this.paths.add(shuffled[i]);
                }
            }

            // åˆ›å»ºç¡®ä¿çš„è¿é€šè·¯å¾„
            createGuaranteedPath() {
                const startX = this.entrance.x;
                const startY = this.entrance.y;
                const endX = this.exit.x;
                const endY = this.exit.y;
                
                let currentX = startX;
                let currentY = startY;
                
                // å…ˆæ°´å¹³ç§»åŠ¨åˆ°ç›®æ ‡Xåæ ‡
                while (currentX !== endX) {
                    const nextX = currentX < endX ? currentX + 1 : currentX - 1;
                    this.removeWallBetweenCells(currentX, currentY, nextX, currentY);
                    currentX = nextX;
                }
                
                // å†å‚ç›´ç§»åŠ¨åˆ°ç›®æ ‡Yåæ ‡
                while (currentY !== endY) {
                    const nextY = currentY < endY ? currentY + 1 : currentY - 1;
                    this.removeWallBetweenCells(currentX, currentY, currentX, nextY);
                    currentY = nextY;
                }
                
                // æ·»åŠ ä¸€äº›éšæœºåˆ†æ”¯è·¯å¾„
                this.addRandomBranches(startX, startY, endX, endY);
            }

            // ç§»é™¤ä¸¤ä¸ªæ ¼å­ä¹‹é—´çš„å¢™å£
            removeWallBetweenCells(x1, y1, x2, y2) {
                // ç¡®ä¿ä¸¤ä¸ªæ ¼å­ç›¸é‚»
                const dx = Math.abs(x1 - x2);
                const dy = Math.abs(y1 - y2);
                if (dx + dy !== 1) return;
                
                let side1, side2;
                if (x2 > x1) { // å‘å³
                    side1 = 'right';
                    side2 = 'left';
                } else if (x2 < x1) { // å‘å·¦
                    side1 = 'left';
                    side2 = 'right';
                } else if (y2 > y1) { // å‘ä¸‹
                    side1 = 'bottom';
                    side2 = 'top';
                } else { // å‘ä¸Š
                    side1 = 'top';
                    side2 = 'bottom';
                }
                
                // ç§»é™¤ä¸¤ä¸ªæ–¹å‘çš„å¢™å£
                const wall1 = `${x1},${y1},${side1}`;
                const wall2 = `${x2},${y2},${side2}`;
                
                this.walls.delete(wall1);
                this.walls.delete(wall2);
                this.paths.add(wall1);
                this.paths.add(wall2);
            }

            // æ·»åŠ éšæœºåˆ†æ”¯è·¯å¾„
            addRandomBranches(startX, startY, endX, endY) {
                const numBranches = 4;
                
                for (let i = 0; i < numBranches; i++) {
                    // åœ¨ä¸»è·¯å¾„ä¸Šé€‰æ‹©ä¸€ä¸ªéšæœºç‚¹ä½œä¸ºåˆ†æ”¯èµ·ç‚¹
                    const branchStartX = Math.min(startX, endX) + Math.floor(Math.random() * (Math.abs(endX - startX) + 1));
                    const branchStartY = Math.min(startY, endY) + Math.floor(Math.random() * (Math.abs(endY - startY) + 1));
                    
                    // åˆ›å»ºä¸€ä¸ªçŸ­çš„éšæœºåˆ†æ”¯
                    let currentX = branchStartX;
                    let currentY = branchStartY;
                    
                    const branchLength = 2 + Math.floor(Math.random() * 3); // 2-4æ­¥é•¿åº¦
                    
                    for (let step = 0; step < branchLength; step++) {
                        const directions = [
                            [0, 1], [0, -1], [1, 0], [-1, 0]
                        ];
                        
                        const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                        const nextX = currentX + dx;
                        const nextY = currentY + dy;
                        
                        // ç¡®ä¿åœ¨è¾¹ç•Œå†…
                        if (nextX >= 0 && nextX < this.gridSize && nextY >= 0 && nextY < this.gridSize) {
                            this.removeWallBetweenCells(currentX, currentY, nextX, nextY);
                            currentX = nextX;
                            currentY = nextY;
                        }
                    }
                }
            }



            setupGame() {
                this.setInstruction('æ‹¼å›¾è¿·å®«ï¼šä»<span class="highlight">ç»¿è‰²å…¥å£</span>æ‹–æ‹½åˆ°<span class="highlight">çº¢è‰²å‡ºå£</span>');
                
                const content = this.getContent();
                content.innerHTML = '';
                
                // åŠ¨æ€è·å–å®¹å™¨å¤§å°
                const contentRect = content.getBoundingClientRect();
                const availableWidth = Math.min(contentRect.width - 40, 400); // å‡å»paddingï¼Œæœ€å¤§400px
                const availableHeight = Math.min(contentRect.height - 40, 400); // å‡å»paddingï¼Œæœ€å¤§400px
                const containerSize = Math.min(availableWidth, availableHeight);
                
                // é‡æ–°è®¡ç®—è¿·å®«å°ºå¯¸
                this.cellSize = Math.floor(containerSize / this.gridSize);
                this.actualMazeSize = this.cellSize * this.gridSize;
                
                const mazeContainer = document.createElement('div');
                mazeContainer.className = 'maze-container';
                mazeContainer.style.cssText = `
                    position: relative;
                    width: ${this.actualMazeSize}px;
                    height: ${this.actualMazeSize}px;
                    margin: 0 auto;
                    background: #f8f9fa;
                    flex-shrink: 0;
                `;
                
                // ç»˜åˆ¶æ ¼å­ï¼ˆå»é™¤ç°è¾¹ï¼‰
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'maze-cell';
                        cell.style.cssText = `
                            position: absolute;
                            left: ${x * this.cellSize}px;
                            top: ${y * this.cellSize}px;
                            width: ${this.cellSize}px;
                            height: ${this.cellSize}px;
                            box-sizing: border-box;
                        `;
                        mazeContainer.appendChild(cell);
                    }
                }
                
                // ç»˜åˆ¶å¢™å£
                this.drawWalls(mazeContainer);
                
                // ç»˜åˆ¶å…¥å£å’Œå‡ºå£æ ‡è®°
                this.drawEntranceAndExit(mazeContainer);
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬
                this.addEventListeners(mazeContainer);
                
                content.appendChild(mazeContainer);
            }

            // ç»˜åˆ¶å¢™å£
            drawWalls(container) {
                for (const wallStr of this.walls) {
                    const [x, y, side] = wallStr.split(',');
                    const xi = parseInt(x);
                    const yi = parseInt(y);
                    
                    const wall = document.createElement('div');
                    wall.className = 'maze-wall';
                    wall.style.cssText = `
                        position: absolute;
                        background: #333;
                        z-index: 2;
                    `;
                    
                    if (side === 'top') {
                        wall.style.cssText += `
                            left: ${xi * this.cellSize}px;
                            top: ${yi * this.cellSize - 1}px;
                            width: ${this.cellSize}px;
                            height: 2px;
                        `;
                    } else if (side === 'bottom') {
                        wall.style.cssText += `
                            left: ${xi * this.cellSize}px;
                            top: ${(yi + 1) * this.cellSize - 1}px;
                            width: ${this.cellSize}px;
                            height: 2px;
                        `;
                    } else if (side === 'left') {
                        wall.style.cssText += `
                            left: ${xi * this.cellSize - 1}px;
                            top: ${yi * this.cellSize}px;
                            width: 2px;
                            height: ${this.cellSize}px;
                        `;
                    } else if (side === 'right') {
                        wall.style.cssText += `
                            left: ${(xi + 1) * this.cellSize - 1}px;
                            top: ${yi * this.cellSize}px;
                            width: 2px;
                            height: ${this.cellSize}px;
                        `;
                    }
                    
                    container.appendChild(wall);
                }
            }

            // ç»˜åˆ¶å…¥å£å’Œå‡ºå£
            drawEntranceAndExit(container) {
                if (this.entrance) {
                    const marker = this.createMarker(this.entrance, '#28a745', 'å…¥å£');
                    container.appendChild(marker);
                }
                
                if (this.exit) {
                    const marker = this.createMarker(this.exit, '#dc3545', 'å‡ºå£');
                    container.appendChild(marker);
                }
            }

            // åˆ›å»ºæ ‡è®°
            createMarker(position, color, text) {
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    background: ${color};
                    color: white;
                    font-size: 12px;
                    font-weight: bold;
                    text-align: center;
                    line-height: 20px;
                    z-index: 3;
                    border-radius: 3px;
                `;
                
                const { x, y, side } = position;
                
                if (side === 'top') {
                    marker.style.cssText += `
                        left: ${x * this.cellSize + 5}px;
                        top: ${y * this.cellSize - 25}px;
                        width: ${this.cellSize - 10}px;
                        height: 20px;
                    `;
                } else if (side === 'bottom') {
                    marker.style.cssText += `
                        left: ${x * this.cellSize + 5}px;
                        top: ${(y + 1) * this.cellSize + 5}px;
                        width: ${this.cellSize - 10}px;
                        height: 20px;
                    `;
                } else if (side === 'left') {
                    marker.style.cssText += `
                        left: ${x * this.cellSize - 45}px;
                        top: ${y * this.cellSize + 10}px;
                        width: 40px;
                        height: 20px;
                    `;
                } else if (side === 'right') {
                    marker.style.cssText += `
                        left: ${(x + 1) * this.cellSize + 5}px;
                        top: ${y * this.cellSize + 10}px;
                        width: 40px;
                        height: 20px;
                    `;
                }
                
                marker.textContent = text;
                return marker;
            }

            // æ·»åŠ äº‹ä»¶ç›‘å¬ï¼ˆæ”¯æŒç§»åŠ¨ç«¯å’Œå³æ—¶æ£€æµ‹ï¼‰
            addEventListeners(container) {
                let lastX, lastY;
                
                // ç»Ÿä¸€å¤„ç†å¼€å§‹äº‹ä»¶
                const handleStart = (e) => {
                    if (this.isPathComplete) return;
                    
                    // åªæœ‰è§¦æ‘¸äº‹ä»¶ä¸”è¢«è®¾ç½®ä¸ºpassiveæ—¶æ‰ä¸è°ƒç”¨preventDefault
                    if (e.type.startsWith('touch')) {
                        // touchstartè®¾ç½®ä¸ºpassiveï¼Œä¸éœ€è¦preventDefault
                    } else {
                        e.preventDefault();
                    }
                    
                    const rect = container.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    lastX = clientX - rect.left;
                    lastY = clientY - rect.top;
                    
                    // æ£€æŸ¥æ˜¯å¦ä»å…¥å£å¼€å§‹
                    if (this.isNearEntrance(lastX, lastY)) {
                        this.isDragging = true;
                        this.currentPath = [{ x: lastX, y: lastY }];
                        this.drawPath(container);
                    }
                };
                
                // ç»Ÿä¸€å¤„ç†ç§»åŠ¨äº‹ä»¶
                const handleMove = (e) => {
                    if (!this.isDragging || this.isPathComplete) return;
                    
                    // touchmoveè®¾ç½®ä¸ºpassive: falseï¼Œå¯ä»¥å®‰å…¨è°ƒç”¨preventDefault
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    const currentX = clientX - rect.left;
                    const currentY = clientY - rect.top;
                    
                    // æ£€æŸ¥æ˜¯å¦æ’å¢™ - ç«‹å³å¤±è´¥
                    if (!this.isValidPath(lastX, lastY, currentX, currentY)) {
                        this.isDragging = false;
                        this.clearPath(container);
                        this.complete(false); // ç«‹å³è§¦å‘å¤±è´¥
                        return;
                    }
                    
                    this.currentPath.push({ x: currentX, y: currentY });
                    this.drawPath(container);
                    
                    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£ - ç«‹å³æˆåŠŸ
                    if (this.isNearExit(currentX, currentY)) {
                        this.isDragging = false;
                        this.isPathComplete = true;
                        this.complete(true); // ç«‹å³è§¦å‘æˆåŠŸ
                        return;
                    }
                    
                    lastX = currentX;
                    lastY = currentY;
                };
                
                // ç»Ÿä¸€å¤„ç†ç»“æŸäº‹ä»¶
                const handleEnd = (e) => {
                    if (!this.isDragging) return;
                    
                    // touchend/touchcancelè®¾ç½®ä¸ºpassiveï¼Œä¸éœ€è¦preventDefault
                    if (e.type.startsWith('mouse')) {
                        e.preventDefault();
                    }
                    
                    this.isDragging = false;
                    
                    // å¦‚æœæ‹–æ‹½ç»“æŸæ—¶æ²¡æœ‰åˆ°è¾¾å‡ºå£ï¼Œæ¸…é™¤è·¯å¾„ä½†ä¸ç«‹å³åˆ¤å®šå¤±è´¥
                    if (!this.isPathComplete) {
                        this.clearPath(container);
                    }
                };
                
                // é¼ æ ‡äº‹ä»¶
                container.addEventListener('mousedown', handleStart);
                container.addEventListener('mousemove', handleMove);
                container.addEventListener('mouseup', handleEnd);
                container.addEventListener('mouseleave', handleEnd);
                
                // è§¦æ‘¸äº‹ä»¶ - æ·»åŠ é€‚å½“çš„passiveå±æ€§æå‡æ€§èƒ½
                container.addEventListener('touchstart', handleStart, { passive: true });
                container.addEventListener('touchmove', handleMove, { passive: false }); // éœ€è¦preventDefaulté˜»æ­¢æ»šåŠ¨
                container.addEventListener('touchend', handleEnd, { passive: true });
                container.addEventListener('touchcancel', handleEnd, { passive: true });
                
                // é˜²æ­¢ç§»åŠ¨ç«¯æ»šåŠ¨
                container.style.touchAction = 'none';
            }

            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘å…¥å£
            isNearEntrance(x, y) {
                if (!this.entrance) return false;
                const { x: ex, y: ey, side } = this.entrance;
                const centerX = ex * this.cellSize + this.cellSize / 2;
                const centerY = ey * this.cellSize + this.cellSize / 2;
                const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                return distance < this.cellSize / 2;
            }

            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘å‡ºå£
            isNearExit(x, y) {
                if (!this.exit) return false;
                const { x: ex, y: ey, side } = this.exit;
                const centerX = ex * this.cellSize + this.cellSize / 2;
                const centerY = ey * this.cellSize + this.cellSize / 2;
                const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                return distance < this.cellSize / 2;
            }

            // æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆï¼ˆæ²¡æœ‰æ’å¢™ï¼‰
            isValidPath(fromX, fromY, toX, toY) {
                // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦åœ¨æœ‰æ•ˆåŒºåŸŸå†…
                if (this.isPositionBlocked(fromX, fromY) || this.isPositionBlocked(toX, toY)) {
                    return false;
                }
                
                // ä½¿ç”¨æ›´ç²¾ç¡®çš„çº¿æ®µä¸å¢™å£ç›¸äº¤æ£€æµ‹
                return !this.checkLineWallCollision(fromX, fromY, toX, toY);
            }

            // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸å¢™å£ç›¸äº¤
            checkLineWallCollision(x1, y1, x2, y2) {
                // éå†æ‰€æœ‰å¢™å£ï¼Œæ£€æŸ¥æ˜¯å¦ä¸è·¯å¾„çº¿æ®µç›¸äº¤
                for (const wallStr of this.walls) {
                    const [x, y, side] = wallStr.split(',');
                    const xi = parseInt(x);
                    const yi = parseInt(y);
                    
                    // è·å–å¢™å£çš„ä¸¤ä¸ªç«¯ç‚¹
                    let wallX1, wallY1, wallX2, wallY2;
                    
                    if (side === 'top') {
                        wallX1 = xi * this.cellSize;
                        wallY1 = yi * this.cellSize;
                        wallX2 = (xi + 1) * this.cellSize;
                        wallY2 = yi * this.cellSize;
                    } else if (side === 'bottom') {
                        wallX1 = xi * this.cellSize;
                        wallY1 = (yi + 1) * this.cellSize;
                        wallX2 = (xi + 1) * this.cellSize;
                        wallY2 = (yi + 1) * this.cellSize;
                    } else if (side === 'left') {
                        wallX1 = xi * this.cellSize;
                        wallY1 = yi * this.cellSize;
                        wallX2 = xi * this.cellSize;
                        wallY2 = (yi + 1) * this.cellSize;
                    } else if (side === 'right') {
                        wallX1 = (xi + 1) * this.cellSize;
                        wallY1 = yi * this.cellSize;
                        wallX2 = (xi + 1) * this.cellSize;
                        wallY2 = (yi + 1) * this.cellSize;
                    }
                    
                    // æ£€æŸ¥ä¸¤ä¸ªçº¿æ®µæ˜¯å¦ç›¸äº¤
                    if (this.lineSegmentIntersect(x1, y1, x2, y2, wallX1, wallY1, wallX2, wallY2)) {
                        return true; // å‘ç”Ÿç¢°æ’
                    }
                }
                
                return false; // æ²¡æœ‰ç¢°æ’
            }

            // æ£€æŸ¥ä¸¤ä¸ªçº¿æ®µæ˜¯å¦ç›¸äº¤
            lineSegmentIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 1e-10) return false; // å¹³è¡Œçº¿
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                return t >= 0 && t <= 1 && u >= 0 && u <= 1;
            }

            // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«è¾¹ç•Œé˜»æŒ¡
            isPositionBlocked(x, y) {
                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¿·å®«è¾¹ç•Œ
                return x < 0 || x >= this.actualMazeSize || y < 0 || y >= this.actualMazeSize;
            }

            // ç»˜åˆ¶è·¯å¾„
            drawPath(container) {
                // æ¸…é™¤ä¹‹å‰çš„è·¯å¾„
                const oldPath = container.querySelector('.maze-path-line');
                if (oldPath) oldPath.remove();
                
                if (this.currentPath.length < 2) return;
                
                const pathLine = document.createElement('canvas');
                pathLine.className = 'maze-path-line';
                pathLine.width = this.actualMazeSize;
                pathLine.height = this.actualMazeSize;
                pathLine.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    z-index: 4;
                    pointer-events: none;
                `;
                
                const ctx = pathLine.getContext('2d');
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(this.currentPath[0].x, this.currentPath[0].y);
                
                for (let i = 1; i < this.currentPath.length; i++) {
                    ctx.lineTo(this.currentPath[i].x, this.currentPath[i].y);
                }
                
                ctx.stroke();
                container.appendChild(pathLine);
            }

            // æ¸…é™¤è·¯å¾„
            clearPath(container) {
                const pathLine = container.querySelector('.maze-path-line');
                if (pathLine) pathLine.remove();
                this.currentPath = [];
            }

            cleanup() {
                // è°ƒç”¨çˆ¶ç±»æ¸…ç†
                super.cleanup();
                
                // æ¸…ç†è¿·å®«æ¸¸æˆç‰¹å®šçŠ¶æ€
                this.isDragging = false;
                this.currentPath = [];
                this.isPathComplete = false;
                
                // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                const content = this.getContent();
                if (content) {
                    const mazeContainer = content.querySelector('.maze-container');
                    if (mazeContainer) {
                        // ç§»é™¤æ‰€æœ‰å¯èƒ½çš„äº‹ä»¶ç›‘å¬å™¨
                        // ç”±äºæˆ‘ä»¬æ²¡æœ‰ä¿å­˜ç›‘å¬å™¨çš„å¼•ç”¨ï¼Œæˆ‘ä»¬é‡æ–°åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨æ¥æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨
                        const newContainer = mazeContainer.cloneNode(true);
                        mazeContainer.parentNode.replaceChild(newContainer, mazeContainer);
                        
                        // æ¸…ç†è·¯å¾„ç”»å¸ƒ
                        this.clearPath(newContainer);
                        
                        // é‡ç½®è§¦æ‘¸åŠ¨ä½œ
                        newContainer.style.touchAction = 'auto';
                    }
                }
            }
        }

        // ç®—æœ¯é¢˜æ¸¸æˆ
        class MathGame extends BaseGame {
            setupGame() {
                this.setInstruction('ç®€å•ç®—æœ¯ï¼šé€‰æ‹©æ­£ç¡®ç­”æ¡ˆ');
                
                let num1 = Math.floor(Math.random() * 20) + 1;
                let num2 = Math.floor(Math.random() * 20) + 1;
                const operators = ['+', '-', '*'];
                const operator = operators[Math.floor(Math.random() * operators.length)];
                
                let answer;
                switch(operator) {
                    case '+': 
                        answer = num1 + num2; 
                        break;
                    case '-': 
                        // ç¡®ä¿è¢«å‡æ•°å¤§äºç­‰äºå‡æ•°ï¼Œç»“æœä¸ºæ­£æ•°æˆ–0
                        if (num1 < num2) {
                            [num1, num2] = [num2, num1]; // äº¤æ¢ä½¿num1 >= num2
                        }
                        answer = num1 - num2; 
                        break;
                    case '*': 
                        answer = num1 * num2; 
                        break;
                }
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="question">${num1} ${operator} ${num2} = ?</div>
                    <div class="options">
                        ${this.generateOptions(answer).map(opt => 
                            `<button class="option" onclick="game.handleAnswer('${this.side}', ${opt}, ${answer})">${opt}</button>`
                        ).join('')}
                    </div>
                `;
            }

            generateOptions(correct) {
                const options = [correct];
                while(options.length < 4) {
                    const wrong = correct + Math.floor(Math.random() * 20) - 10;
                    if (wrong > 0 && !options.includes(wrong)) {
                        options.push(wrong);
                    }
                }
                return options.sort(() => Math.random() - 0.5);
            }
        }

        // çº¸æ¯æ¸¸æˆ
        class CupsGame extends BaseGame {
            constructor(side, gameManager) {
                super(side, gameManager);
                this.ballPosition = Math.floor(Math.random() * 3);
                this.showingBall = true;
                this.gamePhase = 'showing'; // 'showing', 'hiding', 'shuffling', 'guessing'
                this.shuffleCount = 0;
                this.maxShuffles = 3;
                this.canSelect = false;
                this.cupsCurrentState = []; // è®°å½•æ¯ä¸ªæ¯å­çš„å½“å‰transformçŠ¶æ€
                this.gameTimers = []; // è¿½è¸ªæ‰€æœ‰æ¸¸æˆç›¸å…³çš„å®šæ—¶å™¨
            }

            setupGame() {
                this.setInstruction('è®°ä½å°çƒä½ç½®ï¼šè§‚å¯Ÿçº¢çƒä½ç½®ï¼Œç­‰å¾…æ¯å­äº¤æ¢å®Œæˆåé€‰æ‹©');
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="cups">
                        ${[0, 1, 2].map(i => `
                            <div class="cup-container">
                                <div class="cup" id="${this.side}-cup-${i}" data-position="${i}">
                                </div>
                                ${i === this.ballPosition ? '<div class="ball" id="' + this.side + '-ball"></div>' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // åˆå§‹åŒ–æ¯å­çŠ¶æ€è®°å½•
                this.cupsCurrentState = [
                    { translateX: 0, translateY: -30 }, // åˆå§‹æ‚¬æµ®çŠ¶æ€
                    { translateX: 0, translateY: -30 },
                    { translateX: 0, translateY: -30 }
                ];
                
                // è®¾ç½®æ¯å­åˆå§‹æ‚¬æµ®çŠ¶æ€
                const cups = this.getContent().querySelectorAll('.cup');
                cups.forEach((cup, index) => {
                    cup.style.transform = `translateY(-30px)`;
                    cup.style.boxShadow = '0 6px 12px rgba(0,0,0,0.3)';
                });
                
                // 2ç§’åå¼€å§‹éšè—çƒå¹¶ä¸‹é™æ¯å­
                const startHidingTimer = setTimeout(() => {
                    this.startHiding();
                }, 2000);
                this.gameTimers.push(startHidingTimer);
            }

            startHiding() {
                this.gamePhase = 'hiding';
                this.setInstruction('æ¯å­ç›–ä½å°çƒï¼Œå‡†å¤‡äº¤æ¢...');
                
                const ball = document.getElementById(`${this.side}-ball`);
                const cups = this.getContent().querySelectorAll('.cup');
                
                // çƒæ¶ˆå¤±åŠ¨ç”» - ä½¿ç”¨animate API
                if (ball) {
                    ball.animate([
                        { opacity: 1 },
                        { opacity: 0 }
                    ], {
                        duration: 400,
                        easing: 'ease-out',
                        fill: 'forwards'
                    });
                }
                
                // æ¯å­ä¸‹é™åŠ¨ç”» - ä½¿ç”¨animate API
                cups.forEach((cup, index) => {
                    cup.animate([
                        { transform: 'translateY(-30px)', boxShadow: '0 6px 12px rgba(0,0,0,0.3)' },
                        { transform: 'translateY(0px)', boxShadow: '0 2px 4px rgba(0,0,0,0.2)' }
                    ], {
                        duration: 800,
                        easing: 'ease-out',
                        fill: 'forwards'
                    });
                    
                    // æ›´æ–°çŠ¶æ€è®°å½•
                    this.cupsCurrentState[index].translateY = 0;
                });
                
                const startShufflingTimer = setTimeout(() => {
                    this.startShuffling();
                }, 800);
                this.gameTimers.push(startShufflingTimer);
            }

            startShuffling() {
                this.gamePhase = 'shuffling';
                this.setInstruction(`æ¯å­äº¤æ¢ä¸­... (${this.shuffleCount + 1}/${this.maxShuffles})`);
                
                this.performShuffle();
            }

            performShuffle() {
                if (this.shuffleCount >= this.maxShuffles) {
                    this.endShuffling();
                    return;
                }

                // éšæœºé€‰æ‹©ä¸¤ä¸ªä¸åŒçš„æ¯å­è¿›è¡Œäº¤æ¢
                let pos1, pos2;
                do {
                    pos1 = Math.floor(Math.random() * 3);
                    pos2 = Math.floor(Math.random() * 3);
                } while (pos1 === pos2);

                this.swapCups(pos1, pos2);
                
                // æ›´æ–°çƒçš„ä½ç½®è®°å½•
                if (this.ballPosition === pos1) {
                    this.ballPosition = pos2;
                } else if (this.ballPosition === pos2) {
                    this.ballPosition = pos1;
                }

                this.shuffleCount++;
                
                const shuffleTimer = setTimeout(() => {
                    if (this.shuffleCount < this.maxShuffles) {
                        this.setInstruction(`æ¯å­äº¤æ¢ä¸­... (${this.shuffleCount + 1}/${this.maxShuffles})`);
                        const nextShuffleTimer = setTimeout(() => {
                            this.performShuffle();
                        }, 500);
                        this.gameTimers.push(nextShuffleTimer);
                    } else {
                        this.performShuffle();
                    }
                }, 1000);
                this.gameTimers.push(shuffleTimer);
            }

            swapCups(pos1, pos2) {
                const cup1 = document.getElementById(`${this.side}-cup-${pos1}`);
                const cup2 = document.getElementById(`${this.side}-cup-${pos2}`);
                
                if (!cup1 || !cup2) return;

                // è®¡ç®—äº¤æ¢è·ç¦» - åŸºäºå…ƒç´ å®é™…ä½ç½®
                const cup1Rect = cup1.getBoundingClientRect();
                const cup2Rect = cup2.getBoundingClientRect();
                const distance = cup2Rect.left - cup1Rect.left; // å®é™…åƒç´ è·ç¦»
                const duration = 1000; // åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                
                // è·å–å½“å‰çŠ¶æ€
                const currentState1 = this.cupsCurrentState[pos1];
                const currentState2 = this.cupsCurrentState[pos2];
                
                // è®¡ç®—æ–°çš„ä½ç½®
                const newState1 = {
                    translateX: currentState1.translateX + distance,
                    translateY: currentState1.translateY
                };
                const newState2 = {
                    translateX: currentState2.translateX - distance,
                    translateY: currentState2.translateY
                };

                // ä½¿ç”¨animate APIåˆ›å»ºæ¯å­äº¤æ¢åŠ¨ç”»ï¼Œä¿æŒåœ¨ä¸‹é™çŠ¶æ€
                cup1.animate([
                    { transform: `translateX(${currentState1.translateX}px) translateY(${currentState1.translateY}px)` },
                    { transform: `translateX(${newState1.translateX / 2}px) translateY(${currentState1.translateY - 30}px)` },
                    { transform: `translateX(${newState1.translateX}px) translateY(${newState1.translateY}px)` }
                ], { 
                    duration: duration, 
                    easing: 'ease-in-out', 
                });

                cup2.animate([
                    { transform: `translateX(${currentState2.translateX}px) translateY(${currentState2.translateY}px)` },
                    { transform: `translateX(${newState2.translateX / 2}px) translateY(${currentState2.translateY - 30}px)` },
                    { transform: `translateX(${newState2.translateX}px) translateY(${newState2.translateY}px)` }
                ], { 
                    duration: duration, 
                    easing: 'ease-in-out', 
                });
                
                // æ›´æ–°çŠ¶æ€è®°å½•
                this.cupsCurrentState[pos1] = newState2; // æ³¨æ„äº¤æ¢
                this.cupsCurrentState[pos2] = newState1;

                // äº¤æ¢DOMä½ç½®ï¼ˆåœ¨åŠ¨ç”»ç»“æŸåæ‰§è¡Œï¼‰
                const swapDOMTimer = setTimeout(() => {
                    const parent = cup1.parentNode.parentNode;
                    const container1 = cup1.parentNode;
                    const container2 = cup2.parentNode;
                    
                    // åˆ›å»ºä¸´æ—¶æ ‡è®°
                    const temp = document.createElement('div');
                    parent.insertBefore(temp, container1);
                    parent.insertBefore(container1, container2);
                    parent.insertBefore(container2, temp);
                    parent.removeChild(temp);
                    
                    // æ›´æ–°IDå’Œæ•°æ®å±æ€§
                    cup1.id = `${this.side}-cup-${pos2}`;
                    cup2.id = `${this.side}-cup-${pos1}`;
                    cup1.dataset.position = pos2;
                    cup2.dataset.position = pos1;
                    
                    // é‡ç½®transformï¼Œå› ä¸ºDOMä½ç½®å·²ç»æ”¹å˜
                    cup1.style.transform = `translateY(${currentState1.translateY}px)`;
                    cup2.style.transform = `translateY(${currentState2.translateY}px)`;
                    
                    // é‡ç½®çŠ¶æ€è®°å½•ä¸ºDOMäº¤æ¢åçš„çŠ¶æ€
                    this.cupsCurrentState[pos1] = { translateX: 0, translateY: currentState2.translateY };
                    this.cupsCurrentState[pos2] = { translateX: 0, translateY: currentState1.translateY };
                }, duration);
                this.gameTimers.push(swapDOMTimer);
            }

            endShuffling() {
                this.gamePhase = 'guessing';
                this.canSelect = true;
                this.setInstruction('æ¯å­äº¤æ¢å®Œæˆï¼<span class="highlight">ç‚¹å‡»</span>ä½ è®¤ä¸ºè—æœ‰çº¢çƒçš„æ¯å­');
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                const cups = this.getContent().querySelectorAll('.cup');
                cups.forEach((cup, index) => {
                    cup.style.cursor = 'pointer';
                    cup.onclick = () => {
                        if (this.canSelect) {
                            this.selectCup(parseInt(cup.dataset.position));
                        }
                    };
                });
            }

            selectCup(cupIndex) {
                if (!this.canSelect) return;
                
                this.canSelect = false;
                const isCorrect = cupIndex === this.ballPosition;
                
                // æ˜¾ç¤ºç»“æœ
                const cups = this.getContent().querySelectorAll('.cup');
                cups.forEach(cup => {
                    cup.style.cursor = 'default';
                    cup.onclick = null;
                });
                
                // æ­ç¤ºç­”æ¡ˆ - æ¯å­ä¸Šå‡æ˜¾ç¤ºçƒ
                const correctCupContainer = document.querySelector(`#${this.side}-cup-${this.ballPosition}`).parentNode;
                const correctCup = document.querySelector(`#${this.side}-cup-${this.ballPosition}`);
                
                if (correctCup && correctCupContainer) {
                    // æ¯å­ä¸Šå‡åŠ¨ç”»
                    correctCup.animate([
                        { transform: 'translateY(0px)' },
                        { transform: 'translateY(-30px)' }
                    ], {
                        duration: 600,
                        easing: 'ease-out',
                        fill: 'forwards'
                    });
                    
                    // åˆ›å»ºå¹¶æ˜¾ç¤ºçƒ
                    const ball = document.createElement('div');
                    ball.className = 'ball';
                    ball.style.opacity = '0';
                    ball.style.transform = 'translateX(-50%)';
                    correctCupContainer.appendChild(ball);
                    
                    const ballShowTimer = setTimeout(() => {
                        ball.animate([
                            { opacity: 0 },
                            { opacity: 1 }
                        ], {
                            duration: 400,
                            easing: 'ease-out',
                            fill: 'forwards'
                        });
                    }, 200);
                    this.gameTimers.push(ballShowTimer);
                }
                
                const completeTimer = setTimeout(() => {
                    this.complete(isCorrect);
                }, 1000);
                this.gameTimers.push(completeTimer);
            }

            cleanup() {
                // è°ƒç”¨çˆ¶ç±»æ¸…ç†
                super.cleanup();
                
                // æ¸…ç†æ¯å­æ¸¸æˆç‰¹å®šçŠ¶æ€
                this.canSelect = false;
                this.gamePhase = 'ended';
                
                // æ¸…ç†æ‰€æœ‰æ¸¸æˆç›¸å…³çš„å®šæ—¶å™¨
                this.gameTimers.forEach(timerId => {
                    clearTimeout(timerId);
                });
                this.gameTimers = [];
                
                // é‡ç½®æ¯å­çŠ¶æ€
                this.cupsCurrentState = [];
                
                // ç¡®ä¿æ‰€æœ‰æ¯å­éƒ½ç§»é™¤äº‹ä»¶ç›‘å¬å™¨å’Œé‡ç½®æ ·å¼
                const content = this.getContent();
                if (content) {
                    const cups = content.querySelectorAll('.cup');
                    cups.forEach(cup => {
                        cup.style.cursor = 'default';
                        cup.onclick = null;
                        cup.style.animation = 'none';
                        cup.style.transform = '';
                        cup.style.transition = 'none';
                        
                        // å–æ¶ˆæ‰€æœ‰Web Animations APIåŠ¨ç”»
                        if (cup.getAnimations) {
                            cup.getAnimations().forEach(animation => {
                                animation.cancel();
                            });
                        }
                    });
                    
                    // æ¸…ç†çƒå…ƒç´ çš„åŠ¨ç”»
                    const balls = content.querySelectorAll('.ball');
                    balls.forEach(ball => {
                        if (ball.getAnimations) {
                            ball.getAnimations().forEach(animation => {
                                animation.cancel();
                            });
                        }
                    });
                }
            }
        }

        // æ°”æ³¡æ¸¸æˆ
        class BubblesGame extends BaseGame {
            constructor(side, gameManager) {
                super(side, gameManager);
                this.bubbles = [];
                this.colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
                this.bubbleCount = 3;
                this.bubblesPopped = 0;
            }

            setupGame() {
                this.setInstruction('è½»ç‚¹æ°”æ³¡ï¼š<span class="highlight">ç‚¹å‡»</span>æ‰€æœ‰ä¸Šå‡çš„æ°”æ³¡');
                
                const content = this.getContent();
                content.innerHTML = '<div class="bubble-area"></div>';
                
                const bubbleArea = content.querySelector('.bubble-area');
                
                // åˆ›å»ºæ°”æ³¡
                for (let i = 0; i < this.bubbleCount; i++) {
                    setTimeout(() => {
                        this.createBubble(bubbleArea);
                    }, i * 1000);
                }
            }

            createBubble(container) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                bubble.style.backgroundColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                bubble.style.left = Math.random() * (container.offsetWidth - 80) + 'px';
                bubble.style.animation = `bubbleUp ${GAME_CONFIG.BUBBLE_RISE_TIME}s linear`;
                
                bubble.addEventListener('click', () => {
                    bubble.remove();
                    this.bubblesPopped++;
                    if (this.bubblesPopped === this.bubbleCount) {
                        this.complete(true);
                    }
                });

                bubble.addEventListener('animationend', () => {
                    if (bubble.parentNode) {
                        bubble.remove();
                        this.complete(false);
                    }
                });

                container.appendChild(bubble);
            }

            cleanup() {
                // è°ƒç”¨çˆ¶ç±»æ¸…ç†
                super.cleanup();
                
                // æ¸…ç†æ³¡æ³¡æ¸¸æˆç‰¹å®šçŠ¶æ€
                this.bubblesPopped = 0;
                this.bubbles = [];
                
                // åœæ­¢æ‰€æœ‰æ³¡æ³¡çš„åŠ¨ç”»å’Œç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                const content = this.getContent();
                if (content) {
                    const bubbles = content.querySelectorAll('.bubble');
                    bubbles.forEach(bubble => {
                        bubble.style.animation = 'none';
                        bubble.onclick = null;
                        bubble.onanimationend = null;
                        
                        // å–æ¶ˆWeb Animations APIåŠ¨ç”»
                        if (bubble.getAnimations) {
                            bubble.getAnimations().forEach(animation => {
                                animation.cancel();
                            });
                        }
                        
                        // ç«‹å³ç§»é™¤å…ƒç´ 
                        if (bubble.parentNode) {
                            bubble.remove();
                        }
                    });
                }
            }
        }

        // æ‰¾ä¸åŒç±»ç‰©ä½“æ¸¸æˆ
        class OddOneOutGame extends BaseGame {
            setupGame() {
                this.setInstruction('æ‰¾ä¸åŒç±»ï¼š<span class="highlight">ç‚¹å‡»</span>ä¸å±äºåŒç±»çš„ç‰©ä½“');
                
                const categories = [
                    { same: ['ğŸ¶', 'ğŸ±', 'ğŸ°'], different: 'ğŸ' },
                    { same: ['ğŸš—', 'ğŸšŒ', 'ğŸš²'], different: 'ğŸŒ' },
                    { same: ['ğŸ“±', 'ğŸ’»', 'âŒš'], different: 'ğŸŒ¸' },
                    { same: ['âš½', 'ğŸ€', 'ğŸ¾'], different: 'ğŸ“š' },
                    { same: ['ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»'], different: 'ğŸš—' },
                    { same: ['ğŸ', 'ğŸŠ', 'ğŸŒ'], different: 'ğŸ“±' }
                ];
                
                const category = categories[Math.floor(Math.random() * categories.length)];
                const items = [...category.same, category.different];
                
                // ç¡®ä¿æœ‰4ä¸ªé€‰é¡¹ï¼Œå¦‚æœåªæœ‰4ä¸ªå°±ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™éšæœºæ’åˆ—
                const shuffledItems = items.sort(() => Math.random() - 0.5);
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="options">
                        ${shuffledItems.map(item => `
                            <button class="option" onclick="game.selectOddOne('${this.side}', '${item}', '${category.different}')" 
                                    style="font-size: 48px;">${item}</button>
                        `).join('')}
                    </div>
                `;
            }
        }

        // è¯æ±‡åˆ†ç±»æ¸¸æˆ
        class WordCategoryGame extends BaseGame {
            setupGame() {
                this.setInstruction('è¯æ±‡åˆ†ç±»ï¼š<span class="highlight">ç‚¹å‡»</span>ä¸å±äºåŒç±»çš„è¯æ±‡');
                
                const categories = [
                    { same: ['è‹¹æœ', 'é¦™è•‰', 'æ©™å­'], different: 'æ±½è½¦' },
                    { same: ['çŒ«', 'ç‹—', 'å…”å­'], different: 'æ¡Œå­' },
                    { same: ['çº¢è‰²', 'è“è‰²', 'ç»¿è‰²'], different: 'éŸ³ä¹' },
                    { same: ['æ˜¥å¤©', 'å¤å¤©', 'ç§‹å¤©'], different: 'ç”µè„‘' },
                    { same: ['ä¹¦æœ¬', 'ç¬”è®°', 'ä½œä¸š'], different: 'è¥¿ç“œ' },
                    { same: ['è¶³çƒ', 'ç¯®çƒ', 'æ’çƒ'], different: 'é’¢ç´' }
                ];
                
                const category = categories[Math.floor(Math.random() * categories.length)];
                const words = [...category.same, category.different];
                
                // ç¡®ä¿æœ‰4ä¸ªé€‰é¡¹
                const shuffledWords = words.sort(() => Math.random() - 0.5);
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="options">
                        ${shuffledWords.map(word => `
                            <button class="option" onclick="game.selectOddWord('${this.side}', '${word}', '${category.different}')">${word}</button>
                        `).join('')}
                    </div>
                `;
            }
        }

        // é¢œè‰²æ±‰å­—æ¸¸æˆ
        class ColorCharGame extends BaseGame {
            setupGame() {
                this.setInstruction('é¢œè‰²åˆ¤æ–­ï¼šé€‰æ‹©<span class="highlight">æ±‰å­—é¢œè‰²</span>ï¼ˆä¸æ˜¯å­—ä¹‰ï¼‰');
                
                const colors = [
                    { name: 'çº¢', color: '#dc3545' },
                    { name: 'è“', color: '#007bff' },
                    { name: 'ç»¿', color: '#28a745' },
                    { name: 'é»„', color: '#ffc107' }
                ];
                
                const charColor = colors[Math.floor(Math.random() * colors.length)];
                const charName = colors[Math.floor(Math.random() * colors.length)];
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="chinese-char" style="color: ${charColor.color}; font-size: 64px; margin: 0 0 30px; font-weight: bold;">${charName.name}</div>
                    <div class="options">
                        ${colors.map(color => `
                            <button class="option" onclick="game.selectColor('${this.side}', '${color.name}', '${charColor.name}')">${color.name}</button>
                        `).join('')}
                    </div>
                `;
            }
        }

        // å¤šè¾¹å½¢æ¸¸æˆ
        class PolygonGame extends BaseGame {
            constructor(side, gameManager, order) {
                super(side, gameManager);
                this.order = order; // 'asc' or 'desc'
                this.selectedShapes = [];
                this.shapes = [];
            }

            setupGame() {
                const orderText = this.order === 'asc' ? 'ç”±å°‘è‡³å¤š' : 'ç”±å¤šè‡³å°‘';
                this.setInstruction(`å¤šè¾¹å½¢æ’åºï¼šæŒ‰è¾¹æ•°<span class="highlight">${orderText}</span>ä¾æ¬¡ç‚¹å‡»`);
                
                // ç”Ÿæˆ3-8è¾¹å½¢
                const sides = [3, 4, 5, 6].sort(() => Math.random() - 0.5);
                this.shapes = sides;
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="shapes">
                        ${sides.map((side, index) => `
                            <div class="shape" onclick="game.selectShape('${this.side}', ${index}, ${side})" 
                                 style="background: ${this.getShapeColor(side)}; clip-path: ${this.getShapeClipPath(side)};">
                                ${side}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            getShapeColor(sides) {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
                return colors[sides - 3];
            }

            getShapeClipPath(sides) {
                const clipPaths = {
                    3: 'polygon(50% 0%, 0% 100%, 100% 100%)',
                    4: 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)',
                    5: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)',
                    6: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)'
                };
                return clipPaths[sides] || clipPaths[4];
            }
        }

        // å­—æ¯æ¸¸æˆ
        class LetterGame extends BaseGame {
            constructor(side, gameManager, order) {
                super(side, gameManager);
                this.order = order; // 'asc' or 'desc'
                this.selectedLetters = [];
                this.letters = [];
            }

            setupGame() {
                const orderText = this.order === 'asc' ? 'é¡ºåº' : 'é€†åº';
                this.setInstruction(`å­—æ¯æ’åºï¼šæŒ‰<span class="highlight">${orderText}</span>ä¾æ¬¡ç‚¹å‡»å­—æ¯`);
                
                // ç”Ÿæˆ4ä¸ªè¿ç»­å­—æ¯
                const startChar = Math.floor(Math.random() * 23); // A-W
                this.letters = [];
                for (let i = 0; i < 4; i++) {
                    this.letters.push(String.fromCharCode(65 + startChar + i));
                }
                
                const shuffled = [...this.letters].sort(() => Math.random() - 0.5);
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="options">
                        ${shuffled.map(letter => `
                            <button class="option" onclick="game.selectLetter('${this.side}', '${letter}')">${letter}</button>
                        `).join('')}
                    </div>
                `;
            }
        }

        // æ•°å­—æ¸¸æˆ
        class NumberGame extends BaseGame {
            constructor(side, gameManager, order) {
                super(side, gameManager);
                this.order = order; // 'asc' or 'desc'
                this.selectedNumbers = [];
                this.numbers = [];
            }

            setupGame() {
                const orderText = this.order === 'asc' ? 'ç”±å°åˆ°å¤§' : 'ç”±å¤§åˆ°å°';
                this.setInstruction(`æ•°å­—æ’åºï¼š<span class="highlight">${orderText}</span>ä¾æ¬¡ç‚¹å‡»æ•°å­—`);
                
                // ç”Ÿæˆ4ä¸ªä¸é‡å¤æ•°å­—
                this.numbers = [];
                while (this.numbers.length < 4) {
                    const num = Math.floor(Math.random() * 99) + 1;
                    if (!this.numbers.includes(num)) {
                        this.numbers.push(num);
                    }
                }
                
                const shuffled = [...this.numbers].sort(() => Math.random() - 0.5);
                
                const content = this.getContent();
                content.innerHTML = `
                    <div class="options">
                        ${shuffled.map(num => `
                            <button class="option" onclick="game.selectNumber('${this.side}', ${num})">${num}</button>
                        `).join('')}
                    </div>
                `;
            }
        }

        // æ¸¸æˆå®ä¾‹
        let gameInstance;

        function startGame() {
            // å¦‚æœæ¸¸æˆå®ä¾‹å·²å­˜åœ¨ï¼Œç›´æ¥é‡å¯æ¸¸æˆè€Œä¸åˆ›å»ºæ–°å®ä¾‹
            if (gameInstance) {
                gameInstance.startGame();
            } else {
                // åªåœ¨ç¬¬ä¸€æ¬¡æ—¶åˆ›å»ºæ–°å®ä¾‹
                gameInstance = new AttentionGame();
                gameInstance.startGame();
            }
        }

        // æ¸¸æˆäº¤äº’å‡½æ•°
        window.game = {
            handleAnswer(side, selected, correct) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                game.complete(selected === correct);
            },

            selectCup(side, cupIndex) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                if (game && typeof game.selectCup === 'function') {
                    game.selectCup(cupIndex);
                } else {
                    // å…¼å®¹æ—§ç‰ˆæœ¬
                    game.complete(cupIndex === game.ballPosition);
                }
            },

            selectOddOne(side, selected, correct) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                game.complete(selected === correct);
            },

            selectOddWord(side, selected, correct) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                game.complete(selected === correct);
            },

            selectColor(side, selected, correct) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                game.complete(selected === correct);
            },

            selectShape(side, index, sides) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                const button = event.target;
                
                if (button.classList.contains('selected')) return;
                
                button.classList.add('selected');
                game.selectedShapes.push(sides);
                
                const expectedOrder = game.order === 'asc' ? 
                    [...game.shapes].sort((a, b) => a - b) : 
                    [...game.shapes].sort((a, b) => b - a);
                
                const isCorrectSoFar = game.selectedShapes.every((shape, i) => 
                    shape === expectedOrder[i]
                );
                
                if (!isCorrectSoFar) {
                    game.complete(false);
                } else if (game.selectedShapes.length === game.shapes.length) {
                    game.complete(true);
                }
            },

            selectLetter(side, letter) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                const button = event.target;
                
                if (button.classList.contains('selected')) return;
                
                button.classList.add('selected');
                game.selectedLetters.push(letter);
                
                const expectedOrder = game.order === 'asc' ? 
                    [...game.letters].sort() : 
                    [...game.letters].sort().reverse();
                
                const isCorrectSoFar = game.selectedLetters.every((letter, i) => 
                    letter === expectedOrder[i]
                );
                
                if (!isCorrectSoFar) {
                    game.complete(false);
                } else if (game.selectedLetters.length === game.letters.length) {
                    game.complete(true);
                }
            },

            selectNumber(side, number) {
                const game = side === 'left' ? gameInstance.leftGame : gameInstance.rightGame;
                const button = event.target;
                
                if (button.classList.contains('selected')) return;
                
                button.classList.add('selected');
                game.selectedNumbers.push(number);
                
                const expectedOrder = game.order === 'asc' ? 
                    [...game.numbers].sort((a, b) => a - b) : 
                    [...game.numbers].sort((a, b) => b - a);
                
                const isCorrectSoFar = game.selectedNumbers.every((num, i) => 
                    num === expectedOrder[i]
                );
                
                if (!isCorrectSoFar) {
                    game.complete(false);
                } else if (game.selectedNumbers.length === game.numbers.length) {
                    game.complete(true);
                }
            }
        };

        // ç§¯åˆ†å¼¹çª—åŠŸèƒ½
        function showPointsModal() {
            // æ¯æ¬¡æ‰“å¼€ç§¯åˆ†å¼¹çª—æ—¶æŸ¥è¯¢æœ€æ–°ç§¯åˆ†
            gameInstance.getTotalTrainingPoints();
            
            const modal = document.getElementById('pointsModal');
            modal.classList.add('show');
        }

        function hidePointsModal(event) {
            // å¦‚æœäº‹ä»¶å­˜åœ¨ä¸”ç‚¹å‡»çš„æ˜¯å¼¹çª—å†…å®¹åŒºåŸŸï¼Œåˆ™ä¸å…³é—­å¼¹çª—
            if (event && event.target !== event.currentTarget) {
                return;
            }
            
            const modal = document.getElementById('pointsModal');
            modal.classList.remove('show');
        }

        // è§„åˆ™å¼¹çª—åŠŸèƒ½
        function showRulesModal() {
            const modal = document.getElementById('rulesModal');
            modal.classList.add('show');
        }

        function hideRulesModal(event) {
            // å¦‚æœäº‹ä»¶å­˜åœ¨ä¸”ç‚¹å‡»çš„æ˜¯å¼¹çª—å†…å®¹åŒºåŸŸï¼Œåˆ™ä¸å…³é—­å¼¹çª—
            if (event && event.target !== event.currentTarget) {
                return;
            }
            
            const modal = document.getElementById('rulesModal');
            modal.classList.remove('show');
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        gameInstance = new AttentionGame();
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (gameInstance) {
                gameInstance.cleanupMessageHandlers();
            }
        });
        
        // é¡µé¢åŠ è½½å®ŒæˆåæŸ¥è¯¢ç§¯åˆ†å¹¶æ˜¾ç¤ºè§„åˆ™å¼¹çª—
        // æŸ¥è¯¢æ€»ç§¯åˆ†
        gameInstance.getTotalTrainingPoints();
        
        setTimeout(() => {
            showRulesModal();
        }, 500);
        
        // æ¸¸æˆåˆå§‹åŒ–å®Œæ¯•ï¼Œå‘é€gameLoadedäº‹ä»¶
        window.parent.postMessage({
            type: 'gameLoaded'
        }, '*');
    </script>
</body>
</html>
